# Comparing `tmp/PyMieSim-1.9.1-cp312-cp312-win_amd64.whl.zip` & `tmp/PyMieSim-1.9.3-cp312-cp312-macosx_11_0_arm64.whl.zip`

## zipinfo {}

```diff
@@ -1,209 +1,244 @@
-Zip file size: 8519314 bytes, number of entries: 207
--rw-rw-rw-  2.0 fat        7 b- defN 24-May-02 19:31 PyMieSim/VERSION
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-02 19:31 PyMieSim/__init__.py
--rw-rw-rw-  2.0 fat      230 b- defN 24-May-02 19:31 PyMieSim/__main__.py
--rw-rw-rw-  2.0 fat     3780 b- defN 24-May-02 19:31 PyMieSim/measure.py
--rw-rw-rw-  2.0 fat     7864 b- defN 24-May-02 19:31 PyMieSim/mesh.py
--rw-rw-rw-  2.0 fat     1988 b- defN 24-May-02 19:31 PyMieSim/physics.py
--rw-rw-rw-  2.0 fat     2084 b- defN 24-May-02 19:31 PyMieSim/polarization.py
--rw-rw-rw-  2.0 fat   814592 b- defN 24-May-02 19:35 PyMieSim/binary/CoreShellInterface.cp310-win_amd64.pyd
--rw-rw-rw-  2.0 fat   814592 b- defN 24-May-02 19:40 PyMieSim/binary/CoreShellInterface.cp311-win_amd64.pyd
--rw-rw-rw-  2.0 fat   814592 b- defN 24-May-02 19:43 PyMieSim/binary/CoreShellInterface.cp312-win_amd64.pyd
--rw-rw-rw-  2.0 fat   796672 b- defN 24-May-02 19:35 PyMieSim/binary/CylinderInterface.cp310-win_amd64.pyd
--rw-rw-rw-  2.0 fat   797184 b- defN 24-May-02 19:39 PyMieSim/binary/CylinderInterface.cp311-win_amd64.pyd
--rw-rw-rw-  2.0 fat   797696 b- defN 24-May-02 19:43 PyMieSim/binary/CylinderInterface.cp312-win_amd64.pyd
--rw-rw-rw-  2.0 fat   853504 b- defN 24-May-02 19:35 PyMieSim/binary/DetectorInterface.cp310-win_amd64.pyd
--rw-rw-rw-  2.0 fat   853504 b- defN 24-May-02 19:40 PyMieSim/binary/DetectorInterface.cp311-win_amd64.pyd
--rw-rw-rw-  2.0 fat   852992 b- defN 24-May-02 19:43 PyMieSim/binary/DetectorInterface.cp312-win_amd64.pyd
--rw-rw-rw-  2.0 fat   966144 b- defN 24-May-02 19:35 PyMieSim/binary/Experiment.cp310-win_amd64.pyd
--rw-rw-rw-  2.0 fat   966144 b- defN 24-May-02 19:40 PyMieSim/binary/Experiment.cp311-win_amd64.pyd
--rw-rw-rw-  2.0 fat   967680 b- defN 24-May-02 19:43 PyMieSim/binary/Experiment.cp312-win_amd64.pyd
--rw-rw-rw-  2.0 fat   351744 b- defN 24-May-02 19:35 PyMieSim/binary/Fibonacci.cp310-win_amd64.pyd
--rw-rw-rw-  2.0 fat   351744 b- defN 24-May-02 19:39 PyMieSim/binary/Fibonacci.cp311-win_amd64.pyd
--rw-rw-rw-  2.0 fat   351744 b- defN 24-May-02 19:43 PyMieSim/binary/Fibonacci.cp312-win_amd64.pyd
--rw-rw-rw-  2.0 fat   301568 b- defN 24-May-02 19:35 PyMieSim/binary/ModeField.cp310-win_amd64.pyd
--rw-rw-rw-  2.0 fat   301568 b- defN 24-May-02 19:40 PyMieSim/binary/ModeField.cp311-win_amd64.pyd
--rw-rw-rw-  2.0 fat   301568 b- defN 24-May-02 19:43 PyMieSim/binary/ModeField.cp312-win_amd64.pyd
--rw-rw-rw-  2.0 fat   873984 b- defN 24-May-02 19:35 PyMieSim/binary/Sets.cp310-win_amd64.pyd
--rw-rw-rw-  2.0 fat   873984 b- defN 24-May-02 19:40 PyMieSim/binary/Sets.cp311-win_amd64.pyd
--rw-rw-rw-  2.0 fat   872960 b- defN 24-May-02 19:43 PyMieSim/binary/Sets.cp312-win_amd64.pyd
--rw-rw-rw-  2.0 fat   814592 b- defN 24-May-02 19:35 PyMieSim/binary/SphereInterface.cp310-win_amd64.pyd
--rw-rw-rw-  2.0 fat   815104 b- defN 24-May-02 19:39 PyMieSim/binary/SphereInterface.cp311-win_amd64.pyd
--rw-rw-rw-  2.0 fat   815616 b- defN 24-May-02 19:43 PyMieSim/binary/SphereInterface.cp312-win_amd64.pyd
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-02 19:31 PyMieSim/binary/__init__.py
--rw-rw-rw-  2.0 fat   133174 b- defN 24-May-02 19:43 PyMieSim/binary/libZBessel.a
--rw-rw-rw-  2.0 fat      165 b- defN 24-May-02 19:31 PyMieSim/experiment/__init__.py
--rw-rw-rw-  2.0 fat     8444 b- defN 24-May-02 19:31 PyMieSim/experiment/detector.py
--rw-rw-rw-  2.0 fat    16834 b- defN 24-May-02 19:31 PyMieSim/experiment/scatterer.py
--rw-rw-rw-  2.0 fat     5170 b- defN 24-May-02 19:31 PyMieSim/experiment/setup.py
--rw-rw-rw-  2.0 fat     5540 b- defN 24-May-02 19:31 PyMieSim/experiment/source.py
--rw-rw-rw-  2.0 fat      209 b- defN 24-May-02 19:31 PyMieSim/gui/__init__.py
--rw-rw-rw-  2.0 fat     3291 b- defN 24-May-02 19:31 PyMieSim/gui/axis_tab.py
--rw-rw-rw-  2.0 fat     3382 b- defN 24-May-02 19:31 PyMieSim/gui/base_tab.py
--rw-rw-rw-  2.0 fat     6388 b- defN 24-May-02 19:31 PyMieSim/gui/detector_tab.py
--rw-rw-rw-  2.0 fat     7703 b- defN 24-May-02 19:31 PyMieSim/gui/main_window.py
--rw-rw-rw-  2.0 fat     7070 b- defN 24-May-02 19:31 PyMieSim/gui/scatterer_tab.py
--rw-rw-rw-  2.0 fat     2633 b- defN 24-May-02 19:31 PyMieSim/gui/source_tab.py
--rw-rw-rw-  2.0 fat     3122 b- defN 24-May-02 19:31 PyMieSim/gui/widget_collection.py
--rw-rw-rw-  2.0 fat     6658 b- defN 24-May-02 19:31 PyMieSim/gui/widgets.py
--rw-rw-rw-  2.0 fat      139 b- defN 24-May-02 19:31 PyMieSim/single/__init__.py
--rw-rw-rw-  2.0 fat    10529 b- defN 24-May-02 19:31 PyMieSim/single/detector.py
--rw-rw-rw-  2.0 fat    19667 b- defN 24-May-02 19:31 PyMieSim/single/representations.py
--rw-rw-rw-  2.0 fat    20055 b- defN 24-May-02 19:31 PyMieSim/single/scatterer.py
--rw-rw-rw-  2.0 fat     5579 b- defN 24-May-02 19:31 PyMieSim/single/source.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-02 19:31 PyMieSim/tools/__init__.py
--rw-rw-rw-  2.0 fat     1184 b- defN 24-May-02 19:31 PyMieSim/tools/directories.py
--rw-rw-rw-  2.0 fat     6229 b- defN 24-May-02 19:31 PyMieSim/tools/special_functions.py
--rw-rw-rw-  2.0 fat    10073 b- defN 24-May-02 19:31 PyMieSim/validation_data/Figure810BH.csv
--rw-rw-rw-  2.0 fat    40002 b- defN 24-May-02 19:31 PyMieSim/validation_data/Figure87BH.csv
--rw-rw-rw-  2.0 fat    40002 b- defN 24-May-02 19:31 PyMieSim/validation_data/Figure88BH.csv
--rw-rw-rw-  2.0 fat    20800 b- defN 24-May-02 19:31 PyMieSim/validation_data/PyMieScattQsca.csv
--rw-rw-rw-  2.0 fat    10400 b- defN 24-May-02 19:31 PyMieSim/validation_data/PyMieScattQscaCoreShell.csv
--rw-rw-rw-  2.0 fat    10400 b- defN 24-May-02 19:31 PyMieSim/validation_data/PyMieScattQscaCoreShellMedium.csv
--rw-rw-rw-  2.0 fat    20800 b- defN 24-May-02 19:31 PyMieSim/validation_data/PyMieScattQscaMedium.csv
--rw-rw-rw-  2.0 fat      765 b- defN 24-May-02 19:31 development/debugging.py
--rw-rw-rw-  2.0 fat     1051 b- defN 24-May-02 19:31 development/fcm.py
--rw-rw-rw-  2.0 fat    13670 b- defN 24-May-02 19:31 development/gui.py
--rw-rw-rw-  2.0 fat     1161 b- defN 24-May-02 19:31 development/matthew_singe-2.py
--rw-rw-rw-  2.0 fat     1501 b- defN 24-May-02 19:31 development/matthew_singer.py
--rw-rw-rw-  2.0 fat      847 b- defN 24-May-02 19:31 docs/examples/detector/plot_HG01.py
--rw-rw-rw-  2.0 fat      864 b- defN 24-May-02 19:31 docs/examples/detector/plot_HG11.py
--rw-rw-rw-  2.0 fat      851 b- defN 24-May-02 19:31 docs/examples/detector/plot_LG11.py
--rw-rw-rw-  2.0 fat      826 b- defN 24-May-02 19:31 docs/examples/detector/plot_LP01.py
--rw-rw-rw-  2.0 fat      640 b- defN 24-May-02 19:31 docs/examples/detector/plot_LP02.py
--rw-rw-rw-  2.0 fat      640 b- defN 24-May-02 19:31 docs/examples/detector/plot_LP11.py
--rw-rw-rw-  2.0 fat      559 b- defN 24-May-02 19:31 docs/examples/detector/plot_integrating_sphere.py
--rw-rw-rw-  2.0 fat      666 b- defN 24-May-02 19:31 docs/examples/detector/plot_photodiode.py
--rw-rw-rw-  2.0 fat     1897 b- defN 24-May-02 19:31 docs/examples/experiment/plot_coreshell_Qback_vs_corediameter.py
--rw-rw-rw-  2.0 fat     2125 b- defN 24-May-02 19:31 docs/examples/experiment/plot_coreshell_a1_vs_corediameter.py
--rw-rw-rw-  2.0 fat     2033 b- defN 24-May-02 19:31 docs/examples/experiment/plot_coreshell_b1_vs_corediameter.py
--rw-rw-rw-  2.0 fat     2126 b- defN 24-May-02 19:31 docs/examples/experiment/plot_coreshell_coupling_vs_corediameter.py
--rw-rw-rw-  2.0 fat     1869 b- defN 24-May-02 19:31 docs/examples/experiment/plot_cylinder_Qabs_vs_diameter.py
--rw-rw-rw-  2.0 fat     1624 b- defN 24-May-02 19:31 docs/examples/experiment/plot_cylinder_Qsca_vs_diameter.py
--rw-rw-rw-  2.0 fat     1617 b- defN 24-May-02 19:31 docs/examples/experiment/plot_cylinder_Qsca_vs_index.py
--rw-rw-rw-  2.0 fat     1948 b- defN 24-May-02 19:31 docs/examples/experiment/plot_cylinder_Qsca_vs_wavelength.py
--rw-rw-rw-  2.0 fat     1155 b- defN 24-May-02 19:31 docs/examples/experiment/plot_cylinder_Qsca_vs_wavelength_std.py
--rw-rw-rw-  2.0 fat     1594 b- defN 24-May-02 19:31 docs/examples/experiment/plot_cylinder_a11_vs_diameter.py
--rw-rw-rw-  2.0 fat     1507 b- defN 24-May-02 19:31 docs/examples/experiment/plot_cylinder_b11_vs_diameter.py
--rw-rw-rw-  2.0 fat     2026 b- defN 24-May-02 19:31 docs/examples/experiment/plot_cylinder_coupling_vs_diameter.py
--rw-rw-rw-  2.0 fat     2048 b- defN 24-May-02 19:31 docs/examples/experiment/plot_cylinder_coupling_vs_phioffset.py
--rw-rw-rw-  2.0 fat     2259 b- defN 24-May-02 19:31 docs/examples/experiment/plot_cylinder_coupling_vs_wavelength.py
--rw-rw-rw-  2.0 fat     1116 b- defN 24-May-02 19:31 docs/examples/experiment/plot_sphere_Qabs_vs_diameter.py
--rw-rw-rw-  2.0 fat     1022 b- defN 24-May-02 19:31 docs/examples/experiment/plot_sphere_Qsca_vs_diameter.py
--rw-rw-rw-  2.0 fat     1005 b- defN 24-May-02 19:31 docs/examples/experiment/plot_sphere_Qsca_vs_index.py
--rw-rw-rw-  2.0 fat     1033 b- defN 24-May-02 19:31 docs/examples/experiment/plot_sphere_Qsca_vs_wavelength.py
--rw-rw-rw-  2.0 fat     1150 b- defN 24-May-02 19:31 docs/examples/experiment/plot_sphere_Qsca_vs_wavelength_std.py
--rw-rw-rw-  2.0 fat     1020 b- defN 24-May-02 19:31 docs/examples/experiment/plot_sphere_a1_vs_diameter.py
--rw-rw-rw-  2.0 fat     1017 b- defN 24-May-02 19:31 docs/examples/experiment/plot_sphere_b1_vs_diameter.py
--rw-rw-rw-  2.0 fat     1450 b- defN 24-May-02 19:31 docs/examples/experiment/plot_sphere_coherent_coupling_vs_phioffset.py
--rw-rw-rw-  2.0 fat     1380 b- defN 24-May-02 19:31 docs/examples/experiment/plot_sphere_coherent_coupling_vs_rotation.py
--rw-rw-rw-  2.0 fat     1381 b- defN 24-May-02 19:31 docs/examples/experiment/plot_sphere_coupling_vs_diameter.py
--rw-rw-rw-  2.0 fat     1489 b- defN 24-May-02 19:31 docs/examples/experiment/plot_sphere_coupling_vs_filter.py
--rw-rw-rw-  2.0 fat     1355 b- defN 24-May-02 19:31 docs/examples/experiment/plot_sphere_coupling_vs_phioffset.py
--rw-rw-rw-  2.0 fat     1441 b- defN 24-May-02 19:31 docs/examples/experiment/plot_sphere_coupling_vs_wavelength.py
--rw-rw-rw-  2.0 fat     1033 b- defN 24-May-02 19:31 docs/examples/extras/SphereProperties.py
--rw-rw-rw-  2.0 fat     1600 b- defN 24-May-02 19:31 docs/examples/extras/plot_Qsca_vs_permittivity_vs_size_parameter.py
--rw-rw-rw-  2.0 fat     1748 b- defN 24-May-02 19:31 docs/examples/extras/plot_coupling_heatmap.py
--rw-rw-rw-  2.0 fat     1054 b- defN 24-May-02 19:31 docs/examples/scatterer/plot_farfield.py
--rw-rw-rw-  2.0 fat     1336 b- defN 24-May-02 19:31 docs/examples/scatterer/plot_footprint.py
--rw-rw-rw-  2.0 fat      940 b- defN 24-May-02 19:31 docs/examples/scatterer/plot_s1s2.py
--rw-rw-rw-  2.0 fat      593 b- defN 24-May-02 19:31 docs/examples/scatterer/plot_source.py
--rw-rw-rw-  2.0 fat     1003 b- defN 24-May-02 19:31 docs/examples/scatterer/plot_spf.py
--rw-rw-rw-  2.0 fat      946 b- defN 24-May-02 19:31 docs/examples/scatterer/plot_stokes.py
--rw-rw-rw-  2.0 fat     1207 b- defN 24-May-02 19:31 docs/examples/validation/plot_BH810.py
--rw-rw-rw-  2.0 fat     1634 b- defN 24-May-02 19:31 docs/examples/validation/plot_BH87.py
--rw-rw-rw-  2.0 fat     2676 b- defN 24-May-02 19:31 docs/examples/validation/plot_BH88.py
--rw-rw-rw-  2.0 fat     2747 b- defN 24-May-02 19:31 docs/examples/validation/plot_phase_function_detector.py
--rw-rw-rw-  2.0 fat     1950 b- defN 24-May-02 19:31 docs/examples/validation/plot_pymiescatt_0.py
--rw-rw-rw-  2.0 fat     2030 b- defN 24-May-02 19:31 docs/examples/validation/plot_pymiescatt_1.py
--rw-rw-rw-  2.0 fat     2226 b- defN 24-May-02 19:31 docs/examples/validation/plot_pymiescatt_2.py
--rw-rw-rw-  2.0 fat     2328 b- defN 24-May-02 19:31 docs/examples/validation/plot_pymiescatt_3.py
--rw-rw-rw-  2.0 fat     4717 b- defN 24-May-02 19:31 docs/source/conf.py
--rw-rw-rw-  2.0 fat     2872 b- defN 24-May-02 19:31 extern/pybind11/noxfile.py
--rw-rw-rw-  2.0 fat     5027 b- defN 24-May-02 19:31 extern/pybind11/setup.py
--rw-rw-rw-  2.0 fat     2943 b- defN 24-May-02 19:31 extern/pybind11/docs/benchmark.py
--rw-rw-rw-  2.0 fat    11926 b- defN 24-May-02 19:31 extern/pybind11/docs/conf.py
--rw-rw-rw-  2.0 fat      431 b- defN 24-May-02 19:31 extern/pybind11/pybind11/__init__.py
--rw-rw-rw-  2.0 fat     1606 b- defN 24-May-02 19:31 extern/pybind11/pybind11/__main__.py
--rw-rw-rw-  2.0 fat      240 b- defN 24-May-02 19:31 extern/pybind11/pybind11/_version.py
--rw-rw-rw-  2.0 fat     1263 b- defN 24-May-02 19:31 extern/pybind11/pybind11/commands.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-02 19:31 extern/pybind11/pybind11/py.typed
--rw-rw-rw-  2.0 fat    18153 b- defN 24-May-02 19:31 extern/pybind11/pybind11/setup_helpers.py
--rw-rw-rw-  2.0 fat     6114 b- defN 24-May-02 19:31 extern/pybind11/tests/conftest.py
--rw-rw-rw-  2.0 fat      968 b- defN 24-May-02 19:31 extern/pybind11/tests/env.py
--rw-rw-rw-  2.0 fat      558 b- defN 24-May-02 19:31 extern/pybind11/tests/test_async.py
--rw-rw-rw-  2.0 fat     5004 b- defN 24-May-02 19:31 extern/pybind11/tests/test_buffers.py
--rw-rw-rw-  2.0 fat    17771 b- defN 24-May-02 19:31 extern/pybind11/tests/test_builtin_casters.py
--rw-rw-rw-  2.0 fat     6796 b- defN 24-May-02 19:31 extern/pybind11/tests/test_call_policies.py
--rw-rw-rw-  2.0 fat     6454 b- defN 24-May-02 19:31 extern/pybind11/tests/test_callbacks.py
--rw-rw-rw-  2.0 fat     5896 b- defN 24-May-02 19:31 extern/pybind11/tests/test_chrono.py
--rw-rw-rw-  2.0 fat    15302 b- defN 24-May-02 19:31 extern/pybind11/tests/test_class.py
--rw-rw-rw-  2.0 fat      618 b- defN 24-May-02 19:31 extern/pybind11/tests/test_const_name.py
--rw-rw-rw-  2.0 fat     1550 b- defN 24-May-02 19:31 extern/pybind11/tests/test_constants_and_functions.py
--rw-rw-rw-  2.0 fat     4928 b- defN 24-May-02 19:31 extern/pybind11/tests/test_copy_move.py
--rw-rw-rw-  2.0 fat     4106 b- defN 24-May-02 19:31 extern/pybind11/tests/test_custom_type_casters.py
--rw-rw-rw-  2.0 fat     1137 b- defN 24-May-02 19:31 extern/pybind11/tests/test_custom_type_setup.py
--rw-rw-rw-  2.0 fat     2487 b- defN 24-May-02 19:31 extern/pybind11/tests/test_docstring_options.py
--rw-rw-rw-  2.0 fat    29651 b- defN 24-May-02 19:31 extern/pybind11/tests/test_eigen_matrix.py
--rw-rw-rw-  2.0 fat     9740 b- defN 24-May-02 19:31 extern/pybind11/tests/test_eigen_tensor.py
--rw-rw-rw-  2.0 fat     9167 b- defN 24-May-02 19:31 extern/pybind11/tests/test_enum.py
--rw-rw-rw-  2.0 fat     1193 b- defN 24-May-02 19:31 extern/pybind11/tests/test_eval.py
--rw-rw-rw-  2.0 fat      123 b- defN 24-May-02 19:31 extern/pybind11/tests/test_eval_call.py
--rw-rw-rw-  2.0 fat    13157 b- defN 24-May-02 19:31 extern/pybind11/tests/test_exceptions.py
--rw-rw-rw-  2.0 fat    17035 b- defN 24-May-02 19:31 extern/pybind11/tests/test_factory_constructors.py
--rw-rw-rw-  2.0 fat     8784 b- defN 24-May-02 19:31 extern/pybind11/tests/test_gil_scoped.py
--rw-rw-rw-  2.0 fat     7581 b- defN 24-May-02 19:31 extern/pybind11/tests/test_iostream.py
--rw-rw-rw-  2.0 fat    14147 b- defN 24-May-02 19:31 extern/pybind11/tests/test_kwargs_and_defaults.py
--rw-rw-rw-  2.0 fat     8311 b- defN 24-May-02 19:31 extern/pybind11/tests/test_local_bindings.py
--rw-rw-rw-  2.0 fat    18661 b- defN 24-May-02 19:31 extern/pybind11/tests/test_methods_and_attributes.py
--rw-rw-rw-  2.0 fat     4329 b- defN 24-May-02 19:31 extern/pybind11/tests/test_modules.py
--rw-rw-rw-  2.0 fat    12367 b- defN 24-May-02 19:31 extern/pybind11/tests/test_multiple_inheritance.py
--rw-rw-rw-  2.0 fat    20949 b- defN 24-May-02 19:31 extern/pybind11/tests/test_numpy_array.py
--rw-rw-rw-  2.0 fat    14840 b- defN 24-May-02 19:31 extern/pybind11/tests/test_numpy_dtypes.py
--rw-rw-rw-  2.0 fat     9952 b- defN 24-May-02 19:31 extern/pybind11/tests/test_numpy_vectorize.py
--rw-rw-rw-  2.0 fat     1905 b- defN 24-May-02 19:31 extern/pybind11/tests/test_opaque_types.py
--rw-rw-rw-  2.0 fat     4483 b- defN 24-May-02 19:31 extern/pybind11/tests/test_operator_overloading.py
--rw-rw-rw-  2.0 fat     2813 b- defN 24-May-02 19:31 extern/pybind11/tests/test_pickling.py
--rw-rw-rw-  2.0 fat    24515 b- defN 24-May-02 19:31 extern/pybind11/tests/test_pytypes.py
--rw-rw-rw-  2.0 fat     8272 b- defN 24-May-02 19:31 extern/pybind11/tests/test_sequences_and_iterators.py
--rw-rw-rw-  2.0 fat     9845 b- defN 24-May-02 19:31 extern/pybind11/tests/test_smart_ptr.py
--rw-rw-rw-  2.0 fat    12612 b- defN 24-May-02 19:31 extern/pybind11/tests/test_stl.py
--rw-rw-rw-  2.0 fat     9511 b- defN 24-May-02 19:31 extern/pybind11/tests/test_stl_binders.py
--rw-rw-rw-  2.0 fat      769 b- defN 24-May-02 19:31 extern/pybind11/tests/test_tagbased_polymorphic.py
--rw-rw-rw-  2.0 fat      868 b- defN 24-May-02 19:31 extern/pybind11/tests/test_thread.py
--rw-rw-rw-  2.0 fat      156 b- defN 24-May-02 19:31 extern/pybind11/tests/test_union.py
--rw-rw-rw-  2.0 fat    13378 b- defN 24-May-02 19:31 extern/pybind11/tests/test_virtual_functions.py
--rw-rw-rw-  2.0 fat     8582 b- defN 24-May-02 19:31 extern/pybind11/tests/extra_python_package/test_files.py
--rw-rw-rw-  2.0 fat     4304 b- defN 24-May-02 19:31 extern/pybind11/tests/extra_setuptools/test_setuphelper.py
--rw-rw-rw-  2.0 fat      206 b- defN 24-May-02 19:31 extern/pybind11/tests/test_cmake_build/test.py
--rw-rw-rw-  2.0 fat      251 b- defN 24-May-02 19:31 extern/pybind11/tests/test_embed/test_interpreter.py
--rw-rw-rw-  2.0 fat      291 b- defN 24-May-02 19:31 extern/pybind11/tests/test_embed/test_trampoline.py
--rw-rw-rw-  2.0 fat     1075 b- defN 24-May-02 19:31 extern/pybind11/tools/codespell_ignore_lines_from_errors.py
--rw-rw-rw-  2.0 fat     1067 b- defN 24-May-02 19:31 extern/pybind11/tools/libsize.py
--rw-rw-rw-  2.0 fat     1373 b- defN 24-May-02 19:31 extern/pybind11/tools/make_changelog.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-02 19:31 tests/detectors/__init__.py
--rw-rw-rw-  2.0 fat     1835 b- defN 24-May-02 19:31 tests/detectors/test_coherent_mode.py
--rw-rw-rw-  2.0 fat     1555 b- defN 24-May-02 19:31 tests/detectors/test_integration_sphere.py
--rw-rw-rw-  2.0 fat     1763 b- defN 24-May-02 19:31 tests/detectors/test_photodiode.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-02 19:31 tests/experiments/__init__.py
--rw-rw-rw-  2.0 fat     2985 b- defN 24-May-02 19:31 tests/experiments/test_coreshell.py
--rw-rw-rw-  2.0 fat     2248 b- defN 24-May-02 19:31 tests/experiments/test_cylinder.py
--rw-rw-rw-  2.0 fat     2329 b- defN 24-May-02 19:31 tests/experiments/test_sphere.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-02 19:31 tests/extra/__init__.py
--rw-rw-rw-  2.0 fat      222 b- defN 24-May-02 19:31 tests/extra/test_mesh.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-02 19:31 tests/scatterers/__init__.py
--rw-rw-rw-  2.0 fat     3585 b- defN 24-May-02 19:31 tests/scatterers/test_coreshell.py
--rw-rw-rw-  2.0 fat     2677 b- defN 24-May-02 19:31 tests/scatterers/test_cylinder.py
--rw-rw-rw-  2.0 fat     3126 b- defN 24-May-02 19:31 tests/scatterers/test_sphere.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-02 19:31 tests/validation/__init__.py
--rw-rw-rw-  2.0 fat     3083 b- defN 24-May-02 19:31 tests/validation/test_coreshell_pymiescatt.py
--rw-rw-rw-  2.0 fat     3538 b- defN 24-May-02 19:31 tests/validation/test_detector.py
--rw-rw-rw-  2.0 fat     2180 b- defN 24-May-02 19:31 tests/validation/test_sphere_internal.py
--rw-rw-rw-  2.0 fat     2517 b- defN 24-May-02 19:31 tests/validation/test_sphere_pymiescatt.py
--rw-rw-rw-  2.0 fat      954 b- defN 24-May-02 19:31 tests/validation/test_sphere_scott_prahl.py
--rw-rw-rw-  2.0 fat     1109 b- defN 24-May-02 19:43 PyMieSim-1.9.1.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     9453 b- defN 24-May-02 19:43 PyMieSim-1.9.1.dist-info/METADATA
--rw-rw-rw-  2.0 fat      102 b- defN 24-May-02 19:43 PyMieSim-1.9.1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       72 b- defN 24-May-02 19:43 PyMieSim-1.9.1.dist-info/top_level.txt
--rw-rw-r--  2.0 fat    20225 b- defN 24-May-02 19:43 PyMieSim-1.9.1.dist-info/RECORD
-207 files, 18356534 bytes uncompressed, 8486628 bytes compressed:  53.8%
+Zip file size: 8904101 bytes, number of entries: 242
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 development/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 tests/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 docs/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 PyMieSim/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 extern/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 PyMieSim-1.9.3.dist-info/
+-rw-r--r--  2.0 unx      148 b- defN 24-May-30 18:42 development/debugging.py
+-rw-r--r--  2.0 unx     1434 b- defN 24-May-30 18:42 development/matthew_singer.py
+-rw-r--r--  2.0 unx     1003 b- defN 24-May-30 18:42 development/fcm.py
+-rw-r--r--  2.0 unx     1106 b- defN 24-May-30 18:42 development/matthew_singe-2.py
+-rw-r--r--  2.0 unx    13307 b- defN 24-May-30 18:42 development/gui.py
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 tests/experiments/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 tests/scatterers/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 tests/extra/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 tests/detectors/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 tests/validation/
+-rw-r--r--  2.0 unx     2898 b- defN 24-May-30 18:42 tests/experiments/test_coreshell.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-30 18:42 tests/experiments/__init__.py
+-rw-r--r--  2.0 unx     2254 b- defN 24-May-30 18:42 tests/experiments/test_sphere.py
+-rw-r--r--  2.0 unx     2172 b- defN 24-May-30 18:42 tests/experiments/test_cylinder.py
+-rw-r--r--  2.0 unx     3460 b- defN 24-May-30 18:42 tests/scatterers/test_coreshell.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-30 18:42 tests/scatterers/__init__.py
+-rw-r--r--  2.0 unx     3021 b- defN 24-May-30 18:42 tests/scatterers/test_sphere.py
+-rw-r--r--  2.0 unx     2568 b- defN 24-May-30 18:42 tests/scatterers/test_cylinder.py
+-rw-r--r--  2.0 unx      209 b- defN 24-May-30 18:42 tests/extra/test_mesh.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-30 18:42 tests/extra/__init__.py
+-rw-r--r--  2.0 unx     1509 b- defN 24-May-30 18:42 tests/detectors/test_integration_sphere.py
+-rw-r--r--  2.0 unx     1776 b- defN 24-May-30 18:42 tests/detectors/test_coherent_mode.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-30 18:42 tests/detectors/__init__.py
+-rw-r--r--  2.0 unx     1713 b- defN 24-May-30 18:42 tests/detectors/test_photodiode.py
+-rw-r--r--  2.0 unx     3417 b- defN 24-May-30 18:42 tests/validation/test_detector.py
+-rw-r--r--  2.0 unx     2097 b- defN 24-May-30 18:42 tests/validation/test_sphere_internal.py
+-rw-r--r--  2.0 unx      914 b- defN 24-May-30 18:42 tests/validation/test_sphere_scott_prahl.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-30 18:42 tests/validation/__init__.py
+-rw-r--r--  2.0 unx     2417 b- defN 24-May-30 18:42 tests/validation/test_sphere_pymiescatt.py
+-rw-r--r--  2.0 unx     2973 b- defN 24-May-30 18:42 tests/validation/test_coreshell_pymiescatt.py
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 docs/source/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 docs/examples/
+-rw-r--r--  2.0 unx     4528 b- defN 24-May-30 18:42 docs/source/conf.py
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 docs/examples/scatterer/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 docs/examples/detector/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 docs/examples/experiment/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 docs/examples/validation/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 docs/examples/extras/
+-rw-r--r--  2.0 unx      905 b- defN 24-May-30 18:42 docs/examples/scatterer/plot_stokes.py
+-rw-r--r--  2.0 unx     1289 b- defN 24-May-30 18:42 docs/examples/scatterer/plot_footprint.py
+-rw-r--r--  2.0 unx     1012 b- defN 24-May-30 18:42 docs/examples/scatterer/plot_farfield.py
+-rw-r--r--  2.0 unx      899 b- defN 24-May-30 18:42 docs/examples/scatterer/plot_s1s2.py
+-rw-r--r--  2.0 unx      961 b- defN 24-May-30 18:42 docs/examples/scatterer/plot_spf.py
+-rw-r--r--  2.0 unx      565 b- defN 24-May-30 18:42 docs/examples/scatterer/plot_source.py
+-rw-r--r--  2.0 unx      830 b- defN 24-May-30 18:42 docs/examples/detector/plot_HG11.py
+-rw-r--r--  2.0 unx      814 b- defN 24-May-30 18:42 docs/examples/detector/plot_HG01.py
+-rw-r--r--  2.0 unx      612 b- defN 24-May-30 18:42 docs/examples/detector/plot_LP02.py
+-rw-r--r--  2.0 unx      534 b- defN 24-May-30 18:42 docs/examples/detector/plot_integrating_sphere.py
+-rw-r--r--  2.0 unx      818 b- defN 24-May-30 18:42 docs/examples/detector/plot_LG11.py
+-rw-r--r--  2.0 unx      638 b- defN 24-May-30 18:42 docs/examples/detector/plot_photodiode.py
+-rw-r--r--  2.0 unx      793 b- defN 24-May-30 18:42 docs/examples/detector/plot_LP01.py
+-rw-r--r--  2.0 unx      612 b- defN 24-May-30 18:42 docs/examples/detector/plot_LP11.py
+-rw-r--r--  2.0 unx     1538 b- defN 24-May-30 18:42 docs/examples/experiment/plot_cylinder_a11_vs_diameter.py
+-rw-r--r--  2.0 unx     1978 b- defN 24-May-30 18:42 docs/examples/experiment/plot_cylinder_coupling_vs_phioffset.py
+-rw-r--r--  2.0 unx     1289 b- defN 24-May-30 18:42 docs/examples/experiment/plot_sphere_coupling_vs_phioffset.py
+-rw-r--r--  2.0 unx     1561 b- defN 24-May-30 18:42 docs/examples/experiment/plot_cylinder_Qsca_vs_index.py
+-rw-r--r--  2.0 unx     1836 b- defN 24-May-30 18:42 docs/examples/experiment/plot_coreshell_Qback_vs_corediameter.py
+-rw-r--r--  2.0 unx      967 b- defN 24-May-30 18:42 docs/examples/experiment/plot_sphere_a1_vs_diameter.py
+-rw-r--r--  2.0 unx     1333 b- defN 24-May-30 18:42 docs/examples/experiment/plot_sphere_coupling_vs_diameter.py
+-rw-r--r--  2.0 unx     1810 b- defN 24-May-30 18:42 docs/examples/experiment/plot_cylinder_Qabs_vs_diameter.py
+-rw-r--r--  2.0 unx     1568 b- defN 24-May-30 18:42 docs/examples/experiment/plot_cylinder_Qsca_vs_diameter.py
+-rw-r--r--  2.0 unx     1956 b- defN 24-May-30 18:42 docs/examples/experiment/plot_cylinder_coupling_vs_diameter.py
+-rw-r--r--  2.0 unx      954 b- defN 24-May-30 18:42 docs/examples/experiment/plot_sphere_Qsca_vs_index.py
+-rw-r--r--  2.0 unx      964 b- defN 24-May-30 18:42 docs/examples/experiment/plot_sphere_b1_vs_diameter.py
+-rw-r--r--  2.0 unx     1316 b- defN 24-May-30 18:42 docs/examples/experiment/plot_sphere_coherent_coupling_vs_rotation.py
+-rw-r--r--  2.0 unx      971 b- defN 24-May-30 18:42 docs/examples/experiment/plot_sphere_Qsca_vs_diameter.py
+-rw-r--r--  2.0 unx      982 b- defN 24-May-30 18:42 docs/examples/experiment/plot_sphere_Qsca_vs_wavelength.py
+-rw-r--r--  2.0 unx     1063 b- defN 24-May-30 18:42 docs/examples/experiment/plot_sphere_Qabs_vs_diameter.py
+-rw-r--r--  2.0 unx     1382 b- defN 24-May-30 18:42 docs/examples/experiment/plot_sphere_coherent_coupling_vs_phioffset.py
+-rw-r--r--  2.0 unx     2062 b- defN 24-May-30 18:42 docs/examples/experiment/plot_coreshell_a1_vs_corediameter.py
+-rw-r--r--  2.0 unx     2054 b- defN 24-May-30 18:42 docs/examples/experiment/plot_coreshell_coupling_vs_corediameter.py
+-rw-r--r--  2.0 unx     1452 b- defN 24-May-30 18:42 docs/examples/experiment/plot_cylinder_b11_vs_diameter.py
+-rw-r--r--  2.0 unx     1969 b- defN 24-May-30 18:42 docs/examples/experiment/plot_coreshell_b1_vs_corediameter.py
+-rw-r--r--  2.0 unx     1093 b- defN 24-May-30 18:42 docs/examples/experiment/plot_sphere_Qsca_vs_wavelength_std.py
+-rw-r--r--  2.0 unx     1373 b- defN 24-May-30 18:42 docs/examples/experiment/plot_sphere_coupling_vs_wavelength.py
+-rw-r--r--  2.0 unx     1098 b- defN 24-May-30 18:42 docs/examples/experiment/plot_cylinder_Qsca_vs_wavelength_std.py
+-rw-r--r--  2.0 unx     2187 b- defN 24-May-30 18:42 docs/examples/experiment/plot_cylinder_coupling_vs_wavelength.py
+-rw-r--r--  2.0 unx     1420 b- defN 24-May-30 18:42 docs/examples/experiment/plot_sphere_coupling_vs_filter.py
+-rw-r--r--  2.0 unx     1888 b- defN 24-May-30 18:42 docs/examples/experiment/plot_cylinder_Qsca_vs_wavelength.py
+-rw-r--r--  2.0 unx     1878 b- defN 24-May-30 18:42 docs/examples/validation/plot_pymiescatt_0.py
+-rw-r--r--  2.0 unx     2653 b- defN 24-May-30 18:42 docs/examples/validation/plot_phase_function_detector.py
+-rw-r--r--  2.0 unx     1956 b- defN 24-May-30 18:42 docs/examples/validation/plot_pymiescatt_1.py
+-rw-r--r--  2.0 unx     1569 b- defN 24-May-30 18:42 docs/examples/validation/plot_BH87.py
+-rw-r--r--  2.0 unx     2599 b- defN 24-May-30 18:42 docs/examples/validation/plot_BH88.py
+-rw-r--r--  2.0 unx     1154 b- defN 24-May-30 18:42 docs/examples/validation/plot_BH810.py
+-rw-r--r--  2.0 unx     2143 b- defN 24-May-30 18:42 docs/examples/validation/plot_pymiescatt_2.py
+-rw-r--r--  2.0 unx     2246 b- defN 24-May-30 18:42 docs/examples/validation/plot_pymiescatt_3.py
+-rw-r--r--  2.0 unx      983 b- defN 24-May-30 18:42 docs/examples/extras/SphereProperties.py
+-rw-r--r--  2.0 unx     1528 b- defN 24-May-30 18:42 docs/examples/extras/plot_Qsca_vs_permittivity_vs_size_parameter.py
+-rw-r--r--  2.0 unx     1663 b- defN 24-May-30 18:42 docs/examples/extras/plot_coupling_heatmap.py
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 PyMieSim/tools/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 PyMieSim/single/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 PyMieSim/.dylibs/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 PyMieSim/validation_data/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 PyMieSim/gui/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 PyMieSim/experiment/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 PyMieSim/binary/
+-rw-r--r--  2.0 unx     3680 b- defN 24-May-30 18:42 PyMieSim/measure.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-30 18:42 PyMieSim/__init__.py
+-rw-r--r--  2.0 unx     7626 b- defN 24-May-30 18:42 PyMieSim/mesh.py
+-rw-r--r--  2.0 unx     1932 b- defN 24-May-30 18:42 PyMieSim/physics.py
+-rw-r--r--  2.0 unx        6 b- defN 24-May-30 18:42 PyMieSim/VERSION
+-rw-r--r--  2.0 unx     2011 b- defN 24-May-30 18:42 PyMieSim/polarization.py
+-rw-r--r--  2.0 unx      215 b- defN 24-May-30 18:42 PyMieSim/__main__.py
+-rw-r--r--  2.0 unx     1133 b- defN 24-May-30 18:42 PyMieSim/tools/directories.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-30 18:42 PyMieSim/tools/__init__.py
+-rw-r--r--  2.0 unx     6049 b- defN 24-May-30 18:42 PyMieSim/tools/special_functions.py
+-rw-r--r--  2.0 unx    10357 b- defN 24-May-30 18:42 PyMieSim/single/detector.py
+-rw-r--r--  2.0 unx    19442 b- defN 24-May-30 18:42 PyMieSim/single/scatterer.py
+-rw-r--r--  2.0 unx      137 b- defN 24-May-30 18:42 PyMieSim/single/__init__.py
+-rw-r--r--  2.0 unx    19167 b- defN 24-May-30 18:42 PyMieSim/single/representations.py
+-rw-r--r--  2.0 unx     5414 b- defN 24-May-30 18:42 PyMieSim/single/source.py
+-r--r--r--  2.0 unx   477504 b- defN 24-May-30 19:08 PyMieSim/.dylibs/libgomp.1.dylib
+-rw-r--r--  2.0 unx    40000 b- defN 24-May-30 18:42 PyMieSim/validation_data/Figure87BH.csv
+-rw-r--r--  2.0 unx    20000 b- defN 24-May-30 18:42 PyMieSim/validation_data/PyMieScattQsca.csv
+-rw-r--r--  2.0 unx     9828 b- defN 24-May-30 18:42 PyMieSim/validation_data/Figure810BH.csv
+-rw-r--r--  2.0 unx    10000 b- defN 24-May-30 18:42 PyMieSim/validation_data/PyMieScattQscaCoreShell.csv
+-rw-r--r--  2.0 unx    40000 b- defN 24-May-30 18:42 PyMieSim/validation_data/Figure88BH.csv
+-rw-r--r--  2.0 unx    20000 b- defN 24-May-30 18:42 PyMieSim/validation_data/PyMieScattQscaMedium.csv
+-rw-r--r--  2.0 unx    10000 b- defN 24-May-30 18:42 PyMieSim/validation_data/PyMieScattQscaCoreShellMedium.csv
+-rw-r--r--  2.0 unx     7483 b- defN 24-May-30 18:42 PyMieSim/gui/main_window.py
+-rw-r--r--  2.0 unx     2570 b- defN 24-May-30 18:42 PyMieSim/gui/source_tab.py
+-rw-r--r--  2.0 unx      203 b- defN 24-May-30 18:42 PyMieSim/gui/__init__.py
+-rw-r--r--  2.0 unx     3208 b- defN 24-May-30 18:42 PyMieSim/gui/axis_tab.py
+-rw-r--r--  2.0 unx     3306 b- defN 24-May-30 18:42 PyMieSim/gui/base_tab.py
+-rw-r--r--  2.0 unx     6471 b- defN 24-May-30 18:42 PyMieSim/gui/widgets.py
+-rw-r--r--  2.0 unx     3032 b- defN 24-May-30 18:42 PyMieSim/gui/widget_collection.py
+-rw-r--r--  2.0 unx     6245 b- defN 24-May-30 18:42 PyMieSim/gui/detector_tab.py
+-rw-r--r--  2.0 unx     6915 b- defN 24-May-30 18:42 PyMieSim/gui/scatterer_tab.py
+-rw-r--r--  2.0 unx     8281 b- defN 24-May-30 18:42 PyMieSim/experiment/detector.py
+-rw-r--r--  2.0 unx    17033 b- defN 24-May-30 18:42 PyMieSim/experiment/scatterer.py
+-rw-r--r--  2.0 unx      162 b- defN 24-May-30 18:42 PyMieSim/experiment/__init__.py
+-rw-r--r--  2.0 unx     4992 b- defN 24-May-30 18:42 PyMieSim/experiment/setup.py
+-rw-r--r--  2.0 unx     5493 b- defN 24-May-30 18:42 PyMieSim/experiment/source.py
+-rwxr-xr-x  2.0 unx  1006560 b- defN 24-May-30 18:59 PyMieSim/binary/DetectorInterface.cpython-311-darwin.so
+-rwxr-xr-x  2.0 unx   957560 b- defN 24-May-30 18:50 PyMieSim/binary/CoreShellInterface.cpython-310-darwin.so
+-rwxr-xr-x  2.0 unx   430144 b- defN 24-May-30 19:08 PyMieSim/binary/ModeField.cpython-312-darwin.so
+-rwxr-xr-x  2.0 unx   941240 b- defN 24-May-30 19:08 PyMieSim/binary/CylinderInterface.cpython-312-darwin.so
+-rwxr-xr-x  2.0 unx   467368 b- defN 24-May-30 19:08 PyMieSim/binary/Fibonacci.cpython-312-darwin.so
+-rwxr-xr-x  2.0 unx  1025424 b- defN 24-May-30 19:08 PyMieSim/binary/Sets.cpython-312-darwin.so
+-rwxr-xr-x  2.0 unx  1006560 b- defN 24-May-30 18:50 PyMieSim/binary/DetectorInterface.cpython-310-darwin.so
+-rwxr-xr-x  2.0 unx   957560 b- defN 24-May-30 18:59 PyMieSim/binary/CoreShellInterface.cpython-311-darwin.so
+-rwxr-xr-x  2.0 unx   957776 b- defN 24-May-30 19:08 PyMieSim/binary/SphereInterface.cpython-312-darwin.so
+-rw-r--r--  2.0 unx        0 b- defN 24-May-30 18:42 PyMieSim/binary/__init__.py
+-rwxr-xr-x  2.0 unx  1117760 b- defN 24-May-30 19:08 PyMieSim/binary/Experiment.cpython-312-darwin.so
+-rwxr-xr-x  2.0 unx   941120 b- defN 24-May-30 18:59 PyMieSim/binary/CylinderInterface.cpython-311-darwin.so
+-rw-r--r--  2.0 unx   158824 b- defN 24-May-30 19:08 PyMieSim/binary/libZBessel.a
+-rwxr-xr-x  2.0 unx   957696 b- defN 24-May-30 19:08 PyMieSim/binary/CoreShellInterface.cpython-312-darwin.so
+-rwxr-xr-x  2.0 unx  1025312 b- defN 24-May-30 18:59 PyMieSim/binary/Sets.cpython-311-darwin.so
+-rwxr-xr-x  2.0 unx   467248 b- defN 24-May-30 18:59 PyMieSim/binary/Fibonacci.cpython-311-darwin.so
+-rwxr-xr-x  2.0 unx   957640 b- defN 24-May-30 18:59 PyMieSim/binary/SphereInterface.cpython-311-darwin.so
+-rwxr-xr-x  2.0 unx   429872 b- defN 24-May-30 18:49 PyMieSim/binary/ModeField.cpython-310-darwin.so
+-rwxr-xr-x  2.0 unx  1117648 b- defN 24-May-30 19:08 PyMieSim/binary/Experiment.cpython-311-darwin.so
+-rwxr-xr-x  2.0 unx   941120 b- defN 24-May-30 18:50 PyMieSim/binary/CylinderInterface.cpython-310-darwin.so
+-rwxr-xr-x  2.0 unx  1006696 b- defN 24-May-30 19:08 PyMieSim/binary/DetectorInterface.cpython-312-darwin.so
+-rwxr-xr-x  2.0 unx   467248 b- defN 24-May-30 18:49 PyMieSim/binary/Fibonacci.cpython-310-darwin.so
+-rwxr-xr-x  2.0 unx  1025312 b- defN 24-May-30 18:50 PyMieSim/binary/Sets.cpython-310-darwin.so
+-rwxr-xr-x  2.0 unx   957640 b- defN 24-May-30 18:49 PyMieSim/binary/SphereInterface.cpython-310-darwin.so
+-rwxr-xr-x  2.0 unx   429872 b- defN 24-May-30 18:59 PyMieSim/binary/ModeField.cpython-311-darwin.so
+-rwxr-xr-x  2.0 unx  1117648 b- defN 24-May-30 19:08 PyMieSim/binary/Experiment.cpython-310-darwin.so
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 extern/pybind11/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 extern/pybind11/tools/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 extern/pybind11/pybind11/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 extern/pybind11/tests/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 extern/pybind11/docs/
+-rw-r--r--  2.0 unx     4877 b- defN 24-May-30 18:42 extern/pybind11/setup.py
+-rw-r--r--  2.0 unx     2765 b- defN 24-May-30 18:42 extern/pybind11/noxfile.py
+-rw-r--r--  2.0 unx     1031 b- defN 24-May-30 18:42 extern/pybind11/tools/libsize.py
+-rw-r--r--  2.0 unx     1311 b- defN 24-May-30 18:42 extern/pybind11/tools/make_changelog.py
+-rw-r--r--  2.0 unx     1040 b- defN 24-May-30 18:42 extern/pybind11/tools/codespell_ignore_lines_from_errors.py
+-rw-r--r--  2.0 unx    17650 b- defN 24-May-30 18:42 extern/pybind11/pybind11/setup_helpers.py
+-rw-r--r--  2.0 unx      228 b- defN 24-May-30 18:42 extern/pybind11/pybind11/_version.py
+-rw-r--r--  2.0 unx      414 b- defN 24-May-30 18:42 extern/pybind11/pybind11/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-30 18:42 extern/pybind11/pybind11/py.typed
+-rw-r--r--  2.0 unx     1226 b- defN 24-May-30 18:42 extern/pybind11/pybind11/commands.py
+-rw-r--r--  2.0 unx     1544 b- defN 24-May-30 18:42 extern/pybind11/pybind11/__main__.py
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 extern/pybind11/tests/test_embed/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 extern/pybind11/tests/test_cmake_build/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 extern/pybind11/tests/extra_setuptools/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 19:08 extern/pybind11/tests/extra_python_package/
+-rw-r--r--  2.0 unx     9174 b- defN 24-May-30 18:42 extern/pybind11/tests/test_stl_binders.py
+-rw-r--r--  2.0 unx    18134 b- defN 24-May-30 18:42 extern/pybind11/tests/test_methods_and_attributes.py
+-rw-r--r--  2.0 unx     8021 b- defN 24-May-30 18:42 extern/pybind11/tests/test_sequences_and_iterators.py
+-rw-r--r--  2.0 unx     9686 b- defN 24-May-30 18:42 extern/pybind11/tests/test_numpy_vectorize.py
+-rw-r--r--  2.0 unx     5691 b- defN 24-May-30 18:42 extern/pybind11/tests/test_chrono.py
+-rw-r--r--  2.0 unx     5876 b- defN 24-May-30 18:42 extern/pybind11/tests/conftest.py
+-rw-r--r--  2.0 unx     6246 b- defN 24-May-30 18:42 extern/pybind11/tests/test_callbacks.py
+-rw-r--r--  2.0 unx    23630 b- defN 24-May-30 18:42 extern/pybind11/tests/test_pytypes.py
+-rw-r--r--  2.0 unx    14814 b- defN 24-May-30 18:42 extern/pybind11/tests/test_class.py
+-rw-r--r--  2.0 unx      940 b- defN 24-May-30 18:42 extern/pybind11/tests/env.py
+-rw-r--r--  2.0 unx     9450 b- defN 24-May-30 18:42 extern/pybind11/tests/test_eigen_tensor.py
+-rw-r--r--  2.0 unx     2423 b- defN 24-May-30 18:42 extern/pybind11/tests/test_docstring_options.py
+-rw-r--r--  2.0 unx      534 b- defN 24-May-30 18:42 extern/pybind11/tests/test_async.py
+-rw-r--r--  2.0 unx     8054 b- defN 24-May-30 18:42 extern/pybind11/tests/test_local_bindings.py
+-rw-r--r--  2.0 unx     9530 b- defN 24-May-30 18:42 extern/pybind11/tests/test_smart_ptr.py
+-rw-r--r--  2.0 unx    20356 b- defN 24-May-30 18:42 extern/pybind11/tests/test_numpy_array.py
+-rw-r--r--  2.0 unx    17245 b- defN 24-May-30 18:42 extern/pybind11/tests/test_builtin_casters.py
+-rw-r--r--  2.0 unx     1498 b- defN 24-May-30 18:42 extern/pybind11/tests/test_constants_and_functions.py
+-rw-r--r--  2.0 unx    12774 b- defN 24-May-30 18:42 extern/pybind11/tests/test_exceptions.py
+-rw-r--r--  2.0 unx    16519 b- defN 24-May-30 18:42 extern/pybind11/tests/test_factory_constructors.py
+-rw-r--r--  2.0 unx     7286 b- defN 24-May-30 18:42 extern/pybind11/tests/test_iostream.py
+-rw-r--r--  2.0 unx     4332 b- defN 24-May-30 18:42 extern/pybind11/tests/test_operator_overloading.py
+-rw-r--r--  2.0 unx      148 b- defN 24-May-30 18:42 extern/pybind11/tests/test_union.py
+-rw-r--r--  2.0 unx    13757 b- defN 24-May-30 18:42 extern/pybind11/tests/test_kwargs_and_defaults.py
+-rw-r--r--  2.0 unx      826 b- defN 24-May-30 18:42 extern/pybind11/tests/test_thread.py
+-rw-r--r--  2.0 unx     2720 b- defN 24-May-30 18:42 extern/pybind11/tests/test_pickling.py
+-rw-r--r--  2.0 unx     4796 b- defN 24-May-30 18:42 extern/pybind11/tests/test_copy_move.py
+-rw-r--r--  2.0 unx      119 b- defN 24-May-30 18:42 extern/pybind11/tests/test_eval_call.py
+-rw-r--r--  2.0 unx     3985 b- defN 24-May-30 18:42 extern/pybind11/tests/test_custom_type_casters.py
+-rw-r--r--  2.0 unx    12235 b- defN 24-May-30 18:42 extern/pybind11/tests/test_stl.py
+-rw-r--r--  2.0 unx    14394 b- defN 24-May-30 18:42 extern/pybind11/tests/test_numpy_dtypes.py
+-rw-r--r--  2.0 unx    28867 b- defN 24-May-30 18:42 extern/pybind11/tests/test_eigen_matrix.py
+-rw-r--r--  2.0 unx     1847 b- defN 24-May-30 18:42 extern/pybind11/tests/test_opaque_types.py
+-rw-r--r--  2.0 unx    12919 b- defN 24-May-30 18:42 extern/pybind11/tests/test_virtual_functions.py
+-rw-r--r--  2.0 unx      589 b- defN 24-May-30 18:42 extern/pybind11/tests/test_const_name.py
+-rw-r--r--  2.0 unx     6549 b- defN 24-May-30 18:42 extern/pybind11/tests/test_call_policies.py
+-rw-r--r--  2.0 unx     1089 b- defN 24-May-30 18:42 extern/pybind11/tests/test_custom_type_setup.py
+-rw-r--r--  2.0 unx     4841 b- defN 24-May-30 18:42 extern/pybind11/tests/test_buffers.py
+-rw-r--r--  2.0 unx     4209 b- defN 24-May-30 18:42 extern/pybind11/tests/test_modules.py
+-rw-r--r--  2.0 unx     8540 b- defN 24-May-30 18:42 extern/pybind11/tests/test_gil_scoped.py
+-rw-r--r--  2.0 unx    11874 b- defN 24-May-30 18:42 extern/pybind11/tests/test_multiple_inheritance.py
+-rw-r--r--  2.0 unx      741 b- defN 24-May-30 18:42 extern/pybind11/tests/test_tagbased_polymorphic.py
+-rw-r--r--  2.0 unx     1143 b- defN 24-May-30 18:42 extern/pybind11/tests/test_eval.py
+-rw-r--r--  2.0 unx     8903 b- defN 24-May-30 18:42 extern/pybind11/tests/test_enum.py
+-rw-r--r--  2.0 unx      275 b- defN 24-May-30 18:42 extern/pybind11/tests/test_embed/test_trampoline.py
+-rw-r--r--  2.0 unx      237 b- defN 24-May-30 18:42 extern/pybind11/tests/test_embed/test_interpreter.py
+-rw-r--r--  2.0 unx      198 b- defN 24-May-30 18:42 extern/pybind11/tests/test_cmake_build/test.py
+-rw-r--r--  2.0 unx     4153 b- defN 24-May-30 18:42 extern/pybind11/tests/extra_setuptools/test_setuphelper.py
+-rw-r--r--  2.0 unx     8294 b- defN 24-May-30 18:42 extern/pybind11/tests/extra_python_package/test_files.py
+-rw-r--r--  2.0 unx     2856 b- defN 24-May-30 18:42 extern/pybind11/docs/benchmark.py
+-rw-r--r--  2.0 unx    11558 b- defN 24-May-30 18:42 extern/pybind11/docs/conf.py
+-rw-rw-r--  2.0 unx    20574 b- defN 24-May-30 19:08 PyMieSim-1.9.3.dist-info/RECORD
+-rw-r--r--  2.0 unx     1088 b- defN 24-May-30 19:08 PyMieSim-1.9.3.dist-info/LICENSE
+-rw-r--r--  2.0 unx      110 b- defN 24-May-30 19:08 PyMieSim-1.9.3.dist-info/WHEEL
+-rw-r--r--  2.0 unx       60 b- defN 24-May-30 19:08 PyMieSim-1.9.3.dist-info/top_level.txt
+-rw-r--r--  2.0 unx    10426 b- defN 24-May-30 19:08 PyMieSim-1.9.3.dist-info/METADATA
+242 files, 22224604 bytes uncompressed, 8867255 bytes compressed:  60.1%
```

## zipnote {}

```diff
@@ -1,622 +1,727 @@
-Filename: PyMieSim/VERSION
+Filename: development/
 Comment: 
 
-Filename: PyMieSim/__init__.py
+Filename: tests/
 Comment: 
 
-Filename: PyMieSim/__main__.py
+Filename: docs/
 Comment: 
 
-Filename: PyMieSim/measure.py
+Filename: PyMieSim/
 Comment: 
 
-Filename: PyMieSim/mesh.py
+Filename: extern/
 Comment: 
 
-Filename: PyMieSim/physics.py
+Filename: PyMieSim-1.9.3.dist-info/
 Comment: 
 
-Filename: PyMieSim/polarization.py
+Filename: development/debugging.py
 Comment: 
 
-Filename: PyMieSim/binary/CoreShellInterface.cp310-win_amd64.pyd
+Filename: development/matthew_singer.py
 Comment: 
 
-Filename: PyMieSim/binary/CoreShellInterface.cp311-win_amd64.pyd
+Filename: development/fcm.py
 Comment: 
 
-Filename: PyMieSim/binary/CoreShellInterface.cp312-win_amd64.pyd
+Filename: development/matthew_singe-2.py
 Comment: 
 
-Filename: PyMieSim/binary/CylinderInterface.cp310-win_amd64.pyd
+Filename: development/gui.py
 Comment: 
 
-Filename: PyMieSim/binary/CylinderInterface.cp311-win_amd64.pyd
+Filename: tests/experiments/
 Comment: 
 
-Filename: PyMieSim/binary/CylinderInterface.cp312-win_amd64.pyd
+Filename: tests/scatterers/
 Comment: 
 
-Filename: PyMieSim/binary/DetectorInterface.cp310-win_amd64.pyd
+Filename: tests/extra/
 Comment: 
 
-Filename: PyMieSim/binary/DetectorInterface.cp311-win_amd64.pyd
+Filename: tests/detectors/
 Comment: 
 
-Filename: PyMieSim/binary/DetectorInterface.cp312-win_amd64.pyd
+Filename: tests/validation/
 Comment: 
 
-Filename: PyMieSim/binary/Experiment.cp310-win_amd64.pyd
+Filename: tests/experiments/test_coreshell.py
 Comment: 
 
-Filename: PyMieSim/binary/Experiment.cp311-win_amd64.pyd
+Filename: tests/experiments/__init__.py
 Comment: 
 
-Filename: PyMieSim/binary/Experiment.cp312-win_amd64.pyd
+Filename: tests/experiments/test_sphere.py
 Comment: 
 
-Filename: PyMieSim/binary/Fibonacci.cp310-win_amd64.pyd
+Filename: tests/experiments/test_cylinder.py
 Comment: 
 
-Filename: PyMieSim/binary/Fibonacci.cp311-win_amd64.pyd
+Filename: tests/scatterers/test_coreshell.py
 Comment: 
 
-Filename: PyMieSim/binary/Fibonacci.cp312-win_amd64.pyd
+Filename: tests/scatterers/__init__.py
 Comment: 
 
-Filename: PyMieSim/binary/ModeField.cp310-win_amd64.pyd
+Filename: tests/scatterers/test_sphere.py
 Comment: 
 
-Filename: PyMieSim/binary/ModeField.cp311-win_amd64.pyd
+Filename: tests/scatterers/test_cylinder.py
 Comment: 
 
-Filename: PyMieSim/binary/ModeField.cp312-win_amd64.pyd
+Filename: tests/extra/test_mesh.py
 Comment: 
 
-Filename: PyMieSim/binary/Sets.cp310-win_amd64.pyd
+Filename: tests/extra/__init__.py
 Comment: 
 
-Filename: PyMieSim/binary/Sets.cp311-win_amd64.pyd
+Filename: tests/detectors/test_integration_sphere.py
 Comment: 
 
-Filename: PyMieSim/binary/Sets.cp312-win_amd64.pyd
+Filename: tests/detectors/test_coherent_mode.py
 Comment: 
 
-Filename: PyMieSim/binary/SphereInterface.cp310-win_amd64.pyd
+Filename: tests/detectors/__init__.py
 Comment: 
 
-Filename: PyMieSim/binary/SphereInterface.cp311-win_amd64.pyd
+Filename: tests/detectors/test_photodiode.py
 Comment: 
 
-Filename: PyMieSim/binary/SphereInterface.cp312-win_amd64.pyd
+Filename: tests/validation/test_detector.py
 Comment: 
 
-Filename: PyMieSim/binary/__init__.py
+Filename: tests/validation/test_sphere_internal.py
 Comment: 
 
-Filename: PyMieSim/binary/libZBessel.a
+Filename: tests/validation/test_sphere_scott_prahl.py
 Comment: 
 
-Filename: PyMieSim/experiment/__init__.py
+Filename: tests/validation/__init__.py
 Comment: 
 
-Filename: PyMieSim/experiment/detector.py
+Filename: tests/validation/test_sphere_pymiescatt.py
 Comment: 
 
-Filename: PyMieSim/experiment/scatterer.py
+Filename: tests/validation/test_coreshell_pymiescatt.py
 Comment: 
 
-Filename: PyMieSim/experiment/setup.py
+Filename: docs/source/
 Comment: 
 
-Filename: PyMieSim/experiment/source.py
+Filename: docs/examples/
 Comment: 
 
-Filename: PyMieSim/gui/__init__.py
+Filename: docs/source/conf.py
 Comment: 
 
-Filename: PyMieSim/gui/axis_tab.py
+Filename: docs/examples/scatterer/
 Comment: 
 
-Filename: PyMieSim/gui/base_tab.py
+Filename: docs/examples/detector/
 Comment: 
 
-Filename: PyMieSim/gui/detector_tab.py
+Filename: docs/examples/experiment/
 Comment: 
 
-Filename: PyMieSim/gui/main_window.py
+Filename: docs/examples/validation/
 Comment: 
 
-Filename: PyMieSim/gui/scatterer_tab.py
+Filename: docs/examples/extras/
 Comment: 
 
-Filename: PyMieSim/gui/source_tab.py
+Filename: docs/examples/scatterer/plot_stokes.py
 Comment: 
 
-Filename: PyMieSim/gui/widget_collection.py
+Filename: docs/examples/scatterer/plot_footprint.py
 Comment: 
 
-Filename: PyMieSim/gui/widgets.py
+Filename: docs/examples/scatterer/plot_farfield.py
 Comment: 
 
-Filename: PyMieSim/single/__init__.py
+Filename: docs/examples/scatterer/plot_s1s2.py
 Comment: 
 
-Filename: PyMieSim/single/detector.py
+Filename: docs/examples/scatterer/plot_spf.py
 Comment: 
 
-Filename: PyMieSim/single/representations.py
+Filename: docs/examples/scatterer/plot_source.py
 Comment: 
 
-Filename: PyMieSim/single/scatterer.py
+Filename: docs/examples/detector/plot_HG11.py
 Comment: 
 
-Filename: PyMieSim/single/source.py
+Filename: docs/examples/detector/plot_HG01.py
 Comment: 
 
-Filename: PyMieSim/tools/__init__.py
+Filename: docs/examples/detector/plot_LP02.py
 Comment: 
 
-Filename: PyMieSim/tools/directories.py
+Filename: docs/examples/detector/plot_integrating_sphere.py
 Comment: 
 
-Filename: PyMieSim/tools/special_functions.py
+Filename: docs/examples/detector/plot_LG11.py
 Comment: 
 
-Filename: PyMieSim/validation_data/Figure810BH.csv
+Filename: docs/examples/detector/plot_photodiode.py
 Comment: 
 
-Filename: PyMieSim/validation_data/Figure87BH.csv
+Filename: docs/examples/detector/plot_LP01.py
 Comment: 
 
-Filename: PyMieSim/validation_data/Figure88BH.csv
+Filename: docs/examples/detector/plot_LP11.py
 Comment: 
 
-Filename: PyMieSim/validation_data/PyMieScattQsca.csv
+Filename: docs/examples/experiment/plot_cylinder_a11_vs_diameter.py
 Comment: 
 
-Filename: PyMieSim/validation_data/PyMieScattQscaCoreShell.csv
+Filename: docs/examples/experiment/plot_cylinder_coupling_vs_phioffset.py
 Comment: 
 
-Filename: PyMieSim/validation_data/PyMieScattQscaCoreShellMedium.csv
+Filename: docs/examples/experiment/plot_sphere_coupling_vs_phioffset.py
 Comment: 
 
-Filename: PyMieSim/validation_data/PyMieScattQscaMedium.csv
+Filename: docs/examples/experiment/plot_cylinder_Qsca_vs_index.py
 Comment: 
 
-Filename: development/debugging.py
+Filename: docs/examples/experiment/plot_coreshell_Qback_vs_corediameter.py
 Comment: 
 
-Filename: development/fcm.py
+Filename: docs/examples/experiment/plot_sphere_a1_vs_diameter.py
 Comment: 
 
-Filename: development/gui.py
+Filename: docs/examples/experiment/plot_sphere_coupling_vs_diameter.py
 Comment: 
 
-Filename: development/matthew_singe-2.py
+Filename: docs/examples/experiment/plot_cylinder_Qabs_vs_diameter.py
 Comment: 
 
-Filename: development/matthew_singer.py
+Filename: docs/examples/experiment/plot_cylinder_Qsca_vs_diameter.py
 Comment: 
 
-Filename: docs/examples/detector/plot_HG01.py
+Filename: docs/examples/experiment/plot_cylinder_coupling_vs_diameter.py
 Comment: 
 
-Filename: docs/examples/detector/plot_HG11.py
+Filename: docs/examples/experiment/plot_sphere_Qsca_vs_index.py
 Comment: 
 
-Filename: docs/examples/detector/plot_LG11.py
+Filename: docs/examples/experiment/plot_sphere_b1_vs_diameter.py
 Comment: 
 
-Filename: docs/examples/detector/plot_LP01.py
+Filename: docs/examples/experiment/plot_sphere_coherent_coupling_vs_rotation.py
 Comment: 
 
-Filename: docs/examples/detector/plot_LP02.py
+Filename: docs/examples/experiment/plot_sphere_Qsca_vs_diameter.py
 Comment: 
 
-Filename: docs/examples/detector/plot_LP11.py
+Filename: docs/examples/experiment/plot_sphere_Qsca_vs_wavelength.py
 Comment: 
 
-Filename: docs/examples/detector/plot_integrating_sphere.py
+Filename: docs/examples/experiment/plot_sphere_Qabs_vs_diameter.py
 Comment: 
 
-Filename: docs/examples/detector/plot_photodiode.py
+Filename: docs/examples/experiment/plot_sphere_coherent_coupling_vs_phioffset.py
 Comment: 
 
-Filename: docs/examples/experiment/plot_coreshell_Qback_vs_corediameter.py
+Filename: docs/examples/experiment/plot_coreshell_a1_vs_corediameter.py
 Comment: 
 
-Filename: docs/examples/experiment/plot_coreshell_a1_vs_corediameter.py
+Filename: docs/examples/experiment/plot_coreshell_coupling_vs_corediameter.py
+Comment: 
+
+Filename: docs/examples/experiment/plot_cylinder_b11_vs_diameter.py
 Comment: 
 
 Filename: docs/examples/experiment/plot_coreshell_b1_vs_corediameter.py
 Comment: 
 
-Filename: docs/examples/experiment/plot_coreshell_coupling_vs_corediameter.py
+Filename: docs/examples/experiment/plot_sphere_Qsca_vs_wavelength_std.py
 Comment: 
 
-Filename: docs/examples/experiment/plot_cylinder_Qabs_vs_diameter.py
+Filename: docs/examples/experiment/plot_sphere_coupling_vs_wavelength.py
 Comment: 
 
-Filename: docs/examples/experiment/plot_cylinder_Qsca_vs_diameter.py
+Filename: docs/examples/experiment/plot_cylinder_Qsca_vs_wavelength_std.py
 Comment: 
 
-Filename: docs/examples/experiment/plot_cylinder_Qsca_vs_index.py
+Filename: docs/examples/experiment/plot_cylinder_coupling_vs_wavelength.py
+Comment: 
+
+Filename: docs/examples/experiment/plot_sphere_coupling_vs_filter.py
 Comment: 
 
 Filename: docs/examples/experiment/plot_cylinder_Qsca_vs_wavelength.py
 Comment: 
 
-Filename: docs/examples/experiment/plot_cylinder_Qsca_vs_wavelength_std.py
+Filename: docs/examples/validation/plot_pymiescatt_0.py
 Comment: 
 
-Filename: docs/examples/experiment/plot_cylinder_a11_vs_diameter.py
+Filename: docs/examples/validation/plot_phase_function_detector.py
 Comment: 
 
-Filename: docs/examples/experiment/plot_cylinder_b11_vs_diameter.py
+Filename: docs/examples/validation/plot_pymiescatt_1.py
 Comment: 
 
-Filename: docs/examples/experiment/plot_cylinder_coupling_vs_diameter.py
+Filename: docs/examples/validation/plot_BH87.py
 Comment: 
 
-Filename: docs/examples/experiment/plot_cylinder_coupling_vs_phioffset.py
+Filename: docs/examples/validation/plot_BH88.py
 Comment: 
 
-Filename: docs/examples/experiment/plot_cylinder_coupling_vs_wavelength.py
+Filename: docs/examples/validation/plot_BH810.py
 Comment: 
 
-Filename: docs/examples/experiment/plot_sphere_Qabs_vs_diameter.py
+Filename: docs/examples/validation/plot_pymiescatt_2.py
 Comment: 
 
-Filename: docs/examples/experiment/plot_sphere_Qsca_vs_diameter.py
+Filename: docs/examples/validation/plot_pymiescatt_3.py
 Comment: 
 
-Filename: docs/examples/experiment/plot_sphere_Qsca_vs_index.py
+Filename: docs/examples/extras/SphereProperties.py
 Comment: 
 
-Filename: docs/examples/experiment/plot_sphere_Qsca_vs_wavelength.py
+Filename: docs/examples/extras/plot_Qsca_vs_permittivity_vs_size_parameter.py
 Comment: 
 
-Filename: docs/examples/experiment/plot_sphere_Qsca_vs_wavelength_std.py
+Filename: docs/examples/extras/plot_coupling_heatmap.py
 Comment: 
 
-Filename: docs/examples/experiment/plot_sphere_a1_vs_diameter.py
+Filename: PyMieSim/tools/
 Comment: 
 
-Filename: docs/examples/experiment/plot_sphere_b1_vs_diameter.py
+Filename: PyMieSim/single/
 Comment: 
 
-Filename: docs/examples/experiment/plot_sphere_coherent_coupling_vs_phioffset.py
+Filename: PyMieSim/.dylibs/
 Comment: 
 
-Filename: docs/examples/experiment/plot_sphere_coherent_coupling_vs_rotation.py
+Filename: PyMieSim/validation_data/
 Comment: 
 
-Filename: docs/examples/experiment/plot_sphere_coupling_vs_diameter.py
+Filename: PyMieSim/gui/
 Comment: 
 
-Filename: docs/examples/experiment/plot_sphere_coupling_vs_filter.py
+Filename: PyMieSim/experiment/
 Comment: 
 
-Filename: docs/examples/experiment/plot_sphere_coupling_vs_phioffset.py
+Filename: PyMieSim/binary/
 Comment: 
 
-Filename: docs/examples/experiment/plot_sphere_coupling_vs_wavelength.py
+Filename: PyMieSim/measure.py
 Comment: 
 
-Filename: docs/examples/extras/SphereProperties.py
+Filename: PyMieSim/__init__.py
 Comment: 
 
-Filename: docs/examples/extras/plot_Qsca_vs_permittivity_vs_size_parameter.py
+Filename: PyMieSim/mesh.py
 Comment: 
 
-Filename: docs/examples/extras/plot_coupling_heatmap.py
+Filename: PyMieSim/physics.py
 Comment: 
 
-Filename: docs/examples/scatterer/plot_farfield.py
+Filename: PyMieSim/VERSION
 Comment: 
 
-Filename: docs/examples/scatterer/plot_footprint.py
+Filename: PyMieSim/polarization.py
 Comment: 
 
-Filename: docs/examples/scatterer/plot_s1s2.py
+Filename: PyMieSim/__main__.py
 Comment: 
 
-Filename: docs/examples/scatterer/plot_source.py
+Filename: PyMieSim/tools/directories.py
 Comment: 
 
-Filename: docs/examples/scatterer/plot_spf.py
+Filename: PyMieSim/tools/__init__.py
 Comment: 
 
-Filename: docs/examples/scatterer/plot_stokes.py
+Filename: PyMieSim/tools/special_functions.py
 Comment: 
 
-Filename: docs/examples/validation/plot_BH810.py
+Filename: PyMieSim/single/detector.py
 Comment: 
 
-Filename: docs/examples/validation/plot_BH87.py
+Filename: PyMieSim/single/scatterer.py
 Comment: 
 
-Filename: docs/examples/validation/plot_BH88.py
+Filename: PyMieSim/single/__init__.py
 Comment: 
 
-Filename: docs/examples/validation/plot_phase_function_detector.py
+Filename: PyMieSim/single/representations.py
 Comment: 
 
-Filename: docs/examples/validation/plot_pymiescatt_0.py
+Filename: PyMieSim/single/source.py
 Comment: 
 
-Filename: docs/examples/validation/plot_pymiescatt_1.py
+Filename: PyMieSim/.dylibs/libgomp.1.dylib
 Comment: 
 
-Filename: docs/examples/validation/plot_pymiescatt_2.py
+Filename: PyMieSim/validation_data/Figure87BH.csv
 Comment: 
 
-Filename: docs/examples/validation/plot_pymiescatt_3.py
+Filename: PyMieSim/validation_data/PyMieScattQsca.csv
 Comment: 
 
-Filename: docs/source/conf.py
+Filename: PyMieSim/validation_data/Figure810BH.csv
 Comment: 
 
-Filename: extern/pybind11/noxfile.py
+Filename: PyMieSim/validation_data/PyMieScattQscaCoreShell.csv
 Comment: 
 
-Filename: extern/pybind11/setup.py
+Filename: PyMieSim/validation_data/Figure88BH.csv
 Comment: 
 
-Filename: extern/pybind11/docs/benchmark.py
+Filename: PyMieSim/validation_data/PyMieScattQscaMedium.csv
 Comment: 
 
-Filename: extern/pybind11/docs/conf.py
+Filename: PyMieSim/validation_data/PyMieScattQscaCoreShellMedium.csv
 Comment: 
 
-Filename: extern/pybind11/pybind11/__init__.py
+Filename: PyMieSim/gui/main_window.py
 Comment: 
 
-Filename: extern/pybind11/pybind11/__main__.py
+Filename: PyMieSim/gui/source_tab.py
 Comment: 
 
-Filename: extern/pybind11/pybind11/_version.py
+Filename: PyMieSim/gui/__init__.py
 Comment: 
 
-Filename: extern/pybind11/pybind11/commands.py
+Filename: PyMieSim/gui/axis_tab.py
 Comment: 
 
-Filename: extern/pybind11/pybind11/py.typed
+Filename: PyMieSim/gui/base_tab.py
 Comment: 
 
-Filename: extern/pybind11/pybind11/setup_helpers.py
+Filename: PyMieSim/gui/widgets.py
 Comment: 
 
-Filename: extern/pybind11/tests/conftest.py
+Filename: PyMieSim/gui/widget_collection.py
 Comment: 
 
-Filename: extern/pybind11/tests/env.py
+Filename: PyMieSim/gui/detector_tab.py
 Comment: 
 
-Filename: extern/pybind11/tests/test_async.py
+Filename: PyMieSim/gui/scatterer_tab.py
 Comment: 
 
-Filename: extern/pybind11/tests/test_buffers.py
+Filename: PyMieSim/experiment/detector.py
 Comment: 
 
-Filename: extern/pybind11/tests/test_builtin_casters.py
+Filename: PyMieSim/experiment/scatterer.py
 Comment: 
 
-Filename: extern/pybind11/tests/test_call_policies.py
+Filename: PyMieSim/experiment/__init__.py
 Comment: 
 
-Filename: extern/pybind11/tests/test_callbacks.py
+Filename: PyMieSim/experiment/setup.py
 Comment: 
 
-Filename: extern/pybind11/tests/test_chrono.py
+Filename: PyMieSim/experiment/source.py
 Comment: 
 
-Filename: extern/pybind11/tests/test_class.py
+Filename: PyMieSim/binary/DetectorInterface.cpython-311-darwin.so
 Comment: 
 
-Filename: extern/pybind11/tests/test_const_name.py
+Filename: PyMieSim/binary/CoreShellInterface.cpython-310-darwin.so
 Comment: 
 
-Filename: extern/pybind11/tests/test_constants_and_functions.py
+Filename: PyMieSim/binary/ModeField.cpython-312-darwin.so
 Comment: 
 
-Filename: extern/pybind11/tests/test_copy_move.py
+Filename: PyMieSim/binary/CylinderInterface.cpython-312-darwin.so
 Comment: 
 
-Filename: extern/pybind11/tests/test_custom_type_casters.py
+Filename: PyMieSim/binary/Fibonacci.cpython-312-darwin.so
 Comment: 
 
-Filename: extern/pybind11/tests/test_custom_type_setup.py
+Filename: PyMieSim/binary/Sets.cpython-312-darwin.so
 Comment: 
 
-Filename: extern/pybind11/tests/test_docstring_options.py
+Filename: PyMieSim/binary/DetectorInterface.cpython-310-darwin.so
 Comment: 
 
-Filename: extern/pybind11/tests/test_eigen_matrix.py
+Filename: PyMieSim/binary/CoreShellInterface.cpython-311-darwin.so
 Comment: 
 
-Filename: extern/pybind11/tests/test_eigen_tensor.py
+Filename: PyMieSim/binary/SphereInterface.cpython-312-darwin.so
 Comment: 
 
-Filename: extern/pybind11/tests/test_enum.py
+Filename: PyMieSim/binary/__init__.py
 Comment: 
 
-Filename: extern/pybind11/tests/test_eval.py
+Filename: PyMieSim/binary/Experiment.cpython-312-darwin.so
 Comment: 
 
-Filename: extern/pybind11/tests/test_eval_call.py
+Filename: PyMieSim/binary/CylinderInterface.cpython-311-darwin.so
 Comment: 
 
-Filename: extern/pybind11/tests/test_exceptions.py
+Filename: PyMieSim/binary/libZBessel.a
 Comment: 
 
-Filename: extern/pybind11/tests/test_factory_constructors.py
+Filename: PyMieSim/binary/CoreShellInterface.cpython-312-darwin.so
 Comment: 
 
-Filename: extern/pybind11/tests/test_gil_scoped.py
+Filename: PyMieSim/binary/Sets.cpython-311-darwin.so
 Comment: 
 
-Filename: extern/pybind11/tests/test_iostream.py
+Filename: PyMieSim/binary/Fibonacci.cpython-311-darwin.so
 Comment: 
 
-Filename: extern/pybind11/tests/test_kwargs_and_defaults.py
+Filename: PyMieSim/binary/SphereInterface.cpython-311-darwin.so
 Comment: 
 
-Filename: extern/pybind11/tests/test_local_bindings.py
+Filename: PyMieSim/binary/ModeField.cpython-310-darwin.so
 Comment: 
 
-Filename: extern/pybind11/tests/test_methods_and_attributes.py
+Filename: PyMieSim/binary/Experiment.cpython-311-darwin.so
 Comment: 
 
-Filename: extern/pybind11/tests/test_modules.py
+Filename: PyMieSim/binary/CylinderInterface.cpython-310-darwin.so
 Comment: 
 
-Filename: extern/pybind11/tests/test_multiple_inheritance.py
+Filename: PyMieSim/binary/DetectorInterface.cpython-312-darwin.so
 Comment: 
 
-Filename: extern/pybind11/tests/test_numpy_array.py
+Filename: PyMieSim/binary/Fibonacci.cpython-310-darwin.so
 Comment: 
 
-Filename: extern/pybind11/tests/test_numpy_dtypes.py
+Filename: PyMieSim/binary/Sets.cpython-310-darwin.so
+Comment: 
+
+Filename: PyMieSim/binary/SphereInterface.cpython-310-darwin.so
+Comment: 
+
+Filename: PyMieSim/binary/ModeField.cpython-311-darwin.so
+Comment: 
+
+Filename: PyMieSim/binary/Experiment.cpython-310-darwin.so
+Comment: 
+
+Filename: extern/pybind11/
+Comment: 
+
+Filename: extern/pybind11/tools/
+Comment: 
+
+Filename: extern/pybind11/pybind11/
+Comment: 
+
+Filename: extern/pybind11/tests/
+Comment: 
+
+Filename: extern/pybind11/docs/
+Comment: 
+
+Filename: extern/pybind11/setup.py
+Comment: 
+
+Filename: extern/pybind11/noxfile.py
+Comment: 
+
+Filename: extern/pybind11/tools/libsize.py
+Comment: 
+
+Filename: extern/pybind11/tools/make_changelog.py
+Comment: 
+
+Filename: extern/pybind11/tools/codespell_ignore_lines_from_errors.py
+Comment: 
+
+Filename: extern/pybind11/pybind11/setup_helpers.py
+Comment: 
+
+Filename: extern/pybind11/pybind11/_version.py
+Comment: 
+
+Filename: extern/pybind11/pybind11/__init__.py
+Comment: 
+
+Filename: extern/pybind11/pybind11/py.typed
+Comment: 
+
+Filename: extern/pybind11/pybind11/commands.py
+Comment: 
+
+Filename: extern/pybind11/pybind11/__main__.py
+Comment: 
+
+Filename: extern/pybind11/tests/test_embed/
+Comment: 
+
+Filename: extern/pybind11/tests/test_cmake_build/
+Comment: 
+
+Filename: extern/pybind11/tests/extra_setuptools/
+Comment: 
+
+Filename: extern/pybind11/tests/extra_python_package/
+Comment: 
+
+Filename: extern/pybind11/tests/test_stl_binders.py
+Comment: 
+
+Filename: extern/pybind11/tests/test_methods_and_attributes.py
+Comment: 
+
+Filename: extern/pybind11/tests/test_sequences_and_iterators.py
 Comment: 
 
 Filename: extern/pybind11/tests/test_numpy_vectorize.py
 Comment: 
 
-Filename: extern/pybind11/tests/test_opaque_types.py
+Filename: extern/pybind11/tests/test_chrono.py
 Comment: 
 
-Filename: extern/pybind11/tests/test_operator_overloading.py
+Filename: extern/pybind11/tests/conftest.py
 Comment: 
 
-Filename: extern/pybind11/tests/test_pickling.py
+Filename: extern/pybind11/tests/test_callbacks.py
 Comment: 
 
 Filename: extern/pybind11/tests/test_pytypes.py
 Comment: 
 
-Filename: extern/pybind11/tests/test_sequences_and_iterators.py
+Filename: extern/pybind11/tests/test_class.py
+Comment: 
+
+Filename: extern/pybind11/tests/env.py
+Comment: 
+
+Filename: extern/pybind11/tests/test_eigen_tensor.py
+Comment: 
+
+Filename: extern/pybind11/tests/test_docstring_options.py
+Comment: 
+
+Filename: extern/pybind11/tests/test_async.py
+Comment: 
+
+Filename: extern/pybind11/tests/test_local_bindings.py
 Comment: 
 
 Filename: extern/pybind11/tests/test_smart_ptr.py
 Comment: 
 
-Filename: extern/pybind11/tests/test_stl.py
+Filename: extern/pybind11/tests/test_numpy_array.py
 Comment: 
 
-Filename: extern/pybind11/tests/test_stl_binders.py
+Filename: extern/pybind11/tests/test_builtin_casters.py
 Comment: 
 
-Filename: extern/pybind11/tests/test_tagbased_polymorphic.py
+Filename: extern/pybind11/tests/test_constants_and_functions.py
 Comment: 
 
-Filename: extern/pybind11/tests/test_thread.py
+Filename: extern/pybind11/tests/test_exceptions.py
 Comment: 
 
-Filename: extern/pybind11/tests/test_union.py
+Filename: extern/pybind11/tests/test_factory_constructors.py
 Comment: 
 
-Filename: extern/pybind11/tests/test_virtual_functions.py
+Filename: extern/pybind11/tests/test_iostream.py
 Comment: 
 
-Filename: extern/pybind11/tests/extra_python_package/test_files.py
+Filename: extern/pybind11/tests/test_operator_overloading.py
 Comment: 
 
-Filename: extern/pybind11/tests/extra_setuptools/test_setuphelper.py
+Filename: extern/pybind11/tests/test_union.py
 Comment: 
 
-Filename: extern/pybind11/tests/test_cmake_build/test.py
+Filename: extern/pybind11/tests/test_kwargs_and_defaults.py
 Comment: 
 
-Filename: extern/pybind11/tests/test_embed/test_interpreter.py
+Filename: extern/pybind11/tests/test_thread.py
 Comment: 
 
-Filename: extern/pybind11/tests/test_embed/test_trampoline.py
+Filename: extern/pybind11/tests/test_pickling.py
 Comment: 
 
-Filename: extern/pybind11/tools/codespell_ignore_lines_from_errors.py
+Filename: extern/pybind11/tests/test_copy_move.py
 Comment: 
 
-Filename: extern/pybind11/tools/libsize.py
+Filename: extern/pybind11/tests/test_eval_call.py
 Comment: 
 
-Filename: extern/pybind11/tools/make_changelog.py
+Filename: extern/pybind11/tests/test_custom_type_casters.py
 Comment: 
 
-Filename: tests/detectors/__init__.py
+Filename: extern/pybind11/tests/test_stl.py
 Comment: 
 
-Filename: tests/detectors/test_coherent_mode.py
+Filename: extern/pybind11/tests/test_numpy_dtypes.py
 Comment: 
 
-Filename: tests/detectors/test_integration_sphere.py
+Filename: extern/pybind11/tests/test_eigen_matrix.py
 Comment: 
 
-Filename: tests/detectors/test_photodiode.py
+Filename: extern/pybind11/tests/test_opaque_types.py
 Comment: 
 
-Filename: tests/experiments/__init__.py
+Filename: extern/pybind11/tests/test_virtual_functions.py
 Comment: 
 
-Filename: tests/experiments/test_coreshell.py
+Filename: extern/pybind11/tests/test_const_name.py
 Comment: 
 
-Filename: tests/experiments/test_cylinder.py
+Filename: extern/pybind11/tests/test_call_policies.py
 Comment: 
 
-Filename: tests/experiments/test_sphere.py
+Filename: extern/pybind11/tests/test_custom_type_setup.py
 Comment: 
 
-Filename: tests/extra/__init__.py
+Filename: extern/pybind11/tests/test_buffers.py
 Comment: 
 
-Filename: tests/extra/test_mesh.py
+Filename: extern/pybind11/tests/test_modules.py
 Comment: 
 
-Filename: tests/scatterers/__init__.py
+Filename: extern/pybind11/tests/test_gil_scoped.py
 Comment: 
 
-Filename: tests/scatterers/test_coreshell.py
+Filename: extern/pybind11/tests/test_multiple_inheritance.py
 Comment: 
 
-Filename: tests/scatterers/test_cylinder.py
+Filename: extern/pybind11/tests/test_tagbased_polymorphic.py
 Comment: 
 
-Filename: tests/scatterers/test_sphere.py
+Filename: extern/pybind11/tests/test_eval.py
 Comment: 
 
-Filename: tests/validation/__init__.py
+Filename: extern/pybind11/tests/test_enum.py
 Comment: 
 
-Filename: tests/validation/test_coreshell_pymiescatt.py
+Filename: extern/pybind11/tests/test_embed/test_trampoline.py
 Comment: 
 
-Filename: tests/validation/test_detector.py
+Filename: extern/pybind11/tests/test_embed/test_interpreter.py
 Comment: 
 
-Filename: tests/validation/test_sphere_internal.py
+Filename: extern/pybind11/tests/test_cmake_build/test.py
 Comment: 
 
-Filename: tests/validation/test_sphere_pymiescatt.py
+Filename: extern/pybind11/tests/extra_setuptools/test_setuphelper.py
 Comment: 
 
-Filename: tests/validation/test_sphere_scott_prahl.py
+Filename: extern/pybind11/tests/extra_python_package/test_files.py
+Comment: 
+
+Filename: extern/pybind11/docs/benchmark.py
+Comment: 
+
+Filename: extern/pybind11/docs/conf.py
 Comment: 
 
-Filename: PyMieSim-1.9.1.dist-info/LICENSE
+Filename: PyMieSim-1.9.3.dist-info/RECORD
 Comment: 
 
-Filename: PyMieSim-1.9.1.dist-info/METADATA
+Filename: PyMieSim-1.9.3.dist-info/LICENSE
 Comment: 
 
-Filename: PyMieSim-1.9.1.dist-info/WHEEL
+Filename: PyMieSim-1.9.3.dist-info/WHEEL
 Comment: 
 
-Filename: PyMieSim-1.9.1.dist-info/top_level.txt
+Filename: PyMieSim-1.9.3.dist-info/top_level.txt
 Comment: 
 
-Filename: PyMieSim-1.9.1.dist-info/RECORD
+Filename: PyMieSim-1.9.3.dist-info/METADATA
 Comment: 
 
 Zip file comment:
```

## filetype from file(1)

```diff
@@ -1 +1 @@
-Zip archive data, at least v2.0 to extract, compression method=deflate
+Zip archive data, at least v2.0 to extract, compression method=store
```

## PyMieSim/VERSION

```diff
@@ -1 +1 @@
-1.9.1
+1.9.3
```

## PyMieSim/__main__.py

 * *Ordering differences only*

```diff
@@ -1,15 +1,15 @@
-
-import tkinter
-
-from PyMieSim.gui.main_window import PyMieSimGUI
-
-
-def main():
-    root = tkinter.Tk()
-    root.geometry("600x600")
-    PyMieSimGUI(root)
-    root.mainloop()
-
-
-if __name__ == "__main__":
-    main()
+
+import tkinter
+
+from PyMieSim.gui.main_window import PyMieSimGUI
+
+
+def main():
+    root = tkinter.Tk()
+    root.geometry("600x600")
+    PyMieSimGUI(root)
+    root.mainloop()
+
+
+if __name__ == "__main__":
+    main()
```

## PyMieSim/measure.py

 * *Ordering differences only*

```diff
@@ -1,100 +1,100 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-from DataVisual import units
-
-# Efficiencies
-Qsca = units.Efficiency(long_label='Scattering Efficiencies', short_label='Qsca')
-Qext = units.Efficiency(long_label='Extinction Efficiencies', short_label='Qext')
-Qabs = units.Efficiency(long_label='Absorption Efficiencies', short_label='Qabs')
-Qratio = units.Efficiency(long_label='Ratio Efficiencies', short_label='Qratio')
-Qforw = units.Efficiency(long_label='Forward Efficiencies', short_label='Qforw')
-Qback = units.Efficiency(long_label='Backward Efficiencies', short_label='Qback')
-Qpr = units.Efficiency(long_label='Radiation pres Efficiencies', short_label='Qpr')
-
-# Cross section
-Csca = units.Area(long_label='Scattering Cross-Section', short_label='Csca')
-Cext = units.Area(long_label='Extinction Cross-Section', short_label='Cext')
-Cabs = units.Area(long_label='Absorption Cross-Section', short_label='Cabs')
-Cratio = units.Area(long_label='Ratio Cross-Section', short_label='Cratio')
-Cforw = units.Area(long_label='Forward Cross-Section', short_label='Cforw')
-Cback = units.Area(long_label='Backward Cross-Section', short_label='Cback')
-Cpr = units.Area(long_label='Radiation pres Cross-Section', short_label='Cpr')
-
-# Electric & magnetic multipole
-a1 = units.Custom(short_label='a1', long_label='Electric dipole coefficient')
-a2 = units.Custom(short_label='a2', long_label='Electric quadrupole coefficient')
-a3 = units.Custom(short_label='a3', long_label='Electric octopole coeffcient')
-b1 = units.Custom(short_label='b1', long_label='Magnetic dipole coefficient')
-b2 = units.Custom(short_label='b2', long_label='Magnetic quadrupole coefficient')
-b3 = units.Custom(short_label='b3', long_label='Magnetic octopole coefficient')
-
-# Cylinder Electric & magnetic multipole
-a11 = units.Custom(short_label='a11', long_label='Electric dipole coefficient')
-a21 = units.Custom(short_label='a21', long_label='Electric quadrupole coefficient')
-a12 = units.Custom(short_label='a12', long_label='Electric octopole coeffcient')
-a22 = units.Custom(short_label='a22', long_label='Electric dipole coefficient')
-a13 = units.Custom(short_label='a13', long_label='Electric quadrupole coefficient')
-a23 = units.Custom(short_label='a23', long_label='Electric octopole coeffcient')
-
-b11 = units.Custom(short_label='b11', long_label='Magnetic dipole coefficient')
-b21 = units.Custom(short_label='b21', long_label='Magnetic quadrupole coefficient')
-b12 = units.Custom(short_label='b12', long_label='Magnetic octopole coeffcient')
-b22 = units.Custom(short_label='b22', long_label='Magnetic dipole coefficient')
-b13 = units.Custom(short_label='b13', long_label='Magnetic quadrupole coefficient')
-b23 = units.Custom(short_label='b23', long_label='Magnetic octopole coeffcient')
-
-
-# Extra
-g = units.Custom(short_label='g', long_label='Anisotropy coefficient')
-coupling = units.Power(short_label='coupling', long_label='Coupling')
-
-
-__sphere__ = __coreshell__ = {
-    'Qsca': Qsca,
-    'Qext': Qext,
-    'Qabs': Qabs,
-    'Qratio': Qratio,
-    'Qforw': Qforw,
-    'Qback': Qback,
-    'Qpr': Qpr,
-    'Csca': Csca,
-    'Cext': Cext,
-    'Cabs': Cabs,
-    'Cratio': Cratio,
-    'Cforw': Cforw,
-    'Cback': Cback,
-    'Cpr': Cpr,
-    'a1': a1,
-    'a2': a2,
-    'a3': a3,
-    'b1': b1,
-    'b2': b2,
-    'b3': b3,
-    'g': g,
-    'coupling': coupling,
-}
-
-__cylinder__ = {
-    'Qsca': Qsca,
-    'Qext': Qext,
-    'Qabs': Qabs,
-    'Csca': Csca,
-    'Cext': Cext,
-    'Cabs': Cabs,
-    'a11': a11,
-    'a21': a21,
-    'a12': a12,
-    'a22': a22,
-    'a13': a13,
-    'a23': a23,
-    'b11': b11,
-    'b21': b21,
-    'b12': b12,
-    'b22': b22,
-    'b13': b13,
-    'b23': b23,
-    'coupling': coupling,
-}
-
-# -
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+from DataVisual import units
+
+# Efficiencies
+Qsca = units.Efficiency(long_label='Scattering Efficiencies', short_label='Qsca')
+Qext = units.Efficiency(long_label='Extinction Efficiencies', short_label='Qext')
+Qabs = units.Efficiency(long_label='Absorption Efficiencies', short_label='Qabs')
+Qratio = units.Efficiency(long_label='Ratio Efficiencies', short_label='Qratio')
+Qforw = units.Efficiency(long_label='Forward Efficiencies', short_label='Qforw')
+Qback = units.Efficiency(long_label='Backward Efficiencies', short_label='Qback')
+Qpr = units.Efficiency(long_label='Radiation pres Efficiencies', short_label='Qpr')
+
+# Cross section
+Csca = units.Area(long_label='Scattering Cross-Section', short_label='Csca')
+Cext = units.Area(long_label='Extinction Cross-Section', short_label='Cext')
+Cabs = units.Area(long_label='Absorption Cross-Section', short_label='Cabs')
+Cratio = units.Area(long_label='Ratio Cross-Section', short_label='Cratio')
+Cforw = units.Area(long_label='Forward Cross-Section', short_label='Cforw')
+Cback = units.Area(long_label='Backward Cross-Section', short_label='Cback')
+Cpr = units.Area(long_label='Radiation pres Cross-Section', short_label='Cpr')
+
+# Electric & magnetic multipole
+a1 = units.Custom(short_label='a1', long_label='Electric dipole coefficient')
+a2 = units.Custom(short_label='a2', long_label='Electric quadrupole coefficient')
+a3 = units.Custom(short_label='a3', long_label='Electric octopole coeffcient')
+b1 = units.Custom(short_label='b1', long_label='Magnetic dipole coefficient')
+b2 = units.Custom(short_label='b2', long_label='Magnetic quadrupole coefficient')
+b3 = units.Custom(short_label='b3', long_label='Magnetic octopole coefficient')
+
+# Cylinder Electric & magnetic multipole
+a11 = units.Custom(short_label='a11', long_label='Electric dipole coefficient')
+a21 = units.Custom(short_label='a21', long_label='Electric quadrupole coefficient')
+a12 = units.Custom(short_label='a12', long_label='Electric octopole coeffcient')
+a22 = units.Custom(short_label='a22', long_label='Electric dipole coefficient')
+a13 = units.Custom(short_label='a13', long_label='Electric quadrupole coefficient')
+a23 = units.Custom(short_label='a23', long_label='Electric octopole coeffcient')
+
+b11 = units.Custom(short_label='b11', long_label='Magnetic dipole coefficient')
+b21 = units.Custom(short_label='b21', long_label='Magnetic quadrupole coefficient')
+b12 = units.Custom(short_label='b12', long_label='Magnetic octopole coeffcient')
+b22 = units.Custom(short_label='b22', long_label='Magnetic dipole coefficient')
+b13 = units.Custom(short_label='b13', long_label='Magnetic quadrupole coefficient')
+b23 = units.Custom(short_label='b23', long_label='Magnetic octopole coeffcient')
+
+
+# Extra
+g = units.Custom(short_label='g', long_label='Anisotropy coefficient')
+coupling = units.Power(short_label='coupling', long_label='Coupling')
+
+
+__sphere__ = __coreshell__ = {
+    'Qsca': Qsca,
+    'Qext': Qext,
+    'Qabs': Qabs,
+    'Qratio': Qratio,
+    'Qforw': Qforw,
+    'Qback': Qback,
+    'Qpr': Qpr,
+    'Csca': Csca,
+    'Cext': Cext,
+    'Cabs': Cabs,
+    'Cratio': Cratio,
+    'Cforw': Cforw,
+    'Cback': Cback,
+    'Cpr': Cpr,
+    'a1': a1,
+    'a2': a2,
+    'a3': a3,
+    'b1': b1,
+    'b2': b2,
+    'b3': b3,
+    'g': g,
+    'coupling': coupling,
+}
+
+__cylinder__ = {
+    'Qsca': Qsca,
+    'Qext': Qext,
+    'Qabs': Qabs,
+    'Csca': Csca,
+    'Cext': Cext,
+    'Cabs': Cabs,
+    'a11': a11,
+    'a21': a21,
+    'a12': a12,
+    'a22': a22,
+    'a13': a13,
+    'a23': a23,
+    'b11': b11,
+    'b21': b21,
+    'b12': b12,
+    'b22': b22,
+    'b13': b13,
+    'b23': b23,
+    'coupling': coupling,
+}
+
+# -
```

## PyMieSim/mesh.py

 * *Ordering differences only*

```diff
@@ -1,238 +1,238 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-import numpy
-from dataclasses import dataclass
-
-from PyMieSim.binary.Fibonacci import FibonacciMesh as CPPFibonacciMesh
-from MPSPlots.render3D import SceneList as SceneList3D
-
-
-@dataclass
-class FibonacciMesh:
-    """
-    Represents an angular mesh using a Fibonacci sphere distribution where each point covers
-    an equivalent solid angle. This setup is designed to simulate angular distributions
-    in light scattering experiments.
-    """
-    max_angle: float = 1.5  # Angle in radians defined by the numerical aperture of the imaging system.
-    sampling: int = 1000  # Number of points distributed inside the solid angle.
-    phi_offset: float = 0.  # Angle offset in the parallel direction of incident light polarization in degrees.
-    gamma_offset: float = 0.  # Angle offset in the perpendicular direction of incident light polarization in degrees.
-    rotation_angle: float = 0  # Rotation of the mesh around its principal axis in degrees.
-
-    def __post_init__(self):
-        self.structured = False
-
-        self._para = None
-        self._perp = None
-
-        self._parallel_vector_in_plan = None
-        self._perpendicular_vector_in_plan = None
-
-        self._vertical_to_perpendicular_vector = None
-        self._horizontal_to_perpendicular_vector = None
-        self._vertical_to_parallel_vector = None
-        self._horizontal_to_parallel_vector = None
-
-        self._phi = None
-        self._theta = None
-
-        self._plan = None
-
-        self.vertical_vector = numpy.array([1, 0, 0])
-        self.horizontal_vector = numpy.array([0, 1, 0])
-
-        self.cpp_binding = CPPFibonacciMesh(
-            sampling=self.sampling,
-            max_angle=self.max_angle,
-            phi_offset=numpy.deg2rad(self.phi_offset),
-            gamma_offset=numpy.deg2rad(self.gamma_offset),
-            rotation_angle=self.rotation_angle
-        )
-
-        self.initialize_properties()
-
-        self.cpp_binding.compute_vector_field()
-
-    @property
-    def plan(self):
-        if self._plan is None:
-            self.cpp_binding.Computeplan()
-            self._plan = numpy.asarray([self.cpp_binding.Xplan, self.cpp_binding.Yplan, self.cpp_binding.Zplan])
-
-        return self._plan
-
-    @property
-    def perpendicular_vector(self):
-        return self.cpp_binding.perpVector
-
-    @property
-    def parallel_vector(self):
-        return self.cpp_binding.paraVector
-
-    @property
-    def horizontal_to_perpendicular(self):
-        return self.cpp_binding.horizontal_to_perpendicular_vector
-
-    @property
-    def horizontal_to_parallel(self):
-        return self.cpp_binding.horizontal_to_parallel_vector
-
-    @property
-    def vertical_to_perpendicular(self):
-        return self.cpp_binding.perpVector
-
-    @property
-    def vertical_to_parallel(self):
-        return self.cpp_binding.paraVector
-
-    @property
-    def parallel_plan(self):
-        return self.cpp_binding.paraVectorZplanar
-
-    @property
-    def perpendicular_plan(self):
-        return self.cpp_binding.perpVectorZplanar
-
-    def get_phi(self, unit: str = 'radian'):
-        if unit.lower() in ['rad', 'radian']:
-            return self.cpp_binding.phi
-
-        elif unit.lower() in ['deg', 'degree']:
-            return numpy.rad2deg(self.cpp_binding.phi)
-
-    def get_theta(self, unit: str = 'radian'):
-        if unit.lower() in ['rad', 'radian']:
-            return self.cpp_binding.theta
-
-        elif unit.lower() in ['deg', 'degree']:
-            return numpy.rad2deg(self.cpp_binding.theta)
-
-    @property
-    def X(self):
-        return self.cpp_binding.x
-
-    @property
-    def Y(self):
-        return self.cpp_binding.y
-
-    @property
-    def Z(self):
-        return self.cpp_binding.z
-
-    def initialize_properties(self):
-        """
-        Initializes additional mesh properties based on the Fibonacci distribution
-        generated by the cpp_binding.
-        """
-        self.cartesian_coordinates = numpy.column_stack((self.cpp_binding.x, self.cpp_binding.y, self.cpp_binding.z))
-
-        self.d_omega_radian = self.cpp_binding.d_omega
-        self.d_omega_degree = self.cpp_binding.d_omega * (180 / numpy.pi)**2
-
-        self.omega_radian = self.cpp_binding.omega
-        self.omega_degree = self.cpp_binding.omega * (180 / numpy.pi)**2
-
-    def projection_HV_vector(self) -> tuple:
-        parallel_projection = [
-            self.projection_on_base_vector(
-                vector=self.vertical_to_parallel_plan,
-                base_vector=X
-            ) for X in [self.vertical_vector, self.horizontal_vector]
-        ]
-
-        perpendicular_projection = [
-            self.projection_on_base_vector(
-                vector=self.vertical_to_perpendicular_plan,
-                base_vector=X
-            ) for X in [self.vertical_vector, self.horizontal_vector]
-        ]
-
-        return numpy.array(parallel_projection), numpy.array(perpendicular_projection)
-
-    def projection_HV_scalar(self) -> tuple:
-        parallel_projection = [
-            self.projection_on_base_scalar(
-                vector=self.vertical_to_perpendicular_in_z_plan,
-                base_vector=X
-            ) for X in [self.vertical_vector, self.horizontal_vector]
-        ]
-
-        perpendicular_projection = [
-            self.projection_on_base_scalar(
-                vector=self.vertical_to_perpendicular_in_z_plan,
-                base_vector=X
-            ) for X in [self.vertical_vector, self.horizontal_vector]
-        ]
-
-        return numpy.array(parallel_projection), numpy.array(perpendicular_projection)
-
-    def projection_on_base_scalar(self, vector: numpy.ndarray, base_vector: numpy.ndarray) -> numpy.ndarray:
-        return vector.dot(base_vector)
-
-    def projection_on_base_vector(self, vector: numpy.ndarray, base_vector: numpy.ndarray) -> numpy.ndarray:
-        projection = self.projection_on_base_scalar(vector, base_vector)
-
-        base_projection = numpy.outer(projection, base_vector)
-
-        return base_projection
-
-    def plot(self) -> SceneList3D:
-        """
-        Plots the Fibonacci mesh using 3D rendering.
-
-        Returns:
-            SceneList3D: The 3D scene list object containing the mesh plot.
-        """
-        figure = SceneList3D()
-        ax = figure.append_ax()
-        self._add_mesh_to_ax_(ax)
-
-        return figure
-
-    def get_cartesian_coordinates(self) -> numpy.ndarray:
-        return numpy.c_[self.X, self.Y, self.Z].T
-
-    def get_axis_vector(self) -> numpy.ndarray:
-        """
-        Returns the axis vector that correspond ot the phi and gamma offset
-
-        :returns:   The axis vector.
-        :rtype:     numpy.ndarray
-        """
-        x, y, z = self.get_cartesian_coordinates()
-        axis_vector = numpy.array([x[0], y[0], z[0]])
-
-        norm = numpy.sqrt(numpy.square(axis_vector).sum())
-
-        return axis_vector / norm
-
-    def _add_mesh_to_ax_(self, ax) -> None:
-        axis_vector = self.get_axis_vector()
-
-        coordinates = self.get_cartesian_coordinates()
-
-        ax.add_unstructured_mesh(coordinates=coordinates)
-
-        ax.add_unstructured_mesh(coordinates=axis_vector * 1.4)
-
-        # ax.add_unit_sphere()
-        ax.add_unit_axis()
-        ax.add_unit_theta_vector(radius=1.1)
-        ax.add_unit_phi_vector(radius=1.1)
-
-    def rotate_around_axis(self, rotation_angle: float) -> None:
-        """
-        Rotate the mesh around its principal axis.
-
-        :param      rotation_angle:  The rotation angle [degree]
-        :type       rotation_angle:  float
-
-        :returns:   No returns
-        :rtype:     None
-        """
-        self.cpp_binding.rotate_around_axis(rotation_angle)
-
-
-# -
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import numpy
+from dataclasses import dataclass
+
+from PyMieSim.binary.Fibonacci import FibonacciMesh as CPPFibonacciMesh
+from MPSPlots.render3D import SceneList as SceneList3D
+
+
+@dataclass
+class FibonacciMesh:
+    """
+    Represents an angular mesh using a Fibonacci sphere distribution where each point covers
+    an equivalent solid angle. This setup is designed to simulate angular distributions
+    in light scattering experiments.
+    """
+    max_angle: float = 1.5  # Angle in radians defined by the numerical aperture of the imaging system.
+    sampling: int = 1000  # Number of points distributed inside the solid angle.
+    phi_offset: float = 0.  # Angle offset in the parallel direction of incident light polarization in degrees.
+    gamma_offset: float = 0.  # Angle offset in the perpendicular direction of incident light polarization in degrees.
+    rotation_angle: float = 0  # Rotation of the mesh around its principal axis in degrees.
+
+    def __post_init__(self):
+        self.structured = False
+
+        self._para = None
+        self._perp = None
+
+        self._parallel_vector_in_plan = None
+        self._perpendicular_vector_in_plan = None
+
+        self._vertical_to_perpendicular_vector = None
+        self._horizontal_to_perpendicular_vector = None
+        self._vertical_to_parallel_vector = None
+        self._horizontal_to_parallel_vector = None
+
+        self._phi = None
+        self._theta = None
+
+        self._plan = None
+
+        self.vertical_vector = numpy.array([1, 0, 0])
+        self.horizontal_vector = numpy.array([0, 1, 0])
+
+        self.cpp_binding = CPPFibonacciMesh(
+            sampling=self.sampling,
+            max_angle=self.max_angle,
+            phi_offset=numpy.deg2rad(self.phi_offset),
+            gamma_offset=numpy.deg2rad(self.gamma_offset),
+            rotation_angle=self.rotation_angle
+        )
+
+        self.initialize_properties()
+
+        self.cpp_binding.compute_vector_field()
+
+    @property
+    def plan(self):
+        if self._plan is None:
+            self.cpp_binding.Computeplan()
+            self._plan = numpy.asarray([self.cpp_binding.Xplan, self.cpp_binding.Yplan, self.cpp_binding.Zplan])
+
+        return self._plan
+
+    @property
+    def perpendicular_vector(self):
+        return self.cpp_binding.perpVector
+
+    @property
+    def parallel_vector(self):
+        return self.cpp_binding.paraVector
+
+    @property
+    def horizontal_to_perpendicular(self):
+        return self.cpp_binding.horizontal_to_perpendicular_vector
+
+    @property
+    def horizontal_to_parallel(self):
+        return self.cpp_binding.horizontal_to_parallel_vector
+
+    @property
+    def vertical_to_perpendicular(self):
+        return self.cpp_binding.perpVector
+
+    @property
+    def vertical_to_parallel(self):
+        return self.cpp_binding.paraVector
+
+    @property
+    def parallel_plan(self):
+        return self.cpp_binding.paraVectorZplanar
+
+    @property
+    def perpendicular_plan(self):
+        return self.cpp_binding.perpVectorZplanar
+
+    def get_phi(self, unit: str = 'radian'):
+        if unit.lower() in ['rad', 'radian']:
+            return self.cpp_binding.phi
+
+        elif unit.lower() in ['deg', 'degree']:
+            return numpy.rad2deg(self.cpp_binding.phi)
+
+    def get_theta(self, unit: str = 'radian'):
+        if unit.lower() in ['rad', 'radian']:
+            return self.cpp_binding.theta
+
+        elif unit.lower() in ['deg', 'degree']:
+            return numpy.rad2deg(self.cpp_binding.theta)
+
+    @property
+    def X(self):
+        return self.cpp_binding.x
+
+    @property
+    def Y(self):
+        return self.cpp_binding.y
+
+    @property
+    def Z(self):
+        return self.cpp_binding.z
+
+    def initialize_properties(self):
+        """
+        Initializes additional mesh properties based on the Fibonacci distribution
+        generated by the cpp_binding.
+        """
+        self.cartesian_coordinates = numpy.column_stack((self.cpp_binding.x, self.cpp_binding.y, self.cpp_binding.z))
+
+        self.d_omega_radian = self.cpp_binding.d_omega
+        self.d_omega_degree = self.cpp_binding.d_omega * (180 / numpy.pi)**2
+
+        self.omega_radian = self.cpp_binding.omega
+        self.omega_degree = self.cpp_binding.omega * (180 / numpy.pi)**2
+
+    def projection_HV_vector(self) -> tuple:
+        parallel_projection = [
+            self.projection_on_base_vector(
+                vector=self.vertical_to_parallel_plan,
+                base_vector=X
+            ) for X in [self.vertical_vector, self.horizontal_vector]
+        ]
+
+        perpendicular_projection = [
+            self.projection_on_base_vector(
+                vector=self.vertical_to_perpendicular_plan,
+                base_vector=X
+            ) for X in [self.vertical_vector, self.horizontal_vector]
+        ]
+
+        return numpy.array(parallel_projection), numpy.array(perpendicular_projection)
+
+    def projection_HV_scalar(self) -> tuple:
+        parallel_projection = [
+            self.projection_on_base_scalar(
+                vector=self.vertical_to_perpendicular_in_z_plan,
+                base_vector=X
+            ) for X in [self.vertical_vector, self.horizontal_vector]
+        ]
+
+        perpendicular_projection = [
+            self.projection_on_base_scalar(
+                vector=self.vertical_to_perpendicular_in_z_plan,
+                base_vector=X
+            ) for X in [self.vertical_vector, self.horizontal_vector]
+        ]
+
+        return numpy.array(parallel_projection), numpy.array(perpendicular_projection)
+
+    def projection_on_base_scalar(self, vector: numpy.ndarray, base_vector: numpy.ndarray) -> numpy.ndarray:
+        return vector.dot(base_vector)
+
+    def projection_on_base_vector(self, vector: numpy.ndarray, base_vector: numpy.ndarray) -> numpy.ndarray:
+        projection = self.projection_on_base_scalar(vector, base_vector)
+
+        base_projection = numpy.outer(projection, base_vector)
+
+        return base_projection
+
+    def plot(self) -> SceneList3D:
+        """
+        Plots the Fibonacci mesh using 3D rendering.
+
+        Returns:
+            SceneList3D: The 3D scene list object containing the mesh plot.
+        """
+        figure = SceneList3D()
+        ax = figure.append_ax()
+        self._add_mesh_to_ax_(ax)
+
+        return figure
+
+    def get_cartesian_coordinates(self) -> numpy.ndarray:
+        return numpy.c_[self.X, self.Y, self.Z].T
+
+    def get_axis_vector(self) -> numpy.ndarray:
+        """
+        Returns the axis vector that correspond ot the phi and gamma offset
+
+        :returns:   The axis vector.
+        :rtype:     numpy.ndarray
+        """
+        x, y, z = self.get_cartesian_coordinates()
+        axis_vector = numpy.array([x[0], y[0], z[0]])
+
+        norm = numpy.sqrt(numpy.square(axis_vector).sum())
+
+        return axis_vector / norm
+
+    def _add_mesh_to_ax_(self, ax) -> None:
+        axis_vector = self.get_axis_vector()
+
+        coordinates = self.get_cartesian_coordinates()
+
+        ax.add_unstructured_mesh(coordinates=coordinates)
+
+        ax.add_unstructured_mesh(coordinates=axis_vector * 1.4)
+
+        # ax.add_unit_sphere()
+        ax.add_unit_axis()
+        ax.add_unit_theta_vector(radius=1.1)
+        ax.add_unit_phi_vector(radius=1.1)
+
+    def rotate_around_axis(self, rotation_angle: float) -> None:
+        """
+        Rotate the mesh around its principal axis.
+
+        :param      rotation_angle:  The rotation angle [degree]
+        :type       rotation_angle:  float
+
+        :returns:   No returns
+        :rtype:     None
+        """
+        self.cpp_binding.rotate_around_axis(rotation_angle)
+
+
+# -
```

## PyMieSim/physics.py

 * *Ordering differences only*

```diff
@@ -1,56 +1,56 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-import numpy
-from scipy.constants import epsilon_0, c
-
-
-def fraunhofer_diffraction(near_field: numpy.ndarray) -> numpy.ndarray:
-    """
-    Calculate the Far-Field diffraction pattern from a given Near-Field pattern using the Fraunhofer approximation.
-
-    Parameters:
-        - near_field: numpy.ndarray, the near field pattern as a 2D numpy array.
-
-    Returns:
-        - numpy.ndarray, the far field diffraction pattern as a 2D numpy array.
-    """
-    fft_result = numpy.fft.fft2(near_field)
-    fft_result /= generate_fft_shift(fft_result.shape[0])
-    far_field = numpy.fft.fftshift(fft_result)
-    return far_field
-
-
-def generate_fft_shift(n_points: int) -> numpy.ndarray:
-    """
-    Generate a complex shift array for phase correction in FFT, ensuring accurate Fourier transform phase.
-
-    Parameters:
-        - n_points: int, number of points in one dimension of the square array.
-
-    Returns:
-        - numpy.ndarray, a complex shift array for FFT phase correction.
-    """
-    phase_arg = numpy.pi * numpy.arange(n_points) * (n_points - (n_points % 2)) / n_points
-    phase_shift = numpy.exp(-1j * phase_arg)
-    shift_grid = numpy.outer(phase_shift, phase_shift)
-    return shift_grid
-
-
-def power_to_amplitude(optical_power: float, NA: float, wavelength: float) -> float:
-    """
-    Calculate the optical field amplitude from the given optical power, numerical aperture (NA), and wavelength.
-
-    Parameters:
-        - optical_power: float, the optical power in watts.
-        - NA: float, the numerical aperture of the optical system.
-        - wavelength: float, the wavelength of the light in meters.
-
-    Returns:
-        - float, the amplitude of the optical field.
-    """
-    omega = 0.61 * wavelength / NA
-    area = numpy.pi * (omega / 2)**2
-    intensity = optical_power / area
-    amplitude = numpy.sqrt(2 * intensity / (c * epsilon_0))
-    return amplitude
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import numpy
+from scipy.constants import epsilon_0, c
+
+
+def fraunhofer_diffraction(near_field: numpy.ndarray) -> numpy.ndarray:
+    """
+    Calculate the Far-Field diffraction pattern from a given Near-Field pattern using the Fraunhofer approximation.
+
+    Parameters:
+        - near_field: numpy.ndarray, the near field pattern as a 2D numpy array.
+
+    Returns:
+        - numpy.ndarray, the far field diffraction pattern as a 2D numpy array.
+    """
+    fft_result = numpy.fft.fft2(near_field)
+    fft_result /= generate_fft_shift(fft_result.shape[0])
+    far_field = numpy.fft.fftshift(fft_result)
+    return far_field
+
+
+def generate_fft_shift(n_points: int) -> numpy.ndarray:
+    """
+    Generate a complex shift array for phase correction in FFT, ensuring accurate Fourier transform phase.
+
+    Parameters:
+        - n_points: int, number of points in one dimension of the square array.
+
+    Returns:
+        - numpy.ndarray, a complex shift array for FFT phase correction.
+    """
+    phase_arg = numpy.pi * numpy.arange(n_points) * (n_points - (n_points % 2)) / n_points
+    phase_shift = numpy.exp(-1j * phase_arg)
+    shift_grid = numpy.outer(phase_shift, phase_shift)
+    return shift_grid
+
+
+def power_to_amplitude(optical_power: float, NA: float, wavelength: float) -> float:
+    """
+    Calculate the optical field amplitude from the given optical power, numerical aperture (NA), and wavelength.
+
+    Parameters:
+        - optical_power: float, the optical power in watts.
+        - NA: float, the numerical aperture of the optical system.
+        - wavelength: float, the wavelength of the light in meters.
+
+    Returns:
+        - float, the amplitude of the optical field.
+    """
+    omega = 0.61 * wavelength / NA
+    area = numpy.pi * (omega / 2)**2
+    intensity = optical_power / area
+    amplitude = numpy.sqrt(2 * intensity / (c * epsilon_0))
+    return amplitude
```

## PyMieSim/polarization.py

 * *Ordering differences only*

```diff
@@ -1,73 +1,73 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-from typing import Iterable
-import numpy
-
-
-class JonesVector:
-    """
-    Represents a Jones vector for describing the polarization state of light.
-    """
-
-    def __init__(self, jones_vector: Iterable) -> None:
-        """
-        Initialize the Jones vector.
-
-        Parameters:
-            - jones_vector: Iterable, a collection that represents the Jones vector components.
-        """
-        self.jones_vector = numpy.atleast_2d(jones_vector).astype(complex)
-
-    def __repr__(self) -> str:
-        return f"JonesVector({self.jones_vector})"
-
-    def __add__(self, other) -> 'JonesVector':
-        """
-        Add another Jones vector to this Jones vector, combining their polarization states.
-
-        Parameters:
-            - other: JonesVector, another Jones vector to add.
-
-        Returns:
-            - JonesVector, the combined Jones vector.
-        """
-        return JonesVector(numpy.vstack((self.jones_vector, other.jones_vector)))
-
-
-class RightCircular(JonesVector):
-    """
-    Represents right circular polarization.
-    """
-
-    def __init__(self) -> None:
-        super().__init__([1, 1j])
-
-
-class LeftCircular(JonesVector):
-    """
-    Represents left circular polarization.
-    """
-
-    def __init__(self) -> None:
-        super().__init__([1, -1j])
-
-
-class Linear(JonesVector):
-    """
-    Represents linear polarization for a given angle or angles.
-    """
-
-    def __init__(self, *angles: float) -> None:
-        """
-        Initialize linear polarization with one or more angles.
-
-        Parameters:
-            - angles: float, the angle(s) of polarization in degrees.
-        """
-        self.angles = numpy.array(angles, dtype=float)
-        if numpy.isnan(self.angles).any():
-            raise ValueError("Unpolarized light source is not implemented yet.")
-
-        jones_vector = numpy.array([numpy.cos(self.angles * numpy.pi / 180), numpy.sin(self.angles * numpy.pi / 180)])
-        super().__init__(jones_vector=jones_vector)
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+from typing import Iterable
+import numpy
+
+
+class JonesVector:
+    """
+    Represents a Jones vector for describing the polarization state of light.
+    """
+
+    def __init__(self, jones_vector: Iterable) -> None:
+        """
+        Initialize the Jones vector.
+
+        Parameters:
+            - jones_vector: Iterable, a collection that represents the Jones vector components.
+        """
+        self.jones_vector = numpy.atleast_2d(jones_vector).astype(complex)
+
+    def __repr__(self) -> str:
+        return f"JonesVector({self.jones_vector})"
+
+    def __add__(self, other) -> 'JonesVector':
+        """
+        Add another Jones vector to this Jones vector, combining their polarization states.
+
+        Parameters:
+            - other: JonesVector, another Jones vector to add.
+
+        Returns:
+            - JonesVector, the combined Jones vector.
+        """
+        return JonesVector(numpy.vstack((self.jones_vector, other.jones_vector)))
+
+
+class RightCircular(JonesVector):
+    """
+    Represents right circular polarization.
+    """
+
+    def __init__(self) -> None:
+        super().__init__([1, 1j])
+
+
+class LeftCircular(JonesVector):
+    """
+    Represents left circular polarization.
+    """
+
+    def __init__(self) -> None:
+        super().__init__([1, -1j])
+
+
+class Linear(JonesVector):
+    """
+    Represents linear polarization for a given angle or angles.
+    """
+
+    def __init__(self, *angles: float) -> None:
+        """
+        Initialize linear polarization with one or more angles.
+
+        Parameters:
+            - angles: float, the angle(s) of polarization in degrees.
+        """
+        self.angles = numpy.array(angles, dtype=float)
+        if numpy.isnan(self.angles).any():
+            raise ValueError("Unpolarized light source is not implemented yet.")
+
+        jones_vector = numpy.array([numpy.cos(self.angles * numpy.pi / 180), numpy.sin(self.angles * numpy.pi / 180)])
+        super().__init__(jones_vector=jones_vector)
```

## PyMieSim/binary/libZBessel.a

### nm -s {}

 * *error from `nm -s {}` (b):*

 * *nm: amos_iso_c_fortran_wrapper.f90.o: file format not recognized*

 * *nm: machine.for.o: file format not recognized*

 * *nm: zbesh.for.o: file format not recognized*

```diff
@@ -1,176 +1,50 @@
 
 Archive index:
-zbesj_wrap in amos_iso_c_fortran_wrapper.f90.obj
-zbesy_wrap in amos_iso_c_fortran_wrapper.f90.obj
-zbesi_wrap in amos_iso_c_fortran_wrapper.f90.obj
-zbesk_wrap in amos_iso_c_fortran_wrapper.f90.obj
-zbesh_wrap in amos_iso_c_fortran_wrapper.f90.obj
-zairy_wrap in amos_iso_c_fortran_wrapper.f90.obj
-zbiry_wrap in amos_iso_c_fortran_wrapper.f90.obj
-d1mach_ in machine.for.obj
-i1mach_ in machine.for.obj
-r1mach_ in machine.for.obj
-timestamp_ in machine.for.obj
-zdiv_ in zbesh.for.obj
-zsqrt_ in zbesh.for.obj
-zabs_ in zbesh.for.obj
-zuchk_ in zbesh.for.obj
-zmlt_ in zbesh.for.obj
-zexp_ in zbesh.for.obj
-zlog_ in zbesh.for.obj
-zs1s2_ in zbesh.for.obj
-zunhj_ in zbesh.for.obj
-zunik_ in zbesh.for.obj
-zunk1_ in zbesh.for.obj
-zuoik_ in zbesh.for.obj
-zuni1_ in zbesh.for.obj
-zasyi_ in zbesh.for.obj
-zrati_ in zbesh.for.obj
-dgamln_ in zbesh.for.obj
-zmlri_ in zbesh.for.obj
-zseri_ in zbesh.for.obj
-zkscl_ in zbesh.for.obj
-zbknu_ in zbesh.for.obj
-zacai_ in zbesh.for.obj
-zwrsk_ in zbesh.for.obj
-zairy_ in zbesh.for.obj
-zuni2_ in zbesh.for.obj
-zbuni_ in zbesh.for.obj
-zbinu_ in zbesh.for.obj
-zacon_ in zbesh.for.obj
-zbesi_ in zbesh.for.obj
-zunk2_ in zbesh.for.obj
-zbunk_ in zbesh.for.obj
-zbesk_ in zbesh.for.obj
-zshch_ in zbesh.for.obj
-zbesh_ in zbesh.for.obj
-zbesj_ in zbesh.for.obj
-zbesy_ in zbesh.for.obj
-zbiry_ in zbesh.for.obj
-xerror_ in zbesh.for.obj
-
-amos_iso_c_fortran_wrapper.f90.obj:
-0000000000000000 b .bss
-0000000000000000 d .data
-0000000000000000 p .pdata
-0000000000000000 r .rdata$zzz
-0000000000000000 t .text
-0000000000000000 r .xdata
-                 U zairy_
-00000000000002c0 T zairy_wrap
-                 U zbesh_
-0000000000000230 T zbesh_wrap
-                 U zbesi_
-0000000000000130 T zbesi_wrap
-                 U zbesj_
-0000000000000000 T zbesj_wrap
-                 U zbesk_
-00000000000001b0 T zbesk_wrap
-                 U zbesy_
-0000000000000080 T zbesy_wrap
-                 U zbiry_
-0000000000000330 T zbiry_wrap
-
-machine.for.obj:
-0000000000000000 b .bss
-0000000000000000 d .data
-0000000000000000 p .pdata
-0000000000000000 r .rdata
-0000000000000000 r .rdata$zzz
-0000000000000000 t .text
-0000000000000000 r .xdata
-00000000000001c0 r CSWTCH.44
-0000000000000180 r CSWTCH.46
-0000000000000150 r CSWTCH.48
-                 U _gfortran_date_and_time
-                 U _gfortran_st_read
-                 U _gfortran_st_read_done
-                 U _gfortran_st_write
-                 U _gfortran_st_write_done
-                 U _gfortran_stop_string
-                 U _gfortran_transfer_character_write
-                 U _gfortran_transfer_integer
-                 U _gfortran_transfer_integer_write
-0000000000000000 T d1mach_
-0000000000000320 T i1mach_
-0000000000000000 d month.0
-0000000000000640 T r1mach_
-0000000000000960 T timestamp_
-
-zbesh.for.obj:
-0000000000000000 b .bss
-0000000000000000 d .data
-0000000000000000 p .pdata
-0000000000000000 r .rdata
-0000000000000000 r .rdata$zzz
-0000000000000000 t .text
-0000000000000000 r .xdata
-                 U _gfortran_st_write
-                 U _gfortran_st_write_done
-                 U _gfortran_transfer_character_write
-0000000000000ca0 r alfa.65
-0000000000000c20 r ar.61
-                 U atan
-0000000000001240 r beta.66
-0000000000000840 r br.59
-0000000000000460 r c.49
-00000000000008c0 r c.60
-0000000000000060 r cf.15
-0000000000000440 r cipi.45
-0000000000000440 r cipi.7
-00000000000019e0 r cipi.92
-0000000000001a00 r cipr.46
-0000000000001a00 r cipr.8
-0000000000001a00 r cipr.93
-0000000000000820 r con.52
-                 U cos
-                 U cosh
-                 U d1mach_
-0000000000008e60 T dgamln_
-                 U exp
-00000000000018e0 r gama.70
-0000000000000120 r gln.16
-                 U i1mach_
-                 U log
-                 U memset
-                 U pow
-                 U sin
-                 U sincos
-                 U sinh
-00000000000186c0 T xerror_
-00000000000002f0 T zabs_
-000000000000dc10 T zacai_
-0000000000011960 T zacon_
-000000000000f600 T zairy_
-000000000000e680 t zairy_.part.0.constprop.0
-0000000000007940 T zasyi_
-0000000000015d40 T zbesh_
-0000000000012720 T zbesi_
-00000000000168c0 T zbesj_
-00000000000154f0 T zbesk_
-0000000000016ef0 T zbesy_
-00000000000112e0 T zbinu_
-00000000000176e0 T zbiry_
-000000000000b660 T zbknu_
-00000000000109e0 T zbuni_
-0000000000015440 T zbunk_
-0000000000000000 T zdiv_
-0000000000000420 T zexp_
-000000000000ac80 T zkscl_
-0000000000000480 T zlog_
-0000000000009150 T zmlri_
-00000000000003d0 T zmlt_
-00000000000085b0 T zrati_
-0000000000000680 T zs1s2_
-0000000000009eb0 T zseri_
-0000000000015c90 T zshch_
-0000000000000110 T zsqrt_
-0000000000000380 T zuchk_
-0000000000000a30 T zunhj_
-0000000000006ab0 T zuni1_
-000000000000f660 T zuni2_
-0000000000002f70 T zunik_
-0000000000003c10 T zunk1_
-0000000000012d50 T zunk2_
-0000000000005bd0 T zuoik_
-000000000000e200 T zwrsk_
+_d1mach_ in machine.for.o
+_dgamln_ in zbesh.for.o
+_i1mach_ in machine.for.o
+_r1mach_ in machine.for.o
+_timestamp_ in machine.for.o
+_xerror_ in zbesh.for.o
+_zabs_ in zbesh.for.o
+_zacai_ in zbesh.for.o
+_zacon_ in zbesh.for.o
+_zairy_ in zbesh.for.o
+_zairy_wrap in amos_iso_c_fortran_wrapper.f90.o
+_zasyi_ in zbesh.for.o
+_zbesh_ in zbesh.for.o
+_zbesh_wrap in amos_iso_c_fortran_wrapper.f90.o
+_zbesi_ in zbesh.for.o
+_zbesi_wrap in amos_iso_c_fortran_wrapper.f90.o
+_zbesj_ in zbesh.for.o
+_zbesj_wrap in amos_iso_c_fortran_wrapper.f90.o
+_zbesk_ in zbesh.for.o
+_zbesk_wrap in amos_iso_c_fortran_wrapper.f90.o
+_zbesy_ in zbesh.for.o
+_zbesy_wrap in amos_iso_c_fortran_wrapper.f90.o
+_zbinu_ in zbesh.for.o
+_zbiry_ in zbesh.for.o
+_zbiry_wrap in amos_iso_c_fortran_wrapper.f90.o
+_zbknu_ in zbesh.for.o
+_zbuni_ in zbesh.for.o
+_zbunk_ in zbesh.for.o
+_zdiv_ in zbesh.for.o
+_zexp_ in zbesh.for.o
+_zkscl_ in zbesh.for.o
+_zlog_ in zbesh.for.o
+_zmlri_ in zbesh.for.o
+_zmlt_ in zbesh.for.o
+_zrati_ in zbesh.for.o
+_zs1s2_ in zbesh.for.o
+_zseri_ in zbesh.for.o
+_zshch_ in zbesh.for.o
+_zsqrt_ in zbesh.for.o
+_zuchk_ in zbesh.for.o
+_zunhj_ in zbesh.for.o
+_zuni1_ in zbesh.for.o
+_zuni2_ in zbesh.for.o
+_zunik_ in zbesh.for.o
+_zunk1_ in zbesh.for.o
+_zunk2_ in zbesh.for.o
+_zuoik_ in zbesh.for.o
+_zwrsk_ in zbesh.for.o
```

### file list

```diff
@@ -1,5 +1,4 @@
-----------   0        0        0      564 2024-05-02 19:43:19.000000 /
-----------   0        0        0        0 1970-01-01 00:00:00.000000 //
--rw-rw-rw-   0        0        0     2312 2024-05-02 19:43:17.000000 amos_iso_c_fortran_wrapper.f90.obj
--rw-rw-rw-   0        0        0     7208 2024-05-02 19:43:17.000000 machine.for.obj
--rw-rw-rw-   0        0        0   122746 2024-05-02 19:43:19.000000 zbesh.for.obj
+-rw-r--r--   0      501       20      808 2024-05-30 19:08:09.000000 __.SYMDEF SORTED
+-rw-r--r--   0      501       20     2088 2024-05-30 19:08:00.000000 amos_iso_c_fortran_wrapper.f90.o
+-rw-r--r--   0      501       20     7456 2024-05-30 19:08:00.000000 machine.for.o
+-rw-r--r--   0      501       20   148128 2024-05-30 19:08:04.000000 zbesh.for.o
```

### filetype from file(1)

```diff
@@ -1 +1 @@
-current ar archive
+current ar archive random library
```

## PyMieSim/experiment/__init__.py

 * *Ordering differences only*

```diff
@@ -1,4 +1,4 @@
-from .setup import Setup
-from .scatterer import Sphere, CoreShell, Cylinder
-from .source import PlaneWave, Gaussian
+from .setup import Setup
+from .scatterer import Sphere, CoreShell, Cylinder
+from .source import PlaneWave, Gaussian
 from .detector import Photodiode, CoherentMode
```

## PyMieSim/experiment/detector.py

```diff
@@ -1,215 +1,216 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-from __future__ import annotations
-from typing import TYPE_CHECKING
-if TYPE_CHECKING:
-    from PyMieSim.experiment.setup import Setup
-    from typing import NoReturn, Iterable
-
-import numpy
-from dataclasses import dataclass, field
-
-from DataVisual import units
-from PyMieSim.binary.Sets import CppDetectorSet
-
-
-@dataclass
-class BaseDetector():
-    """
-    Base class for constructing detectors in Mie scattering simulations, managing common attributes and methods.
-
-    This class is responsible for formatting input parameters, calculating detector characteristics, and
-    binding detectors to a simulation experiment. It should be subclassed to create specific detector types.
-
-    Attributes:
-        NA (Iterable[float]): Defines the numerical aperture, which is the range of angles the system can accept light.
-        gamma_offset (Iterable[float]): Specifies the angular offset perpendicular to polarization (in degrees).
-        phi_offset (Iterable[float]): Specifies the angular offset parallel to polarization (in degrees).
-        polarization_filter (Iterable[float]): Sets the angle of the polarization filter (in degrees).
-        sampling (Iterable[int]): Dictates the resolution for field sampling.
-
-    This class is not intended for direct instantiation.
-    """
-
-    def __post_init__(self) -> NoReturn:
-        """
-        Called automatically after the class initialization to prepare the detector by formatting inputs, computing
-        field arrays, setting up rotation angles, and initializing visualization and C++ bindings.
-        """
-        self.mapping = self.setup_mapping()
-        self.initialize_binding()
-
-    def setup_mapping(self) -> dict:
-        """
-        Creates a dictionary to map detector settings to their respective values, serving as a base for data visualization
-        and C++ integration setup.
-
-        Returns:
-            dict: A mapping of detector settings to values.
-        """
-        return {
-            'mode_number': None,
-            'sampling': None,
-            'rotation': None,
-            'NA': None,
-            'phi_offset': None,
-            'gamma_offset': None,
-            'polarization_filter': None,
-        }
-
-    def initialize_binding(self) -> NoReturn:
-        """
-        Prepares and initializes the C++ bindings necessary for the simulation, configuring the detector with simulation
-        parameters.
-        """
-        self.binding_kwargs = dict(
-            mode_number=numpy.atleast_1d(self.mode_number).astype(str),
-            sampling=numpy.atleast_1d(self.sampling).astype(int),
-            NA=numpy.atleast_1d(self.NA).astype(float),
-            phi_offset=numpy.deg2rad(numpy.atleast_1d(self.phi_offset).astype(float)),
-            gamma_offset=numpy.deg2rad(numpy.atleast_1d(self.gamma_offset).astype(float)),
-            polarization_filter=numpy.deg2rad(numpy.atleast_1d(self.polarization_filter).astype(float)),
-            rotation=numpy.deg2rad(numpy.atleast_1d(self.rotation)).astype(float),
-            mean_coupling=self.mean_coupling,
-            coherent=self.coherent
-        )
-
-        self.binding = CppDetectorSet(**self.binding_kwargs)
-
-    def bind_to_experiment(self, experiment: Setup) -> NoReturn:
-        """
-        Binds the detector to a specified experimental setup, ensuring integration into the simulation workflow.
-
-        Parameters:
-            experiment (Setup): The experiment setup to which the detector is bound.
-        """
-        experiment.binding.set_detector(self.binding)
-
-    def get_datavisual_table(self) -> NoReturn:
-        """
-        Compiles the detector's properties into a table format for data visualization.
-
-        Returns:
-            list: A list of formatted data visual elements representing the detector's properties.
-        """
-        self.mapping['mode_number'] = units.Custom(
-            long_label='Mode number',
-            short_label='mode',
-            base_values=self.mode_number,
-        )
-
-        self.mapping['sampling'] = units.Custom(
-            long_label='Sampling',
-            short_label='sampling',
-            base_values=self.sampling,
-        )
-
-        self.mapping['rotation'] = units.Degree(
-            long_label='Rotation angle',
-            short_label='rot',
-            base_values=self.rotation,
-            string_format='.1f'
-        )
-
-        self.mapping['NA'] = units.Index(
-            long_label='Numerical aperture',
-            short_label='NA',
-            base_values=self.NA,
-            use_prefix=False,
-            string_format=""
-        )
-
-        self.mapping['phi_offset'] = units.Degree(
-            long_label='Phi angle',
-            short_label=r'$\phi$',
-            base_values=self.phi_offset,
-            use_prefix=False,
-            string_format='.1f'
-        )
-
-        self.mapping['gamma_offset'] = units.Degree(
-            long_label='Gamma angle',
-            short_label=r'$\gamma$',
-            base_values=self.gamma_offset,
-            use_prefix=False,
-            string_format='.1f'
-        )
-
-        self.mapping['polarization_filter'] = units.Degree(
-            long_label=r'Polarization filter',
-            short_label=r'f$_{pol}$',
-            base_values=self.polarization_filter,
-            use_prefix=False,
-            string_format='.1f'
-        )
-
-        return [v for k, v in self.mapping.items() if v is not None]
-
-
-@dataclass
-class Photodiode(BaseDetector):
-    """
-    Represents a photodiode detector tailored for Mie scattering simulations, enhancing the BaseDetector with specific features.
-
-    Attributes:
-        coupling_mode (str): Indicates the mode coupling method, either 'point' or 'Mean'.
-        coherent (bool): Specifies if the detection is coherent (True) or incoherent (False). Defaults to False.
-        name (str): The name of the detector, initialized to "Photodiode". Not intended to be modified.
-
-    Note:
-        This class is specifically configured to simulate a photodiode detector within a Mie scattering experiment.
-    """
-    NA: Iterable[float] | float
-    gamma_offset: Iterable[float] | float
-    phi_offset: Iterable[float] | float
-    polarization_filter: Iterable[float] | float
-    sampling: Iterable[int] | int
-    mean_coupling: bool = True
-    rotation: Iterable[float] | float = field(default=0, init=False)
-    coherent: bool = field(default=False, init=False)
-    mode_number: str = field(default='NC00', init=False)
-
-
-@dataclass
-class CoherentMode(BaseDetector):
-    """
-    Specialized for coherent detection modes in Mie scattering simulations, this class extends BaseDetector.
-
-    It manages the initialization and representation of coherent detection modes, specifically addressing their unique requirements.
-
-    Attributes:
-        mode_number (Iterable[str] | str): Designates the mode numbers involved in the detection.
-        mean_coupling (bool): Indicates whether to use average coupling for calculations. Defaults to False.
-        coherent (bool): Specifies if the detection is inherently coherent. Defaults to True.
-
-    Note:
-        This class is specifically designed to handle and simulate coherent detection modes.
-    """
-    mode_number: Iterable[str] | str
-    rotation: Iterable[float] | float
-    NA: Iterable[float] | float
-    gamma_offset: Iterable[float] | float
-    phi_offset: Iterable[float] | float
-    polarization_filter: Iterable[float] | float
-    sampling: Iterable[int] | int
-    mean_coupling: bool = False
-    coherent: bool = field(default=True, init=False)
-
-    def __post_init__(self):
-        """
-        Initializes complex scalar field arrays to represent CoherentMode modes, preparing the detector for simulation.
-
-        Returns:
-            numpy.ndarray: An array of complex scalar fields representing the modes used in detection.
-        """
-        self.mode_number = numpy.atleast_1d(self.mode_number).astype(str)
-
-        for idx, mode_name in enumerate(self.mode_number):
-            mode_family_name = mode_name[:2]
-            if mode_family_name not in ['LP', 'HG', 'LG', 'NC']:
-                raise ValueError('Invalid mode family name, must be one of: LP, HG, LG, NC')
-
-        super().__post_init__()
-
-# -
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+from __future__ import annotations
+from typing import TYPE_CHECKING
+if TYPE_CHECKING:
+    from PyMieSim.experiment.setup import Setup
+
+import numpy
+from dataclasses import field
+
+from DataVisual import units
+from PyMieSim.binary.Sets import CppDetectorSet
+from pydantic.dataclasses import dataclass
+
+from typing import List, Union, NoReturn
+
+
+class BaseDetector():
+    """
+    Base class for constructing detectors in Mie scattering simulations, managing common attributes and methods.
+
+    This class is responsible for formatting input parameters, calculating detector characteristics, and
+    binding detectors to a simulation experiment. It should be subclassed to create specific detector types.
+
+    Attributes:
+        NA (List[float]): Defines the numerical aperture, which is the range of angles the system can accept light.
+        gamma_offset (List[float]): Specifies the angular offset perpendicular to polarization (in degrees).
+        phi_offset (List[float]): Specifies the angular offset parallel to polarization (in degrees).
+        polarization_filter (List[float]): Sets the angle of the polarization filter (in degrees).
+        sampling (List[int]): Dictates the resolution for field sampling.
+
+    This class is not intended for direct instantiation.
+    """
+
+    def __post_init__(self) -> NoReturn:
+        """
+        Called automatically after the class initialization to prepare the detector by formatting inputs, computing
+        field arrays, setting up rotation angles, and initializing visualization and C++ bindings.
+        """
+        self.mapping = self.setup_mapping()
+        self.initialize_binding()
+
+    def setup_mapping(self) -> dict:
+        """
+        Creates a dictionary to map detector settings to their respective values, serving as a base for data visualization
+        and C++ integration setup.
+
+        Returns:
+            dict: A mapping of detector settings to values.
+        """
+        return {
+            'mode_number': None,
+            'sampling': None,
+            'rotation': None,
+            'NA': None,
+            'phi_offset': None,
+            'gamma_offset': None,
+            'polarization_filter': None,
+        }
+
+    def initialize_binding(self) -> NoReturn:
+        """
+        Prepares and initializes the C++ bindings necessary for the simulation, configuring the detector with simulation
+        parameters.
+        """
+        self.binding_kwargs = dict(
+            mode_number=numpy.atleast_1d(self.mode_number).astype(str),
+            sampling=numpy.atleast_1d(self.sampling).astype(int),
+            NA=numpy.atleast_1d(self.NA).astype(float),
+            phi_offset=numpy.deg2rad(numpy.atleast_1d(self.phi_offset).astype(float)),
+            gamma_offset=numpy.deg2rad(numpy.atleast_1d(self.gamma_offset).astype(float)),
+            polarization_filter=numpy.deg2rad(numpy.atleast_1d(self.polarization_filter).astype(float)),
+            rotation=numpy.deg2rad(numpy.atleast_1d(self.rotation)).astype(float),
+            mean_coupling=self.mean_coupling,
+            coherent=self.coherent
+        )
+
+        self.binding = CppDetectorSet(**self.binding_kwargs)
+
+    def bind_to_experiment(self, experiment: Setup) -> NoReturn:
+        """
+        Binds the detector to a specified experimental setup, ensuring integration into the simulation workflow.
+
+        Parameters:
+            experiment (Setup): The experiment setup to which the detector is bound.
+        """
+        experiment.binding.set_detector(self.binding)
+
+    def get_datavisual_table(self) -> NoReturn:
+        """
+        Compiles the detector's properties into a table format for data visualization.
+
+        Returns:
+            list: A list of formatted data visual elements representing the detector's properties.
+        """
+        self.mapping['mode_number'] = units.Custom(
+            long_label='Mode number',
+            short_label='mode',
+            base_values=self.mode_number,
+        )
+
+        self.mapping['sampling'] = units.Custom(
+            long_label='Sampling',
+            short_label='sampling',
+            base_values=self.sampling,
+        )
+
+        self.mapping['rotation'] = units.Degree(
+            long_label='Rotation angle',
+            short_label='rot',
+            base_values=self.rotation,
+            string_format='.1f'
+        )
+
+        self.mapping['NA'] = units.Index(
+            long_label='Numerical aperture',
+            short_label='NA',
+            base_values=self.NA,
+            use_prefix=False,
+            string_format=""
+        )
+
+        self.mapping['phi_offset'] = units.Degree(
+            long_label='Phi angle',
+            short_label=r'$\phi$',
+            base_values=self.phi_offset,
+            use_prefix=False,
+            string_format='.1f'
+        )
+
+        self.mapping['gamma_offset'] = units.Degree(
+            long_label='Gamma angle',
+            short_label=r'$\gamma$',
+            base_values=self.gamma_offset,
+            use_prefix=False,
+            string_format='.1f'
+        )
+
+        self.mapping['polarization_filter'] = units.Degree(
+            long_label=r'Polarization filter',
+            short_label=r'f$_{pol}$',
+            base_values=self.polarization_filter,
+            use_prefix=False,
+            string_format='.1f'
+        )
+
+        return [v for k, v in self.mapping.items() if v is not None]
+
+
+@dataclass
+class Photodiode(BaseDetector):
+    """
+    Represents a photodiode detector tailored for Mie scattering simulations, enhancing the BaseDetector with specific features.
+
+    Attributes:
+        coupling_mode (str): Indicates the mode coupling method, either 'point' or 'Mean'.
+        coherent (bool): Specifies if the detection is coherent (True) or incoherent (False). Defaults to False.
+        name (str): The name of the detector, initialized to "Photodiode". Not intended to be modified.
+
+    Note:
+        This class is specifically configured to simulate a photodiode detector within a Mie scattering experiment.
+    """
+    NA: Union[List[float], float]
+    gamma_offset: Union[List[float], float]
+    phi_offset: Union[List[float], float]
+    polarization_filter: Union[List[float | None], float | None]
+    sampling: Union[List[int], int]
+    mean_coupling: bool = True
+    rotation: Union[List[float] | float] = field(default=0, init=False)
+    coherent: bool = field(default=False, init=False)
+    mode_number: str = field(default='NC00', init=False)
+
+
+@dataclass
+class CoherentMode(BaseDetector):
+    """
+    Specialized for coherent detection modes in Mie scattering simulations, this class extends BaseDetector.
+
+    It manages the initialization and representation of coherent detection modes, specifically addressing their unique requirements.
+
+    Attributes:
+        mode_number (List[str] | str): Designates the mode numbers involved in the detection.
+        mean_coupling (bool): Indicates whether to use average coupling for calculations. Defaults to False.
+        coherent (bool): Specifies if the detection is inherently coherent. Defaults to True.
+
+    Note:
+        This class is specifically designed to handle and simulate coherent detection modes.
+    """
+    mode_number: Union[List[str], str]
+    rotation: Union[List[float], float]
+    NA: Union[List[float], float]
+    gamma_offset: Union[List[float], float]
+    phi_offset: Union[List[float], float]
+    polarization_filter: Union[List[float | None], float | None]
+    sampling: Union[List[int], int]
+    mean_coupling: bool = False
+    coherent: bool = field(default=True, init=False)
+
+    def __post_init__(self):
+        """
+        Initializes complex scalar field arrays to represent CoherentMode modes, preparing the detector for simulation.
+
+        Returns:
+            numpy.ndarray: An array of complex scalar fields representing the modes used in detection.
+        """
+        self.mode_number = numpy.atleast_1d(self.mode_number).astype(str)
+
+        for idx, mode_name in enumerate(self.mode_number):
+            mode_family_name = mode_name[:2]
+            if mode_family_name not in ['LP', 'HG', 'LG', 'NC']:
+                raise ValueError('Invalid mode family name, must be one of: LP, HG, LG, NC')
+
+        super().__post_init__()
+
+# -
```

## PyMieSim/experiment/scatterer.py

```diff
@@ -1,375 +1,376 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-from __future__ import annotations
-from typing import TYPE_CHECKING
-if TYPE_CHECKING:
-    from typing import NoReturn
-    from PyMieSim.experiment.setup import Setup
-    from PyMieSim.experiment.source import Gaussian, PlaneWave
-    from collections.abc import Iterable
-
-import numpy
-from dataclasses import dataclass
-
-from DataVisual import units
-from PyMieSim.binary.Sets import CppCoreShellSet, CppCylinderSet, CppSphereSet
-from PyMieSim import measure
-
-
-@dataclass
-class BaseScatterer():
-    """
-    Base class for scatterer objects. This class handles the initialization and setup of
-    scatterer parameters for use in PyMieSim simulations.
-
-    Attributes:
-        medium_index (Iterable): Refractive index of the medium in which the scatterers are placed.
-        source (Union[Gaussian, PlaneWave]): Light source configuration for the simulation.
-    """
-    source: Gaussian | PlaneWave
-
-    def __post_init__(self) -> NoReturn:
-        """
-        Initializes the scatterer instance by asserting inputs, formatting them, building binding
-        arguments, and Units for visualization. This method is automatically called after the
-        class has been initialized.
-
-        Returns:
-            NoReturn
-        """
-        self.build_binding_kwargs()
-
-    def bind_to_experiment(self, experiment: Setup) -> NoReturn:
-        """
-        Binds this scatterer instance to a given experimental setup. This method is crucial for integrating
-        the scatterer into the simulation environment, allowing its optical properties to be evaluated
-        within the context of the specified experiment.
-
-        Parameters:
-            experiment (Setup): The experimental setup to which the scatterer will be bound. The setup
-                                should be capable of integrating scatterers and managing their interactions
-                                with defined light sources and measurement configurations.
-        """
-        method_str = 'set_' + self.__class__.__name__.lower()
-
-        getattr(experiment.binding, method_str)(self.binding)
-
-    def add_material_index_to_mapping(self, name: str = None) -> NoReturn:
-        """
-        Adds material or refractive index details to a mapping dictionary used for visualization or further processing.
-        This method is used to create a mapping of material properties to human-readable and accessible formats for
-        UI or data outputs.
-
-        Parameters:
-            name (str, optional): The base name to use for the keys in the mapping dictionary. This name is used
-                                  to differentiate between different materials or indices if multiple exist within
-                                  the same scatterer.
-        """
-        detached_material_name = f"{name} material" if name else "material"
-        attached_material_name = detached_material_name.replace(' ', '_').lower()
-
-        detached_index_name = f"{name} index" if name else "index"
-        attached_index_name = detached_index_name.replace(' ', '_').lower()
-
-        if getattr(self, attached_material_name):
-            self.mapping[attached_material_name] = units.Custom(
-                long_label=detached_material_name,
-                short_label=attached_material_name,
-                value_representation=getattr(self, attached_material_name),
-                base_values=getattr(self, attached_material_name),
-                use_prefix=False,
-            )
-
-        else:
-            self.mapping[attached_index_name] = units.Index(
-                long_label=detached_index_name,
-                short_label=attached_index_name,
-                base_values=self.binding_kwargs.get(attached_index_name),
-                string_format='.2f'
-            )
-
-    def add_material_index_to_binding_kwargs(self, name: str, data_type: type) -> NoReturn:
-        """
-        Adds either material properties or a refractive index to the binding keyword arguments for the experiment.
-        This method validates and processes the material or index information, converting it into a format suitable
-        for simulation use, and ensuring that either a material or an index is provided but not both.
-
-        Parameters:
-            name (str): The base name for the material or index. This name helps identify the property and is used
-                        to handle multiple materials or indices.
-            data_type (type): The expected Python data type (e.g., float, numpy.ndarray) to which the material
-                              or index values should be converted for simulation purposes.
-
-        Raises:
-            ValueError: If both a material and an index are provided, or if neither is provided.
-        """
-        detached_material_name = f"{name} material" if name else "material"
-        attached_material_name = detached_material_name.replace(' ', '_').lower()
-
-        detached_index_name = f"{name} index" if name else "index"
-        attached_index_name = detached_index_name.replace(' ', '_').lower()
-
-        material_value = getattr(self, attached_material_name)
-        index_value = getattr(self, attached_index_name)
-
-        if material_value is not None and index_value is not None:
-            raise ValueError(f"Either {name} material or {name} index must be provided, not both.")
-        if material_value is None and index_value is None:
-            raise ValueError(f"One of {name} material or {name} index must be provided.")
-
-        if material_value:
-            self.binding_kwargs[attached_material_name] = numpy.asarray([
-                mat.get_refractive_index(self.source.wavelength) for mat in numpy.atleast_1d(getattr(self, attached_material_name))
-            ])
-            if data_type is float:
-                self.binding_kwargs[attached_material_name] = self.binding_kwargs[attached_material_name].real
-            self.binding_kwargs[attached_material_name] = self.binding_kwargs[attached_material_name].astype(data_type)
-
-        else:
-            self.binding_kwargs[attached_index_name] = numpy.atleast_1d(index_value).astype(data_type)
-
-
-@dataclass
-class Sphere(BaseScatterer):
-    """
-    A data class that represents a spherical scatterer configuration used in PyMieSim simulations.
-
-    This class provides specific implementations for setting up and binding spherical scatterers
-    with their properties to a simulation environment. It extends the `BaseScatterer` class by
-    adding spherical-specific attributes and methods for handling simulation setups.
-
-    Attributes:
-        diameter (Iterable): Diameter(s) of the spherical scatterers in meters.
-        medium_index (Iterable, optional): Refractive index or indices of the medium surrounding the scatterers.
-        medium_material (Iterable, optional): Material(s) defining the medium, used if `medium_index` is not provided.
-        index (Iterable, optional): Refractive index or indices of the spherical scatterers themselves.
-        material (Iterable, optional): Material(s) of the scatterers, used if `index` is not provided.
-        name (str): Name identifier for the scatterer type, defaulted to 'sphere' and not intended for initialization.
-    """
-    diameter: Iterable
-    medium_index: Iterable | None = None
-    medium_material: Iterable | None = None
-    index: Iterable | None = None
-    material: Iterable | None = None
-    available_measure_list = measure.__sphere__
-
-    def __post_init__(self):
-        """
-        Extends the base class post-initialization process by setting up additional properties specific to spherical scatterers.
-        Initializes a mapping dictionary to support visualization and other operations.
-        """
-        self.mapping: dict = {
-            'diameter': None,
-            'index': None,
-            'material': None,
-            'medium_index': None,
-            'medium_material': None
-        }
-
-        super().__post_init__()
-
-    def build_binding_kwargs(self) -> NoReturn:
-        """
-        Constructs the keyword arguments necessary for the C++ binding interface, specifically tailored for spherical scatterers.
-        This includes processing material indices and organizing them into a structured dictionary for simulation interaction.
-
-        This method automatically configures the `binding_kwargs` attribute with appropriately formatted values.
-        """
-        self.binding_kwargs = dict(
-            diameter=numpy.atleast_1d(self.diameter).astype(float),
-        )
-
-        self.add_material_index_to_binding_kwargs(name=None, data_type=complex)
-        self.add_material_index_to_binding_kwargs(name='medium', data_type=float)
-
-        self.binding = CppSphereSet(**self.binding_kwargs)
-
-    def get_datavisual_table(self) -> NoReturn:
-        """
-        Constructs a table of the scatterer's properties formatted for data visualization.
-        This method populates the `mapping` dictionary with user-friendly descriptions and formats of the scatterer properties.
-
-        Returns:
-            list: A list of visual representations for each property in the `mapping` dictionary that has been populated.
-        """
-        self.mapping['diameter'] = units.Length(
-            long_label='Scatterer diameter',
-            short_label='diameter',
-            base_values=self.binding_kwargs.get('diameter'),
-            string_format='.1f'
-        )
-
-        self.add_material_index_to_mapping(name=None)
-        self.add_material_index_to_mapping(name='Medium')
-
-        return [v for k, v in self.mapping.items() if v is not None]
-
-
-@dataclass
-class CoreShell(BaseScatterer):
-    """
-    A data class representing a core-shell scatterer configuration used in PyMieSim simulations.
-
-    This class facilitates the setup and manipulation of core-shell scatterers by providing structured
-    attributes and methods that ensure the scatterers are configured correctly for simulations.
-    It extends the BaseScatterer class, adding specific attributes and methods relevant to core-shell geometries.
-
-    Attributes:
-        core_diameter (Iterable): Diameters of the core components in meters.
-        shell_width (Iterable): Thicknesses of the shell components in meters.
-        medium_index (Iterable, optional): Refractive index or indices of the medium where the scatterers are placed.
-        medium_material (Iterable, optional): Material(s) defining the medium, used if `medium_index` is not provided.
-        core_index (Iterable, optional): Refractive index or indices of the core.
-        shell_index (Iterable, optional): Refractive index or indices of the shell.
-        core_material (Iterable, optional): Material(s) of the core, used if `core_index` is not provided.
-        shell_material (Iterable, optional): Material(s) of the shell, used if `shell_index` is not provided.
-        name (str): An identifier for the scatterer type, defaulted to 'coreshell' and not intended for initialization.
-    """
-    core_diameter: Iterable
-    shell_width: Iterable
-    medium_index: Iterable | None = None
-    medium_material: Iterable | None = None
-    core_index: Iterable | None = None
-    shell_index: Iterable | None = None
-    core_material: Iterable | None = None
-    shell_material: Iterable | None = None
-
-    available_measure_list = measure.__coreshell__
-
-    def __post_init__(self):
-        """
-        Extends the BaseScatterer post-initialization by setting up additional mappings specific to core-shell scatterers.
-        Initializes mappings for visualizing and interacting with scatterer properties.
-        """
-        self.mapping = {
-            'core_diameter': None,
-            'shell_diameter': None,
-            'core_index': None,
-            'core_material': None,
-            'shell_index': None,
-            'shell_material': None,
-            'medium_index': None,
-            'medium_material': None
-        }
-
-        super().__post_init__()
-
-    def build_binding_kwargs(self) -> NoReturn:
-        """
-        Assembles the keyword arguments necessary for C++ binding, tailored for core-shell scatterers.
-        Prepares structured data from scatterer properties for efficient simulation integration.
-
-        This function populates `binding_kwargs` with values formatted appropriately for the C++ backend used in simulations.
-        """
-        self.binding_kwargs = dict(
-            core_diameter=numpy.atleast_1d(self.core_diameter).astype(float),
-            shell_width=numpy.atleast_1d(self.shell_width).astype(float),
-        )
-
-        self.add_material_index_to_binding_kwargs(name='Core', data_type=complex)
-        self.add_material_index_to_binding_kwargs(name='Shell', data_type=complex)
-        self.add_material_index_to_binding_kwargs(name='medium', data_type=float)
-
-        self.binding = CppCoreShellSet(**self.binding_kwargs)
-
-    def get_datavisual_table(self) -> NoReturn:
-        """
-        Generates a list of data visualizations for the scatterer's properties, which can be used in user interfaces or reports.
-        Each property is formatted into a user-friendly structure, making it easier to visualize and understand.
-
-        Returns:
-            list: A collection of formatted representations for the scatterer properties.
-        """
-        self.mapping['core_diameter'] = units.Length(
-            long_label='Core diameter',
-            short_label='core_diameter',
-            base_values=self.binding_kwargs.get('core_diameter'),
-            string_format='.2f'
-        )
-
-        self.mapping['shell_width'] = units.Length(
-            long_label='Shell width',
-            short_label='shell_width',
-            base_values=self.binding_kwargs.get('shell_width'),
-            string_format='.2f'
-        )
-
-        self.add_material_index_to_mapping(name='Core')
-        self.add_material_index_to_mapping(name='Shell')
-        self.add_material_index_to_mapping(name='Medium')
-
-        return [v for k, v in self.mapping.items() if v is not None]
-
-
-@dataclass
-class Cylinder(BaseScatterer):
-    """
-    Represents a cylindrical scatterer configuration for PyMieSim simulations.
-
-    Attributes:
-        diameter (Iterable): Diameter(s) of the cylinder in meters.
-        height (Iterable): Height(s) of the cylinder in meters.
-        index (Iterable, optional): Refractive index of the cylinder.
-        material (Iterable, optional): Material(s) of the cylinder, used if `index` is not provided.
-    """
-    diameter: Iterable
-    medium_index: Iterable | None = None
-    medium_material: Iterable | None = None
-    index: Iterable | None = None
-    material: Iterable | None = None
-
-    available_measure_list = measure.__cylinder__
-
-    def __post_init__(self):
-        self.mapping = {
-            'diameter': None,
-            'index': None,
-            'material': None,
-            'medium_index': None,
-            'medium_material': None
-        }
-
-        super().__post_init__()
-
-    def build_binding_kwargs(self) -> NoReturn:
-        """
-        Prepares the keyword arguments for the C++ binding based on the scatterer's properties. This
-        involves evaluating material indices and organizing them into a dictionary for the C++ interface.
-
-        Returns:
-            None
-        """
-        self.binding_kwargs = dict(
-            diameter=numpy.atleast_1d(self.diameter).astype(float),
-        )
-
-        self.add_material_index_to_binding_kwargs(name=None, data_type=complex)
-        self.add_material_index_to_binding_kwargs(name='medium', data_type=float)
-
-        self.binding = CppCylinderSet(**self.binding_kwargs)
-
-    def get_datavisual_table(self) -> NoReturn:
-        """
-        Appends the scatterer's properties to a given table for visualization purposes. This enables the
-        representation of scatterer properties in graphical formats.
-
-        Parameters:
-            table (list): The table to which the scatterer's properties will be appended.
-
-        Returns:
-            list: The updated table with the scatterer's properties included.
-        """
-        self.mapping['diameter'] = units.Length(
-            long_label='Scatterer diameter',
-            short_label='diameter',
-            base_values=self.binding_kwargs.get('diameter'),
-            string_format='.1f'
-        )
-
-        self.add_material_index_to_mapping(name=None)
-        self.add_material_index_to_mapping(name='Medium')
-
-        return [v for k, v in self.mapping.items() if v is not None]
-
-# -
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+from __future__ import annotations
+from typing import TYPE_CHECKING
+if TYPE_CHECKING:
+    from PyMieSim.experiment.setup import Setup
+from PyMieSim.experiment.source import Gaussian, PlaneWave
+
+import numpy
+
+from DataVisual import units
+from PyMieSim.binary.Sets import CppCoreShellSet, CppCylinderSet, CppSphereSet
+from PyMieSim import measure
+from PyOptik import Sellmeier, DataMeasurement
+
+from pydantic.dataclasses import dataclass
+from typing import List, Union, NoReturn, Any
+
+
+@dataclass
+class BaseScatterer():
+    """
+    Base class for scatterer objects. This class handles the initialization and setup of
+    scatterer parameters for use in PyMieSim simulations.
+
+    Attributes:
+        medium_index (List): Refractive index of the medium in which the scatterers are placed.
+        source (Union[Gaussian, PlaneWave]): Light source configuration for the simulation.
+    """
+    source: Gaussian | PlaneWave
+
+    def __post_init__(self) -> NoReturn:
+        """
+        Initializes the scatterer instance by asserting inputs, formatting them, building binding
+        arguments, and Units for visualization. This method is automatically called after the
+        class has been initialized.
+
+        Returns:
+            NoReturn
+        """
+        self.build_binding_kwargs()
+
+    def bind_to_experiment(self, experiment: Setup) -> NoReturn:
+        """
+        Binds this scatterer instance to a given experimental setup. This method is crucial for integrating
+        the scatterer into the simulation environment, allowing its optical properties to be evaluated
+        within the context of the specified experiment.
+
+        Parameters:
+            experiment (Setup): The experimental setup to which the scatterer will be bound. The setup
+                                should be capable of integrating scatterers and managing their interactions
+                                with defined light sources and measurement configurations.
+        """
+        method_str = 'set_' + self.__class__.__name__.lower()
+
+        getattr(experiment.binding, method_str)(self.binding)
+
+    def add_material_index_to_mapping(self, name: str = None) -> NoReturn:
+        """
+        Adds material or refractive index details to a mapping dictionary used for visualization or further processing.
+        This method is used to create a mapping of material properties to human-readable and accessible formats for
+        UI or data outputs.
+
+        Parameters:
+            name (str, optional): The base name to use for the keys in the mapping dictionary. This name is used
+                                  to differentiate between different materials or indices if multiple exist within
+                                  the same scatterer.
+        """
+        detached_material_name = f"{name} material" if name else "material"
+        attached_material_name = detached_material_name.replace(' ', '_').lower()
+
+        detached_index_name = f"{name} index" if name else "index"
+        attached_index_name = detached_index_name.replace(' ', '_').lower()
+
+        if getattr(self, attached_material_name):
+            self.mapping[attached_material_name] = units.Custom(
+                long_label=detached_material_name,
+                short_label=attached_material_name,
+                value_representation=getattr(self, attached_material_name),
+                base_values=getattr(self, attached_material_name),
+                use_prefix=False,
+            )
+
+        else:
+            self.mapping[attached_index_name] = units.Index(
+                long_label=detached_index_name,
+                short_label=attached_index_name,
+                base_values=self.binding_kwargs.get(attached_index_name),
+                string_format='.2f'
+            )
+
+    def add_material_index_to_binding_kwargs(self, name: str, data_type: type) -> NoReturn:
+        """
+        Adds either material properties or a refractive index to the binding keyword arguments for the experiment.
+        This method validates and processes the material or index information, converting it into a format suitable
+        for simulation use, and ensuring that either a material or an index is provided but not both.
+
+        Parameters:
+            name (str): The base name for the material or index. This name helps identify the property and is used
+                        to handle multiple materials or indices.
+            data_type (type): The expected Python data type (e.g., float, numpy.ndarray) to which the material
+                              or index values should be converted for simulation purposes.
+
+        Raises:
+            ValueError: If both a material and an index are provided, or if neither is provided.
+        """
+        detached_material_name = f"{name} material" if name else "material"
+        attached_material_name = detached_material_name.replace(' ', '_').lower()
+
+        detached_index_name = f"{name} index" if name else "index"
+        attached_index_name = detached_index_name.replace(' ', '_').lower()
+
+        material_value = getattr(self, attached_material_name)
+        index_value = getattr(self, attached_index_name)
+
+        if material_value is not None and index_value is not None:
+            raise ValueError(f"Either {name} material or {name} index must be provided, not both.")
+        if material_value is None and index_value is None:
+            raise ValueError(f"One of {name} material or {name} index must be provided.")
+
+        if material_value:
+            self.binding_kwargs[attached_material_name] = numpy.asarray([
+                mat.get_refractive_index(self.source.wavelength) for mat in numpy.atleast_1d(getattr(self, attached_material_name))
+            ])
+            if data_type is float:
+                self.binding_kwargs[attached_material_name] = self.binding_kwargs[attached_material_name].real
+            self.binding_kwargs[attached_material_name] = self.binding_kwargs[attached_material_name].astype(data_type)
+
+        else:
+            self.binding_kwargs[attached_index_name] = numpy.atleast_1d(index_value).astype(data_type)
+
+
+@dataclass
+class Sphere(BaseScatterer):
+    """
+    A data class that represents a spherical scatterer configuration used in PyMieSim simulations.
+
+    This class provides specific implementations for setting up and binding spherical scatterers
+    with their properties to a simulation environment. It extends the `BaseScatterer` class by
+    adding spherical-specific attributes and methods for handling simulation setups.
+
+    Attributes:
+        diameter (List): Diameter(s) of the spherical scatterers in meters.
+        medium_index (List, optional): Refractive index or indices of the medium surrounding the scatterers.
+        medium_material (List, optional): Material(s) defining the medium, used if `medium_index` is not provided.
+        index (List, optional): Refractive index or indices of the spherical scatterers themselves.
+        material (List, optional): Material(s) of the scatterers, used if `index` is not provided.
+        name (str): Name identifier for the scatterer type, defaulted to 'sphere' and not intended for initialization.
+    """
+    diameter: Union[List[float], float]
+    medium_index: Union[List[float], float, None] = None
+    medium_material: Union[List[Sellmeier | DataMeasurement], Sellmeier | DataMeasurement, None] = None
+    index: Union[List[Any], Any] = None
+    material: Union[List[Sellmeier | DataMeasurement], Sellmeier | DataMeasurement, None] = None
+    available_measure_list = measure.__sphere__
+
+    def __post_init__(self):
+        """
+        Extends the base class post-initialization process by setting up additional properties specific to spherical scatterers.
+        Initializes a mapping dictionary to support visualization and other operations.
+        """
+        self.mapping: dict = {
+            'diameter': None,
+            'index': None,
+            'material': None,
+            'medium_index': None,
+            'medium_material': None
+        }
+
+        super().__post_init__()
+
+    def build_binding_kwargs(self) -> NoReturn:
+        """
+        Constructs the keyword arguments necessary for the C++ binding interface, specifically tailored for spherical scatterers.
+        This includes processing material indices and organizing them into a structured dictionary for simulation interaction.
+
+        This method automatically configures the `binding_kwargs` attribute with appropriately formatted values.
+        """
+        self.binding_kwargs = dict(
+            diameter=numpy.atleast_1d(self.diameter).astype(float),
+        )
+
+        self.add_material_index_to_binding_kwargs(name=None, data_type=complex)
+        self.add_material_index_to_binding_kwargs(name='medium', data_type=float)
+
+        self.binding = CppSphereSet(**self.binding_kwargs)
+
+    def get_datavisual_table(self) -> NoReturn:
+        """
+        Constructs a table of the scatterer's properties formatted for data visualization.
+        This method populates the `mapping` dictionary with user-friendly descriptions and formats of the scatterer properties.
+
+        Returns:
+            list: A list of visual representations for each property in the `mapping` dictionary that has been populated.
+        """
+        self.mapping['diameter'] = units.Length(
+            long_label='Scatterer diameter',
+            short_label='diameter',
+            base_values=self.binding_kwargs.get('diameter'),
+            string_format='.1f'
+        )
+
+        self.add_material_index_to_mapping(name=None)
+        self.add_material_index_to_mapping(name='Medium')
+
+        return [v for k, v in self.mapping.items() if v is not None]
+
+
+@dataclass
+class CoreShell(BaseScatterer):
+    """
+    A data class representing a core-shell scatterer configuration used in PyMieSim simulations.
+
+    This class facilitates the setup and manipulation of core-shell scatterers by providing structured
+    attributes and methods that ensure the scatterers are configured correctly for simulations.
+    It extends the BaseScatterer class, adding specific attributes and methods relevant to core-shell geometries.
+
+    Attributes:
+        core_diameter (Union[List[float], float]): Diameters of the core components in meters.
+        shell_width (Union[List[float], float]): Thicknesses of the shell components in meters.
+        medium_index (List, optional): Refractive index or indices of the medium where the scatterers are placed.
+        medium_material (List, optional): Material(s) defining the medium, used if `medium_index` is not provided.
+        core_index (List, optional): Refractive index or indices of the core.
+        shell_index (List, optional): Refractive index or indices of the shell.
+        core_material (List, optional): Material(s) of the core, used if `core_index` is not provided.
+        shell_material (List, optional): Material(s) of the shell, used if `shell_index` is not provided.
+        name (str): An identifier for the scatterer type, defaulted to 'coreshell' and not intended for initialization.
+    """
+    core_diameter: Union[List[float], float]
+    shell_width: Union[List[float], float]
+    medium_index: Union[List[float], float, None] = None
+    medium_material: Union[List[Sellmeier | DataMeasurement], Sellmeier | DataMeasurement, None] = None
+    shell_index: Union[List[Any], Any, None] = None
+    core_material: Union[List[Sellmeier | DataMeasurement], Sellmeier | DataMeasurement, None] = None
+    core_index: Union[List[Any], Any, None] = None
+    shell_material: Union[List[Sellmeier | DataMeasurement], Sellmeier | DataMeasurement, None] = None
+
+    available_measure_list = measure.__coreshell__
+
+    def __post_init__(self):
+        """
+        Extends the BaseScatterer post-initialization by setting up additional mappings specific to core-shell scatterers.
+        Initializes mappings for visualizing and interacting with scatterer properties.
+        """
+        self.mapping = {
+            'core_diameter': None,
+            'shell_diameter': None,
+            'core_index': None,
+            'core_material': None,
+            'shell_index': None,
+            'shell_material': None,
+            'medium_index': None,
+            'medium_material': None
+        }
+
+        super().__post_init__()
+
+    def build_binding_kwargs(self) -> NoReturn:
+        """
+        Assembles the keyword arguments necessary for C++ binding, tailored for core-shell scatterers.
+        Prepares structured data from scatterer properties for efficient simulation integration.
+
+        This function populates `binding_kwargs` with values formatted appropriately for the C++ backend used in simulations.
+        """
+        self.binding_kwargs = dict(
+            core_diameter=numpy.atleast_1d(self.core_diameter).astype(float),
+            shell_width=numpy.atleast_1d(self.shell_width).astype(float),
+        )
+
+        self.add_material_index_to_binding_kwargs(name='Core', data_type=complex)
+        self.add_material_index_to_binding_kwargs(name='Shell', data_type=complex)
+        self.add_material_index_to_binding_kwargs(name='medium', data_type=float)
+
+        self.binding = CppCoreShellSet(**self.binding_kwargs)
+
+    def get_datavisual_table(self) -> NoReturn:
+        """
+        Generates a list of data visualizations for the scatterer's properties, which can be used in user interfaces or reports.
+        Each property is formatted into a user-friendly structure, making it easier to visualize and understand.
+
+        Returns:
+            list: A collection of formatted representations for the scatterer properties.
+        """
+        self.mapping['core_diameter'] = units.Length(
+            long_label='Core diameter',
+            short_label='core_diameter',
+            base_values=self.binding_kwargs.get('core_diameter'),
+            string_format='.2f'
+        )
+
+        self.mapping['shell_width'] = units.Length(
+            long_label='Shell width',
+            short_label='shell_width',
+            base_values=self.binding_kwargs.get('shell_width'),
+            string_format='.2f'
+        )
+
+        self.add_material_index_to_mapping(name='Core')
+        self.add_material_index_to_mapping(name='Shell')
+        self.add_material_index_to_mapping(name='Medium')
+
+        return [v for k, v in self.mapping.items() if v is not None]
+
+
+@dataclass
+class Cylinder(BaseScatterer):
+    """
+    Represents a cylindrical scatterer configuration for PyMieSim simulations.
+
+    Attributes:
+        diameter (List): Diameter(s) of the cylinder in meters.
+        height (List): Height(s) of the cylinder in meters.
+        index (List, optional): Refractive index of the cylinder.
+        material (List, optional): Material(s) of the cylinder, used if `index` is not provided.
+    """
+    diameter: Union[List[float], float]
+    medium_index: Union[List[float], float, None] = None
+    medium_material: Union[List[Sellmeier | DataMeasurement], Sellmeier | DataMeasurement, None] = None
+    index: Union[List[Any], Any, None] = None
+    material: Union[List[Sellmeier | DataMeasurement], Sellmeier | DataMeasurement, None] = None
+
+    available_measure_list = measure.__cylinder__
+
+    def __post_init__(self):
+        self.mapping = {
+            'diameter': None,
+            'index': None,
+            'material': None,
+            'medium_index': None,
+            'medium_material': None
+        }
+
+        super().__post_init__()
+
+    def build_binding_kwargs(self) -> NoReturn:
+        """
+        Prepares the keyword arguments for the C++ binding based on the scatterer's properties. This
+        involves evaluating material indices and organizing them into a dictionary for the C++ interface.
+
+        Returns:
+            None
+        """
+        self.binding_kwargs = dict(
+            diameter=numpy.atleast_1d(self.diameter).astype(float),
+        )
+
+        self.add_material_index_to_binding_kwargs(name=None, data_type=complex)
+        self.add_material_index_to_binding_kwargs(name='medium', data_type=float)
+
+        self.binding = CppCylinderSet(**self.binding_kwargs)
+
+    def get_datavisual_table(self) -> NoReturn:
+        """
+        Appends the scatterer's properties to a given table for visualization purposes. This enables the
+        representation of scatterer properties in graphical formats.
+
+        Parameters:
+            table (list): The table to which the scatterer's properties will be appended.
+
+        Returns:
+            list: The updated table with the scatterer's properties included.
+        """
+        self.mapping['diameter'] = units.Length(
+            long_label='Scatterer diameter',
+            short_label='diameter',
+            base_values=self.binding_kwargs.get('diameter'),
+            string_format='.1f'
+        )
+
+        self.add_material_index_to_mapping(name=None)
+        self.add_material_index_to_mapping(name='Medium')
+
+        return [v for k, v in self.mapping.items() if v is not None]
+
+# -
```

## PyMieSim/experiment/setup.py

```diff
@@ -1,126 +1,123 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-from __future__ import annotations
-from typing import TYPE_CHECKING
-if TYPE_CHECKING:
-    from typing import NoReturn
-    from PyMieSim.experiment.scatterer import Sphere, Cylinder, CoreShell
-    from PyMieSim.experiment.detector import Photodiode, LPMode
-    from PyMieSim.experiment.source import Gaussian, PlaneWave
-
-import numpy
-from dataclasses import dataclass
-
-from DataVisual import Array, Table
-from PyMieSim.binary.Experiment import CppExperiment
-
-
-@dataclass
-class Setup(object):
-    """
-    Orchestrates the setup and execution of light scattering experiments using PyMieSim.
-
-    Attributes:
-        scatterer (Union[Sphere, Cylinder, CoreShell]): Configuration for the scatterer in the experiment.
-            Defines the physical properties of the particle being studied.
-        source (Union[Gaussian, PlaneWave]): Configuration for the light source. Specifies the characteristics
-            of the light (e.g., wavelength, polarization) illuminating the scatterer.
-        detector (Union[Photodiode, LPMode, None], optional): Configuration for the detector, if any. Details the
-            method of detection for scattered light, including positional and analytical parameters. Defaults to None.
-
-    Methods provide functionality for initializing bindings, generating parameter tables for visualization,
-    and executing the simulation to compute and retrieve specified measures.
-    """
-    scatterer: Sphere | Cylinder | CoreShell
-    source: Gaussian | PlaneWave
-    detector: Photodiode | LPMode | None = None
-
-    def __post_init__(self):
-        """
-        Initializes the experiment by setting the source for the scatterer and establishing bindings
-        between the components and the simulation environment.
-        """
-        self.initialize_experiment()
-        self.bind_components()
-
-    def initialize_experiment(self) -> NoReturn:
-        """
-        Initializes the experiment with necessary bindings.
-        """
-        self.scatterer.source = self.source
-
-        self.binding = CppExperiment()
-
-    def bind_components(self):
-        """Binds the experiment components to the CppExperiment instance."""
-        for component in [self.source, self.scatterer, self.detector]:
-            if component:
-                component.bind_to_experiment(experiment=self)
-
-    def generate_datavisual_table(self) -> NoReturn:
-        """
-        Generates and populates the 'x_table' with parameters from the source, scatterer, and detector sets.
-        This table is instrumental for data visualization and analysis.
-
-        Returns:
-            NoReturn
-        """
-        self.x_table = []
-        self.x_table.extend(self.source.get_datavisual_table())
-        self.x_table.extend(self.scatterer.get_datavisual_table())
-
-        if self.detector:
-            self.x_table.extend(self.detector.get_datavisual_table())
-
-    def get(self, measure: Table, export_as_numpy: bool = False) -> numpy.ndarray | Array:
-        """
-        Executes the simulation to compute and retrieve the specified measure.
-
-        Parameters:
-            measure (Table): The measure to be computed by the simulation, defined by the user.
-            export_as_numpy (bool): Determines the format of the returned data. If True, returns a numpy array,
-                                    otherwise returns a Array object for enhanced visualization capabilities.
-
-        Returns:
-            Union[numpy.ndarray, Array]: The computed data in the specified format, either as raw numerical
-                                              values in a numpy array or structured for visualization with Array.
-        """
-        if measure.short_label not in self.scatterer.available_measure_list:
-            raise ValueError(f"Cannot compute {measure.short_label} for {self.scatterer.__class__.__name__.lower()}")
-
-        measure_string = f'get_{self.scatterer.__class__.__name__.lower()}_{measure.short_label}'
-
-        array = getattr(self.binding, measure_string)()
-
-        if export_as_numpy:
-            return self._export_as_numpy(array)
-
-        return self._export_as_data_visual(measure, array)
-
-    def _export_as_numpy(self, array):
-        for k, v in self.source.binding_kwargs.items():
-            setattr(self, k, v)
-        for k, v in self.scatterer.binding_kwargs.items():
-            setattr(self, k, v)
-        if self.detector is not None:
-            for k, v in self.detector.binding_kwargs.items():
-                setattr(self, k, v)
-
-        return array
-
-    def _export_as_data_visual(self, measure, array):
-        self.generate_datavisual_table()
-        measure.set_base_values(array)
-
-        for k, v in self.source.mapping.items():
-            setattr(self, k, v)
-        for k, v in self.scatterer.mapping.items():
-            setattr(self, k, v)
-        if self.detector is not None:
-            for k, v in self.detector.mapping.items():
-                setattr(self, k, v)
-
-        return Array(x_table=Table(self.x_table), y=measure)
-
-# -
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import numpy
+from pydantic.dataclasses import dataclass
+
+from DataVisual import Array, Table
+from PyMieSim.binary.Experiment import CppExperiment
+
+from typing import Union, NoReturn
+from PyMieSim.experiment.scatterer import Sphere, Cylinder, CoreShell
+from PyMieSim.experiment.detector import Photodiode, CoherentMode
+from PyMieSim.experiment.source import Gaussian, PlaneWave
+
+
+@dataclass
+class Setup(object):
+    """
+    Orchestrates the setup and execution of light scattering experiments using PyMieSim.
+
+    Attributes:
+        scatterer (Union[Sphere, Cylinder, CoreShell]): Configuration for the scatterer in the experiment.
+            Defines the physical properties of the particle being studied.
+        source (Union[Gaussian, PlaneWave]): Configuration for the light source. Specifies the characteristics
+            of the light (e.g., wavelength, polarization) illuminating the scatterer.
+        detector (Union[Photodiode, CoherentMode, None], optional): Configuration for the detector, if any. Details the
+            method of detection for scattered light, including positional and analytical parameters. Defaults to None.
+
+    Methods provide functionality for initializing bindings, generating parameter tables for visualization,
+    and executing the simulation to compute and retrieve specified measures.
+    """
+    scatterer: Union[Sphere, Cylinder, CoreShell]
+    source: Union[Gaussian, PlaneWave]
+    detector: Union[Photodiode, CoherentMode, None] = None
+
+    def __post_init__(self):
+        """
+        Initializes the experiment by setting the source for the scatterer and establishing bindings
+        between the components and the simulation environment.
+        """
+        self.initialize_experiment()
+        self.bind_components()
+
+    def initialize_experiment(self) -> NoReturn:
+        """
+        Initializes the experiment with necessary bindings.
+        """
+        self.scatterer.source = self.source
+
+        self.binding = CppExperiment()
+
+    def bind_components(self):
+        """Binds the experiment components to the CppExperiment instance."""
+        for component in [self.source, self.scatterer, self.detector]:
+            if component:
+                component.bind_to_experiment(experiment=self)
+
+    def generate_datavisual_table(self) -> NoReturn:
+        """
+        Generates and populates the 'x_table' with parameters from the source, scatterer, and detector sets.
+        This table is instrumental for data visualization and analysis.
+
+        Returns:
+            NoReturn
+        """
+        self.x_table = []
+        self.x_table.extend(self.source.get_datavisual_table())
+        self.x_table.extend(self.scatterer.get_datavisual_table())
+
+        if self.detector:
+            self.x_table.extend(self.detector.get_datavisual_table())
+
+    def get(self, measure: Table, export_as_numpy: bool = False) -> numpy.ndarray | Array:
+        """
+        Executes the simulation to compute and retrieve the specified measure.
+
+        Parameters:
+            measure (Table): The measure to be computed by the simulation, defined by the user.
+            export_as_numpy (bool): Determines the format of the returned data. If True, returns a numpy array,
+                                    otherwise returns a Array object for enhanced visualization capabilities.
+
+        Returns:
+            Union[numpy.ndarray, Array]: The computed data in the specified format, either as raw numerical
+                                              values in a numpy array or structured for visualization with Array.
+        """
+        if measure.short_label not in self.scatterer.available_measure_list:
+            raise ValueError(f"Cannot compute {measure.short_label} for {self.scatterer.__class__.__name__.lower()}")
+
+        measure_string = f'get_{self.scatterer.__class__.__name__.lower()}_{measure.short_label}'
+
+        array = getattr(self.binding, measure_string)()
+
+        if export_as_numpy:
+            return self._export_as_numpy(array)
+
+        return self._export_as_data_visual(measure, array)
+
+    def _export_as_numpy(self, array):
+        for k, v in self.source.binding_kwargs.items():
+            setattr(self, k, v)
+        for k, v in self.scatterer.binding_kwargs.items():
+            setattr(self, k, v)
+        if self.detector is not None:
+            for k, v in self.detector.binding_kwargs.items():
+                setattr(self, k, v)
+
+        return array
+
+    def _export_as_data_visual(self, measure, array):
+        self.generate_datavisual_table()
+        measure.set_base_values(array)
+
+        for k, v in self.source.mapping.items():
+            setattr(self, k, v)
+        for k, v in self.scatterer.mapping.items():
+            setattr(self, k, v)
+        if self.detector is not None:
+            for k, v in self.detector.mapping.items():
+                setattr(self, k, v)
+
+        return Array(x_table=Table(self.x_table), y=measure)
+
+# -
```

## PyMieSim/experiment/source.py

```diff
@@ -1,160 +1,163 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-from __future__ import annotations
-from typing import TYPE_CHECKING, Iterable, NoReturn
-if TYPE_CHECKING:
-    from PyMieSim.experiment.setup import Setup
-
-import numpy
-from dataclasses import dataclass, field
-
-from PyMieSim.physics import power_to_amplitude
-from PyMieSim import polarization
-from PyMieSim.binary.Sets import CppSourceSet
-from DataVisual import units
-
-
-@dataclass
-class BaseSource:
-    """
-    Base class for light sources in PyMieSim experiments.
-
-    Attributes:
-        wavelength (Iterable): The wavelength(s) of the light source.
-        polarization_value (Iterable): The polarization values of the light source, in degrees.
-        name (str): The name of the source set, defaults to 'PlaneWave'.
-    """
-    wavelength: Iterable
-    polarization_value: Iterable
-    name: str = field(default='PlaneWave', init=False)
-
-    def __post_init__(self):
-        self.mapping = {
-            'wavelength': None,
-            'polarization': None
-        }
-
-        self.format_inputs()
-        # self.generate_polarization_attribute()
-        self.generate_amplitude()
-        self.generate_binding()
-
-    def format_inputs(self):
-        """Formats input wavelengths and polarization values into numpy arrays."""
-        self.polarization_value = numpy.atleast_1d(self.polarization_value).astype(float)
-        self.wavelength = numpy.atleast_1d(self.wavelength).astype(float)
-
-    def get_datavisual_table(self) -> NoReturn:
-        """
-        Appends the scatterer's properties to a given table for visualization purposes. This enables the
-        representation of scatterer properties in graphical formats.
-
-        Parameters:
-            table (list): The table to which the scatterer's properties will be appended.
-
-        Returns:
-            list: The updated table with the scatterer's properties included.
-        """
-        self.mapping['wavelength'] = units.Length(
-            long_label='Wavelength',
-            short_label=r'$\lambda$',
-            base_values=self.wavelength,
-            string_format='.2f'
-        )
-
-        self.mapping['polarization'] = units.Degree(
-            long_label='Polarization',
-            short_label=r'Pol',
-            base_values=self.polarization_value,
-            string_format='.2f'
-        )
-
-        return [v for k, v in self.mapping.items() if v is not None]
-
-    def bind_to_experiment(self, experiment: Setup):
-        """
-        Binds the source set to an experiment.
-
-        Parameters:
-            experiment (Setup): The experiment setup to bind the source to.
-        """
-        experiment.binding.set_source(self.binding)
-
-
-@dataclass
-class Gaussian(BaseSource):
-    """
-    Represents a Gaussian light source with a specified numerical aperture and optical power.
-
-    Inherits from BaseSource and adds specific attributes for Gaussian sources.
-
-    Attributes:
-        NA (Iterable): The numerical aperture(s) of the Gaussian source.
-        optical_power (float): The optical power of the source, in Watts.
-        polarization_type (str): The type of polarization, defaults to 'linear'.
-    """
-    NA: Iterable
-    optical_power: float
-    polarization_type: str = 'linear'
-
-    def generate_binding(self) -> NoReturn:
-        """
-        Prepares the keyword arguments for the C++ binding based on the scatterer's properties. This
-        involves evaluating material indices and organizing them into a dictionary for the C++ interface.
-
-        Returns:
-            None
-        """
-        linear_polarization = polarization.Linear(*self.polarization_value)
-
-        self.binding_kwargs = dict(
-            wavelength=numpy.atleast_1d(self.wavelength).astype(float),
-            jones_vector=numpy.atleast_2d(linear_polarization.jones_vector).astype(complex).T,
-            amplitude=numpy.atleast_1d(self.amplitude).astype(float),
-        )
-
-        self.binding = CppSourceSet(**self.binding_kwargs)
-
-    def generate_amplitude(self):
-        """Generates the amplitude of the Gaussian source based on its optical power and numerical aperture."""
-        self.amplitude = power_to_amplitude(
-            wavelength=self.wavelength,
-            optical_power=self.optical_power,
-            NA=self.NA
-        )
-
-
-@dataclass
-class PlaneWave(BaseSource):
-    """
-    Represents a Plane Wave light source with a specified amplitude.
-
-    Inherits from BaseSource and specifies amplitude directly.
-
-    Attributes:
-        amplitude (float): The amplitude of the plane wave, in Watts.
-        polarization_type (str): The type of polarization, defaults to 'linear'.
-    """
-    amplitude: float
-    polarization_type: str = 'linear'
-
-    def generate_binding(self) -> NoReturn:
-        """
-        Prepares the keyword arguments for the C++ binding based on the scatterer's properties. This
-        involves evaluating material indices and organizing them into a dictionary for the C++ interface.
-
-        Returns:
-            None
-        """
-        self.binding_kwargs = dict(
-            wavelength=self.wavelength,
-            jones_vector=self.jones_vector,
-            amplitude=self.amplitude
-        )
-
-        self.binding = CppSourceSet(**self.binding_kwargs)
-
-    def generate_amplitude(self):
-        """Sets the amplitude of the plane wave as a numpy array."""
-        self.amplitude = numpy.atleast_1d(self.amplitude)
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+from __future__ import annotations
+from typing import TYPE_CHECKING
+if TYPE_CHECKING:
+    from PyMieSim.experiment.setup import Setup
+
+import numpy
+from pydantic.dataclasses import dataclass
+from dataclasses import field
+
+from PyMieSim.physics import power_to_amplitude
+from PyMieSim import polarization
+from PyMieSim.binary.Sets import CppSourceSet
+from DataVisual import units
+
+from typing import List, Union, NoReturn
+
+
+@dataclass
+class BaseSource:
+    """
+    Base class for light sources in PyMieSim experiments.
+
+    Attributes:
+        wavelength (List): The wavelength(s) of the light source.
+        polarization_value (List): The polarization values of the light source, in degrees.
+        name (str): The name of the source set, defaults to 'PlaneWave'.
+    """
+    wavelength: Union[List[float], float]
+    polarization_value: Union[List[float], float]
+    name: str = field(default='PlaneWave', init=False)
+
+    def __post_init__(self):
+        self.mapping = {
+            'wavelength': None,
+            'polarization': None
+        }
+
+        self.format_inputs()
+        # self.generate_polarization_attribute()
+        self.generate_amplitude()
+        self.generate_binding()
+
+    def format_inputs(self):
+        """Formats input wavelengths and polarization values into numpy arrays."""
+        self.polarization_value = numpy.atleast_1d(self.polarization_value).astype(float)
+        self.wavelength = numpy.atleast_1d(self.wavelength).astype(float)
+
+    def get_datavisual_table(self) -> NoReturn:
+        """
+        Appends the scatterer's properties to a given table for visualization purposes. This enables the
+        representation of scatterer properties in graphical formats.
+
+        Parameters:
+            table (list): The table to which the scatterer's properties will be appended.
+
+        Returns:
+            list: The updated table with the scatterer's properties included.
+        """
+        self.mapping['wavelength'] = units.Length(
+            long_label='Wavelength',
+            short_label=r'$\lambda$',
+            base_values=self.wavelength,
+            string_format='.2f'
+        )
+
+        self.mapping['polarization'] = units.Degree(
+            long_label='Polarization',
+            short_label=r'Pol',
+            base_values=self.polarization_value,
+            string_format='.2f'
+        )
+
+        return [v for k, v in self.mapping.items() if v is not None]
+
+    def bind_to_experiment(self, experiment: Setup):
+        """
+        Binds the source set to an experiment.
+
+        Parameters:
+            experiment (Setup): The experiment setup to bind the source to.
+        """
+        experiment.binding.set_source(self.binding)
+
+
+@dataclass
+class Gaussian(BaseSource):
+    """
+    Represents a Gaussian light source with a specified numerical aperture and optical power.
+
+    Inherits from BaseSource and adds specific attributes for Gaussian sources.
+
+    Attributes:
+        NA (List): The numerical aperture(s) of the Gaussian source.
+        optical_power (float): The optical power of the source, in Watts.
+        polarization_type (str): The type of polarization, defaults to 'linear'.
+    """
+    NA: Union[List[float], float]
+    optical_power: float
+    polarization_type: str = 'linear'
+
+    def generate_binding(self) -> NoReturn:
+        """
+        Prepares the keyword arguments for the C++ binding based on the scatterer's properties. This
+        involves evaluating material indices and organizing them into a dictionary for the C++ interface.
+
+        Returns:
+            None
+        """
+        linear_polarization = polarization.Linear(*self.polarization_value)
+
+        self.binding_kwargs = dict(
+            wavelength=numpy.atleast_1d(self.wavelength).astype(float),
+            jones_vector=numpy.atleast_2d(linear_polarization.jones_vector).astype(complex).T,
+            amplitude=numpy.atleast_1d(self.amplitude).astype(float),
+        )
+
+        self.binding = CppSourceSet(**self.binding_kwargs)
+
+    def generate_amplitude(self):
+        """Generates the amplitude of the Gaussian source based on its optical power and numerical aperture."""
+        self.amplitude = power_to_amplitude(
+            wavelength=self.wavelength,
+            optical_power=self.optical_power,
+            NA=self.NA
+        )
+
+
+@dataclass
+class PlaneWave(BaseSource):
+    """
+    Represents a Plane Wave light source with a specified amplitude.
+
+    Inherits from BaseSource and specifies amplitude directly.
+
+    Attributes:
+        amplitude (float): The amplitude of the plane wave, in Watts.
+        polarization_type (str): The type of polarization, defaults to 'linear'.
+    """
+    amplitude: Union[List[float], float]
+    polarization_type: str = 'linear'
+
+    def generate_binding(self) -> NoReturn:
+        """
+        Prepares the keyword arguments for the C++ binding based on the scatterer's properties. This
+        involves evaluating material indices and organizing them into a dictionary for the C++ interface.
+
+        Returns:
+            None
+        """
+        self.binding_kwargs = dict(
+            wavelength=self.wavelength,
+            jones_vector=self.jones_vector,
+            amplitude=self.amplitude
+        )
+
+        self.binding = CppSourceSet(**self.binding_kwargs)
+
+    def generate_amplitude(self):
+        """Sets the amplitude of the plane wave as a numpy array."""
+        self.amplitude = numpy.atleast_1d(self.amplitude)
```

## PyMieSim/gui/__init__.py

 * *Ordering differences only*

```diff
@@ -1,6 +1,6 @@
-from .scatterer_tab import ScattererTab  # noqa: F401
-from .source_tab import SourceTab  # noqa: F401
-from .detector_tab import DetectorTab  # noqa: F401
-from .axis_tab import AxisTab  # noqa: F401
-
-# -
+from .scatterer_tab import ScattererTab  # noqa: F401
+from .source_tab import SourceTab  # noqa: F401
+from .detector_tab import DetectorTab  # noqa: F401
+from .axis_tab import AxisTab  # noqa: F401
+
+# -
```

## PyMieSim/gui/axis_tab.py

 * *Ordering differences only*

```diff
@@ -1,83 +1,83 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-from typing import NoReturn, Optional, Dict
-from tkinter import ttk
-from PyMieSim.experiment import scatterer
-from PyMieSim.gui.base_tab import BaseTab
-from PyMieSim.gui.widgets import ComBoxWidget
-from PyMieSim.gui.widget_collection import WidgetCollection
-
-
-class AxisTab(BaseTab):
-    measure_map = scatterer.Sphere.available_measure_list
-
-    def __init__(self, master: ttk.Notebook, label: str, other_tabs: list[BaseTab], **kwargs) -> NoReturn:
-        """
-        Initializes the Axis Configuration tab with references to other tabs to gather possible axis choices.
-
-        Args:
-            master (ttk.Notebook): The notebook widget this tab will be part of.
-            label (str): The label for the tab.
-            other_tabs (List[BaseTab]): List of other tab instances to reference for setting up axis mappings.
-        """
-        self.other_tabs = other_tabs
-        super().__init__(master, label=label)
-        self.setup()
-
-    def setup(self) -> NoReturn:
-        """
-        Sets up the UI elements for axis configuration, including comboboxes for selecting
-        variables for the x-axis, y-axis, and an optional standard deviation (STD) axis.
-        """
-        self.x_axis_options = list(self.axis_mapping.keys())
-        self.y_axis_options = list(self.measure_map.keys())
-
-        self.widget_collection = WidgetCollection(frame=self.frame)
-
-        self.widget_collection.add_widgets(
-            ComBoxWidget(label='x-axis', component_label='x_axis', options=self.x_axis_options, default_options=11),
-            ComBoxWidget(label='y-axis', component_label='y_axis', options=self.y_axis_options, default_options=21),
-            ComBoxWidget(label='STD-axis', component_label='std_axis', options=['none', *self.x_axis_options], default_options=0),
-        )
-
-        self.widget_collection.setup_widgets()
-
-    @property
-    def x_axis(self) -> str:
-        """
-        Retrieves the selected x-axis variable from the widget collection.
-
-        Returns:
-            str: The key in the axis mapping corresponding to the selected x-axis variable.
-        """
-        x_axis = self.widget_collection.widgets[0].tk_widget.get()
-        return self.axis_mapping[x_axis]
-
-    @property
-    def std_axis(self) -> Optional[str]:
-        """
-        Retrieves the selected standard deviation axis variable, if any.
-
-        Returns:
-            Optional[str]: The key in the axis mapping corresponding to the selected standard deviation axis variable,
-            or None if 'none' is selected.
-        """
-        std_axis = self.widget_collection.widgets[2].tk_widget.get()
-        if std_axis == 'none':
-            return None
-        return self.axis_mapping[std_axis]
-
-    @property
-    def axis_mapping(self) -> Dict[str, str]:
-        """
-        Combines mappings from all other tabs to provide a comprehensive dictionary of available axis options.
-
-        Returns:
-            Dict[str, str]: A dictionary mapping UI labels to internal scatterer parameter names.
-        """
-        _axis_mapping = {}
-        for tab in self.other_tabs:
-            _axis_mapping.update(tab.component.mapping)
-
-        return _axis_mapping
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+from typing import NoReturn, Optional, Dict
+from tkinter import ttk
+from PyMieSim.experiment import scatterer
+from PyMieSim.gui.base_tab import BaseTab
+from PyMieSim.gui.widgets import ComBoxWidget
+from PyMieSim.gui.widget_collection import WidgetCollection
+
+
+class AxisTab(BaseTab):
+    measure_map = scatterer.Sphere.available_measure_list
+
+    def __init__(self, master: ttk.Notebook, label: str, other_tabs: list[BaseTab], **kwargs) -> NoReturn:
+        """
+        Initializes the Axis Configuration tab with references to other tabs to gather possible axis choices.
+
+        Args:
+            master (ttk.Notebook): The notebook widget this tab will be part of.
+            label (str): The label for the tab.
+            other_tabs (List[BaseTab]): List of other tab instances to reference for setting up axis mappings.
+        """
+        self.other_tabs = other_tabs
+        super().__init__(master, label=label)
+        self.setup()
+
+    def setup(self) -> NoReturn:
+        """
+        Sets up the UI elements for axis configuration, including comboboxes for selecting
+        variables for the x-axis, y-axis, and an optional standard deviation (STD) axis.
+        """
+        self.x_axis_options = list(self.axis_mapping.keys())
+        self.y_axis_options = list(self.measure_map.keys())
+
+        self.widget_collection = WidgetCollection(frame=self.frame)
+
+        self.widget_collection.add_widgets(
+            ComBoxWidget(label='x-axis', component_label='x_axis', options=self.x_axis_options, default_options=11),
+            ComBoxWidget(label='y-axis', component_label='y_axis', options=self.y_axis_options, default_options=21),
+            ComBoxWidget(label='STD-axis', component_label='std_axis', options=['none', *self.x_axis_options], default_options=0),
+        )
+
+        self.widget_collection.setup_widgets()
+
+    @property
+    def x_axis(self) -> str:
+        """
+        Retrieves the selected x-axis variable from the widget collection.
+
+        Returns:
+            str: The key in the axis mapping corresponding to the selected x-axis variable.
+        """
+        x_axis = self.widget_collection.widgets[0].tk_widget.get()
+        return self.axis_mapping[x_axis]
+
+    @property
+    def std_axis(self) -> Optional[str]:
+        """
+        Retrieves the selected standard deviation axis variable, if any.
+
+        Returns:
+            Optional[str]: The key in the axis mapping corresponding to the selected standard deviation axis variable,
+            or None if 'none' is selected.
+        """
+        std_axis = self.widget_collection.widgets[2].tk_widget.get()
+        if std_axis == 'none':
+            return None
+        return self.axis_mapping[std_axis]
+
+    @property
+    def axis_mapping(self) -> Dict[str, str]:
+        """
+        Combines mappings from all other tabs to provide a comprehensive dictionary of available axis options.
+
+        Returns:
+            Dict[str, str]: A dictionary mapping UI labels to internal scatterer parameter names.
+        """
+        _axis_mapping = {}
+        for tab in self.other_tabs:
+            _axis_mapping.update(tab.component.mapping)
+
+        return _axis_mapping
```

## PyMieSim/gui/base_tab.py

 * *Ordering differences only*

```diff
@@ -1,76 +1,76 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-from typing import NoReturn
-from tkinter import ttk
-
-
-class BaseTab:
-    """
-    Base class for creating tabs within a notebook in a GUI application. This class provides the foundational
-    structure and common functionalities needed for different tabs, including initializing the tab's frame
-    and setting up basic attributes.
-
-    Each tab is intended to be a distinct section of the GUI, capable of hosting its own set of widgets and controls.
-    Subclasses of BaseTab should implement the setup_tab method to define specific layouts and behaviors.
-
-    Attributes:
-        label (str): The label of the tab, displayed in the notebook.
-        frame (ttk.Frame): The frame serving as the container for the tab's contents.
-        main_window: Reference to the main window of the application, if applicable.
-    """
-
-    def __init__(self, notebook: ttk.Notebook, label: str, main_window=None):
-        """
-        Initializes a new tab within the provided notebook widget.
-
-        Parameters:
-            notebook (ttk.Notebook): The parent notebook widget to which this tab will be added.
-            label (str): The text label for the tab.
-            main_window: An optional reference to the main application window, allowing access to shared resources or controls.
-        """
-        self.label = label
-        self.frame = ttk.Frame(notebook)
-        notebook.add(self.frame, text=self.label)
-        self.main_window = main_window
-
-    def setup_tab(self) -> NoReturn:
-        """
-        Sets up the layout and widgets specific to this tab. This method is intended to be overridden by subclasses
-        to create a customized interface for each tab.
-
-        Raises:
-            NotImplementedError: If the subclass does not implement this method.
-        """
-        raise NotImplementedError("Subclasses must implement this method to set up the tab's layout and widgets.")
-
-    def get_inputs(self) -> list:
-        """
-        Retrieves user inputs from all widgets in the tab.
-
-        This method assumes that the tab contains a collection of widgets from which user inputs can be extracted.
-        Subclasses should provide a mechanism to store and manage these widgets, allowing for easy retrieval of their values.
-
-        Returns:
-            list: A list of values representing the user inputs from the tab's widgets.
-        """
-        if hasattr(self, 'widget_collection'):
-            return [widget.tk_widget.get() for widget in self.widget_collection.widgets]
-        else:
-            raise AttributeError("The tab does not have a widget_collection attribute.")
-
-    def update_user_input(self) -> NoReturn:
-        """
-        Updates or refreshes the user inputs from the tab's widgets. This method is intended to synchronize
-        the current widget states with their corresponding attributes or variables.
-
-        This implementation is a placeholder and should be overridden by subclasses to provide specific
-        functionality for updating user inputs.
-        """
-        if hasattr(self, 'widget_collection'):
-            for widget in self.widget_collection.widgets:
-                widget.update()
-        else:
-            raise AttributeError("The tab does not have a widget_collection attribute.")
-
-# -
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+from typing import NoReturn
+from tkinter import ttk
+
+
+class BaseTab:
+    """
+    Base class for creating tabs within a notebook in a GUI application. This class provides the foundational
+    structure and common functionalities needed for different tabs, including initializing the tab's frame
+    and setting up basic attributes.
+
+    Each tab is intended to be a distinct section of the GUI, capable of hosting its own set of widgets and controls.
+    Subclasses of BaseTab should implement the setup_tab method to define specific layouts and behaviors.
+
+    Attributes:
+        label (str): The label of the tab, displayed in the notebook.
+        frame (ttk.Frame): The frame serving as the container for the tab's contents.
+        main_window: Reference to the main window of the application, if applicable.
+    """
+
+    def __init__(self, notebook: ttk.Notebook, label: str, main_window=None):
+        """
+        Initializes a new tab within the provided notebook widget.
+
+        Parameters:
+            notebook (ttk.Notebook): The parent notebook widget to which this tab will be added.
+            label (str): The text label for the tab.
+            main_window: An optional reference to the main application window, allowing access to shared resources or controls.
+        """
+        self.label = label
+        self.frame = ttk.Frame(notebook)
+        notebook.add(self.frame, text=self.label)
+        self.main_window = main_window
+
+    def setup_tab(self) -> NoReturn:
+        """
+        Sets up the layout and widgets specific to this tab. This method is intended to be overridden by subclasses
+        to create a customized interface for each tab.
+
+        Raises:
+            NotImplementedError: If the subclass does not implement this method.
+        """
+        raise NotImplementedError("Subclasses must implement this method to set up the tab's layout and widgets.")
+
+    def get_inputs(self) -> list:
+        """
+        Retrieves user inputs from all widgets in the tab.
+
+        This method assumes that the tab contains a collection of widgets from which user inputs can be extracted.
+        Subclasses should provide a mechanism to store and manage these widgets, allowing for easy retrieval of their values.
+
+        Returns:
+            list: A list of values representing the user inputs from the tab's widgets.
+        """
+        if hasattr(self, 'widget_collection'):
+            return [widget.tk_widget.get() for widget in self.widget_collection.widgets]
+        else:
+            raise AttributeError("The tab does not have a widget_collection attribute.")
+
+    def update_user_input(self) -> NoReturn:
+        """
+        Updates or refreshes the user inputs from the tab's widgets. This method is intended to synchronize
+        the current widget states with their corresponding attributes or variables.
+
+        This implementation is a placeholder and should be overridden by subclasses to provide specific
+        functionality for updating user inputs.
+        """
+        if hasattr(self, 'widget_collection'):
+            for widget in self.widget_collection.widgets:
+                widget.update()
+        else:
+            raise AttributeError("The tab does not have a widget_collection attribute.")
+
+# -
```

## PyMieSim/gui/detector_tab.py

 * *Ordering differences only*

```diff
@@ -1,143 +1,143 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-from typing import NoReturn
-from tkinter import ttk, StringVar
-from PyMieSim.experiment.detector import Photodiode, CoherentMode
-from PyMieSim.gui.base_tab import BaseTab
-from PyMieSim.gui.widgets import InputWidget, ComBoxWidget, RadioButtonWidget
-from PyMieSim.gui.widget_collection import WidgetCollection
-
-
-class DetectorTab(BaseTab):
-    """
-    A GUI tab for configuring the detector parameters for simulations in PyMieSim.
-
-    Allows for the setup of detector characteristics such as numerical aperture (NA),
-    angular offsets (gamma and phi), and polarization filter angle, facilitating
-    the detailed configuration of the simulation's detector component.
-
-    Attributes:
-        variables (WidgetCollection): A collection of widgets for detector configuration.
-    """
-
-    def __init__(self, master: ttk.Notebook, label: str) -> None:
-        """
-        Initialize the DetectorTab with UI components to configure the detector parameters.
-
-        Args:
-            master (ttk.Notebook): The notebook widget this tab is a part of.
-            label (str): The tab label.
-        """
-        super().__init__(master, label=label)
-        self.type_button = StringVar(value='Photodiode')
-        self.setup_type_combobox()
-        self.setup_widgets()
-
-    def setup_type_combobox(self) -> None:
-        """
-        Create and configure a combobox to select the type of detector, binding it to update UI on change.
-        """
-        self.type_widget = ttk.Combobox(
-            self.frame,
-            textvariable=self.type_button,
-            values=['Photodiode', 'CoherentMode'],
-            state="readonly"
-        )
-        self.type_widget.grid(row=0, column=0)
-        self.type_widget.bind("<<ComboboxSelected>>", self.on_type_change)
-
-    def on_type_change(self, event=None) -> NoReturn:
-        """
-        Handles the event triggered by a change in the selected scatterer type. It updates the UI to match
-        the selected scatterer configuration.
-
-        Args:
-            event: The event that triggered this method (default is None).
-        """
-        detector_type = self.type_widget.get().lower()
-        setup_method = getattr(self, f"setup_{detector_type}_widgets", None)
-        self.widget_collection.clear_widgets()
-        if callable(setup_method):
-            setup_method()
-        else:
-            raise ValueError(f"Unsupported detector type: {detector_type}")
-
-    def setup_widgets(self) -> NoReturn:
-        """
-        Configures the GUI elements for the Scatterer tab based on the selected scatterer type.
-        """
-        detector_type = self.type_widget.get()
-
-        match detector_type:
-            case 'Photodiode':
-                self.setup_photodiode_widgets()
-            case 'CoherentMode':
-                self.setup_coherentmode_widgets()
-            case _:
-                raise ValueError(f'Detector type not valid: {detector_type}')
-
-    def setup_photodiode_widgets(self) -> None:
-        """
-        Setup widgets specific to configuring a Photodiode detector.
-        """
-        self.widget_collection = WidgetCollection(frame=self.frame)
-
-        self.widget_collection.add_widgets(
-            InputWidget(default_value='0.2, 0.3, 0.4', label='Numerical aperture (NA)', component_label='NA', dtype=float),
-            InputWidget(default_value='0', label='Gamma [degree]', component_label='gamma_offset', dtype=float),
-            InputWidget(default_value='0:360:200', label='Phi [degree]', component_label='phi_offset', dtype=float),
-            InputWidget(default_value='None', label='Polarization filter [degree]', component_label='polarization_filter', dtype=float),
-            InputWidget(default_value='500', label='Sampling', component_label='sampling', dtype=int)
-        )
-
-        self.widget_collection.setup_widgets(row_start=1)
-        self.setup_photodiode_component()
-
-    def setup_coherentmode_widgets(self) -> None:
-        """
-        Setup widgets specific to configuring a Coherent Mode detector.
-        """
-        self.widget_collection = WidgetCollection(frame=self.frame)
-
-        self.widget_collection.add_widgets(
-            RadioButtonWidget(option_text=['Point', 'Mean'], options_values=[False, True], component_label='mean_coupling', label='Mean coupling'),
-            InputWidget(default_value='0.', label='Polarization filter [degree]', component_label='polarization_filter', dtype=float),
-            InputWidget(default_value='0', label='Gamma [degree]', component_label='gamma_offset', dtype=float),
-            InputWidget(default_value='180:-180:200', label='Phi [degree]', component_label='phi_offset', dtype=float),
-            InputWidget(default_value='0.2, 0.3, 0.4', label='Numerical aperture (NA)', component_label='NA', dtype=float),
-            InputWidget(default_value='LP01', label='Mode field', component_label='mode_number', dtype=str),
-            InputWidget(default_value='0', label='Field rotation [degree]', component_label='rotation', dtype=float),
-            InputWidget(default_value='500', label='Sampling', component_label='sampling', dtype=int)
-        )
-
-        self.widget_collection.setup_widgets(row_start=1)
-        self.setup_coherentmode_component()
-
-    def setup_component(self, event=None) -> NoReturn:
-        """
-        Handles the event triggered by a change in the selected scatterer type. It updates the UI to match
-        the selected scatterer configuration.
-
-        Args:
-            event: The event that triggered this method (default is None).
-        """
-        detector_type = self.type_button.get().lower()
-        self.widget_collection.update()
-        setup_method = getattr(self, f"setup_{detector_type}_component", None)
-        if callable(setup_method):
-            setup_method()
-        else:
-            raise ValueError(f"Unsupported scatterer type: {detector_type}")
-
-    def setup_photodiode_component(self) -> NoReturn:
-        kwargs = self.widget_collection.to_component_dict()
-
-        self.component = Photodiode(**kwargs)
-
-    def setup_coherentmode_component(self) -> NoReturn:
-        kwargs = self.widget_collection.to_component_dict()
-
-        self.component = CoherentMode(**kwargs)
-
-# -
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+from typing import NoReturn
+from tkinter import ttk, StringVar
+from PyMieSim.experiment.detector import Photodiode, CoherentMode
+from PyMieSim.gui.base_tab import BaseTab
+from PyMieSim.gui.widgets import InputWidget, ComBoxWidget, RadioButtonWidget
+from PyMieSim.gui.widget_collection import WidgetCollection
+
+
+class DetectorTab(BaseTab):
+    """
+    A GUI tab for configuring the detector parameters for simulations in PyMieSim.
+
+    Allows for the setup of detector characteristics such as numerical aperture (NA),
+    angular offsets (gamma and phi), and polarization filter angle, facilitating
+    the detailed configuration of the simulation's detector component.
+
+    Attributes:
+        variables (WidgetCollection): A collection of widgets for detector configuration.
+    """
+
+    def __init__(self, master: ttk.Notebook, label: str) -> None:
+        """
+        Initialize the DetectorTab with UI components to configure the detector parameters.
+
+        Args:
+            master (ttk.Notebook): The notebook widget this tab is a part of.
+            label (str): The tab label.
+        """
+        super().__init__(master, label=label)
+        self.type_button = StringVar(value='Photodiode')
+        self.setup_type_combobox()
+        self.setup_widgets()
+
+    def setup_type_combobox(self) -> None:
+        """
+        Create and configure a combobox to select the type of detector, binding it to update UI on change.
+        """
+        self.type_widget = ttk.Combobox(
+            self.frame,
+            textvariable=self.type_button,
+            values=['Photodiode', 'CoherentMode'],
+            state="readonly"
+        )
+        self.type_widget.grid(row=0, column=0)
+        self.type_widget.bind("<<ComboboxSelected>>", self.on_type_change)
+
+    def on_type_change(self, event=None) -> NoReturn:
+        """
+        Handles the event triggered by a change in the selected scatterer type. It updates the UI to match
+        the selected scatterer configuration.
+
+        Args:
+            event: The event that triggered this method (default is None).
+        """
+        detector_type = self.type_widget.get().lower()
+        setup_method = getattr(self, f"setup_{detector_type}_widgets", None)
+        self.widget_collection.clear_widgets()
+        if callable(setup_method):
+            setup_method()
+        else:
+            raise ValueError(f"Unsupported detector type: {detector_type}")
+
+    def setup_widgets(self) -> NoReturn:
+        """
+        Configures the GUI elements for the Scatterer tab based on the selected scatterer type.
+        """
+        detector_type = self.type_widget.get()
+
+        match detector_type:
+            case 'Photodiode':
+                self.setup_photodiode_widgets()
+            case 'CoherentMode':
+                self.setup_coherentmode_widgets()
+            case _:
+                raise ValueError(f'Detector type not valid: {detector_type}')
+
+    def setup_photodiode_widgets(self) -> None:
+        """
+        Setup widgets specific to configuring a Photodiode detector.
+        """
+        self.widget_collection = WidgetCollection(frame=self.frame)
+
+        self.widget_collection.add_widgets(
+            InputWidget(default_value='0.2, 0.3, 0.4', label='Numerical aperture (NA)', component_label='NA', dtype=float),
+            InputWidget(default_value='0', label='Gamma [degree]', component_label='gamma_offset', dtype=float),
+            InputWidget(default_value='0:360:200', label='Phi [degree]', component_label='phi_offset', dtype=float),
+            InputWidget(default_value='None', label='Polarization filter [degree]', component_label='polarization_filter', dtype=float),
+            InputWidget(default_value='500', label='Sampling', component_label='sampling', dtype=int)
+        )
+
+        self.widget_collection.setup_widgets(row_start=1)
+        self.setup_photodiode_component()
+
+    def setup_coherentmode_widgets(self) -> None:
+        """
+        Setup widgets specific to configuring a Coherent Mode detector.
+        """
+        self.widget_collection = WidgetCollection(frame=self.frame)
+
+        self.widget_collection.add_widgets(
+            RadioButtonWidget(option_text=['Point', 'Mean'], options_values=[False, True], component_label='mean_coupling', label='Mean coupling'),
+            InputWidget(default_value='0.', label='Polarization filter [degree]', component_label='polarization_filter', dtype=float),
+            InputWidget(default_value='0', label='Gamma [degree]', component_label='gamma_offset', dtype=float),
+            InputWidget(default_value='180:-180:200', label='Phi [degree]', component_label='phi_offset', dtype=float),
+            InputWidget(default_value='0.2, 0.3, 0.4', label='Numerical aperture (NA)', component_label='NA', dtype=float),
+            InputWidget(default_value='LP01', label='Mode field', component_label='mode_number', dtype=str),
+            InputWidget(default_value='0', label='Field rotation [degree]', component_label='rotation', dtype=float),
+            InputWidget(default_value='500', label='Sampling', component_label='sampling', dtype=int)
+        )
+
+        self.widget_collection.setup_widgets(row_start=1)
+        self.setup_coherentmode_component()
+
+    def setup_component(self, event=None) -> NoReturn:
+        """
+        Handles the event triggered by a change in the selected scatterer type. It updates the UI to match
+        the selected scatterer configuration.
+
+        Args:
+            event: The event that triggered this method (default is None).
+        """
+        detector_type = self.type_button.get().lower()
+        self.widget_collection.update()
+        setup_method = getattr(self, f"setup_{detector_type}_component", None)
+        if callable(setup_method):
+            setup_method()
+        else:
+            raise ValueError(f"Unsupported scatterer type: {detector_type}")
+
+    def setup_photodiode_component(self) -> NoReturn:
+        kwargs = self.widget_collection.to_component_dict()
+
+        self.component = Photodiode(**kwargs)
+
+    def setup_coherentmode_component(self) -> NoReturn:
+        kwargs = self.widget_collection.to_component_dict()
+
+        self.component = CoherentMode(**kwargs)
+
+# -
```

## PyMieSim/gui/main_window.py

 * *Ordering differences only*

```diff
@@ -1,220 +1,220 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-from typing import NoReturn
-import tkinter as tk
-from tkinter import ttk, filedialog, messagebox
-import numpy as np
-import matplotlib.pyplot as plt
-from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
-
-from PyMieSim.experiment import Setup
-
-from PyMieSim.gui import SourceTab, ScattererTab, DetectorTab, AxisTab
-
-
-class PyMieSimGUI:
-    """
-    Graphical User Interface for computing and visualizing the B1 scattering coefficient
-    for cylindrical scatterers using PyMieSim.
-
-    Attributes:
-        master (tk.Tk): The main tkinter window.
-    """
-
-    def __init__(self, master: tk.Tk):
-        """
-        Initializes the GUI, setting up variables, plot frame, notebook, and controls.
-
-        Parameters:
-            master (tk.Tk): The root window of the application.
-        """
-        self.master = master
-        self.master.protocol("WM_DELETE_WINDOW", self.on_close)
-        self.master.title("PyMieSim Graphic Interface")
-
-        self.customize_notebook_style()
-        self.setup_notebook()
-        self.setup_controls()
-
-    def on_close(self) -> NoReturn:
-        """
-        Handles the GUI close event.
-        """
-        plt.close('all')  # Close all matplotlib figures
-        self.master.destroy()  # Close the Tkinter window
-
-    def customize_notebook_style(self) -> NoReturn:
-        """
-        Customizes the ttk Notebook style for a unique appearance of tabs, making them larger.
-        """
-        style = ttk.Style()
-        style.configure("TNotebook", background="#f0f0f0")
-
-        style.configure(
-            "TNotebook.Tab",
-            background="#d0d0d0",
-            padding=[10, 20, 10, 20],  # Increase padding for larger tabs
-            font=('Helvetica', 12)     # Larger font for tabs
-        )
-
-        style.map(
-            "TNotebook.Tab",
-            background=[("selected", "#a0a0a0")],
-            expand=[("selected", [1, 1, 1, 0])]
-        )
-
-        style.configure(
-            "Large.TButton",
-            font=('Helvetica', 18),
-            padding=[20, 20]
-        )
-
-    def setup_notebook(self) -> NoReturn:
-        """
-        Sets up the notebook widget with tabs for Source, Scatterer, and Detector configurations.
-        """
-        self.notebook = ttk.Notebook(self.master)
-        self.notebook.grid(row=0, column=0, sticky="ewns")
-
-        self.notebook_2 = ttk.Notebook(self.master)
-        self.notebook_2.grid(row=2, column=0, sticky="ewns")
-
-        # Create tab instances
-        self.source_tab = SourceTab(notebook=self.notebook, label='Source')
-        self.scatterer_tab = ScattererTab(self.notebook, 'Scatterer', source_tab=self.source_tab)
-        self.detector_tab = DetectorTab(self.notebook, 'Detector')
-        self.axis_tab = AxisTab(self.notebook_2, 'Axis Configuration', other_tabs=[self.source_tab, self.scatterer_tab, self.detector_tab])
-
-    def export_plot(self) -> NoReturn:
-        """
-        Opens a file dialog for the user to choose where to save the current plot,
-        then saves the plot to the specified location.
-        """
-        # Ensure there's a plot to save
-        if hasattr(self, 'figure'):
-            # Open file dialog to choose file name and type
-            filetypes = [
-                ('PNG files', '*.png'),
-                ('JPEG files', '*.jpg;*.jpeg'),
-                ('PDF files', '*.pdf'),
-                ('SVG files', '*.svg'),
-                ('All files', '*.*')
-            ]
-
-            filepath = filedialog.asksaveasfilename(
-                defaultextension=".png",
-                filetypes=filetypes,
-                title="Save plot as..."
-            )
-
-            # If a file was selected (i.e., dialog not cancelled)
-            if filepath:
-                # Save the figure using matplotlib's savefig
-                self.figure.savefig(filepath)
-                messagebox.showinfo("Export Successful", f"Plot successfully saved to {filepath}")
-        else:
-            messagebox.showwarning("Export Failed", "No plot available to export.")
-
-    def setup_controls(self) -> NoReturn:
-        """
-        Sets up control buttons for calculating results and saving data.
-        """
-        self.controls_frame = ttk.Frame(self.master)
-        self.controls_frame.grid(row=1, column=0, sticky="ew")
-
-        ttk.Button(
-            self.controls_frame,
-            text="Calculate",
-            style="Large.TButton",
-            command=self.update_plot
-        ).grid(row=0, column=0, sticky="ew")
-
-        ttk.Button(
-            self.controls_frame,
-            text="Save as CSV",
-            style="Large.TButton",
-            command=self.save_data_as_csv
-        ).grid(row=0, column=1, sticky="ew")
-
-        ttk.Button(
-            self.controls_frame,
-            text="Export Plot",
-            style="Large.TButton",
-            command=self.export_plot
-        ).grid(row=0, column=2, sticky="ew")
-
-    def setup_PyMieSim(self) -> NoReturn:
-        """
-        Compute the B1 scattering data using either a single diameter or a range of diameters.
-        """
-        self.scatterer_tab.setup_component()
-        self.source_tab.setup_component()
-        self.detector_tab.setup_component()
-
-        self.experiment = Setup(
-            scatterer=self.scatterer_tab.component,
-            source=self.source_tab.component,
-            detector=self.detector_tab.component
-        )
-
-    def save_data_as_csv(self) -> NoReturn:
-        """
-        Triggered by the "Save as CSV" button. Opens a file dialog to save the computed data as a CSV file.
-        """
-        if hasattr(self, 'data'):
-            filepath = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV files", "*.csv")])
-            if filepath:
-                # Assuming self.data is a pandas DataFrame or can be converted to one
-                np.savetxt(filepath, self.data.y.values.squeeze(), delimiter=",")
-                print(f"Data saved to {filepath}")
-        else:
-            print("No data to save. Please calculate first.")
-
-    def generate_figure(self):
-        """
-        Generates and displays the simulation results as a plot in a new window.
-        """
-        if hasattr(self, 'new_window'):
-            self.new_window.destroy()
-
-        self.new_window = tk.Toplevel(self.master)
-        self.new_window.title("Plot Window")
-
-        x_axis = self.axis_tab.x_axis
-
-        std_axis = None if self.axis_tab.std_axis == "none" else self.axis_tab.std_axis
-
-        figure = self.data.plot(x=x_axis, std=std_axis)
-        figure.unit_size = (9, 4)
-        figure._render_()
-        self.figure = figure._mpl_figure
-
-        canvas = FigureCanvasTkAgg(self.figure, master=self.new_window)
-        canvas.draw()
-        canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
-
-        self.toolbar = NavigationToolbar2Tk(canvas, self.new_window)
-        self.toolbar.update()
-        canvas._tkcanvas.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
-
-    def update_plot(self) -> NoReturn:
-        plt.close('all')
-        x_axis, y_axis, std_axis = self.axis_tab.get_inputs()
-
-        self.y_axis = self.axis_tab.measure_map[y_axis]
-
-        self.setup_PyMieSim()
-
-        self.data = self.experiment.get(self.y_axis)
-
-        self.x_axis = self.axis_tab.axis_mapping[x_axis]
-
-        try:
-            self.generate_figure()
-
-        except ValueError as e:
-            messagebox.showerror("Input Error", str(e))
-
-
-# -
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+from typing import NoReturn
+import tkinter as tk
+from tkinter import ttk, filedialog, messagebox
+import numpy as np
+import matplotlib.pyplot as plt
+from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
+
+from PyMieSim.experiment import Setup
+
+from PyMieSim.gui import SourceTab, ScattererTab, DetectorTab, AxisTab
+
+
+class PyMieSimGUI:
+    """
+    Graphical User Interface for computing and visualizing the B1 scattering coefficient
+    for cylindrical scatterers using PyMieSim.
+
+    Attributes:
+        master (tk.Tk): The main tkinter window.
+    """
+
+    def __init__(self, master: tk.Tk):
+        """
+        Initializes the GUI, setting up variables, plot frame, notebook, and controls.
+
+        Parameters:
+            master (tk.Tk): The root window of the application.
+        """
+        self.master = master
+        self.master.protocol("WM_DELETE_WINDOW", self.on_close)
+        self.master.title("PyMieSim Graphic Interface")
+
+        self.customize_notebook_style()
+        self.setup_notebook()
+        self.setup_controls()
+
+    def on_close(self) -> NoReturn:
+        """
+        Handles the GUI close event.
+        """
+        plt.close('all')  # Close all matplotlib figures
+        self.master.destroy()  # Close the Tkinter window
+
+    def customize_notebook_style(self) -> NoReturn:
+        """
+        Customizes the ttk Notebook style for a unique appearance of tabs, making them larger.
+        """
+        style = ttk.Style()
+        style.configure("TNotebook", background="#f0f0f0")
+
+        style.configure(
+            "TNotebook.Tab",
+            background="#d0d0d0",
+            padding=[10, 20, 10, 20],  # Increase padding for larger tabs
+            font=('Helvetica', 12)     # Larger font for tabs
+        )
+
+        style.map(
+            "TNotebook.Tab",
+            background=[("selected", "#a0a0a0")],
+            expand=[("selected", [1, 1, 1, 0])]
+        )
+
+        style.configure(
+            "Large.TButton",
+            font=('Helvetica', 18),
+            padding=[20, 20]
+        )
+
+    def setup_notebook(self) -> NoReturn:
+        """
+        Sets up the notebook widget with tabs for Source, Scatterer, and Detector configurations.
+        """
+        self.notebook = ttk.Notebook(self.master)
+        self.notebook.grid(row=0, column=0, sticky="ewns")
+
+        self.notebook_2 = ttk.Notebook(self.master)
+        self.notebook_2.grid(row=2, column=0, sticky="ewns")
+
+        # Create tab instances
+        self.source_tab = SourceTab(notebook=self.notebook, label='Source')
+        self.scatterer_tab = ScattererTab(self.notebook, 'Scatterer', source_tab=self.source_tab)
+        self.detector_tab = DetectorTab(self.notebook, 'Detector')
+        self.axis_tab = AxisTab(self.notebook_2, 'Axis Configuration', other_tabs=[self.source_tab, self.scatterer_tab, self.detector_tab])
+
+    def export_plot(self) -> NoReturn:
+        """
+        Opens a file dialog for the user to choose where to save the current plot,
+        then saves the plot to the specified location.
+        """
+        # Ensure there's a plot to save
+        if hasattr(self, 'figure'):
+            # Open file dialog to choose file name and type
+            filetypes = [
+                ('PNG files', '*.png'),
+                ('JPEG files', '*.jpg;*.jpeg'),
+                ('PDF files', '*.pdf'),
+                ('SVG files', '*.svg'),
+                ('All files', '*.*')
+            ]
+
+            filepath = filedialog.asksaveasfilename(
+                defaultextension=".png",
+                filetypes=filetypes,
+                title="Save plot as..."
+            )
+
+            # If a file was selected (i.e., dialog not cancelled)
+            if filepath:
+                # Save the figure using matplotlib's savefig
+                self.figure.savefig(filepath)
+                messagebox.showinfo("Export Successful", f"Plot successfully saved to {filepath}")
+        else:
+            messagebox.showwarning("Export Failed", "No plot available to export.")
+
+    def setup_controls(self) -> NoReturn:
+        """
+        Sets up control buttons for calculating results and saving data.
+        """
+        self.controls_frame = ttk.Frame(self.master)
+        self.controls_frame.grid(row=1, column=0, sticky="ew")
+
+        ttk.Button(
+            self.controls_frame,
+            text="Calculate",
+            style="Large.TButton",
+            command=self.update_plot
+        ).grid(row=0, column=0, sticky="ew")
+
+        ttk.Button(
+            self.controls_frame,
+            text="Save as CSV",
+            style="Large.TButton",
+            command=self.save_data_as_csv
+        ).grid(row=0, column=1, sticky="ew")
+
+        ttk.Button(
+            self.controls_frame,
+            text="Export Plot",
+            style="Large.TButton",
+            command=self.export_plot
+        ).grid(row=0, column=2, sticky="ew")
+
+    def setup_PyMieSim(self) -> NoReturn:
+        """
+        Compute the B1 scattering data using either a single diameter or a range of diameters.
+        """
+        self.scatterer_tab.setup_component()
+        self.source_tab.setup_component()
+        self.detector_tab.setup_component()
+
+        self.experiment = Setup(
+            scatterer=self.scatterer_tab.component,
+            source=self.source_tab.component,
+            detector=self.detector_tab.component
+        )
+
+    def save_data_as_csv(self) -> NoReturn:
+        """
+        Triggered by the "Save as CSV" button. Opens a file dialog to save the computed data as a CSV file.
+        """
+        if hasattr(self, 'data'):
+            filepath = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV files", "*.csv")])
+            if filepath:
+                # Assuming self.data is a pandas DataFrame or can be converted to one
+                np.savetxt(filepath, self.data.y.values.squeeze(), delimiter=",")
+                print(f"Data saved to {filepath}")
+        else:
+            print("No data to save. Please calculate first.")
+
+    def generate_figure(self):
+        """
+        Generates and displays the simulation results as a plot in a new window.
+        """
+        if hasattr(self, 'new_window'):
+            self.new_window.destroy()
+
+        self.new_window = tk.Toplevel(self.master)
+        self.new_window.title("Plot Window")
+
+        x_axis = self.axis_tab.x_axis
+
+        std_axis = None if self.axis_tab.std_axis == "none" else self.axis_tab.std_axis
+
+        figure = self.data.plot(x=x_axis, std=std_axis)
+        figure.unit_size = (9, 4)
+        figure._render_()
+        self.figure = figure._mpl_figure
+
+        canvas = FigureCanvasTkAgg(self.figure, master=self.new_window)
+        canvas.draw()
+        canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
+
+        self.toolbar = NavigationToolbar2Tk(canvas, self.new_window)
+        self.toolbar.update()
+        canvas._tkcanvas.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
+
+    def update_plot(self) -> NoReturn:
+        plt.close('all')
+        x_axis, y_axis, std_axis = self.axis_tab.get_inputs()
+
+        self.y_axis = self.axis_tab.measure_map[y_axis]
+
+        self.setup_PyMieSim()
+
+        self.data = self.experiment.get(self.y_axis)
+
+        self.x_axis = self.axis_tab.axis_mapping[x_axis]
+
+        try:
+            self.generate_figure()
+
+        except ValueError as e:
+            messagebox.showerror("Input Error", str(e))
+
+
+# -
```

## PyMieSim/gui/scatterer_tab.py

 * *Ordering differences only*

```diff
@@ -1,155 +1,155 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-from typing import NoReturn
-from tkinter import ttk
-import tkinter
-from PyMieSim.experiment import scatterer
-from PyMieSim.gui.base_tab import BaseTab
-from PyMieSim.gui.widgets import InputWidget
-from PyMieSim.gui.widget_collection import WidgetCollection
-
-
-class ScattererTab(BaseTab):
-    """
-    A GUI tab for configuring scatterer parameters within PyMieSim experiments. This tab allows users
-    to choose between different scatterer types (Sphere, Cylinder, CoreShell) and set relevant
-    parameters like dimensions and refractive indices.
-
-    Attributes:
-        master (ttk.Notebook): The notebook widget this tab is part of.
-        label (str): The label for the tab.
-        source_tab (BaseTab): Reference to the source tab for source component configurations.
-    """
-
-    def __init__(self, master: ttk.Notebook, label: str, source_tab: BaseTab) -> NoReturn:
-        """
-        Initializes the ScattererTab with user interface elements for scatterer configuration.
-
-        Args:
-            master (ttk.Notebook): The notebook widget this tab will be part of.
-            label (str): The label for the tab.
-            source_tab (BaseTab): Reference to the source tab for accessing source component settings.
-        """
-        self.type_button = tkinter.StringVar(value='Sphere')
-        self.source_tab = source_tab
-
-        super().__init__(master, label=label)
-        self._setup_combobox()
-        self.setup_widgets()
-
-    def setup_widgets(self) -> NoReturn:
-        """
-        Configures the GUI elements for the Scatterer tab based on the selected scatterer type.
-        """
-        match self.type_button.get():
-            case 'Sphere':
-                self.setup_sphere_widgets()
-            case 'Cylinder':
-                self.setup_cylinder_widgets()
-            case 'CoreShell':
-                self.setup_coreshell_widgets()
-            case _:
-                raise ValueError('Scatterer type not valid')
-
-    def _setup_combobox(self) -> NoReturn:
-        """
-        Sets up a combobox for selecting the type of scatterer. It provides options for Sphere, Cylinder,
-        or CoreShell configurations.
-        """
-        combobox = tkinter.ttk.Combobox(
-            self.frame,
-            textvariable=self.type_button,
-            values=['Sphere', 'Cylinder', 'CoreShell'],
-            state="readonly"
-        )
-
-        combobox.grid(row=0, column=0)
-        combobox.bind("<<ComboboxSelected>>", self.on_type_change)
-
-    def on_type_change(self, event=None) -> NoReturn:
-        """
-        Handles the event triggered by a change in the selected scatterer type. It updates the UI to match
-        the selected scatterer configuration.
-
-        Args:
-            event: The event that triggered this method (default is None).
-        """
-        scatterer_type = self.type_button.get().lower()
-        setup_method = getattr(self, f"setup_{scatterer_type}_widgets", None)
-        self.widget_collection.clear_widgets()
-        if callable(setup_method):
-            setup_method()
-        else:
-            raise ValueError(f"Unsupported scatterer type: {scatterer_type}")
-
-    def setup_sphere_widgets(self) -> NoReturn:
-        """
-        Sets up the configuration widgets for a Sphere scatterer and initializes the component.
-        """
-        self.widget_collection = WidgetCollection(frame=self.frame)
-
-        self.widget_collection.add_widgets(
-            InputWidget(default_value='500', label='Diameter [nm]', component_label='diameter', multiplicative_factor=1e-9, dtype=float),
-            InputWidget(default_value='1.4', label='Refractive Index', component_label='index', dtype=float),
-            InputWidget(default_value='1.0', label='Medium Refractive Index', component_label='medium_index', dtype=float)
-        )
-        self.widget_collection.setup_widgets()
-        self.setup_sphere_component()
-
-    def setup_cylinder_widgets(self) -> NoReturn:
-        """
-        Sets up the configuration widgets for a Cylinder scatterer and initializes the component.
-        """
-        self.widget_collection = WidgetCollection(frame=self.frame)
-
-        self.widget_collection.add_widgets(
-            InputWidget(default_value='1000', label='Diameter [nm]', component_label='diameter', multiplicative_factor=1e-9, dtype=float),
-            InputWidget(default_value='1.4', label='Refractive Index', component_label='index', dtype=complex),
-            InputWidget(default_value='1.0', label='Medium Refractive Index', component_label='medium_index', dtype=float)
-        )
-        self.widget_collection.setup_widgets()
-        self.setup_cylinder_component()
-
-    def setup_coreshell_widgets(self) -> NoReturn:
-        """
-        Sets up the configuration widgets for a CoreShell scatterer and initializes the component.
-        """
-        self.widget_collection = WidgetCollection(frame=self.frame)
-
-        self.widget_collection.add_widgets(
-            InputWidget(default_value='1000', label='Core Diameter [nm]', component_label='core_diameter', multiplicative_factor=1e-9, dtype=float),
-            InputWidget(default_value='200', label='Shell Width [nm]', component_label='shell_width', multiplicative_factor=1e-9, dtype=float),
-            InputWidget(default_value='1.4', label='Core Refractive Index', component_label='core_index', dtype=complex),
-            InputWidget(default_value='1.4', label='Shell Refractive Index', component_label='shell_index', dtype=complex),
-            InputWidget(default_value='1.0', label='Medium Refractive Index', component_label='medium_index', dtype=float)
-        )
-        self.widget_collection.setup_widgets()
-        self.setup_coreshell_component()
-
-    def setup_component(self, event=None) -> NoReturn:
-        """
-        Handles the event triggered by a change in the selected scatterer type. It updates the UI to match
-        the selected scatterer configuration.
-
-        Args:
-            event: The event that triggered this method (default is None).
-        """
-        scatterer_type = self.type_button.get().lower()
-        self.widget_collection.update()
-        setup_method = getattr(self, f"setup_{scatterer_type}_component", None)
-        if callable(setup_method):
-            setup_method()
-        else:
-            raise ValueError(f"Unsupported scatterer type: {scatterer_type}")
-
-    def setup_sphere_component(self) -> NoReturn:
-        self.component = scatterer.Sphere(**self.widget_collection.to_component_dict(), source=self.source_tab.component)
-
-    def setup_cylinder_component(self) -> NoReturn:
-        self.component = scatterer.Cylinder(**self.widget_collection.to_component_dict(), source=self.source_tab.component)
-
-    def setup_coreshell_component(self) -> NoReturn:
-        self.component = scatterer.CoreShell(**self.widget_collection.to_component_dict(), source=self.source_tab.component)
-
-# -
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+from typing import NoReturn
+from tkinter import ttk
+import tkinter
+from PyMieSim.experiment import scatterer
+from PyMieSim.gui.base_tab import BaseTab
+from PyMieSim.gui.widgets import InputWidget
+from PyMieSim.gui.widget_collection import WidgetCollection
+
+
+class ScattererTab(BaseTab):
+    """
+    A GUI tab for configuring scatterer parameters within PyMieSim experiments. This tab allows users
+    to choose between different scatterer types (Sphere, Cylinder, CoreShell) and set relevant
+    parameters like dimensions and refractive indices.
+
+    Attributes:
+        master (ttk.Notebook): The notebook widget this tab is part of.
+        label (str): The label for the tab.
+        source_tab (BaseTab): Reference to the source tab for source component configurations.
+    """
+
+    def __init__(self, master: ttk.Notebook, label: str, source_tab: BaseTab) -> NoReturn:
+        """
+        Initializes the ScattererTab with user interface elements for scatterer configuration.
+
+        Args:
+            master (ttk.Notebook): The notebook widget this tab will be part of.
+            label (str): The label for the tab.
+            source_tab (BaseTab): Reference to the source tab for accessing source component settings.
+        """
+        self.type_button = tkinter.StringVar(value='Sphere')
+        self.source_tab = source_tab
+
+        super().__init__(master, label=label)
+        self._setup_combobox()
+        self.setup_widgets()
+
+    def setup_widgets(self) -> NoReturn:
+        """
+        Configures the GUI elements for the Scatterer tab based on the selected scatterer type.
+        """
+        match self.type_button.get():
+            case 'Sphere':
+                self.setup_sphere_widgets()
+            case 'Cylinder':
+                self.setup_cylinder_widgets()
+            case 'CoreShell':
+                self.setup_coreshell_widgets()
+            case _:
+                raise ValueError('Scatterer type not valid')
+
+    def _setup_combobox(self) -> NoReturn:
+        """
+        Sets up a combobox for selecting the type of scatterer. It provides options for Sphere, Cylinder,
+        or CoreShell configurations.
+        """
+        combobox = tkinter.ttk.Combobox(
+            self.frame,
+            textvariable=self.type_button,
+            values=['Sphere', 'Cylinder', 'CoreShell'],
+            state="readonly"
+        )
+
+        combobox.grid(row=0, column=0)
+        combobox.bind("<<ComboboxSelected>>", self.on_type_change)
+
+    def on_type_change(self, event=None) -> NoReturn:
+        """
+        Handles the event triggered by a change in the selected scatterer type. It updates the UI to match
+        the selected scatterer configuration.
+
+        Args:
+            event: The event that triggered this method (default is None).
+        """
+        scatterer_type = self.type_button.get().lower()
+        setup_method = getattr(self, f"setup_{scatterer_type}_widgets", None)
+        self.widget_collection.clear_widgets()
+        if callable(setup_method):
+            setup_method()
+        else:
+            raise ValueError(f"Unsupported scatterer type: {scatterer_type}")
+
+    def setup_sphere_widgets(self) -> NoReturn:
+        """
+        Sets up the configuration widgets for a Sphere scatterer and initializes the component.
+        """
+        self.widget_collection = WidgetCollection(frame=self.frame)
+
+        self.widget_collection.add_widgets(
+            InputWidget(default_value='500', label='Diameter [nm]', component_label='diameter', multiplicative_factor=1e-9, dtype=float),
+            InputWidget(default_value='1.4', label='Refractive Index', component_label='index', dtype=float),
+            InputWidget(default_value='1.0', label='Medium Refractive Index', component_label='medium_index', dtype=float)
+        )
+        self.widget_collection.setup_widgets()
+        self.setup_sphere_component()
+
+    def setup_cylinder_widgets(self) -> NoReturn:
+        """
+        Sets up the configuration widgets for a Cylinder scatterer and initializes the component.
+        """
+        self.widget_collection = WidgetCollection(frame=self.frame)
+
+        self.widget_collection.add_widgets(
+            InputWidget(default_value='1000', label='Diameter [nm]', component_label='diameter', multiplicative_factor=1e-9, dtype=float),
+            InputWidget(default_value='1.4', label='Refractive Index', component_label='index', dtype=complex),
+            InputWidget(default_value='1.0', label='Medium Refractive Index', component_label='medium_index', dtype=float)
+        )
+        self.widget_collection.setup_widgets()
+        self.setup_cylinder_component()
+
+    def setup_coreshell_widgets(self) -> NoReturn:
+        """
+        Sets up the configuration widgets for a CoreShell scatterer and initializes the component.
+        """
+        self.widget_collection = WidgetCollection(frame=self.frame)
+
+        self.widget_collection.add_widgets(
+            InputWidget(default_value='1000', label='Core Diameter [nm]', component_label='core_diameter', multiplicative_factor=1e-9, dtype=float),
+            InputWidget(default_value='200', label='Shell Width [nm]', component_label='shell_width', multiplicative_factor=1e-9, dtype=float),
+            InputWidget(default_value='1.4', label='Core Refractive Index', component_label='core_index', dtype=complex),
+            InputWidget(default_value='1.4', label='Shell Refractive Index', component_label='shell_index', dtype=complex),
+            InputWidget(default_value='1.0', label='Medium Refractive Index', component_label='medium_index', dtype=float)
+        )
+        self.widget_collection.setup_widgets()
+        self.setup_coreshell_component()
+
+    def setup_component(self, event=None) -> NoReturn:
+        """
+        Handles the event triggered by a change in the selected scatterer type. It updates the UI to match
+        the selected scatterer configuration.
+
+        Args:
+            event: The event that triggered this method (default is None).
+        """
+        scatterer_type = self.type_button.get().lower()
+        self.widget_collection.update()
+        setup_method = getattr(self, f"setup_{scatterer_type}_component", None)
+        if callable(setup_method):
+            setup_method()
+        else:
+            raise ValueError(f"Unsupported scatterer type: {scatterer_type}")
+
+    def setup_sphere_component(self) -> NoReturn:
+        self.component = scatterer.Sphere(**self.widget_collection.to_component_dict(), source=self.source_tab.component)
+
+    def setup_cylinder_component(self) -> NoReturn:
+        self.component = scatterer.Cylinder(**self.widget_collection.to_component_dict(), source=self.source_tab.component)
+
+    def setup_coreshell_component(self) -> NoReturn:
+        self.component = scatterer.CoreShell(**self.widget_collection.to_component_dict(), source=self.source_tab.component)
+
+# -
```

## PyMieSim/gui/source_tab.py

 * *Ordering differences only*

```diff
@@ -1,63 +1,63 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-from typing import NoReturn
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.gui.base_tab import BaseTab
-from PyMieSim.gui.widgets import InputWidget
-from PyMieSim.gui.widget_collection import WidgetCollection
-
-
-class SourceTab(BaseTab):
-    """
-    A GUI tab for configuring the light source parameters for simulations in PyMieSim.
-
-    This class provides a user interface for setting up the light source by specifying
-    parameters such as wavelength, polarization, optical power, and numerical aperture (NA).
-    User inputs are used to configure a Gaussian light source in the simulation.
-
-    Attributes:
-        variables (WidgetCollection): A collection of widgets for source configuration.
-    """
-
-    def __init__(self, *args, **kwargs):
-        """
-        Initializes the SourceTab with UI components for source configuration.
-
-        Parameters:
-            *args: Variable length argument list for BaseTab.
-            **kwargs: Arbitrary keyword arguments for BaseTab.
-        """
-        super().__init__(*args, **kwargs)
-        self.setup_widgets()
-
-    def setup_widgets(self) -> NoReturn:
-        """
-        Configures the GUI elements for the Source tab.
-
-        This method sets up labels and entry fields for each source parameter, facilitating
-        user interaction for the configuration of the light source.
-        """
-        self.widget_collection = WidgetCollection(frame=self.frame)
-
-        self.widget_collection.add_widgets(
-            InputWidget(default_value='1310', label='Wavelength [nm]', component_label='wavelength', multiplicative_factor=1e-9, dtype=float),
-            InputWidget(default_value='0', label='Polarization angle [degree]', component_label='polarization_value', dtype=float),
-            InputWidget(default_value='1.0', label='Optical Power [mW] [fix]', component_label='optical_power', multiplicative_factor=1e-3, dtype=float),
-            InputWidget(default_value='0.2', label='Numerical Aperture (NA) [fix]', component_label='NA', dtype=float)
-        )
-
-        self.widget_collection.setup_widgets()
-        self.setup_component()
-
-    def setup_component(self) -> NoReturn:
-        """
-        Initializes the Gaussian source component based on user input.
-
-        This method reads input values from the UI widgets and uses them to configure
-        a Gaussian source component for the simulation.
-        """
-        self.widget_collection.update()
-        self.component = Gaussian(**self.widget_collection.to_component_dict())
-
-# -
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+from typing import NoReturn
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.gui.base_tab import BaseTab
+from PyMieSim.gui.widgets import InputWidget
+from PyMieSim.gui.widget_collection import WidgetCollection
+
+
+class SourceTab(BaseTab):
+    """
+    A GUI tab for configuring the light source parameters for simulations in PyMieSim.
+
+    This class provides a user interface for setting up the light source by specifying
+    parameters such as wavelength, polarization, optical power, and numerical aperture (NA).
+    User inputs are used to configure a Gaussian light source in the simulation.
+
+    Attributes:
+        variables (WidgetCollection): A collection of widgets for source configuration.
+    """
+
+    def __init__(self, *args, **kwargs):
+        """
+        Initializes the SourceTab with UI components for source configuration.
+
+        Parameters:
+            *args: Variable length argument list for BaseTab.
+            **kwargs: Arbitrary keyword arguments for BaseTab.
+        """
+        super().__init__(*args, **kwargs)
+        self.setup_widgets()
+
+    def setup_widgets(self) -> NoReturn:
+        """
+        Configures the GUI elements for the Source tab.
+
+        This method sets up labels and entry fields for each source parameter, facilitating
+        user interaction for the configuration of the light source.
+        """
+        self.widget_collection = WidgetCollection(frame=self.frame)
+
+        self.widget_collection.add_widgets(
+            InputWidget(default_value='1310', label='Wavelength [nm]', component_label='wavelength', multiplicative_factor=1e-9, dtype=float),
+            InputWidget(default_value='0', label='Polarization angle [degree]', component_label='polarization_value', dtype=float),
+            InputWidget(default_value='1.0', label='Optical Power [mW] [fix]', component_label='optical_power', multiplicative_factor=1e-3, dtype=float),
+            InputWidget(default_value='0.2', label='Numerical Aperture (NA) [fix]', component_label='NA', dtype=float)
+        )
+
+        self.widget_collection.setup_widgets()
+        self.setup_component()
+
+    def setup_component(self) -> NoReturn:
+        """
+        Initializes the Gaussian source component based on user input.
+
+        This method reads input values from the UI widgets and uses them to configure
+        a Gaussian source component for the simulation.
+        """
+        self.widget_collection.update()
+        self.component = Gaussian(**self.widget_collection.to_component_dict())
+
+# -
```

## PyMieSim/gui/widget_collection.py

 * *Ordering differences only*

```diff
@@ -1,90 +1,90 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-from typing import NoReturn, Dict
-
-from PyMieSim.gui.widgets import BaseWidget
-
-
-class WidgetCollection:
-    """
-    A collection class for managing multiple Widget instances.
-
-    This class facilitates the grouping of Widget instances, allowing for collective operations like
-    updating widget values, clearing non-permanent widgets, and setting up widgets within a tkinter frame.
-
-    Attributes:
-        widgets (tuple[Widget, ...]): A tuple of Widget instances included in the collection.
-    """
-
-    def __init__(self, frame, *widgets: BaseWidget) -> None:
-        """
-        Initializes a new instance of WidgetCollection with a given set of Widget instances.
-
-        Args:
-            *widgets (Widget): Variable length Widget instances to be included in the collection.
-        """
-        self.frame = frame
-        self.row_start = 0
-
-    def add_widgets(self, *widgets) -> NoReturn:
-        for widget in widgets:
-            widget.frame = self.frame
-
-        self.widgets = widgets
-
-    def to_component_dict(self) -> Dict[str, float | str]:
-        """
-        Creates a dictionary mapping component labels to their respective widget values.
-
-        Returns:
-            dict[str, float | str]: A dictionary where keys are component labels and values are widget values.
-        """
-        return {widget.component_label: widget.get_value() for widget in self.widgets}
-
-    def __getitem__(self, component_label: str) -> BaseWidget:
-        """
-        Allows direct access to a Widget instance in the collection by its component label.
-
-        Args:
-            component_label (str): The component label of the desired Widget.
-
-        Returns:
-            Widget: The Widget instance with the matching component label, if found.
-        """
-        return next((widget for widget in self.widgets if widget.component_label == component_label), None)
-
-    def clear_widgets(self) -> NoReturn:
-        """
-        Clears all non-permanent widgets from the tkinter frame.
-        """
-        for widget in self.widgets:
-            if not widget.is_permanent:
-                widget.destroy()
-                widget.destroy()
-
-    def update(self) -> NoReturn:
-        """
-        Updates the value of all widgets in the collection.
-        """
-        for widget in self.widgets:
-            widget.update()
-
-    def setup_widgets(self, row_start: int = 0) -> NoReturn:
-        """
-        Sets up and packs the widgets within a specified tkinter frame.
-
-        Args:
-            frame (tkinter.Frame): The tkinter frame where widgets are to be packed.
-        """
-        for row, widget in enumerate(self.widgets):
-            widget.setup(row=row + row_start)
-
-    def __repr__(self) -> str:
-        """
-        Returns a string representation of the WidgetCollection instance, listing all widget labels.
-
-        Returns:
-            str: A space-separated string of widget labels.
-        """
-        return " ".join(str(widget) for widget in self.widgets)
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+from typing import NoReturn, Dict
+
+from PyMieSim.gui.widgets import BaseWidget
+
+
+class WidgetCollection:
+    """
+    A collection class for managing multiple Widget instances.
+
+    This class facilitates the grouping of Widget instances, allowing for collective operations like
+    updating widget values, clearing non-permanent widgets, and setting up widgets within a tkinter frame.
+
+    Attributes:
+        widgets (tuple[Widget, ...]): A tuple of Widget instances included in the collection.
+    """
+
+    def __init__(self, frame, *widgets: BaseWidget) -> None:
+        """
+        Initializes a new instance of WidgetCollection with a given set of Widget instances.
+
+        Args:
+            *widgets (Widget): Variable length Widget instances to be included in the collection.
+        """
+        self.frame = frame
+        self.row_start = 0
+
+    def add_widgets(self, *widgets) -> NoReturn:
+        for widget in widgets:
+            widget.frame = self.frame
+
+        self.widgets = widgets
+
+    def to_component_dict(self) -> Dict[str, float | str]:
+        """
+        Creates a dictionary mapping component labels to their respective widget values.
+
+        Returns:
+            dict[str, float | str]: A dictionary where keys are component labels and values are widget values.
+        """
+        return {widget.component_label: widget.get_value() for widget in self.widgets}
+
+    def __getitem__(self, component_label: str) -> BaseWidget:
+        """
+        Allows direct access to a Widget instance in the collection by its component label.
+
+        Args:
+            component_label (str): The component label of the desired Widget.
+
+        Returns:
+            Widget: The Widget instance with the matching component label, if found.
+        """
+        return next((widget for widget in self.widgets if widget.component_label == component_label), None)
+
+    def clear_widgets(self) -> NoReturn:
+        """
+        Clears all non-permanent widgets from the tkinter frame.
+        """
+        for widget in self.widgets:
+            if not widget.is_permanent:
+                widget.destroy()
+                widget.destroy()
+
+    def update(self) -> NoReturn:
+        """
+        Updates the value of all widgets in the collection.
+        """
+        for widget in self.widgets:
+            widget.update()
+
+    def setup_widgets(self, row_start: int = 0) -> NoReturn:
+        """
+        Sets up and packs the widgets within a specified tkinter frame.
+
+        Args:
+            frame (tkinter.Frame): The tkinter frame where widgets are to be packed.
+        """
+        for row, widget in enumerate(self.widgets):
+            widget.setup(row=row + row_start)
+
+    def __repr__(self) -> str:
+        """
+        Returns a string representation of the WidgetCollection instance, listing all widget labels.
+
+        Returns:
+            str: A space-separated string of widget labels.
+        """
+        return " ".join(str(widget) for widget in self.widgets)
```

## PyMieSim/gui/widgets.py

 * *Ordering differences only*

```diff
@@ -1,187 +1,187 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-from typing import NoReturn
-import numpy
-import tkinter
-
-
-class BaseWidget():
-    def __init__(self, label: str, component_label: str, dtype: type = None, is_permanent: bool = False) -> None:
-        """
-        Initializes a new instance of the Widget class.
-        """
-        self.label = label
-        self.component_label = component_label
-        self.dtype = dtype
-        self.is_permanent = is_permanent
-
-    def __repr__(self) -> str:
-        return f"Widget(label={self.label})"
-
-    def destroy(self) -> NoReturn:
-        self.tk_label.destroy()
-        self.tk_widget.destroy()
-
-
-class ComBoxWidget(BaseWidget):
-    """
-    A Widget class that encapsulates a GUI widget with specific properties.
-
-    Attributes:
-        default_value (float | str): The default value for the widget.
-        label (str): A label for the widget used for identification.
-        component_label (str): A label for the component part of the widget.
-        multiplicative_factor (float | None): An optional factor by which the widget's value is multiplied.
-        to_float (bool): A flag indicating whether the input should be converted to float. Defaults to True.
-        is_permanent (bool): A flag indicating if the widget's value is permanent. Defaults to False.
-
-    Methods:
-        update(): Updates the widget's value based on user input.
-        get_input(): Retrieves the current input from the widget.
-        process_input(): Processes the user input, converting it into a float or numpy array as appropriate.
-    """
-
-    def __init__(self, default_options: int = 0, options: list = [], **kwargs) -> None:
-        """
-        Initializes a new instance of the Widget class.
-        """
-        super().__init__(**kwargs)
-        self.default_options = default_options
-        self.value = None
-        self.options = options
-
-    def setup(self, row: int = 0):
-        self.tk_label = tkinter.Label(self.frame, text=self.label)
-        self.tk_widget = tkinter.ttk.Combobox(self.frame, values=self.options)
-        self.tk_widget.current(self.default_options)
-
-        self.tk_widget.grid(row=row, column=1)
-        self.tk_label.grid(row=row, column=0)
-
-    def get_value(self):
-        self.update()
-
-        return self.value
-
-    def update(self) -> None:
-        """
-        Updates the widget's value based on the current user input.
-        """
-        self.value = self.tk_widget.get()
-
-    def get_input(self) -> str:
-        """
-        Retrieves the current input from the tkinter StringVar associated with the widget.
-
-        Returns:
-            str: The current input value as a string.
-        """
-        return self.tk_widget.get()
-
-
-class RadioButtonWidget(BaseWidget):
-
-    def __init__(self, option_text: list, options_values: list, **kwargs):
-        super().__init__(**kwargs)
-        self.option_text = option_text
-        self.tk_variable = tkinter.IntVar()
-        self.options_values = options_values
-
-    def update(self):
-        pass
-
-    def setup(self, row: int):
-        self.tk_label = tkinter.Label(self.frame, text='Coupling mode: ')
-        self.tk_label.grid(row=row, column=0, sticky="W")
-
-        self.tk_widgets = []
-
-        for column, text in enumerate(self.option_text):
-            option = tkinter.Radiobutton(
-                self.frame,
-                text=text,
-                variable=self.tk_variable,
-                value=column,
-            )
-
-            option.grid(row=row, column=column + 1)
-            self.tk_widgets.append(option)
-
-    def destroy(self) -> NoReturn:
-        for widget in self.tk_widgets:
-            widget.destroy()
-
-    def get_value(self):
-        return self.options_values[self.tk_variable.get()]
-
-
-class InputWidget(BaseWidget):
-    """
-    A Widget class that encapsulates a GUI widget with specific properties.
-
-    Attributes:
-        default_value (float | str): The default value for the widget.
-        label (str): A label for the widget used for identification.
-        component_label (str): A label for the component part of the widget.
-        multiplicative_factor (float | None): An optional factor by which the widget's value is multiplied.
-        to_float (bool): A flag indicating whether the input should be converted to float. Defaults to True.
-        is_permanent (bool): A flag indicating if the widget's value is permanent. Defaults to False.
-
-    Methods:
-        update(): Updates the widget's value based on user input.
-        process_input(): Processes the user input, converting it into a float or numpy array as appropriate.
-    """
-
-    def __init__(self, default_value: float | str, multiplicative_factor: float | None = None, **kwargs) -> None:
-        """
-        Initializes a new instance of the Widget class.
-        """
-        super().__init__(**kwargs)
-        self.default_value = default_value
-        self.tk_widget = tkinter.StringVar(value=str(default_value))
-        self.value = None
-        self.multiplicative_factor = multiplicative_factor
-        self.update()
-
-    def setup(self, row: int):
-        self.tk_label = tkinter.Label(self.frame, text=self.label)
-        self.tk_label.grid(row=row + 1, column=0, sticky="W", pady=2)
-        self.tk_widget = tkinter.Entry(self.frame, textvariable=self.tk_widget)
-        self.tk_widget.grid(row=row + 1, column=1, sticky="W", pady=2)
-
-    def get_value(self):
-        self.update()
-
-        return self.value
-
-    def update(self) -> None:
-        """
-        Processes the user input, converting it into a float or numpy array based on the input format.
-
-        Returns:
-            numpy.ndarray | float: The processed input value, either as a float or numpy array.
-        """
-        user_input = self.tk_widget.get()
-        value = numpy.nan  # Default case
-
-        # Handling different input formats
-        if "," in user_input:
-            value = [numpy.nan if p.lower() == 'none' else p.strip() for p in user_input.split(',')]
-        elif ":" in user_input:
-            start, end, points = map(float, user_input.split(':'))
-            value = numpy.linspace(start, end, int(points))
-        else:
-            value = numpy.nan if user_input.lower() == 'none' else user_input
-
-        value = numpy.asarray(value)
-
-        if self.dtype:
-            value = value.astype(self.dtype)
-        if self.multiplicative_factor is not None:
-            value *= self.multiplicative_factor
-
-        self.value = value
-
-
-
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+from typing import NoReturn
+import numpy
+import tkinter
+
+
+class BaseWidget():
+    def __init__(self, label: str, component_label: str, dtype: type = None, is_permanent: bool = False) -> None:
+        """
+        Initializes a new instance of the Widget class.
+        """
+        self.label = label
+        self.component_label = component_label
+        self.dtype = dtype
+        self.is_permanent = is_permanent
+
+    def __repr__(self) -> str:
+        return f"Widget(label={self.label})"
+
+    def destroy(self) -> NoReturn:
+        self.tk_label.destroy()
+        self.tk_widget.destroy()
+
+
+class ComBoxWidget(BaseWidget):
+    """
+    A Widget class that encapsulates a GUI widget with specific properties.
+
+    Attributes:
+        default_value (float | str): The default value for the widget.
+        label (str): A label for the widget used for identification.
+        component_label (str): A label for the component part of the widget.
+        multiplicative_factor (float | None): An optional factor by which the widget's value is multiplied.
+        to_float (bool): A flag indicating whether the input should be converted to float. Defaults to True.
+        is_permanent (bool): A flag indicating if the widget's value is permanent. Defaults to False.
+
+    Methods:
+        update(): Updates the widget's value based on user input.
+        get_input(): Retrieves the current input from the widget.
+        process_input(): Processes the user input, converting it into a float or numpy array as appropriate.
+    """
+
+    def __init__(self, default_options: int = 0, options: list = [], **kwargs) -> None:
+        """
+        Initializes a new instance of the Widget class.
+        """
+        super().__init__(**kwargs)
+        self.default_options = default_options
+        self.value = None
+        self.options = options
+
+    def setup(self, row: int = 0):
+        self.tk_label = tkinter.Label(self.frame, text=self.label)
+        self.tk_widget = tkinter.ttk.Combobox(self.frame, values=self.options)
+        self.tk_widget.current(self.default_options)
+
+        self.tk_widget.grid(row=row, column=1)
+        self.tk_label.grid(row=row, column=0)
+
+    def get_value(self):
+        self.update()
+
+        return self.value
+
+    def update(self) -> None:
+        """
+        Updates the widget's value based on the current user input.
+        """
+        self.value = self.tk_widget.get()
+
+    def get_input(self) -> str:
+        """
+        Retrieves the current input from the tkinter StringVar associated with the widget.
+
+        Returns:
+            str: The current input value as a string.
+        """
+        return self.tk_widget.get()
+
+
+class RadioButtonWidget(BaseWidget):
+
+    def __init__(self, option_text: list, options_values: list, **kwargs):
+        super().__init__(**kwargs)
+        self.option_text = option_text
+        self.tk_variable = tkinter.IntVar()
+        self.options_values = options_values
+
+    def update(self):
+        pass
+
+    def setup(self, row: int):
+        self.tk_label = tkinter.Label(self.frame, text='Coupling mode: ')
+        self.tk_label.grid(row=row, column=0, sticky="W")
+
+        self.tk_widgets = []
+
+        for column, text in enumerate(self.option_text):
+            option = tkinter.Radiobutton(
+                self.frame,
+                text=text,
+                variable=self.tk_variable,
+                value=column,
+            )
+
+            option.grid(row=row, column=column + 1)
+            self.tk_widgets.append(option)
+
+    def destroy(self) -> NoReturn:
+        for widget in self.tk_widgets:
+            widget.destroy()
+
+    def get_value(self):
+        return self.options_values[self.tk_variable.get()]
+
+
+class InputWidget(BaseWidget):
+    """
+    A Widget class that encapsulates a GUI widget with specific properties.
+
+    Attributes:
+        default_value (float | str): The default value for the widget.
+        label (str): A label for the widget used for identification.
+        component_label (str): A label for the component part of the widget.
+        multiplicative_factor (float | None): An optional factor by which the widget's value is multiplied.
+        to_float (bool): A flag indicating whether the input should be converted to float. Defaults to True.
+        is_permanent (bool): A flag indicating if the widget's value is permanent. Defaults to False.
+
+    Methods:
+        update(): Updates the widget's value based on user input.
+        process_input(): Processes the user input, converting it into a float or numpy array as appropriate.
+    """
+
+    def __init__(self, default_value: float | str, multiplicative_factor: float | None = None, **kwargs) -> None:
+        """
+        Initializes a new instance of the Widget class.
+        """
+        super().__init__(**kwargs)
+        self.default_value = default_value
+        self.tk_widget = tkinter.StringVar(value=str(default_value))
+        self.value = None
+        self.multiplicative_factor = multiplicative_factor
+        self.update()
+
+    def setup(self, row: int):
+        self.tk_label = tkinter.Label(self.frame, text=self.label)
+        self.tk_label.grid(row=row + 1, column=0, sticky="W", pady=2)
+        self.tk_widget = tkinter.Entry(self.frame, textvariable=self.tk_widget)
+        self.tk_widget.grid(row=row + 1, column=1, sticky="W", pady=2)
+
+    def get_value(self):
+        self.update()
+
+        return self.value
+
+    def update(self) -> None:
+        """
+        Processes the user input, converting it into a float or numpy array based on the input format.
+
+        Returns:
+            numpy.ndarray | float: The processed input value, either as a float or numpy array.
+        """
+        user_input = self.tk_widget.get()
+        value = numpy.nan  # Default case
+
+        # Handling different input formats
+        if "," in user_input:
+            value = [numpy.nan if p.lower() == 'none' else p.strip() for p in user_input.split(',')]
+        elif ":" in user_input:
+            start, end, points = map(float, user_input.split(':'))
+            value = numpy.linspace(start, end, int(points))
+        else:
+            value = numpy.nan if user_input.lower() == 'none' else user_input
+
+        value = numpy.asarray(value)
+
+        if self.dtype:
+            value = value.astype(self.dtype)
+        if self.multiplicative_factor is not None:
+            value *= self.multiplicative_factor
+
+        self.value = value
+
+
+
```

## PyMieSim/single/__init__.py

 * *Ordering differences only*

```diff
@@ -1,3 +1,3 @@
-from .scatterer import Sphere, CoreShell, Cylinder
-from .source import PlaneWave, Gaussian
+from .scatterer import Sphere, CoreShell, Cylinder
+from .source import PlaneWave, Gaussian
 from .detector import Photodiode, CoherentMode
```

## PyMieSim/single/detector.py

```diff
@@ -1,268 +1,270 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-from __future__ import annotations
-from typing import TYPE_CHECKING
-if TYPE_CHECKING:
-    from PyMieSim.single.scatterer import Sphere, CoreShell, Cylinder
-
-
-import numpy
-import logging
-from dataclasses import dataclass, field
-
-from PyMieSim.single.representations import Footprint
-from PyMieSim.binary.Fibonacci import FibonacciMesh as CPPFibonacciMesh  # has to be imported as extension  # noqa: F401
-from PyMieSim.binary.DetectorInterface import BindedDetector
-from PyMieSim.binary import ModeField
-from PyMieSim.tools.special_functions import NA_to_angle
-from MPSPlots.render3D import SceneList as SceneList3D
-
-
-class GenericDetector():
-    """
-    Base class for different types of detectors with methods for setup, rotation,
-    calculating light coupling, and generating footprint and 3D plots.
-    """
-
-    def __init__(self, **kwargs):
-        """
-        Initialize detector attributes from keyword arguments.
-        """
-        for key, value in kwargs.items():
-            setattr(self, key, value)
-
-    def coupling(self, scatterer: Sphere | CoreShell | Cylinder) -> float:
-        r"""
-        Calculate the light coupling between the detector and a scatterer.
-
-        .. math::
-            |\iint_{\Omega}  \Phi_{det} \,\, \Psi_{scat}^* \,  d \Omega|^2
-
-        | Where:
-        |   :math:`\Phi_{det}` is the capturing field of the detector and
-        |   :math:`\Psi_{scat}` is the scattered field.
-
-        Args:
-            scatterer (Sphere|CoreShell|Cylinder): The scatterer object.
-
-        Returns:
-            float: The coupling in watts.
-        """
-        return getattr(self.cpp_binding, "Coupling" + type(scatterer).__name__)(scatterer.binding)
-
-    def get_footprint(self, scatterer: Sphere | CoreShell | Cylinder) -> Footprint:
-        r"""
-        Generate the footprint of the scattered light coupling with the detector.
-
-        .. math::
-            \big| \mathscr{F}^{-1} \big\{ \tilde{ \psi } (\xi, \nu),\
-                   \tilde{ \phi}_{l,m}(\xi, \nu)  \big\}
-                   (\delta_x, \delta_y) \big|^2
-
-        | Where:
-        |   :math:`\Phi_{det}` is the capturing field of the detector and
-        |   :math:`\Psi_{scat}` is the scattered field.
-
-        Args:
-            scatterer (Sphere|CoreShell|Cylinder): The scatterer object.
-
-        Returns:
-            Footprint: The scatterer footprint with this detector.
-        """
-        return Footprint(scatterer=scatterer, detector=self)
-
-    def plot(self) -> SceneList3D:
-        """
-        Plot the real and imaginary parts of the scattered fields.
-
-        Returns:
-            SceneList3D: The 3D plotting scene containing the field plots.
-        """
-        coordinate = numpy.row_stack((
-            self.cpp_binding.mesh.x,
-            self.cpp_binding.mesh.y,
-            self.cpp_binding.mesh.z
-        ))
-
-        figure = SceneList3D()
-
-        for scalar_type in ['real', 'imag']:
-            scalar = getattr(numpy.asarray(self.cpp_binding.scalar_field), scalar_type)
-
-            ax = figure.append_ax()
-            artist = ax.add_unstructured_mesh(
-                coordinates=coordinate,
-                scalar_coloring=scalar,
-                symmetric_map=True,
-                symmetric_colormap=True
-            )
-
-            ax.add_unit_sphere(opacity=0.3)
-            ax.add_unit_axis(show_label=False)
-            ax.add_colorbar(artist=artist, title=f'field [{scalar_type}]')
-
-        return figure
-
-
-@dataclass
-class Photodiode(GenericDetector):
-    """
-    Detector type class representing a photodiode, light coupling mechanism is non-coherent and thus
-    independent of the phase of the impinging scattered light field.
-    """
-    NA: float
-    """ Numerical aperture of imaging system. """
-    gamma_offset: float
-    """ Angle [Degree] offset of detector in the direction perpendicular to polarization. """
-    phi_offset: float
-    """ Angle [Degree] offset of detector in the direction parallel to polarization. """
-    sampling: int = 200
-    """ Sampling of the farfield distribution """
-    polarization_filter: float = None
-    """ Angle [Degree] of polarization filter in front of detector. """
-    coherent: bool = field(default=False, init=False)
-    """ Indicate if the coupling mechanism is coherent or not """
-    mean_coupling: bool = field(default=False, init=False)
-    """ Indicate if the coupling mechanism is point-wise or mean-wise. Value is either point or mean. """
-    rotation: str = field(default=0, init=False)
-    """ Indicate the rotation of the field in the axis of propagation. """
-
-    def __post_init__(self):
-        self.polarization_filter = numpy.float64(self.polarization_filter)
-
-        self.max_angle = NA_to_angle(NA=self.NA)
-
-        self.cpp_binding = BindedDetector(
-            mode_number='NC00',
-            sampling=self.sampling,
-            NA=self.NA,
-            phi_offset=numpy.deg2rad(self.phi_offset),
-            gamma_offset=numpy.deg2rad(self.gamma_offset),
-            polarization_filter=numpy.deg2rad(self.polarization_filter),
-            rotation=numpy.deg2rad(self.rotation),
-            coherent=self.coherent,
-            mean_coupling=self.mean_coupling
-        )
-
-    def get_structured_scalarfield(self, sampling: int = 100) -> numpy.ndarray:
-        return numpy.ones([sampling, sampling])
-
-
-@dataclass
-class IntegratingSphere(Photodiode):
-    """
-    Detector type class representing a photodiode, light coupling mechanism is non-coherent and thus
-    independent of the phase of the impinging scattered light field.
-    """
-    sampling: int = 200
-    """ Sampling of the farfield distribution """
-    polarization_filter: float = None
-    """ Angle [Degree] of polarization filter in front of detector. """
-    NA: float = field(default=2, init=False)
-    """ Numerical aperture of imaging system. """
-    gamma_offset: float = field(default=0, init=False)
-    """ Angle [Degree] offset of detector in the direction perpendicular to polarization. """
-    phi_offset: float = field(default=0, init=False)
-    """ Angle [Degree] offset of detector in the direction parallel to polarization. """
-    coherent: bool = field(default=False, init=False)
-    """ Indicate if the coupling mechanism is coherent or not """
-    mean_coupling: bool = field(default=False, init=False)
-    """ indicate if the coupling mechanism is point-wise or mean-wise. Value is either point or mean. """
-    rotation: float = field(default=0, init=False)
-    """ Indicate the rotation of the field in the axis of propagation. """
-
-    def __post_init__(self):
-        super().__post_init__()
-
-    def get_structured_scalarfield(self, sampling: int = 100) -> numpy.ndarray:
-        return numpy.ones([sampling, sampling])
-
-
-@dataclass
-class CoherentMode(GenericDetector):
-    """
-    Detector type class representing a laser Hermite-Gauss mode, light coupling mechanism is coherent
-    and thus, dependent of the phase of the impinging scattered light field.
-    """
-    mode_number: str
-    """ String representing the HG mode to be initialized (e.g. 'LP01', 'HG11', 'LG22' etc)"""
-    NA: float
-    """ Numerical aperture of imaging system. """
-    gamma_offset: float
-    """ Angle [Degree] offset of detector in the direction perpendicular to polarization. """
-    phi_offset: float
-    """ Angle [Degree] offset of detector in the direction parallel to polarization. """
-    sampling: int = 200
-    """ Sampling of the farfield distribution """
-    polarization_filter: float = None
-    """ Angle [Degree] of polarization filter in front of detector. """
-    mean_coupling: bool = False
-    """ indicate if the coupling mechanism is point-wise (if setted True) or mean-wise (if setted False). """
-    coherent: bool = field(default=True, init=False)
-    """ Indicate if the coupling mechanism is coherent or not. """
-    rotation: float = 90
-    """ Indicate the rotation of the field in the axis of propagation. """
-
-    def __post_init__(self):
-        if self.NA > 0.3 or self.NA < 0:
-            logging.warning(f"High values of NA: {self.NA} do not comply with the paraxial approximation. Value under 0.3 are prefered.")
-
-        self.mode_family = self.mode_number[:2]
-
-        if self.mode_family.lower() not in ['lp', 'lg', 'hg']:
-            raise ValueError(f'Invalid mode family: {self.mode_family}. Options are ["LP", "LG", "HG"]')
-
-        number_0, number_1 = self.mode_number[2:]
-        self.number_0, self.number_1 = int(number_0), int(number_1)
-
-        match self.mode_family.lower():
-            case 'lp':
-                self.azimuthal_number, self.radial_number = self.number_0, self.number_1
-                self.cpp_mode_field_getter = ModeField.get_LP
-            case 'lg':
-                self.azimuthal_number, self.radial_number = self.number_0, self.number_1
-                self.cpp_mode_field_getter = ModeField.get_LG
-            case 'hg':
-                self.x_number, self.y_number = self.number_0, self.number_1
-                self.cpp_mode_field_getter = ModeField.get_HG
-
-        self.max_angle = NA_to_angle(NA=self.NA)
-
-        self.polarization_filter = numpy.float64(self.polarization_filter)
-
-        self.cpp_binding = BindedDetector(
-            mode_number=self.mode_number,
-            sampling=self.sampling,
-            NA=self.NA,
-            phi_offset=numpy.deg2rad(self.phi_offset),
-            gamma_offset=numpy.deg2rad(self.gamma_offset),
-            polarization_filter=numpy.deg2rad(self.polarization_filter),
-            rotation=numpy.deg2rad(self.rotation),
-            coherent=self.coherent,
-            mean_coupling=self.mean_coupling
-        )
-
-    def get_structured_scalarfield(self, sampling: int = 100) -> numpy.ndarray:
-        x_mesh, y_mesh = numpy.mgrid[-100:100:complex(sampling), -100:100:complex(sampling)]
-
-        coordinates = numpy.row_stack((
-            x_mesh.ravel(),
-            y_mesh.ravel(),
-        ))
-
-        norm = numpy.sqrt(numpy.square(coordinates).sum(axis=0)).max()
-
-        coordinates /= norm
-
-        field = self.cpp_mode_field_getter(
-            coordinates[0],
-            coordinates[1],
-            self.number_0,
-            self.number_1
-        )
-
-        return field.reshape([sampling, sampling])
-
-
-# -
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+from __future__ import annotations
+from typing import TYPE_CHECKING
+if TYPE_CHECKING:
+    from PyMieSim.single.scatterer import Sphere, CoreShell, Cylinder
+
+
+import numpy
+import logging
+from dataclasses import field
+from pydantic.dataclasses import dataclass
+from typing import Union
+
+from PyMieSim.single.representations import Footprint
+from PyMieSim.binary.Fibonacci import FibonacciMesh as CPPFibonacciMesh  # has to be imported as extension  # noqa: F401
+from PyMieSim.binary.DetectorInterface import BindedDetector
+from PyMieSim.binary import ModeField
+from PyMieSim.tools.special_functions import NA_to_angle
+from MPSPlots.render3D import SceneList as SceneList3D
+
+
+class GenericDetector():
+    """
+    Base class for different types of detectors with methods for setup, rotation,
+    calculating light coupling, and generating footprint and 3D plots.
+    """
+
+    def __init__(self, **kwargs):
+        """
+        Initialize detector attributes from keyword arguments.
+        """
+        for key, value in kwargs.items():
+            setattr(self, key, value)
+
+    def coupling(self, scatterer: Sphere | CoreShell | Cylinder) -> float:
+        r"""
+        Calculate the light coupling between the detector and a scatterer.
+
+        .. math::
+            |\iint_{\Omega}  \Phi_{det} \,\, \Psi_{scat}^* \,  d \Omega|^2
+
+        | Where:
+        |   :math:`\Phi_{det}` is the capturing field of the detector and
+        |   :math:`\Psi_{scat}` is the scattered field.
+
+        Args:
+            scatterer (Sphere|CoreShell|Cylinder): The scatterer object.
+
+        Returns:
+            float: The coupling in watts.
+        """
+        return getattr(self.cpp_binding, "Coupling" + type(scatterer).__name__)(scatterer.binding)
+
+    def get_footprint(self, scatterer: Sphere | CoreShell | Cylinder) -> Footprint:
+        r"""
+        Generate the footprint of the scattered light coupling with the detector.
+
+        .. math::
+            \big| \mathscr{F}^{-1} \big\{ \tilde{ \psi } (\xi, \nu),\
+                   \tilde{ \phi}_{l,m}(\xi, \nu)  \big\}
+                   (\delta_x, \delta_y) \big|^2
+
+        | Where:
+        |   :math:`\Phi_{det}` is the capturing field of the detector and
+        |   :math:`\Psi_{scat}` is the scattered field.
+
+        Args:
+            scatterer (Sphere|CoreShell|Cylinder): The scatterer object.
+
+        Returns:
+            Footprint: The scatterer footprint with this detector.
+        """
+        return Footprint(scatterer=scatterer, detector=self)
+
+    def plot(self) -> SceneList3D:
+        """
+        Plot the real and imaginary parts of the scattered fields.
+
+        Returns:
+            SceneList3D: The 3D plotting scene containing the field plots.
+        """
+        coordinate = numpy.row_stack((
+            self.cpp_binding.mesh.x,
+            self.cpp_binding.mesh.y,
+            self.cpp_binding.mesh.z
+        ))
+
+        figure = SceneList3D()
+
+        for scalar_type in ['real', 'imag']:
+            scalar = getattr(numpy.asarray(self.cpp_binding.scalar_field), scalar_type)
+
+            ax = figure.append_ax()
+            artist = ax.add_unstructured_mesh(
+                coordinates=coordinate,
+                scalar_coloring=scalar,
+                symmetric_map=True,
+                symmetric_colormap=True
+            )
+
+            ax.add_unit_sphere(opacity=0.3)
+            ax.add_unit_axis(show_label=False)
+            ax.add_colorbar(artist=artist, title=f'field [{scalar_type}]')
+
+        return figure
+
+
+@dataclass
+class Photodiode(GenericDetector):
+    """
+    Detector type class representing a photodiode, light coupling mechanism is non-coherent and thus
+    independent of the phase of the impinging scattered light field.
+    """
+    NA: float
+    """ Numerical aperture of imaging system. """
+    gamma_offset: float
+    """ Angle [Degree] offset of detector in the direction perpendicular to polarization. """
+    phi_offset: float
+    """ Angle [Degree] offset of detector in the direction parallel to polarization. """
+    sampling: int = 200
+    """ Sampling of the farfield distribution """
+    polarization_filter: Union[float, None] = None
+    """ Angle [Degree] of polarization filter in front of detector. """
+    coherent: bool = field(default=False, init=False)
+    """ Indicate if the coupling mechanism is coherent or not """
+    mean_coupling: bool = field(default=False, init=False)
+    """ Indicate if the coupling mechanism is point-wise or mean-wise. Value is either point or mean. """
+    rotation: str = field(default=0, init=False)
+    """ Indicate the rotation of the field in the axis of propagation. """
+
+    def __post_init__(self):
+        self.polarization_filter = numpy.float64(self.polarization_filter)
+
+        self.max_angle = NA_to_angle(NA=self.NA)
+
+        self.cpp_binding = BindedDetector(
+            mode_number='NC00',
+            sampling=self.sampling,
+            NA=self.NA,
+            phi_offset=numpy.deg2rad(self.phi_offset),
+            gamma_offset=numpy.deg2rad(self.gamma_offset),
+            polarization_filter=numpy.deg2rad(self.polarization_filter),
+            rotation=numpy.deg2rad(self.rotation),
+            coherent=self.coherent,
+            mean_coupling=self.mean_coupling
+        )
+
+    def get_structured_scalarfield(self, sampling: int = 100) -> numpy.ndarray:
+        return numpy.ones([sampling, sampling])
+
+
+@dataclass
+class IntegratingSphere(Photodiode):
+    """
+    Detector type class representing a photodiode, light coupling mechanism is non-coherent and thus
+    independent of the phase of the impinging scattered light field.
+    """
+    sampling: int = 200
+    """ Sampling of the farfield distribution """
+    polarization_filter: Union[float, None] = None
+    """ Angle [Degree] of polarization filter in front of detector. """
+    NA: float = field(default=2, init=False)
+    """ Numerical aperture of imaging system. """
+    gamma_offset: float = field(default=0, init=False)
+    """ Angle [Degree] offset of detector in the direction perpendicular to polarization. """
+    phi_offset: float = field(default=0, init=False)
+    """ Angle [Degree] offset of detector in the direction parallel to polarization. """
+    coherent: bool = field(default=False, init=False)
+    """ Indicate if the coupling mechanism is coherent or not """
+    mean_coupling: bool = field(default=False, init=False)
+    """ indicate if the coupling mechanism is point-wise or mean-wise. Value is either point or mean. """
+    rotation: float = field(default=0, init=False)
+    """ Indicate the rotation of the field in the axis of propagation. """
+
+    def __post_init__(self):
+        super().__post_init__()
+
+    def get_structured_scalarfield(self, sampling: int = 100) -> numpy.ndarray:
+        return numpy.ones([sampling, sampling])
+
+
+@dataclass
+class CoherentMode(GenericDetector):
+    """
+    Detector type class representing a laser Hermite-Gauss mode, light coupling mechanism is coherent
+    and thus, dependent of the phase of the impinging scattered light field.
+    """
+    mode_number: str
+    """ String representing the HG mode to be initialized (e.g. 'LP01', 'HG11', 'LG22' etc)"""
+    NA: float
+    """ Numerical aperture of imaging system. """
+    gamma_offset: float
+    """ Angle [Degree] offset of detector in the direction perpendicular to polarization. """
+    phi_offset: float
+    """ Angle [Degree] offset of detector in the direction parallel to polarization. """
+    sampling: int = 200
+    """ Sampling of the farfield distribution """
+    polarization_filter: Union[float, None] = None
+    """ Angle [Degree] of polarization filter in front of detector. """
+    mean_coupling: bool = False
+    """ indicate if the coupling mechanism is point-wise (if setted True) or mean-wise (if setted False). """
+    coherent: bool = field(default=True, init=False)
+    """ Indicate if the coupling mechanism is coherent or not. """
+    rotation: float = 90
+    """ Indicate the rotation of the field in the axis of propagation. """
+
+    def __post_init__(self):
+        if self.NA > 0.3 or self.NA < 0:
+            logging.warning(f"High values of NA: {self.NA} do not comply with the paraxial approximation. Value under 0.3 are prefered.")
+
+        self.mode_family = self.mode_number[:2]
+
+        if self.mode_family.lower() not in ['lp', 'lg', 'hg']:
+            raise ValueError(f'Invalid mode family: {self.mode_family}. Options are ["LP", "LG", "HG"]')
+
+        number_0, number_1 = self.mode_number[2:]
+        self.number_0, self.number_1 = int(number_0), int(number_1)
+
+        match self.mode_family.lower():
+            case 'lp':
+                self.azimuthal_number, self.radial_number = self.number_0, self.number_1
+                self.cpp_mode_field_getter = ModeField.get_LP
+            case 'lg':
+                self.azimuthal_number, self.radial_number = self.number_0, self.number_1
+                self.cpp_mode_field_getter = ModeField.get_LG
+            case 'hg':
+                self.x_number, self.y_number = self.number_0, self.number_1
+                self.cpp_mode_field_getter = ModeField.get_HG
+
+        self.max_angle = NA_to_angle(NA=self.NA)
+
+        self.polarization_filter = numpy.float64(self.polarization_filter)
+
+        self.cpp_binding = BindedDetector(
+            mode_number=self.mode_number,
+            sampling=self.sampling,
+            NA=self.NA,
+            phi_offset=numpy.deg2rad(self.phi_offset),
+            gamma_offset=numpy.deg2rad(self.gamma_offset),
+            polarization_filter=numpy.deg2rad(self.polarization_filter),
+            rotation=numpy.deg2rad(self.rotation),
+            coherent=self.coherent,
+            mean_coupling=self.mean_coupling
+        )
+
+    def get_structured_scalarfield(self, sampling: int = 100) -> numpy.ndarray:
+        x_mesh, y_mesh = numpy.mgrid[-100:100:complex(sampling), -100:100:complex(sampling)]
+
+        coordinates = numpy.row_stack((
+            x_mesh.ravel(),
+            y_mesh.ravel(),
+        ))
+
+        norm = numpy.sqrt(numpy.square(coordinates).sum(axis=0)).max()
+
+        coordinates /= norm
+
+        field = self.cpp_mode_field_getter(
+            coordinates[0],
+            coordinates[1],
+            self.number_0,
+            self.number_1
+        )
+
+        return field.reshape([sampling, sampling])
+
+
+# -
```

## PyMieSim/single/representations.py

 * *Ordering differences only*

```diff
@@ -1,500 +1,500 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-from __future__ import annotations
-from typing import TYPE_CHECKING
-if TYPE_CHECKING:
-    from PyMieSim.single.scatterer import Sphere, CoreShell, Cylinder
-    from PyMieSim.single.detector import Photodiode, LPmode, IntegratingSphere
-
-
-import numpy
-from MPSPlots.render3D import SceneList as SceneList3D
-from MPSPlots.render2D import SceneList
-from dataclasses import dataclass
-from PyMieSim.tools.special_functions import spherical_to_cartesian, rotate_on_x
-
-
-@dataclass
-class BaseRepresentation():
-    """
-    Base class for scattering representations.
-
-    Attributes:
-        scatterer (Union[Sphere, CoreShell, Cylinder]): The scatterer object, representing the physical scatterer in the simulation.
-        sampling (int): The number of points used for evaluating the Stokes parameters in spherical coordinates (default is 100).
-        distance (float): The distance from the scatterer at which fields are evaluated (default is 1.0).
-
-    Methods:
-        compute_components: A placeholder method intended to be overridden by subclasses for computing specific scattering components.
-    """
-    scatterer: Sphere | CoreShell | Cylinder
-    sampling: int = 100
-    distance: float = 1.0
-
-    def __post_init__(self):
-        fields = self.scatterer.binding.get_full_fields(
-            sampling=self.sampling,
-            r=self.distance
-        )
-
-        self.E_phi, self.E_theta, self.theta, self.phi = fields
-
-        self.compute_components()
-
-    def compute_components(self) -> None:
-        """
-        Placeholder method for computing scattering components. Intended to be overridden by subclasses.
-        """
-        raise NotImplementedError("This method should be implemented by subclasses.")
-
-
-class Stokes(BaseRepresentation):
-    r"""
-    Represents the scattering far-field in the Stokes representation.
-
-    Inherits from BaseRepresentation and calculates the Stokes parameters which describe the polarization state of light.
-
-    The Stokes parameters (I, Q, U, V) are defined according to their conventional definitions, representing the total intensity,
-    difference in intensities between horizontal and vertical polarizations, difference in intensities between two diagonal polarizations,
-    and the right and left circular polarizations, respectively.
-
-    | The stokes parameters are:
-    |     I : intensity of the fields
-    |     Q : linear polarization parallel to incident polarization
-    |     U : linear polarization 45 degree to incident polarization
-    |     V : Circular polarization
-
-    .. math:
-        I &= \big| E_x \big|^2 + \big| E_y \big|^2 \\[10pt]
-
-        Q &= \big| E_x \big|^2 - \big| E_y \big|^2 \\[10pt]
-
-        U &= 2 \mathcal{Re} \big\{ E_x E_y^* \big\} \\[10pt]
-
-        V &= 2 \mathcal{Im} \big\{ E_x E_y^* \big\} \\[10pt]
-
-    Methods:
-        compute_components: Computes the Stokes parameters based on the electric field components.
-        plot: Visualizes the Stokes parameters on a 3D plot.
-
-    """
-
-    def compute_components(self) -> None:
-        """
-        Computes the Stokes parameters (I, Q, U, V) based on the electric field components (E_phi and E_theta).
-
-        The method calculates the normalized intensity (I), linear polarizations (Q and U), and circular polarization (V) of the light
-        scattered by the particle, using the electric field components in spherical coordinates.
-
-        The Stokes parameters are calculated using the following formulas:
-        I = |E_phi|^2 + |E_theta|^2
-        Q = |E_phi|^2 - |E_theta|^2
-        U = 2 * Re{E_phi * E_theta*}
-        V = -2 * Im{E_phi * E_theta*}
-
-        The results are stored as attributes of the instance: I, Q, U, and V.
-        """
-        intensity = numpy.abs(self.E_phi)**2 + numpy.abs(self.E_theta)**2
-
-        self.I = intensity / numpy.max(intensity)  # noqa: E741
-        self.Q = (numpy.abs(self.E_phi)**2 - numpy.abs(self.E_theta)**2) / intensity
-        self.U = (+2 * numpy.real(self.E_phi * self.E_theta.conjugate())) / intensity
-        self.V = (-2 * numpy.imag(self.E_phi * self.E_theta.conjugate())) / intensity
-
-    def plot(self) -> SceneList3D:
-        """
-        Visualizes the Stokes parameters (I, Q, U, V) on a 3D plot.
-
-        Returns:
-            - SceneList3D: An object containing the 3D visualization of the Stokes parameters.
-        """
-
-        phi_mesh, theta_mesh = numpy.meshgrid(self.phi, self.theta)
-
-        x, y, z = spherical_to_cartesian(
-            r=phi_mesh * 0 + 0.5,
-            phi=phi_mesh,
-            theta=theta_mesh
-        )
-
-        figure = SceneList3D()
-
-        for field_name in ['I', 'Q', 'U', 'V']:
-            field = getattr(self, field_name)
-
-            ax = figure.append_ax()
-
-            artist = ax.add_mesh(
-                x=x,
-                y=y,
-                z=z,
-                scalar_coloring=field,
-                colormap='seismic',
-                show_edges=False
-            )
-
-            ax.add_unit_axis(show_label=False)
-            ax.add_colorbar(artist=artist, title=f'{field_name} field')
-
-        return figure
-
-
-class FarField(BaseRepresentation):
-    r"""
-    Represents the scattering far-field in spherical coordinates.
-
-    Inherits from BaseRepresentation and visualizes the far-field pattern characterized by the perpendicular and parallel components
-    of the electric field in spherical coordinates.
-
-    .. math::
-        \text{Fields} = E_{||}(\phi,\theta)^2, E_{\perp}(\phi,\theta)^2
-
-    Methods:
-        compute_components: Calculates the field components. This implementation is a placeholder, as the components are precomputed.
-        plot: Visualizes the far-field pattern in a 3D plot.
-
-    """
-
-    def compute_components(self) -> None:
-        """
-        Placeholder method in FarField class. Does not perform any computation as field components are precomputed.
-
-        This method is intended to be consistent with the structure of BaseRepresentation but does not need to modify or compute
-        any attributes for FarField instances.
-        """
-        return
-
-    def plot(self) -> SceneList3D:
-        """
-        Visualizes the far-field pattern in a 3D plot, representing the squared magnitudes of the parallel and perpendicular components
-        of the electric field in spherical coordinates.
-
-        Returns:
-        - SceneList3D: An object containing the 3D visualization of the far-field pattern.
-        """
-        phi_mesh, theta_mesh = numpy.meshgrid(self.phi, self.theta)
-
-        x, y, z = spherical_to_cartesian(r=phi_mesh * 0 + 0.5, phi=phi_mesh, theta=theta_mesh)
-
-        figure = SceneList3D()
-
-        for field_name in ['phi', 'theta']:
-            field_array = getattr(self, f"E_{field_name}")
-            ax = figure.append_ax()
-
-            artist = ax.add_mesh(
-                x=x,
-                y=y,
-                z=z,
-                scalar_coloring=field_array.real,
-                colormap='seismic',
-                show_edges=False,
-            )
-
-            ax.add_unit_axis(show_label=False)
-            ax.add_colorbar(artist=artist, title=f'{field_name} field [real]')
-
-            if 'phi' in field_name:
-                ax.add_unit_phi_vector(radius=1 / 2)
-            elif 'theta' in field_name:
-                ax.add_unit_theta_vector(radius=1 / 2)
-
-            field_array = getattr(self, f"E_{field_name}")
-            ax = figure.append_ax()
-            artist = ax.add_mesh(
-                x=x,
-                y=y,
-                z=z,
-                scalar_coloring=field_array.imag,
-                colormap='seismic',
-                show_edges=False,
-            )
-
-            ax.add_unit_axis(show_label=False)
-            ax.add_colorbar(artist=artist, title=f'{field_name} field [imag]')
-
-            if 'phi' in field_name:
-                ax.add_unit_phi_vector(radius=1 / 2)
-            elif 'theta' in field_name:
-                ax.add_unit_theta_vector(radius=1 / 2)
-
-        return figure
-
-
-class SPF(BaseRepresentation):
-    r"""
-    Represents the Scattering Phase Function (SPF).
-
-    Inherits from BaseRepresentation and computes the SPF, which is a measure of how light is scattered by a particle at different angles.
-
-    .. math::
-        \text{SPF} = E_{\parallel}(\phi,\theta)^2 + E_{\perp}(\phi,\theta)^2
-
-    Methods:
-        compute_components: Computes the SPF based on the electric field components.
-        plot: Visualizes the SPF on a 3D plot.
-
-    """
-
-    def compute_components(self) -> None:
-        """
-        Computes the Scattering Phase Function (SPF) based on the electric field components (E_phi and E_theta).
-
-        The SPF is calculated as the square root of the sum of the squared magnitudes of the electric field components, representing
-        the total scattering intensity distribution as a function of angles.
-
-        The result is stored as the SPF attribute of the instance.
-        """
-        self.SPF = numpy.sqrt(numpy.abs(self.E_phi)**2 + numpy.abs(self.E_theta)**2)
-
-    def plot(self, log_scale: bool = False) -> SceneList3D:
-        """
-        Visualizes the Scattering Phase Function (SPF) on a 3D plot.
-
-        The method maps the SPF values to radial distances from the origin in spherical coordinates, providing a visual representation
-        of how light is scattered by the particle in different directions.
-
-        Returns:
-        - SceneList3D: An object containing the 3D visualization of the SPF.
-        """
-        scalar_mesh = self.SPF / self.SPF.max() * 2
-
-        if log_scale:
-            scalar_mesh = numpy.log(scalar_mesh)
-
-        phi_mesh, theta_mesh = numpy.meshgrid(self.phi, self.theta)
-
-        x, y, z = spherical_to_cartesian(
-            r=scalar_mesh,
-            phi=phi_mesh,
-            theta=theta_mesh
-        )
-
-        figure = SceneList3D()
-
-        ax = figure.append_ax()
-        artist = ax.add_mesh(
-            x=x,
-            y=y,
-            z=z,
-            scalar_coloring=scalar_mesh,
-            show_edges=False
-        )
-
-        ax.add_unit_axis(show_label=False)
-        ax.add_colorbar(artist=artist, title='Scattering phase function')
-
-        return figure
-
-
-@dataclass
-class S1S2():
-    """
-    Represents the S1 and S2 scattering functions, which are components of the scattering matrix.
-
-    Attributes:
-        scatterer (Union[Sphere, CoreShell, Cylinder]): The scatterer object.
-        sampling (int): Number of points for evaluating the S1 and S2 functions.
-        distance (float): Distance at which the fields are evaluated.
-
-    Methods:
-        compute_components: Computes the S1 and S2 functions based on the scatterer's properties.
-        plot: Visualizes the S1 and S2 functions on a polar plot.
-    """
-    scatterer: Sphere | CoreShell | Cylinder
-    sampling: int = 300
-    distance: float = 1.0
-
-    def __post_init__(self):
-        self.phi = numpy.linspace(-180, 180, self.sampling)
-
-        self.compute_components()
-
-    def compute_components(self) -> None:
-        """
-        Computes the S1 and S2 scattering parameters based on the scatterer's properties and the scattering angle phi.
-
-        S1 and S2 are integral parts of the scattering matrix describing the change in polarization state of light upon scattering.
-
-        The method calculates these parameters for a range of phi angles and stores them as the S1 and S2 attributes of the instance.
-        """
-        self.S1, self.S2 = self.scatterer.binding.get_s1s2(phi=numpy.deg2rad(self.phi) + numpy.pi / 2)
-
-    def plot(self) -> SceneList:
-        """
-        Visualizes the S1 and S2 scattering parameters on a polar plot.
-
-        The method creates two polar plots representing the absolute values of S1 and S2 as functions of the scattering angle phi.
-
-        Returns:
-        - SceneList: An object containing the polar plots of the S1 and S2 parameters.
-        """
-        figure = SceneList(unit_size=(3, 3))
-
-        ax_s1 = figure.append_ax(projection='polar', title=r'S_1 parameter')
-        ax_s2 = figure.append_ax(projection='polar', title=r'S_2 parameter')
-
-        ax_s1.add_fill_line(
-            x=numpy.deg2rad(self.phi),
-            y0=numpy.zeros(self.phi.shape),
-            y1=numpy.abs(self.S1),
-            color='C0',
-            line_style='-'
-        )
-
-        ax_s2.add_fill_line(
-            x=numpy.deg2rad(self.phi),
-            y0=numpy.zeros(self.phi.shape),
-            y1=numpy.abs(self.S2),
-            color='C1',
-            line_style='-'
-        )
-
-        return figure
-
-
-@dataclass
-class Footprint():
-    r"""
-    Represents the footprint of the scatterer as detected by various detectors.
-
-    .. math::
-        \text{Footprint} = \big| \mathscr{F}^{-1} \big\{ \tilde{ \psi }\
-        (\xi, \nu), \tilde{ \phi}_{l,m}(\xi, \nu)  \big\} \
-        (\delta_x, \delta_y) \big|^2
-
-    For more information see references in the
-    `documentation <https://pymiesim.readthedocs.io/en/latest>`_
-    The footprint is defined as:
-
-    Attributes:
-        detector (Union[Photodiode, LPmode, IntegratingSphere]): The detector object.
-        scatterer (Union[Sphere, CoreShell, Cylinder]): The scatterer object.
-        sampling (int): Number of points to evaluate the Stokes parameters in spherical coordinates (default is 500).
-        padding_factor (int): Padding factor for the Fourier transform (default is 20).
-
-    Methods:
-        compute_footprint: Computes the footprint based on the far-field patterns and detector characteristics.
-        plot: Visualizes the computed footprint.
-    """
-    detector: Photodiode | LPmode | IntegratingSphere
-    scatterer: Sphere | CoreShell | Cylinder
-    sampling: int = 200
-    padding_factor: int = 20
-
-    def __post_init__(self):
-        self.compute_footprint()
-
-    def compute_footprint(self):
-        """
-        Computes the footprint of the scatterer as detected by the specified detector.
-
-        The footprint is calculated based on the far-field scattering patterns and the characteristics of the detector,
-        using a Fourier transform to project the far-field onto the detector plane.
-
-        The computed footprint and the corresponding spatial coordinates are stored as attributes of the instance.
-        """
-        max_angle = self.detector.max_angle
-        n_point = complex(self.sampling)
-
-        phi, theta = numpy.mgrid[
-            -max_angle: max_angle: n_point, 0: numpy.pi: n_point
-        ]
-
-        max_distance_direct_space = 1 / (numpy.sin(self.detector.max_angle) * self.scatterer.source.k / (2 * numpy.pi))
-
-        x = y = numpy.linspace(-1, 1, self.sampling) * self.sampling / 2 * max_distance_direct_space / self.padding_factor
-
-        _, phi, theta = rotate_on_x(phi + numpy.pi / 2, theta, numpy.pi / 2)
-
-        far_field_para, far_field_perp = self.scatterer.get_farfields_array(
-            phi=phi.ravel() + numpy.pi / 2,
-            theta=theta.ravel(),
-            r=1.0,
-        )
-
-        detector_structured_farfield = self.detector.get_structured_scalarfield(sampling=self.sampling)
-
-        perpendicular_projection = detector_structured_farfield * far_field_perp.reshape(theta.shape)
-
-        parallel_projection = detector_structured_farfield * far_field_para.reshape(theta.shape)
-
-        fourier_parallel = self.get_fourier_component(parallel_projection)
-        fourier_perpendicular = self.get_fourier_component(perpendicular_projection)
-
-        self.mapping = (fourier_parallel + fourier_perpendicular)
-        self.direct_x = x
-        self.direct_y = y
-
-    def get_fourier_component(self, scalar: numpy.ndarray) -> numpy.ndarray:
-        """
-        Computes the Fourier component of a given scalar field.
-
-        This method performs a two-dimensional inverse Fourier transform on the input scalar field, which represents
-        a projection (either parallel or perpendicular) of the far-field pattern. It then extracts a central portion
-        of the result, effectively applying a padding factor to increase the resolution of the Fourier transform.
-
-        Parameters:
-        - scalar (numpy.ndarray): A two-dimensional numpy array representing the scalar field of which the Fourier component
-          is to be computed. This field could represent either the parallel or perpendicular projection of the far-field
-          pattern onto the detector plane.
-
-        Returns:
-        - numpy.ndarray: A two-dimensional numpy array representing the computed Fourier component. This array is a square
-          section, extracted from the center of the full Fourier transform, with dimensions determined by the original
-          sampling rate and the padding factor of the instance. The values in the array represent the intensity distribution
-          of the light in the detector plane, providing insights into the spatial characteristics of the scattering pattern.
-
-        The method uses numpy's fft module to perform the Fourier transform, applying a padding factor to the input to
-        achieve a higher resolution in the Fourier domain. The resulting Fourier transform is then squared and fftshifted
-        to center the zero-frequency component, and a central portion is extracted to match the intended output size.
-        """
-        # Calculate the target size based on the sampling and padding factor, and the indices for the central portion extraction.
-        total_size = self.sampling * self.padding_factor
-        offset = (total_size - self.sampling) // 2
-
-        # Apply zero-padding to the scalar field to increase the resolution of the Fourier transform.
-        padded_scalar = numpy.pad(scalar, pad_width=((offset, offset), (offset, offset)), mode='constant', constant_values=0)
-
-        # Perform the two-dimensional inverse Fourier transform on the padded scalar field.
-        fourier_transformed = numpy.fft.ifft2(padded_scalar)
-
-        # Compute the squared magnitude and center the zero-frequency component.
-        fourier_magnitude_squared = numpy.abs(numpy.fft.fftshift(fourier_transformed))**2
-
-        # Extract the central portion corresponding to the original sampling rate adjusted by the padding factor.
-        central_portion = fourier_magnitude_squared[offset:-offset, offset:-offset]
-
-        return central_portion
-
-    def plot(self) -> SceneList:
-        """
-        Visualizes the footprint of the scatterer on the detector plane.
-
-        Creates a 2D plot representing the intensity distribution of the scattered light as it would be detected by the specified detector,
-        providing insight into the spatial characteristics of the scattering pattern.
-
-        Returns:
-        - SceneList: An object containing the 2D plot of the scatterer's footprint.
-        """
-        figure = SceneList(unit_size=(6, 6))
-
-        ax = figure.append_ax(
-            title='Scatterer Footprint',
-            x_label=r'Offset distance in X-axis [$\mu$m]',
-            y_label=r'Offset distance in Y-axis [$\mu$m]',
-        )
-
-        artist = ax.add_mesh(
-            x=self.direct_y * 1e6,
-            y=self.direct_x * 1e6,
-            scalar=self.mapping,
-        )
-
-        ax.add_colorbar(artist=artist, colormap='gray')
-
-        return figure
-
-
-# -
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+from __future__ import annotations
+from typing import TYPE_CHECKING
+if TYPE_CHECKING:
+    from PyMieSim.single.scatterer import Sphere, CoreShell, Cylinder
+    from PyMieSim.single.detector import Photodiode, LPmode, IntegratingSphere
+
+
+import numpy
+from MPSPlots.render3D import SceneList as SceneList3D
+from MPSPlots.render2D import SceneList
+from dataclasses import dataclass
+from PyMieSim.tools.special_functions import spherical_to_cartesian, rotate_on_x
+
+
+@dataclass
+class BaseRepresentation():
+    """
+    Base class for scattering representations.
+
+    Attributes:
+        scatterer (Union[Sphere, CoreShell, Cylinder]): The scatterer object, representing the physical scatterer in the simulation.
+        sampling (int): The number of points used for evaluating the Stokes parameters in spherical coordinates (default is 100).
+        distance (float): The distance from the scatterer at which fields are evaluated (default is 1.0).
+
+    Methods:
+        compute_components: A placeholder method intended to be overridden by subclasses for computing specific scattering components.
+    """
+    scatterer: Sphere | CoreShell | Cylinder
+    sampling: int = 100
+    distance: float = 1.0
+
+    def __post_init__(self):
+        fields = self.scatterer.binding.get_full_fields(
+            sampling=self.sampling,
+            r=self.distance
+        )
+
+        self.E_phi, self.E_theta, self.theta, self.phi = fields
+
+        self.compute_components()
+
+    def compute_components(self) -> None:
+        """
+        Placeholder method for computing scattering components. Intended to be overridden by subclasses.
+        """
+        raise NotImplementedError("This method should be implemented by subclasses.")
+
+
+class Stokes(BaseRepresentation):
+    r"""
+    Represents the scattering far-field in the Stokes representation.
+
+    Inherits from BaseRepresentation and calculates the Stokes parameters which describe the polarization state of light.
+
+    The Stokes parameters (I, Q, U, V) are defined according to their conventional definitions, representing the total intensity,
+    difference in intensities between horizontal and vertical polarizations, difference in intensities between two diagonal polarizations,
+    and the right and left circular polarizations, respectively.
+
+    | The stokes parameters are:
+    |     I : intensity of the fields
+    |     Q : linear polarization parallel to incident polarization
+    |     U : linear polarization 45 degree to incident polarization
+    |     V : Circular polarization
+
+    .. math:
+        I &= \big| E_x \big|^2 + \big| E_y \big|^2 \\[10pt]
+
+        Q &= \big| E_x \big|^2 - \big| E_y \big|^2 \\[10pt]
+
+        U &= 2 \mathcal{Re} \big\{ E_x E_y^* \big\} \\[10pt]
+
+        V &= 2 \mathcal{Im} \big\{ E_x E_y^* \big\} \\[10pt]
+
+    Methods:
+        compute_components: Computes the Stokes parameters based on the electric field components.
+        plot: Visualizes the Stokes parameters on a 3D plot.
+
+    """
+
+    def compute_components(self) -> None:
+        """
+        Computes the Stokes parameters (I, Q, U, V) based on the electric field components (E_phi and E_theta).
+
+        The method calculates the normalized intensity (I), linear polarizations (Q and U), and circular polarization (V) of the light
+        scattered by the particle, using the electric field components in spherical coordinates.
+
+        The Stokes parameters are calculated using the following formulas:
+        I = |E_phi|^2 + |E_theta|^2
+        Q = |E_phi|^2 - |E_theta|^2
+        U = 2 * Re{E_phi * E_theta*}
+        V = -2 * Im{E_phi * E_theta*}
+
+        The results are stored as attributes of the instance: I, Q, U, and V.
+        """
+        intensity = numpy.abs(self.E_phi)**2 + numpy.abs(self.E_theta)**2
+
+        self.I = intensity / numpy.max(intensity)  # noqa: E741
+        self.Q = (numpy.abs(self.E_phi)**2 - numpy.abs(self.E_theta)**2) / intensity
+        self.U = (+2 * numpy.real(self.E_phi * self.E_theta.conjugate())) / intensity
+        self.V = (-2 * numpy.imag(self.E_phi * self.E_theta.conjugate())) / intensity
+
+    def plot(self) -> SceneList3D:
+        """
+        Visualizes the Stokes parameters (I, Q, U, V) on a 3D plot.
+
+        Returns:
+            - SceneList3D: An object containing the 3D visualization of the Stokes parameters.
+        """
+
+        phi_mesh, theta_mesh = numpy.meshgrid(self.phi, self.theta)
+
+        x, y, z = spherical_to_cartesian(
+            r=phi_mesh * 0 + 0.5,
+            phi=phi_mesh,
+            theta=theta_mesh
+        )
+
+        figure = SceneList3D()
+
+        for field_name in ['I', 'Q', 'U', 'V']:
+            field = getattr(self, field_name)
+
+            ax = figure.append_ax()
+
+            artist = ax.add_mesh(
+                x=x,
+                y=y,
+                z=z,
+                scalar_coloring=field,
+                colormap='seismic',
+                show_edges=False
+            )
+
+            ax.add_unit_axis(show_label=False)
+            ax.add_colorbar(artist=artist, title=f'{field_name} field')
+
+        return figure
+
+
+class FarField(BaseRepresentation):
+    r"""
+    Represents the scattering far-field in spherical coordinates.
+
+    Inherits from BaseRepresentation and visualizes the far-field pattern characterized by the perpendicular and parallel components
+    of the electric field in spherical coordinates.
+
+    .. math::
+        \text{Fields} = E_{||}(\phi,\theta)^2, E_{\perp}(\phi,\theta)^2
+
+    Methods:
+        compute_components: Calculates the field components. This implementation is a placeholder, as the components are precomputed.
+        plot: Visualizes the far-field pattern in a 3D plot.
+
+    """
+
+    def compute_components(self) -> None:
+        """
+        Placeholder method in FarField class. Does not perform any computation as field components are precomputed.
+
+        This method is intended to be consistent with the structure of BaseRepresentation but does not need to modify or compute
+        any attributes for FarField instances.
+        """
+        return
+
+    def plot(self) -> SceneList3D:
+        """
+        Visualizes the far-field pattern in a 3D plot, representing the squared magnitudes of the parallel and perpendicular components
+        of the electric field in spherical coordinates.
+
+        Returns:
+        - SceneList3D: An object containing the 3D visualization of the far-field pattern.
+        """
+        phi_mesh, theta_mesh = numpy.meshgrid(self.phi, self.theta)
+
+        x, y, z = spherical_to_cartesian(r=phi_mesh * 0 + 0.5, phi=phi_mesh, theta=theta_mesh)
+
+        figure = SceneList3D()
+
+        for field_name in ['phi', 'theta']:
+            field_array = getattr(self, f"E_{field_name}")
+            ax = figure.append_ax()
+
+            artist = ax.add_mesh(
+                x=x,
+                y=y,
+                z=z,
+                scalar_coloring=field_array.real,
+                colormap='seismic',
+                show_edges=False,
+            )
+
+            ax.add_unit_axis(show_label=False)
+            ax.add_colorbar(artist=artist, title=f'{field_name} field [real]')
+
+            if 'phi' in field_name:
+                ax.add_unit_phi_vector(radius=1 / 2)
+            elif 'theta' in field_name:
+                ax.add_unit_theta_vector(radius=1 / 2)
+
+            field_array = getattr(self, f"E_{field_name}")
+            ax = figure.append_ax()
+            artist = ax.add_mesh(
+                x=x,
+                y=y,
+                z=z,
+                scalar_coloring=field_array.imag,
+                colormap='seismic',
+                show_edges=False,
+            )
+
+            ax.add_unit_axis(show_label=False)
+            ax.add_colorbar(artist=artist, title=f'{field_name} field [imag]')
+
+            if 'phi' in field_name:
+                ax.add_unit_phi_vector(radius=1 / 2)
+            elif 'theta' in field_name:
+                ax.add_unit_theta_vector(radius=1 / 2)
+
+        return figure
+
+
+class SPF(BaseRepresentation):
+    r"""
+    Represents the Scattering Phase Function (SPF).
+
+    Inherits from BaseRepresentation and computes the SPF, which is a measure of how light is scattered by a particle at different angles.
+
+    .. math::
+        \text{SPF} = E_{\parallel}(\phi,\theta)^2 + E_{\perp}(\phi,\theta)^2
+
+    Methods:
+        compute_components: Computes the SPF based on the electric field components.
+        plot: Visualizes the SPF on a 3D plot.
+
+    """
+
+    def compute_components(self) -> None:
+        """
+        Computes the Scattering Phase Function (SPF) based on the electric field components (E_phi and E_theta).
+
+        The SPF is calculated as the square root of the sum of the squared magnitudes of the electric field components, representing
+        the total scattering intensity distribution as a function of angles.
+
+        The result is stored as the SPF attribute of the instance.
+        """
+        self.SPF = numpy.sqrt(numpy.abs(self.E_phi)**2 + numpy.abs(self.E_theta)**2)
+
+    def plot(self, log_scale: bool = False) -> SceneList3D:
+        """
+        Visualizes the Scattering Phase Function (SPF) on a 3D plot.
+
+        The method maps the SPF values to radial distances from the origin in spherical coordinates, providing a visual representation
+        of how light is scattered by the particle in different directions.
+
+        Returns:
+        - SceneList3D: An object containing the 3D visualization of the SPF.
+        """
+        scalar_mesh = self.SPF / self.SPF.max() * 2
+
+        if log_scale:
+            scalar_mesh = numpy.log(scalar_mesh)
+
+        phi_mesh, theta_mesh = numpy.meshgrid(self.phi, self.theta)
+
+        x, y, z = spherical_to_cartesian(
+            r=scalar_mesh,
+            phi=phi_mesh,
+            theta=theta_mesh
+        )
+
+        figure = SceneList3D()
+
+        ax = figure.append_ax()
+        artist = ax.add_mesh(
+            x=x,
+            y=y,
+            z=z,
+            scalar_coloring=scalar_mesh,
+            show_edges=False
+        )
+
+        ax.add_unit_axis(show_label=False)
+        ax.add_colorbar(artist=artist, title='Scattering phase function')
+
+        return figure
+
+
+@dataclass
+class S1S2():
+    """
+    Represents the S1 and S2 scattering functions, which are components of the scattering matrix.
+
+    Attributes:
+        scatterer (Union[Sphere, CoreShell, Cylinder]): The scatterer object.
+        sampling (int): Number of points for evaluating the S1 and S2 functions.
+        distance (float): Distance at which the fields are evaluated.
+
+    Methods:
+        compute_components: Computes the S1 and S2 functions based on the scatterer's properties.
+        plot: Visualizes the S1 and S2 functions on a polar plot.
+    """
+    scatterer: Sphere | CoreShell | Cylinder
+    sampling: int = 300
+    distance: float = 1.0
+
+    def __post_init__(self):
+        self.phi = numpy.linspace(-180, 180, self.sampling)
+
+        self.compute_components()
+
+    def compute_components(self) -> None:
+        """
+        Computes the S1 and S2 scattering parameters based on the scatterer's properties and the scattering angle phi.
+
+        S1 and S2 are integral parts of the scattering matrix describing the change in polarization state of light upon scattering.
+
+        The method calculates these parameters for a range of phi angles and stores them as the S1 and S2 attributes of the instance.
+        """
+        self.S1, self.S2 = self.scatterer.binding.get_s1s2(phi=numpy.deg2rad(self.phi) + numpy.pi / 2)
+
+    def plot(self) -> SceneList:
+        """
+        Visualizes the S1 and S2 scattering parameters on a polar plot.
+
+        The method creates two polar plots representing the absolute values of S1 and S2 as functions of the scattering angle phi.
+
+        Returns:
+        - SceneList: An object containing the polar plots of the S1 and S2 parameters.
+        """
+        figure = SceneList(unit_size=(3, 3))
+
+        ax_s1 = figure.append_ax(projection='polar', title=r'S_1 parameter')
+        ax_s2 = figure.append_ax(projection='polar', title=r'S_2 parameter')
+
+        ax_s1.add_fill_line(
+            x=numpy.deg2rad(self.phi),
+            y0=numpy.zeros(self.phi.shape),
+            y1=numpy.abs(self.S1),
+            color='C0',
+            line_style='-'
+        )
+
+        ax_s2.add_fill_line(
+            x=numpy.deg2rad(self.phi),
+            y0=numpy.zeros(self.phi.shape),
+            y1=numpy.abs(self.S2),
+            color='C1',
+            line_style='-'
+        )
+
+        return figure
+
+
+@dataclass
+class Footprint():
+    r"""
+    Represents the footprint of the scatterer as detected by various detectors.
+
+    .. math::
+        \text{Footprint} = \big| \mathscr{F}^{-1} \big\{ \tilde{ \psi }\
+        (\xi, \nu), \tilde{ \phi}_{l,m}(\xi, \nu)  \big\} \
+        (\delta_x, \delta_y) \big|^2
+
+    For more information see references in the
+    `documentation <https://pymiesim.readthedocs.io/en/latest>`_
+    The footprint is defined as:
+
+    Attributes:
+        detector (Union[Photodiode, LPmode, IntegratingSphere]): The detector object.
+        scatterer (Union[Sphere, CoreShell, Cylinder]): The scatterer object.
+        sampling (int): Number of points to evaluate the Stokes parameters in spherical coordinates (default is 500).
+        padding_factor (int): Padding factor for the Fourier transform (default is 20).
+
+    Methods:
+        compute_footprint: Computes the footprint based on the far-field patterns and detector characteristics.
+        plot: Visualizes the computed footprint.
+    """
+    detector: Photodiode | LPmode | IntegratingSphere
+    scatterer: Sphere | CoreShell | Cylinder
+    sampling: int = 200
+    padding_factor: int = 20
+
+    def __post_init__(self):
+        self.compute_footprint()
+
+    def compute_footprint(self):
+        """
+        Computes the footprint of the scatterer as detected by the specified detector.
+
+        The footprint is calculated based on the far-field scattering patterns and the characteristics of the detector,
+        using a Fourier transform to project the far-field onto the detector plane.
+
+        The computed footprint and the corresponding spatial coordinates are stored as attributes of the instance.
+        """
+        max_angle = self.detector.max_angle
+        n_point = complex(self.sampling)
+
+        phi, theta = numpy.mgrid[
+            -max_angle: max_angle: n_point, 0: numpy.pi: n_point
+        ]
+
+        max_distance_direct_space = 1 / (numpy.sin(self.detector.max_angle) * self.scatterer.source.k / (2 * numpy.pi))
+
+        x = y = numpy.linspace(-1, 1, self.sampling) * self.sampling / 2 * max_distance_direct_space / self.padding_factor
+
+        _, phi, theta = rotate_on_x(phi + numpy.pi / 2, theta, numpy.pi / 2)
+
+        far_field_para, far_field_perp = self.scatterer.get_farfields_array(
+            phi=phi.ravel() + numpy.pi / 2,
+            theta=theta.ravel(),
+            r=1.0,
+        )
+
+        detector_structured_farfield = self.detector.get_structured_scalarfield(sampling=self.sampling)
+
+        perpendicular_projection = detector_structured_farfield * far_field_perp.reshape(theta.shape)
+
+        parallel_projection = detector_structured_farfield * far_field_para.reshape(theta.shape)
+
+        fourier_parallel = self.get_fourier_component(parallel_projection)
+        fourier_perpendicular = self.get_fourier_component(perpendicular_projection)
+
+        self.mapping = (fourier_parallel + fourier_perpendicular)
+        self.direct_x = x
+        self.direct_y = y
+
+    def get_fourier_component(self, scalar: numpy.ndarray) -> numpy.ndarray:
+        """
+        Computes the Fourier component of a given scalar field.
+
+        This method performs a two-dimensional inverse Fourier transform on the input scalar field, which represents
+        a projection (either parallel or perpendicular) of the far-field pattern. It then extracts a central portion
+        of the result, effectively applying a padding factor to increase the resolution of the Fourier transform.
+
+        Parameters:
+        - scalar (numpy.ndarray): A two-dimensional numpy array representing the scalar field of which the Fourier component
+          is to be computed. This field could represent either the parallel or perpendicular projection of the far-field
+          pattern onto the detector plane.
+
+        Returns:
+        - numpy.ndarray: A two-dimensional numpy array representing the computed Fourier component. This array is a square
+          section, extracted from the center of the full Fourier transform, with dimensions determined by the original
+          sampling rate and the padding factor of the instance. The values in the array represent the intensity distribution
+          of the light in the detector plane, providing insights into the spatial characteristics of the scattering pattern.
+
+        The method uses numpy's fft module to perform the Fourier transform, applying a padding factor to the input to
+        achieve a higher resolution in the Fourier domain. The resulting Fourier transform is then squared and fftshifted
+        to center the zero-frequency component, and a central portion is extracted to match the intended output size.
+        """
+        # Calculate the target size based on the sampling and padding factor, and the indices for the central portion extraction.
+        total_size = self.sampling * self.padding_factor
+        offset = (total_size - self.sampling) // 2
+
+        # Apply zero-padding to the scalar field to increase the resolution of the Fourier transform.
+        padded_scalar = numpy.pad(scalar, pad_width=((offset, offset), (offset, offset)), mode='constant', constant_values=0)
+
+        # Perform the two-dimensional inverse Fourier transform on the padded scalar field.
+        fourier_transformed = numpy.fft.ifft2(padded_scalar)
+
+        # Compute the squared magnitude and center the zero-frequency component.
+        fourier_magnitude_squared = numpy.abs(numpy.fft.fftshift(fourier_transformed))**2
+
+        # Extract the central portion corresponding to the original sampling rate adjusted by the padding factor.
+        central_portion = fourier_magnitude_squared[offset:-offset, offset:-offset]
+
+        return central_portion
+
+    def plot(self) -> SceneList:
+        """
+        Visualizes the footprint of the scatterer on the detector plane.
+
+        Creates a 2D plot representing the intensity distribution of the scattered light as it would be detected by the specified detector,
+        providing insight into the spatial characteristics of the scattering pattern.
+
+        Returns:
+        - SceneList: An object containing the 2D plot of the scatterer's footprint.
+        """
+        figure = SceneList(unit_size=(6, 6))
+
+        ax = figure.append_ax(
+            title='Scatterer Footprint',
+            x_label=r'Offset distance in X-axis [$\mu$m]',
+            y_label=r'Offset distance in Y-axis [$\mu$m]',
+        )
+
+        artist = ax.add_mesh(
+            x=self.direct_y * 1e6,
+            y=self.direct_x * 1e6,
+            scalar=self.mapping,
+        )
+
+        ax.add_colorbar(artist=artist, colormap='gray')
+
+        return figure
+
+
+# -
```

## PyMieSim/single/scatterer.py

 * *Ordering differences only*

```diff
@@ -1,613 +1,613 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-from __future__ import annotations
-from typing import TYPE_CHECKING
-if TYPE_CHECKING:
-    from PyOptik import DataMeasurement, Sellmeier
-
-import numpy
-import logging
-from dataclasses import dataclass
-from tabulate import tabulate
-
-
-from PyMieSim.mesh import FibonacciMesh
-from PyMieSim.single.source import PlaneWave, Gaussian
-from PyMieSim.single.representations import S1S2, FarField, Stokes, SPF, Footprint
-
-c = 299792458.0  #: Speed of light in vacuum (m/s).
-epsilon0 = 8.854187817620389e-12  #: Vacuum permittivity (F/m).
-
-
-class GenericScatterer():
-    """
-    Generic class for scatterer
-    """
-    def print_properties(self) -> None:
-        property_names = [
-            "size_parameter", "area", "index", "Qsca", "Qext",
-            "Qabs", "Qback", "Qratio", "Qpr", "Csca",
-            "Cext", "Cabs", "Cback", "Cratio", "Cpr", "g",
-        ]
-
-        data = [getattr(self, name) for name in property_names]
-        property_dict = {"Property": property_names, "value": data}
-
-        table = tabulate(
-            property_dict,
-            headers="keys"
-        )
-        print(table)
-
-    @property
-    def size_parameter(self) -> float:
-        return self.binding.size_parameter
-
-    @property
-    def area(self) -> float:
-        return self.binding.area
-
-    @property
-    def Qsca(self) -> float:
-        """ Scattering efficiency. """
-        return self.binding.Qsca
-
-    @property
-    def Qext(self) -> float:
-        """ Extinction efficiency. """
-        return self.binding.Qext
-
-    @property
-    def Qabs(self) -> float:
-        """ Absorption efficiency. """
-        return self.binding.Qabs
-
-    @property
-    def Qback(self) -> float:
-        """ Backscattering efficiency. """
-        return self.binding.Qback
-
-    @property
-    def Qratio(self) -> float:
-        """ Efficiency: Ratio of backscattering over total scattering. """
-        return self.binding.Qback / self.binding.Qsca
-
-    @property
-    def g(self) -> float:
-        """ Anisotropy factor. """
-        return self.binding.g
-
-    @property
-    def Qpr(self) -> float:
-        """ Radiation pressure efficiency. """
-        return self.binding.Qpr
-
-    @property
-    def Csca(self) -> float:
-        """ Scattering cross-section. """
-        return self.binding.Csca
-
-    @property
-    def Cext(self) -> float:
-        """ Extinction cross-section. """
-        return self.binding.Cext
-
-    @property
-    def Cabs(self) -> float:
-        """ Absorption cross-section. """
-        return self.binding.Cabs
-
-    @property
-    def Cpr(self) -> float:
-        """ Radiation pressure cross-section. """
-        return self.binding.Cpr
-
-    @property
-    def Cback(self) -> float:
-        """ Backscattering cross-section. """
-        return self.binding.Cback
-
-    @property
-    def Cratio(self) -> float:
-        """ Ratio of backscattering cross-section over total scattering. """
-        return self.binding.Cback / self.binding.Csca
-
-    def get_farfields_array(self, phi: numpy.ndarray, theta: numpy.ndarray, r: numpy.ndarray) -> numpy.array:
-        r"""
-        Method Compute scattering Far Field for unstructured coordinate.
-
-        .. math::
-            \text{Fields} = E_{||}(\phi,\theta), E_{\perp}(\phi,\theta)
-
-
-        The Fields are up to a constant phase value.
-
-        .. math::
-            \exp{\big(-i k r \big)}
-
-        :param      phi:         The phi array
-        :type       phi:         numpy.ndarray
-        :param      theta:       The theta array
-        :type       theta:       numpy.ndarray
-        :param      r:           The radial array
-        :type       r:           numpy.ndarray
-        :param      structured:  Indicates if computing mesh is structured or not
-        :type       structured:  bool
-
-        :returns:   The far fields
-        :rtype:     numpy.ndarray
-        """
-        return self.binding.get_fields(phi=phi, theta=theta, r=r)
-
-    def get_s1s2(self, **kwargs) -> S1S2:
-        r"""
-        Method compute :math:`S_1(\phi)` and :math:`S_2(\phi)`.
-        For spherical Scatterer such as here S1 and S2 are computed as follow:
-
-        .. math::
-            S_1=\sum\limits_{n=1}^{n_{max}} \frac{2n+1}{n(n+1)}(a_n \pi_n+b_n \tau_n) \\[10pt]
-
-            S_2=\sum\limits_{n=1}^{n_{max}}\frac{2n+1}{n(n+1)}(a_n \tau_n+b_n \pi_n) \\[10pt]
-
-        :param      kwargs:  The keywords arguments
-        :type       kwargs:  dictionary
-
-        :returns:   The S1 and S2 parameters
-        :rtype:     S1S2
-        """
-        return S1S2(scatterer=self, **kwargs)
-
-    def get_stokes(self, **kwargs) -> Stokes:
-        r"""
-        Returns the four Stokes components. The method compute the Stokes parameters: I, Q, U, V.
-        Those parameters are defined as:
-
-        .. math:
-            I &= \big| E_x \big|^2 + \big| E_y \big|^2 \\[10pt]
-
-            Q &= \big| E_x \big|^2 - \big| E_y \big|^2 \\[10pt]
-
-            U &= 2 \mathcal{Re} \big\{ E_x E_y^* \big\} \\[10pt]
-
-            V &= 2 \mathcal{Im} \big\{ E_x E_y^* \big\} \\[10pt]
-
-        :param      kwargs:  The keywords arguments
-        :type       kwargs:  dictionary
-
-        :returns:   The stokes.
-        :rtype:     Stokes
-        """
-        return Stokes(scatterer=self, **kwargs)
-
-    def get_far_field(self, **kwargs) -> FarField:
-        r"""
-        Returns the scattering far-fields defined as.
-
-        .. math::
-            \text{Fields} = E_{||}(\phi,\theta)^2, E_{\perp}(\phi,\theta)^2
-
-
-        The Fields are up to a constant phase value:
-
-        .. math::
-            \exp{\big(-i k r \big)}
-
-        :param      kwargs:  The keywords arguments
-        :type       kwargs:  dictionary
-
-        :returns:   The far field.
-        :rtype:     FarField
-        """
-        return FarField(scatterer=self, **kwargs)
-
-    def get_spf(self, **kwargs) -> SPF:
-        r"""
-        Returns the scattering phase function.
-
-        .. math::
-            \text{SPF} = \sqrt{ E_{\parallel}(\phi,\theta)^2
-            + E_{\perp}(\phi,\theta)^2 }
-
-        :param      kwargs:  The keywords arguments
-        :type       kwargs:  dictionary
-
-        :returns:   The scattering phase function.
-        :rtype:     SPF
-        """
-        return SPF(scatterer=self, **kwargs)
-
-    def get_footprint(self, detector) -> Footprint:
-        r"""
-        Return the footprint of the scattererd light coupling with the
-        detector as computed as:
-
-        .. math::
-            \big| \mathscr{F}^{-1} \big\{ \tilde{ \psi } (\xi, \nu),\
-                   \tilde{ \phi}_{l,m}(\xi, \nu)  \big\}
-                   (\delta_x, \delta_y) \big|^2
-
-        | Where:
-        |   :math:`\Phi_{det}` is the capturing field of the detector and
-        |   :math:`\Psi_{scat}` is the scattered field.
-
-        :param      detector:  The detector
-        :type       detector:  GenericDetector
-
-        :returns:   The scatterer footprint.
-        :rtype:     Footprint
-        """
-        return Footprint(scatterer=self, detector=detector)
-
-    def get_poynting_vector(self, mesh: FibonacciMesh) -> float:
-        r"""
-
-        Method return the Poynting vector norm defined as:
-
-        .. math::
-            \vec{S} = \epsilon c^2 \vec{E} \times \vec{B}
-
-        Parameters :
-            Mesh : Number of voxel in the 4 pi space to compute energy flow.
-
-        """
-        Ephi, Etheta = self.get_farfields_array(phi=mesh.phi, theta=mesh.theta, r=1.)
-
-        E_norm = numpy.sqrt(numpy.abs(Ephi)**2 + numpy.abs(Etheta)**2)
-
-        B_norm = E_norm / c
-
-        poynting = epsilon0 * c**2 * E_norm * B_norm
-
-        return poynting
-
-    def get_energy_flow(self, mesh: FibonacciMesh) -> float:
-        r"""
-        Returns energy flow defined as:
-
-        .. math::
-            W_a &= \sigma_{sca} * I_{inc} \\[10pt]
-            P &= \int_{A} I dA \\[10pt]
-            I &= \frac{c n \epsilon_0}{2} |E|^2 \\[10pt]
-
-        | With:
-        |     I : Energy density
-        |     n  : Refractive index of the medium
-        |     :math:`\epsilon_0` : Vaccum permitivity
-        |     E  : Electric field
-        |     \sigma_{sca}: Scattering cross section.
-
-        More info on wikipedia link (see ref[6]).
-
-        :param      Mesh:  The mesh
-        :type       Mesh:  FibonacciMesh
-
-        :returns:   The energy flow.
-        :rtype:     float
-        """
-        Poynting = self.get_poynting_vector(mesh)
-
-        total_power = 0.5 * numpy.sum(Poynting) * mesh.d_omega
-
-        return total_power
-
-    def get_cross_section(self):
-        return (self.Qsca * self.area)  # similar to self.EnergyFlow(Mesh) / self.source.I
-
-    def _assign_index_or_material(self, index, material) -> tuple:
-        assert bool(index) ^ bool(material), logging.error("Exactly one of the parameter [index or Material] have to be assigned.")
-        index = index if index is not None else material.get_refractive_index(self.source.wavelength)
-        material = material if material is not None else None
-
-        if not numpy.isscalar(index) and len(index) == 1:
-            return index[0], material
-
-        return index, material
-
-
-@dataclass()
-class Sphere(GenericScatterer):
-    """ Class representing a homogeneous spherical scatterer """
-    diameter: float
-    """ diameter of the single scatterer in unit of meter. """
-    source: PlaneWave | Gaussian
-    """ Light source object containing info on polarization and wavelength. """
-    index: complex = None
-    """ Refractive index of scatterer. """
-    medium_index: float = 1.0
-    """ Refractive index of scatterer medium. """
-    material: DataMeasurement | Sellmeier | None = None
-    """ Material of which the scatterer is made of. Only if index is not specified. """
-
-    def __post_init__(self):
-        self.index, self.material = self._assign_index_or_material(self.index, self.material)
-
-        self.set_cpp_binding()
-
-    def set_cpp_binding(self) -> None:
-        """
-        Method call and bind c++ scatterer class
-
-        """
-        from PyMieSim.binary.SphereInterface import SPHERE
-
-        self.binding = SPHERE(
-            wavelength=self.source.wavelength,
-            amplitude=self.source.amplitude,
-            diameter=self.diameter,
-            index=self.index,
-            medium_index=self.medium_index,
-            jones_vector=self.source.polarization.jones_vector.squeeze(),
-        )
-
-    def an(self, max_order: int = None) -> numpy.array:
-        r"""
-        Compute :math:`a_n` coefficient as defined in Eq:III.88 of B&B:
-
-        .. math::
-            a_n = \frac{
-            \mu_{sp} \Psi_n(\alpha) \Psi_n^\prime(\beta) -
-            \mu M \Psi_n^\prime(\alpha) \Psi_n(\beta)}
-            {\mu_{sp} \xi_n(\alpha) \Psi_n^\prime(\beta)-
-            \mu M \xi_n^\prime (\alpha) \Psi_n(\beta)}
-
-        With :math:`M = \frac{k_{sp}}{k}` (Eq:I.103)
-        """
-        return self.binding.an()
-
-    def bn(self, max_order: int = None) -> numpy.array:
-        r"""
-        Compute :math:`b_n` coefficient as defined in Eq:III.89 of B&B:
-
-        .. math::
-            b_n = \frac{
-            \mu M \Psi_n(\alpha) \Psi_n^\prime(\beta) -
-            \mu_{sp} \Psi_n^\prime(\alpha) \Psi_n(\beta)}
-            {\mu M \xi_n(\alpha) \Psi_n^\prime(\beta)-
-            \mu_{sp} \xi_n^\prime (\alpha) \Psi_n(\beta)}
-
-        With :math:`M = \frac{k_{sp}}{k}` (Eq:I.103)
-        """
-        return self.binding.bn()
-
-    def cn(self, max_order: int = None) -> numpy.array:
-        r"""
-        Compute :math:`c_n` coefficient as defined in Eq:III.90 of B&B:
-
-        .. math::
-            c_n = \frac{
-            \mu_{sp} M \big[ \xi_n(\alpha) \Psi_n^\prime(\alpha) -
-            \xi_n^\prime(\alpha) \Psi_n(\alpha) \big]}
-            {\mu_{sp} \xi_n(\alpha) \Psi_n^\prime(\beta)-
-            \mu M \xi_n^\prime (\alpha) \Psi_n(\beta)}
-
-        With :math:`M = \frac{k_{sp}}{k}` (Eq:I.103)
-        """
-        return self.binding.cn()
-
-    def dn(self, max_order: int = None) -> numpy.array:
-        r"""
-        Compute :math:`d_n` coefficient as defined in Eq:III.91 of B&B:
-
-        .. math::
-            d_n = \frac{
-            \mu M^2 \big[ \xi_n(\alpha) \Psi_n^\prime(\alpha) -
-            \xi_n^\prime(\alpha) \Psi_n(\alpha) \big]}
-            {\mu M \xi_n(\alpha) \Psi_n^\prime(\beta)-
-            \mu_{sp} M \xi_n^\prime (\alpha) \Psi_n(\beta)}
-
-        With :math:`M = \frac{k_{sp}}{k}` (Eq:I.103)
-        """
-        return self.binding.dn()
-
-
-@dataclass()
-class CoreShell(GenericScatterer):
-    """
-    Class representing a core/shell spherical scatterer.
-    """
-
-    core_diameter: float
-    """ diameter of the core of the single scatterer [m]. """
-    shell_width: float
-    """ diameter of the shell of the single scatterer [m]. """
-    source: PlaneWave | Gaussian
-    """ Light source object containing info on polarization and wavelength. """
-    core_index: complex = None
-    """ Refractive index of the core of the scatterer. """
-    shell_index: complex = None
-    """ Refractive index of the shell of the scatterer. """
-    core_material: DataMeasurement | Sellmeier | None = None
-    """ Core material of which the scatterer is made of. Only if core_index is not specified.  """
-    shell_material: DataMeasurement | Sellmeier | None = None
-    """ Shell material of which the scatterer is made of. Only if shell_index is not specified.  """
-    medium_index: float = 1.0
-    """ Refractive index of scatterer medium. """
-
-    def __post_init__(self):
-        self.core_index, self.core_material = self._assign_index_or_material(self.core_index, self.core_material)
-
-        self.shell_index, self.shell_material = self._assign_index_or_material(self.shell_index, self.shell_material)
-
-        self.shell_diameter = self.core_diameter + self.shell_width
-
-        self.set_cpp_binding()
-
-    def set_cpp_binding(self) -> None:
-        """
-        Method call and bind c++ scatterer class
-        """
-        from PyMieSim.binary.CoreShellInterface import CORESHELL
-
-        self.binding = CORESHELL(
-            shell_index=self.shell_index,
-            core_index=self.core_index,
-            shell_width=self.shell_width,
-            core_diameter=self.core_diameter,
-            wavelength=self.source.wavelength,
-            medium_index=self.medium_index,
-            jones_vector=self.source.polarization.jones_vector.squeeze(),
-            amplitude=self.source.amplitude
-        )
-
-    def an(self, max_order: int = None) -> numpy.array:
-        r"""
-        Compute :math:`a_n` coefficient
-        """
-        if max_order is None:
-            return self.binding.an()
-        else:
-            return self.binding._an(max_order)
-
-    def bn(self, max_order: int = None) -> numpy.array:
-        r"""
-        Compute :math:`b_n` coefficient.
-        """
-        if max_order is None:
-            return self.binding.bn()
-        else:
-            return self.binding._bn(max_order)
-
-
-@dataclass()
-class Cylinder(GenericScatterer):
-    """
-    Class representing a right angle cylindrical scatterer.
-    """
-
-    diameter: float
-    """ diameter of the single scatterer in unit of meter. """
-    source: PlaneWave | Gaussian
-    """ Light source object containing info on polarization and wavelength. """
-    index: complex = None
-    """ Refractive index of scatterer. """
-    medium_index: float = 1.0
-    """ Material of which the scatterer is made of. Only if index is not specified. """
-    material: DataMeasurement | Sellmeier | None = None
-    """ Refractive index of scatterer medium. """
-
-    def __post_init__(self):
-        self.index, self.material = self._assign_index_or_material(
-            index=self.index,
-            material=self.material
-        )
-
-        self.set_cpp_binding()
-
-    def set_cpp_binding(self) -> None:
-        """
-        Binds the Python representation of the cylinder to its C++ counterpart using provided properties.
-        """
-        from PyMieSim.binary.CylinderInterface import CYLINDER
-
-        self.binding = CYLINDER(
-            index=self.index,
-            diameter=self.diameter,
-            wavelength=self.source.wavelength,
-            medium_index=self.medium_index,
-            amplitude=self.source.amplitude,
-            jones_vector=self.source.polarization.jones_vector.squeeze()
-        )
-
-    def a1n(self, max_order: int = None) -> numpy.array:
-        r"""
-        Compute :math:`a_n` coefficient as defined ref[5]:
-
-        .. math::
-            a_n = \frac{ m_t J_n(m_t x) J_n^\prime (m x) - m J_n^\prime (m_t x) J_n(m x) }
-            { m_t J_n(m_t x) H_n^\prime (m x) - m J_n^\prime (m_t x) H_n(m x) }
-
-        | With :math:`m` being the refractive index of the medium and
-        |      :math:`m_t` being the refractive index of the index.
-
-        :param      max_order:  The maximum order
-        :type       max_order:  int
-
-        :returns:   The first electric mutlipole amplitude
-        :rtype:     numpy.array
-        """
-        return self.binding.a1n()
-
-    def a2n(self, max_order: int = None) -> numpy.array:
-        r"""
-        Compute :math:`a_n` coefficient as defined ref[5]:
-
-        .. math::
-            a_n = \frac{ m_t J_n(m_t x) J_n^\prime (m x) - m J_n^\prime (m_t x) J_n(m x) }
-            { m_t J_n(m_t x) H_n^\prime (m x) - m J_n^\prime (m_t x) H_n(m x) }
-
-        | With :math:`m` being the refractive index of the medium and
-        |      :math:`m_t` being the refractive index of the index.
-
-        :param      max_order:  The maximum order
-        :type       max_order:  int
-
-        :returns:   The second electric mutlipole amplitude
-        :rtype:     numpy.array
-        """
-        return self.binding.a2n()
-
-    def b1n(self, max_order: int = None) -> numpy.array:
-        r"""
-        Compute :math:`b_n` coefficient as defined in ref[5]:
-
-        .. math::
-            b_n = \frac{ m J_n(m_t x) J_n^\prime (m x) - m_t J_n^\prime (m_t x) J_n(m x) }
-            { m J_n(m_t x) H_n^\prime (m x) - m_t J_n^\prime (m_t x) H_n(m x) }
-
-        | With :math:`m` being the refractive index of the medium and
-        |      :math:`m_t` being the refractive index of the index.
-
-
-        :param      max_order:  The maximum order
-        :type       max_order:  int
-
-        :returns:   The first magnetic mutlipole amplitude
-        :rtype:     numpy.array
-        """
-        return self.binding.b1n()
-
-    def b2n(self, max_order: int = None) -> numpy.array:
-        r"""
-        Compute :math:`b_n` coefficient as defined in ref[5]:
-
-        .. math::
-            b_n = \frac{ m J_n(m_t x) J_n^\prime (m x) - m_t J_n^\prime (m_t x) J_n(m x) }
-            { m J_n(m_t x) H_n^\prime (m x) - m_t J_n^\prime (m_t x) H_n(m x) }
-
-        | With :math:`m` being the refractive index of the medium and
-        |      :math:`m_t` being the refractive index of the index.
-
-        :param      max_order:  The maximum order
-        :type       max_order:  int
-
-        :returns:   The second magnetic mutlipole amplitude
-        :rtype:     numpy.array
-        """
-        return self.binding.b2n()
-
-    @property
-    def Cback(self) -> None:
-        raise NotImplementedError
-
-    @property
-    def Qback(self) -> None:
-        raise NotImplementedError
-
-    @property
-    def Cratio(self) -> None:
-        raise NotImplementedError
-
-    @property
-    def Qratio(self) -> None:
-        raise NotImplementedError
-
-    @property
-    def Cpr(self) -> None:
-        raise NotImplementedError
-
-    @property
-    def Qpr(self) -> None:
-        raise NotImplementedError
-
-# -
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+from __future__ import annotations
+from typing import TYPE_CHECKING
+if TYPE_CHECKING:
+    from PyOptik import DataMeasurement, Sellmeier
+
+import numpy
+import logging
+from dataclasses import dataclass
+from tabulate import tabulate
+
+
+from PyMieSim.mesh import FibonacciMesh
+from PyMieSim.single.source import PlaneWave, Gaussian
+from PyMieSim.single.representations import S1S2, FarField, Stokes, SPF, Footprint
+
+c = 299792458.0  #: Speed of light in vacuum (m/s).
+epsilon0 = 8.854187817620389e-12  #: Vacuum permittivity (F/m).
+
+
+class GenericScatterer():
+    """
+    Generic class for scatterer
+    """
+    def print_properties(self) -> None:
+        property_names = [
+            "size_parameter", "area", "index", "Qsca", "Qext",
+            "Qabs", "Qback", "Qratio", "Qpr", "Csca",
+            "Cext", "Cabs", "Cback", "Cratio", "Cpr", "g",
+        ]
+
+        data = [getattr(self, name) for name in property_names]
+        property_dict = {"Property": property_names, "value": data}
+
+        table = tabulate(
+            property_dict,
+            headers="keys"
+        )
+        print(table)
+
+    @property
+    def size_parameter(self) -> float:
+        return self.binding.size_parameter
+
+    @property
+    def area(self) -> float:
+        return self.binding.area
+
+    @property
+    def Qsca(self) -> float:
+        """ Scattering efficiency. """
+        return self.binding.Qsca
+
+    @property
+    def Qext(self) -> float:
+        """ Extinction efficiency. """
+        return self.binding.Qext
+
+    @property
+    def Qabs(self) -> float:
+        """ Absorption efficiency. """
+        return self.binding.Qabs
+
+    @property
+    def Qback(self) -> float:
+        """ Backscattering efficiency. """
+        return self.binding.Qback
+
+    @property
+    def Qratio(self) -> float:
+        """ Efficiency: Ratio of backscattering over total scattering. """
+        return self.binding.Qback / self.binding.Qsca
+
+    @property
+    def g(self) -> float:
+        """ Anisotropy factor. """
+        return self.binding.g
+
+    @property
+    def Qpr(self) -> float:
+        """ Radiation pressure efficiency. """
+        return self.binding.Qpr
+
+    @property
+    def Csca(self) -> float:
+        """ Scattering cross-section. """
+        return self.binding.Csca
+
+    @property
+    def Cext(self) -> float:
+        """ Extinction cross-section. """
+        return self.binding.Cext
+
+    @property
+    def Cabs(self) -> float:
+        """ Absorption cross-section. """
+        return self.binding.Cabs
+
+    @property
+    def Cpr(self) -> float:
+        """ Radiation pressure cross-section. """
+        return self.binding.Cpr
+
+    @property
+    def Cback(self) -> float:
+        """ Backscattering cross-section. """
+        return self.binding.Cback
+
+    @property
+    def Cratio(self) -> float:
+        """ Ratio of backscattering cross-section over total scattering. """
+        return self.binding.Cback / self.binding.Csca
+
+    def get_farfields_array(self, phi: numpy.ndarray, theta: numpy.ndarray, r: numpy.ndarray) -> numpy.array:
+        r"""
+        Method Compute scattering Far Field for unstructured coordinate.
+
+        .. math::
+            \text{Fields} = E_{||}(\phi,\theta), E_{\perp}(\phi,\theta)
+
+
+        The Fields are up to a constant phase value.
+
+        .. math::
+            \exp{\big(-i k r \big)}
+
+        :param      phi:         The phi array
+        :type       phi:         numpy.ndarray
+        :param      theta:       The theta array
+        :type       theta:       numpy.ndarray
+        :param      r:           The radial array
+        :type       r:           numpy.ndarray
+        :param      structured:  Indicates if computing mesh is structured or not
+        :type       structured:  bool
+
+        :returns:   The far fields
+        :rtype:     numpy.ndarray
+        """
+        return self.binding.get_fields(phi=phi, theta=theta, r=r)
+
+    def get_s1s2(self, **kwargs) -> S1S2:
+        r"""
+        Method compute :math:`S_1(\phi)` and :math:`S_2(\phi)`.
+        For spherical Scatterer such as here S1 and S2 are computed as follow:
+
+        .. math::
+            S_1=\sum\limits_{n=1}^{n_{max}} \frac{2n+1}{n(n+1)}(a_n \pi_n+b_n \tau_n) \\[10pt]
+
+            S_2=\sum\limits_{n=1}^{n_{max}}\frac{2n+1}{n(n+1)}(a_n \tau_n+b_n \pi_n) \\[10pt]
+
+        :param      kwargs:  The keywords arguments
+        :type       kwargs:  dictionary
+
+        :returns:   The S1 and S2 parameters
+        :rtype:     S1S2
+        """
+        return S1S2(scatterer=self, **kwargs)
+
+    def get_stokes(self, **kwargs) -> Stokes:
+        r"""
+        Returns the four Stokes components. The method compute the Stokes parameters: I, Q, U, V.
+        Those parameters are defined as:
+
+        .. math:
+            I &= \big| E_x \big|^2 + \big| E_y \big|^2 \\[10pt]
+
+            Q &= \big| E_x \big|^2 - \big| E_y \big|^2 \\[10pt]
+
+            U &= 2 \mathcal{Re} \big\{ E_x E_y^* \big\} \\[10pt]
+
+            V &= 2 \mathcal{Im} \big\{ E_x E_y^* \big\} \\[10pt]
+
+        :param      kwargs:  The keywords arguments
+        :type       kwargs:  dictionary
+
+        :returns:   The stokes.
+        :rtype:     Stokes
+        """
+        return Stokes(scatterer=self, **kwargs)
+
+    def get_far_field(self, **kwargs) -> FarField:
+        r"""
+        Returns the scattering far-fields defined as.
+
+        .. math::
+            \text{Fields} = E_{||}(\phi,\theta)^2, E_{\perp}(\phi,\theta)^2
+
+
+        The Fields are up to a constant phase value:
+
+        .. math::
+            \exp{\big(-i k r \big)}
+
+        :param      kwargs:  The keywords arguments
+        :type       kwargs:  dictionary
+
+        :returns:   The far field.
+        :rtype:     FarField
+        """
+        return FarField(scatterer=self, **kwargs)
+
+    def get_spf(self, **kwargs) -> SPF:
+        r"""
+        Returns the scattering phase function.
+
+        .. math::
+            \text{SPF} = \sqrt{ E_{\parallel}(\phi,\theta)^2
+            + E_{\perp}(\phi,\theta)^2 }
+
+        :param      kwargs:  The keywords arguments
+        :type       kwargs:  dictionary
+
+        :returns:   The scattering phase function.
+        :rtype:     SPF
+        """
+        return SPF(scatterer=self, **kwargs)
+
+    def get_footprint(self, detector) -> Footprint:
+        r"""
+        Return the footprint of the scattererd light coupling with the
+        detector as computed as:
+
+        .. math::
+            \big| \mathscr{F}^{-1} \big\{ \tilde{ \psi } (\xi, \nu),\
+                   \tilde{ \phi}_{l,m}(\xi, \nu)  \big\}
+                   (\delta_x, \delta_y) \big|^2
+
+        | Where:
+        |   :math:`\Phi_{det}` is the capturing field of the detector and
+        |   :math:`\Psi_{scat}` is the scattered field.
+
+        :param      detector:  The detector
+        :type       detector:  GenericDetector
+
+        :returns:   The scatterer footprint.
+        :rtype:     Footprint
+        """
+        return Footprint(scatterer=self, detector=detector)
+
+    def get_poynting_vector(self, mesh: FibonacciMesh) -> float:
+        r"""
+
+        Method return the Poynting vector norm defined as:
+
+        .. math::
+            \vec{S} = \epsilon c^2 \vec{E} \times \vec{B}
+
+        Parameters :
+            Mesh : Number of voxel in the 4 pi space to compute energy flow.
+
+        """
+        Ephi, Etheta = self.get_farfields_array(phi=mesh.phi, theta=mesh.theta, r=1.)
+
+        E_norm = numpy.sqrt(numpy.abs(Ephi)**2 + numpy.abs(Etheta)**2)
+
+        B_norm = E_norm / c
+
+        poynting = epsilon0 * c**2 * E_norm * B_norm
+
+        return poynting
+
+    def get_energy_flow(self, mesh: FibonacciMesh) -> float:
+        r"""
+        Returns energy flow defined as:
+
+        .. math::
+            W_a &= \sigma_{sca} * I_{inc} \\[10pt]
+            P &= \int_{A} I dA \\[10pt]
+            I &= \frac{c n \epsilon_0}{2} |E|^2 \\[10pt]
+
+        | With:
+        |     I : Energy density
+        |     n  : Refractive index of the medium
+        |     :math:`\epsilon_0` : Vaccum permitivity
+        |     E  : Electric field
+        |     \sigma_{sca}: Scattering cross section.
+
+        More info on wikipedia link (see ref[6]).
+
+        :param      Mesh:  The mesh
+        :type       Mesh:  FibonacciMesh
+
+        :returns:   The energy flow.
+        :rtype:     float
+        """
+        Poynting = self.get_poynting_vector(mesh)
+
+        total_power = 0.5 * numpy.sum(Poynting) * mesh.d_omega
+
+        return total_power
+
+    def get_cross_section(self):
+        return (self.Qsca * self.area)  # similar to self.EnergyFlow(Mesh) / self.source.I
+
+    def _assign_index_or_material(self, index, material) -> tuple:
+        assert bool(index) ^ bool(material), logging.error("Exactly one of the parameter [index or Material] have to be assigned.")
+        index = index if index is not None else material.get_refractive_index(self.source.wavelength)
+        material = material if material is not None else None
+
+        if not numpy.isscalar(index) and len(index) == 1:
+            return index[0], material
+
+        return index, material
+
+
+@dataclass()
+class Sphere(GenericScatterer):
+    """ Class representing a homogeneous spherical scatterer """
+    diameter: float
+    """ diameter of the single scatterer in unit of meter. """
+    source: PlaneWave | Gaussian
+    """ Light source object containing info on polarization and wavelength. """
+    index: complex = None
+    """ Refractive index of scatterer. """
+    medium_index: float = 1.0
+    """ Refractive index of scatterer medium. """
+    material: DataMeasurement | Sellmeier | None = None
+    """ Material of which the scatterer is made of. Only if index is not specified. """
+
+    def __post_init__(self):
+        self.index, self.material = self._assign_index_or_material(self.index, self.material)
+
+        self.set_cpp_binding()
+
+    def set_cpp_binding(self) -> None:
+        """
+        Method call and bind c++ scatterer class
+
+        """
+        from PyMieSim.binary.SphereInterface import SPHERE
+
+        self.binding = SPHERE(
+            wavelength=self.source.wavelength,
+            amplitude=self.source.amplitude,
+            diameter=self.diameter,
+            index=self.index,
+            medium_index=self.medium_index,
+            jones_vector=self.source.polarization.jones_vector.squeeze(),
+        )
+
+    def an(self, max_order: int = None) -> numpy.array:
+        r"""
+        Compute :math:`a_n` coefficient as defined in Eq:III.88 of B&B:
+
+        .. math::
+            a_n = \frac{
+            \mu_{sp} \Psi_n(\alpha) \Psi_n^\prime(\beta) -
+            \mu M \Psi_n^\prime(\alpha) \Psi_n(\beta)}
+            {\mu_{sp} \xi_n(\alpha) \Psi_n^\prime(\beta)-
+            \mu M \xi_n^\prime (\alpha) \Psi_n(\beta)}
+
+        With :math:`M = \frac{k_{sp}}{k}` (Eq:I.103)
+        """
+        return self.binding.an()
+
+    def bn(self, max_order: int = None) -> numpy.array:
+        r"""
+        Compute :math:`b_n` coefficient as defined in Eq:III.89 of B&B:
+
+        .. math::
+            b_n = \frac{
+            \mu M \Psi_n(\alpha) \Psi_n^\prime(\beta) -
+            \mu_{sp} \Psi_n^\prime(\alpha) \Psi_n(\beta)}
+            {\mu M \xi_n(\alpha) \Psi_n^\prime(\beta)-
+            \mu_{sp} \xi_n^\prime (\alpha) \Psi_n(\beta)}
+
+        With :math:`M = \frac{k_{sp}}{k}` (Eq:I.103)
+        """
+        return self.binding.bn()
+
+    def cn(self, max_order: int = None) -> numpy.array:
+        r"""
+        Compute :math:`c_n` coefficient as defined in Eq:III.90 of B&B:
+
+        .. math::
+            c_n = \frac{
+            \mu_{sp} M \big[ \xi_n(\alpha) \Psi_n^\prime(\alpha) -
+            \xi_n^\prime(\alpha) \Psi_n(\alpha) \big]}
+            {\mu_{sp} \xi_n(\alpha) \Psi_n^\prime(\beta)-
+            \mu M \xi_n^\prime (\alpha) \Psi_n(\beta)}
+
+        With :math:`M = \frac{k_{sp}}{k}` (Eq:I.103)
+        """
+        return self.binding.cn()
+
+    def dn(self, max_order: int = None) -> numpy.array:
+        r"""
+        Compute :math:`d_n` coefficient as defined in Eq:III.91 of B&B:
+
+        .. math::
+            d_n = \frac{
+            \mu M^2 \big[ \xi_n(\alpha) \Psi_n^\prime(\alpha) -
+            \xi_n^\prime(\alpha) \Psi_n(\alpha) \big]}
+            {\mu M \xi_n(\alpha) \Psi_n^\prime(\beta)-
+            \mu_{sp} M \xi_n^\prime (\alpha) \Psi_n(\beta)}
+
+        With :math:`M = \frac{k_{sp}}{k}` (Eq:I.103)
+        """
+        return self.binding.dn()
+
+
+@dataclass()
+class CoreShell(GenericScatterer):
+    """
+    Class representing a core/shell spherical scatterer.
+    """
+
+    core_diameter: float
+    """ diameter of the core of the single scatterer [m]. """
+    shell_width: float
+    """ diameter of the shell of the single scatterer [m]. """
+    source: PlaneWave | Gaussian
+    """ Light source object containing info on polarization and wavelength. """
+    core_index: complex = None
+    """ Refractive index of the core of the scatterer. """
+    shell_index: complex = None
+    """ Refractive index of the shell of the scatterer. """
+    core_material: DataMeasurement | Sellmeier | None = None
+    """ Core material of which the scatterer is made of. Only if core_index is not specified.  """
+    shell_material: DataMeasurement | Sellmeier | None = None
+    """ Shell material of which the scatterer is made of. Only if shell_index is not specified.  """
+    medium_index: float = 1.0
+    """ Refractive index of scatterer medium. """
+
+    def __post_init__(self):
+        self.core_index, self.core_material = self._assign_index_or_material(self.core_index, self.core_material)
+
+        self.shell_index, self.shell_material = self._assign_index_or_material(self.shell_index, self.shell_material)
+
+        self.shell_diameter = self.core_diameter + self.shell_width
+
+        self.set_cpp_binding()
+
+    def set_cpp_binding(self) -> None:
+        """
+        Method call and bind c++ scatterer class
+        """
+        from PyMieSim.binary.CoreShellInterface import CORESHELL
+
+        self.binding = CORESHELL(
+            shell_index=self.shell_index,
+            core_index=self.core_index,
+            shell_width=self.shell_width,
+            core_diameter=self.core_diameter,
+            wavelength=self.source.wavelength,
+            medium_index=self.medium_index,
+            jones_vector=self.source.polarization.jones_vector.squeeze(),
+            amplitude=self.source.amplitude
+        )
+
+    def an(self, max_order: int = None) -> numpy.array:
+        r"""
+        Compute :math:`a_n` coefficient
+        """
+        if max_order is None:
+            return self.binding.an()
+        else:
+            return self.binding._an(max_order)
+
+    def bn(self, max_order: int = None) -> numpy.array:
+        r"""
+        Compute :math:`b_n` coefficient.
+        """
+        if max_order is None:
+            return self.binding.bn()
+        else:
+            return self.binding._bn(max_order)
+
+
+@dataclass()
+class Cylinder(GenericScatterer):
+    """
+    Class representing a right angle cylindrical scatterer.
+    """
+
+    diameter: float
+    """ diameter of the single scatterer in unit of meter. """
+    source: PlaneWave | Gaussian
+    """ Light source object containing info on polarization and wavelength. """
+    index: complex = None
+    """ Refractive index of scatterer. """
+    medium_index: float = 1.0
+    """ Material of which the scatterer is made of. Only if index is not specified. """
+    material: DataMeasurement | Sellmeier | None = None
+    """ Refractive index of scatterer medium. """
+
+    def __post_init__(self):
+        self.index, self.material = self._assign_index_or_material(
+            index=self.index,
+            material=self.material
+        )
+
+        self.set_cpp_binding()
+
+    def set_cpp_binding(self) -> None:
+        """
+        Binds the Python representation of the cylinder to its C++ counterpart using provided properties.
+        """
+        from PyMieSim.binary.CylinderInterface import CYLINDER
+
+        self.binding = CYLINDER(
+            index=self.index,
+            diameter=self.diameter,
+            wavelength=self.source.wavelength,
+            medium_index=self.medium_index,
+            amplitude=self.source.amplitude,
+            jones_vector=self.source.polarization.jones_vector.squeeze()
+        )
+
+    def a1n(self, max_order: int = None) -> numpy.array:
+        r"""
+        Compute :math:`a_n` coefficient as defined ref[5]:
+
+        .. math::
+            a_n = \frac{ m_t J_n(m_t x) J_n^\prime (m x) - m J_n^\prime (m_t x) J_n(m x) }
+            { m_t J_n(m_t x) H_n^\prime (m x) - m J_n^\prime (m_t x) H_n(m x) }
+
+        | With :math:`m` being the refractive index of the medium and
+        |      :math:`m_t` being the refractive index of the index.
+
+        :param      max_order:  The maximum order
+        :type       max_order:  int
+
+        :returns:   The first electric mutlipole amplitude
+        :rtype:     numpy.array
+        """
+        return self.binding.a1n()
+
+    def a2n(self, max_order: int = None) -> numpy.array:
+        r"""
+        Compute :math:`a_n` coefficient as defined ref[5]:
+
+        .. math::
+            a_n = \frac{ m_t J_n(m_t x) J_n^\prime (m x) - m J_n^\prime (m_t x) J_n(m x) }
+            { m_t J_n(m_t x) H_n^\prime (m x) - m J_n^\prime (m_t x) H_n(m x) }
+
+        | With :math:`m` being the refractive index of the medium and
+        |      :math:`m_t` being the refractive index of the index.
+
+        :param      max_order:  The maximum order
+        :type       max_order:  int
+
+        :returns:   The second electric mutlipole amplitude
+        :rtype:     numpy.array
+        """
+        return self.binding.a2n()
+
+    def b1n(self, max_order: int = None) -> numpy.array:
+        r"""
+        Compute :math:`b_n` coefficient as defined in ref[5]:
+
+        .. math::
+            b_n = \frac{ m J_n(m_t x) J_n^\prime (m x) - m_t J_n^\prime (m_t x) J_n(m x) }
+            { m J_n(m_t x) H_n^\prime (m x) - m_t J_n^\prime (m_t x) H_n(m x) }
+
+        | With :math:`m` being the refractive index of the medium and
+        |      :math:`m_t` being the refractive index of the index.
+
+
+        :param      max_order:  The maximum order
+        :type       max_order:  int
+
+        :returns:   The first magnetic mutlipole amplitude
+        :rtype:     numpy.array
+        """
+        return self.binding.b1n()
+
+    def b2n(self, max_order: int = None) -> numpy.array:
+        r"""
+        Compute :math:`b_n` coefficient as defined in ref[5]:
+
+        .. math::
+            b_n = \frac{ m J_n(m_t x) J_n^\prime (m x) - m_t J_n^\prime (m_t x) J_n(m x) }
+            { m J_n(m_t x) H_n^\prime (m x) - m_t J_n^\prime (m_t x) H_n(m x) }
+
+        | With :math:`m` being the refractive index of the medium and
+        |      :math:`m_t` being the refractive index of the index.
+
+        :param      max_order:  The maximum order
+        :type       max_order:  int
+
+        :returns:   The second magnetic mutlipole amplitude
+        :rtype:     numpy.array
+        """
+        return self.binding.b2n()
+
+    @property
+    def Cback(self) -> None:
+        raise NotImplementedError
+
+    @property
+    def Qback(self) -> None:
+        raise NotImplementedError
+
+    @property
+    def Cratio(self) -> None:
+        raise NotImplementedError
+
+    @property
+    def Qratio(self) -> None:
+        raise NotImplementedError
+
+    @property
+    def Cpr(self) -> None:
+        raise NotImplementedError
+
+    @property
+    def Qpr(self) -> None:
+        raise NotImplementedError
+
+# -
```

## PyMieSim/single/source.py

 * *Ordering differences only*

```diff
@@ -1,165 +1,165 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-from collections.abc import Iterable
-import numpy
-from dataclasses import dataclass
-
-from PyMieSim.physics import power_to_amplitude
-from PyMieSim import polarization
-from PyMieSim.tools.special_functions import NA_to_angle
-from MPSPlots.render3D import SceneList as SceneList3D
-
-
-@dataclass(kw_only=True)
-class LightSource:
-    """
-    Abstract class for light sources in light scattering simulations.
-
-    Attributes:
-        wavelength (float): Wavelength of the light field in meters.
-        polarization_value (float): Polarization state of the light field.
-        polarization_type (str): Specifies how the polarization_value should be interpreted ('linear', 'jones vector', 'circular').
-        amplitude (float): Amplitude of the electric field.
-    """
-    wavelength: float
-    polarization_value: float
-    polarization_type: str = 'linear'
-
-    def __post_init__(self):
-        self.k = 2 * numpy.pi / self.wavelength  # Wave number
-        self.generate_polarization_attribute()
-
-    def generate_polarization_attribute(self) -> None:
-        """
-        Generates the polarization attribute based on the specified polarization_type and polarization_value.
-        """
-        match self.polarization_type.lower():
-            case 'linear':
-                self.polarization = polarization.Linear(self.polarization_value)
-            case 'jones vector':
-                self.polarization = self.interpret_jones_vector(self.polarization_value)
-            case 'circular':
-                self.polarization = self.interpret_circular_polarization(self.polarization_value)
-            case _:
-                raise ValueError(f'Invalid polarization type: {self.polarization_type}. Supported options are "linear", "jones vector", "circular".')
-
-    def interpret_jones_vector(self, value: Iterable) -> polarization.JonesVector:
-        """
-        Interprets the given value as a Jones vector.
-
-        Parameters:
-            value (Iterable): A size 2 iterable representing the Jones vector.
-
-        Returns:
-            polarization.JonesVector: The Jones vector representation of the polarization.
-        """
-        value = numpy.atleast_1d(value)
-        assert value.size == 2, 'Jones vector must be a size 2 complex vector.'
-        return polarization.JonesVector(value)
-
-    def interpret_circular_polarization(self, value: str):
-        """
-        Interprets the given value as circular polarization.
-
-        Parameters:
-            value (str): 'right' or 'left' indicating the circular polarization direction.
-
-        Returns:
-            polarization.RightCircular or polarization.LeftCircular: The circular polarization object.
-        """
-        match value.lower():
-            case 'right':
-                return polarization.RightCircular()
-            case 'left':
-                return polarization.LeftCircular()
-            case _:
-                raise ValueError('Circular polarization value must be either "right" or "left".')
-
-    def plot(self) -> SceneList3D:
-        """
-        Abstract method for plotting the structure of the source. To be implemented by subclasses.
-        """
-        raise NotImplementedError("Subclass must implement this method.")
-
-
-@dataclass(kw_only=True)
-class PlaneWave(LightSource):
-    """
-    Represents a plane wave light source for light scattering simulations.
-
-    Inherits from LightSource and specifies amplitude directly.
-    """
-
-    amplitude: float | None = None
-
-    def __post_init__(self):
-        super().__post_init__()
-        # Assuming amplitude is directly specified; no additional calculation required for PlaneWave.
-
-    def plot(self) -> SceneList3D:
-        """
-        Plots the structure of the PlaneWave source.
-
-        Returns:
-            SceneList3D: A 3D plotting scene object.
-        """
-        # Example plotting logic; adjust as needed for your specific visualization requirements.
-        figure = SceneList3D()
-        ax = figure.append_ax()
-        ax.add_unit_sphere(opacity=0.3)
-        ax.add_unit_axis(show_label=False)
-        return figure
-
-
-@dataclass(kw_only=True)
-class Gaussian(LightSource):
-    """
-    Represents a Gaussian light source for light scattering simulations, characterized by its optical power and numerical aperture.
-
-    Attributes:
-        optical_power (float): Optical power of the source in Watts.
-        NA (float): Numerical aperture of the source.
-    """
-    optical_power: float
-    NA: float
-
-    def __post_init__(self):
-        self.amplitude = power_to_amplitude(
-            wavelength=self.wavelength,
-            optical_power=self.optical_power,
-            NA=self.NA
-        )
-
-        super().__post_init__()
-
-    def plot(self) -> SceneList3D:
-        """
-        Plots the structure of the Gaussian source.
-
-        Returns:
-            SceneList3D: A 3D plotting scene object.
-        """
-        max_angle = NA_to_angle(NA=self.NA)
-        max_angle = numpy.rad2deg(max_angle)
-
-        figure = SceneList3D()
-
-        ax = figure.append_ax()
-
-        ax.add_cone(
-            center=(0.0, 0.0, 0.45),
-            direction=(0.0, 0.0, -1.0),
-            height=0.9,
-            resolution=100,
-            angle=max_angle,
-            color='red',
-            opacity=0.7
-        )
-
-        ax.add_unit_sphere(opacity=0.3)
-        ax.add_unit_axis(show_label=False)
-        return figure
-
-
-# -
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+from collections.abc import Iterable
+import numpy
+from dataclasses import dataclass
+
+from PyMieSim.physics import power_to_amplitude
+from PyMieSim import polarization
+from PyMieSim.tools.special_functions import NA_to_angle
+from MPSPlots.render3D import SceneList as SceneList3D
+
+
+@dataclass(kw_only=True)
+class LightSource:
+    """
+    Abstract class for light sources in light scattering simulations.
+
+    Attributes:
+        wavelength (float): Wavelength of the light field in meters.
+        polarization_value (float): Polarization state of the light field.
+        polarization_type (str): Specifies how the polarization_value should be interpreted ('linear', 'jones vector', 'circular').
+        amplitude (float): Amplitude of the electric field.
+    """
+    wavelength: float
+    polarization_value: float
+    polarization_type: str = 'linear'
+
+    def __post_init__(self):
+        self.k = 2 * numpy.pi / self.wavelength  # Wave number
+        self.generate_polarization_attribute()
+
+    def generate_polarization_attribute(self) -> None:
+        """
+        Generates the polarization attribute based on the specified polarization_type and polarization_value.
+        """
+        match self.polarization_type.lower():
+            case 'linear':
+                self.polarization = polarization.Linear(self.polarization_value)
+            case 'jones vector':
+                self.polarization = self.interpret_jones_vector(self.polarization_value)
+            case 'circular':
+                self.polarization = self.interpret_circular_polarization(self.polarization_value)
+            case _:
+                raise ValueError(f'Invalid polarization type: {self.polarization_type}. Supported options are "linear", "jones vector", "circular".')
+
+    def interpret_jones_vector(self, value: Iterable) -> polarization.JonesVector:
+        """
+        Interprets the given value as a Jones vector.
+
+        Parameters:
+            value (Iterable): A size 2 iterable representing the Jones vector.
+
+        Returns:
+            polarization.JonesVector: The Jones vector representation of the polarization.
+        """
+        value = numpy.atleast_1d(value)
+        assert value.size == 2, 'Jones vector must be a size 2 complex vector.'
+        return polarization.JonesVector(value)
+
+    def interpret_circular_polarization(self, value: str):
+        """
+        Interprets the given value as circular polarization.
+
+        Parameters:
+            value (str): 'right' or 'left' indicating the circular polarization direction.
+
+        Returns:
+            polarization.RightCircular or polarization.LeftCircular: The circular polarization object.
+        """
+        match value.lower():
+            case 'right':
+                return polarization.RightCircular()
+            case 'left':
+                return polarization.LeftCircular()
+            case _:
+                raise ValueError('Circular polarization value must be either "right" or "left".')
+
+    def plot(self) -> SceneList3D:
+        """
+        Abstract method for plotting the structure of the source. To be implemented by subclasses.
+        """
+        raise NotImplementedError("Subclass must implement this method.")
+
+
+@dataclass(kw_only=True)
+class PlaneWave(LightSource):
+    """
+    Represents a plane wave light source for light scattering simulations.
+
+    Inherits from LightSource and specifies amplitude directly.
+    """
+
+    amplitude: float | None = None
+
+    def __post_init__(self):
+        super().__post_init__()
+        # Assuming amplitude is directly specified; no additional calculation required for PlaneWave.
+
+    def plot(self) -> SceneList3D:
+        """
+        Plots the structure of the PlaneWave source.
+
+        Returns:
+            SceneList3D: A 3D plotting scene object.
+        """
+        # Example plotting logic; adjust as needed for your specific visualization requirements.
+        figure = SceneList3D()
+        ax = figure.append_ax()
+        ax.add_unit_sphere(opacity=0.3)
+        ax.add_unit_axis(show_label=False)
+        return figure
+
+
+@dataclass(kw_only=True)
+class Gaussian(LightSource):
+    """
+    Represents a Gaussian light source for light scattering simulations, characterized by its optical power and numerical aperture.
+
+    Attributes:
+        optical_power (float): Optical power of the source in Watts.
+        NA (float): Numerical aperture of the source.
+    """
+    optical_power: float
+    NA: float
+
+    def __post_init__(self):
+        self.amplitude = power_to_amplitude(
+            wavelength=self.wavelength,
+            optical_power=self.optical_power,
+            NA=self.NA
+        )
+
+        super().__post_init__()
+
+    def plot(self) -> SceneList3D:
+        """
+        Plots the structure of the Gaussian source.
+
+        Returns:
+            SceneList3D: A 3D plotting scene object.
+        """
+        max_angle = NA_to_angle(NA=self.NA)
+        max_angle = numpy.rad2deg(max_angle)
+
+        figure = SceneList3D()
+
+        ax = figure.append_ax()
+
+        ax.add_cone(
+            center=(0.0, 0.0, 0.45),
+            direction=(0.0, 0.0, -1.0),
+            height=0.9,
+            resolution=100,
+            angle=max_angle,
+            color='red',
+            opacity=0.7
+        )
+
+        ax.add_unit_sphere(opacity=0.3)
+        ax.add_unit_axis(show_label=False)
+        return figure
+
+
+# -
```

## PyMieSim/tools/directories.py

 * *Ordering differences only*

```diff
@@ -1,51 +1,51 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-from pathlib import Path
-import PyMieSim
-
-__all__ = [
-    'root_path',
-    'project_path',
-    'test_path',
-    'static_doc_path',
-    'lp_mode_path',
-    'examples_path',
-    'version_path',
-    'validation_data_path',
-    'doc_path',
-    'logo_path',
-    'doc_css_path'
-]
-
-root_path = Path(PyMieSim.__path__[0])
-
-project_path = root_path.parents[0]
-
-test_path = project_path.joinpath('tests')
-
-static_doc_path = root_path.parents[0].joinpath('docs/images')
-
-lp_mode_path = root_path.joinpath('lp_modes')
-
-examples_path = root_path.joinpath('examples')
-
-version_path = root_path.joinpath('VERSION')
-
-validation_data_path = root_path.joinpath('validation_data')
-
-doc_path = root_path.parents[0].joinpath('docs')
-
-logo_path = doc_path.joinpath('images/logo.png')
-
-doc_css_path = doc_path.joinpath('source/_static/default.css')
-
-rtd_example = 'https://pymiesim.readthedocs.io/en/latest/gallery/index.html'
-
-if __name__ == '__main__':
-    for path_name in __all__:
-        path = locals()[path_name]
-        print(path)
-        assert path.exists(), f"Path {path_name} do not exists"
-
-# -
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+from pathlib import Path
+import PyMieSim
+
+__all__ = [
+    'root_path',
+    'project_path',
+    'test_path',
+    'static_doc_path',
+    'lp_mode_path',
+    'examples_path',
+    'version_path',
+    'validation_data_path',
+    'doc_path',
+    'logo_path',
+    'doc_css_path'
+]
+
+root_path = Path(PyMieSim.__path__[0])
+
+project_path = root_path.parents[0]
+
+test_path = project_path.joinpath('tests')
+
+static_doc_path = root_path.parents[0].joinpath('docs/images')
+
+lp_mode_path = root_path.joinpath('lp_modes')
+
+examples_path = root_path.joinpath('examples')
+
+version_path = root_path.joinpath('VERSION')
+
+validation_data_path = root_path.joinpath('validation_data')
+
+doc_path = root_path.parents[0].joinpath('docs')
+
+logo_path = doc_path.joinpath('images/logo.png')
+
+doc_css_path = doc_path.joinpath('source/_static/default.css')
+
+rtd_example = 'https://pymiesim.readthedocs.io/en/latest/gallery/index.html'
+
+if __name__ == '__main__':
+    for path_name in __all__:
+        path = locals()[path_name]
+        print(path)
+        assert path.exists(), f"Path {path_name} do not exists"
+
+# -
```

## PyMieSim/tools/special_functions.py

 * *Ordering differences only*

```diff
@@ -1,180 +1,180 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-import numpy
-
-
-def get_rotation_matrix(axis: numpy.ndarray, theta: float) -> numpy.ndarray:
-    """
-    Calculate the rotation matrix for a counterclockwise rotation around a given axis.
-
-    Parameters:
-        - axis: numpy.ndarray, the axis of rotation.
-        - theta: float, the angle of rotation in degrees.
-
-    Returns:
-        - numpy.ndarray, the rotation matrix.
-    """
-    theta_rad = numpy.deg2rad(theta)
-    axis = axis / numpy.linalg.norm(axis)
-    a, b, c = axis * numpy.sin(theta_rad / 2.0)
-    aa, bb, cc, dd = numpy.cos(theta_rad / 2.0), a * a, b * b, c * c
-    bc, ad, ac, ab, bd, cd = b * c, a * numpy.cos(theta_rad / 2.0), a * c, a * b, b * numpy.cos(theta_rad / 2.0), c * numpy.cos(theta_rad / 2.0)
-
-    return numpy.array([[aa + bb - cc - dd, 2 * (bc + ad), 2 * (bd - ac)],
-                        [2 * (bc - ad), aa + cc - bb - dd, 2 * (cd + ab)],
-                        [2 * (bd + ac), 2 * (cd - ab), aa + dd - bb - cc]])
-
-
-def NA_to_angle(NA: float) -> float:
-    """
-    Convert numerical aperture (NA) to angle in radians.
-
-    Parameters:
-        - NA: float, the numerical aperture.
-
-    Returns:
-        - float, the angle in radians.
-    """
-    return numpy.arcsin(NA) if NA <= 1.0 else numpy.arcsin(NA - 1) + numpy.pi / 2
-
-
-def angle_space_to_direct(angle_space: numpy.ndarray, k: float) -> numpy.ndarray:
-    """
-    Convert angle space to direct space.
-
-    Parameters:
-        - angle_space: numpy.ndarray, the angle space array.
-        - k: float, the wave number.
-
-    Returns:
-    - numpy.ndarray, the direct space array.
-    """
-    rad_space = numpy.deg2rad(angle_space)
-    fourier_space = numpy.sin(rad_space) * k / (2 * numpy.pi)
-    fourier_unit = numpy.abs(numpy.diff(fourier_space)[0])
-    return numpy.fft.fftshift(numpy.fft.fftfreq(angle_space.size, d=fourier_unit))
-
-
-def direct_space_to_angle(direct_space: numpy.ndarray, k: float) -> numpy.ndarray:
-    """
-    Convert direct space to angle space.
-
-    Parameters:
-        - direct_space: numpy.ndarray, the direct space array.
-        - k: float, the wave number.
-
-    Returns:
-    - numpy.ndarray, the angle space array in degrees.
-    """
-    direct_unit = numpy.abs(numpy.diff(direct_space)[0])
-    fourier_space = numpy.fft.fftshift(numpy.fft.fftfreq(direct_space.size, d=direct_unit))
-    angle_space = numpy.arcsin(2 * numpy.pi * fourier_space / k)
-    if numpy.isnan(angle_space).any():
-        raise ValueError("Magnification too large.")
-    return numpy.rad2deg(angle_space)
-
-
-def cartesian_to_spherical(x: numpy.ndarray, y: numpy.ndarray, z: numpy.ndarray) -> tuple:
-    """
-    Convert Cartesian coordinates to spherical coordinates.
-
-    Parameters:
-        - x: numpy.ndarray, the x coordinates.
-        - y: numpy.ndarray, the y coordinates.
-        - z: numpy.ndarray, the z coordinates.
-
-    Returns:
-        - tuple of numpy.ndarray, (r, phi, theta) the spherical coordinates.
-    """
-    r = numpy.sqrt(x**2 + y**2 + z**2)
-    phi = numpy.arcsin(z / r)
-    theta = numpy.arctan2(y, x)
-    return r, phi, theta
-
-
-def spherical_to_cartesian(phi: numpy.ndarray, theta: numpy.ndarray, r: numpy.ndarray = None) -> tuple:
-    """
-    Convert spherical coordinates to Cartesian coordinates.
-
-    Parameters:
-        - phi: numpy.ndarray, the phi angles.
-        - theta: numpy.ndarray, the theta angles.
-        - r: numpy.ndarray, the radial distances; defaults to unit radius if None.
-
-    Returns:
-        - tuple of numpy.ndarray, (x, y, z) the Cartesian coordinates.
-    """
-    if r is None:
-        r = numpy.ones_like(phi)
-
-    x = r * numpy.cos(phi) * numpy.cos(theta)
-    y = r * numpy.cos(phi) * numpy.sin(theta)
-    z = r * numpy.sin(phi)
-    return x, y, z
-
-
-def rotate_on_y(phi: numpy.ndarray, theta: numpy.ndarray, angle: float) -> tuple:
-    """
-    Rotate spherical coordinates around the Y-axis.
-
-    Parameters:
-        - phi: numpy.ndarray, the phi angles in radians.
-        - theta: numpy.ndarray, the theta angles in radians.
-        - angle: float, the rotation angle in radians.
-
-    Returns:
-        - tuple of numpy.ndarray, the rotated spherical coordinates (r, phi, theta).
-    """
-    # Convert to Cartesian coordinates for rotation
-    x, y, z = spherical_to_cartesian(phi, theta)
-    # Apply rotation around the Y-axis
-    xp = x * numpy.cos(angle) + z * numpy.sin(angle)
-    zp = -x * numpy.sin(angle) + z * numpy.cos(angle)
-    # Convert back to spherical coordinates
-    return cartesian_to_spherical(xp, y, zp)
-
-
-def rotate_on_z(phi: numpy.ndarray, theta: numpy.ndarray, angle: float) -> tuple:
-    """
-    Rotate spherical coordinates around the Z-axis.
-
-    Parameters:
-        - phi: numpy.ndarray, the phi angles in radians.
-        - theta: numpy.ndarray, the theta angles in radians.
-        - angle: float, the rotation angle in radians.
-
-    Returns:
-        - tuple of numpy.ndarray, the rotated spherical coordinates (r, phi, theta).
-    """
-    # Convert to Cartesian for rotation
-    x, y, z = spherical_to_cartesian(phi, theta)
-    # Apply rotation around the Z-axis
-    xp = x * numpy.cos(angle) - y * numpy.sin(angle)
-    yp = x * numpy.sin(angle) + y * numpy.cos(angle)
-    # Convert back to spherical coordinates
-    return cartesian_to_spherical(xp, yp, z)
-
-
-def rotate_on_x(phi: numpy.ndarray, theta: numpy.ndarray, angle: float) -> tuple:
-    """
-    Rotate spherical coordinates around the X-axis.
-
-    Parameters:
-        - phi: numpy.ndarray, the phi angles in radians.
-        - theta: numpy.ndarray, the theta angles in radians.
-        - angle: float, the rotation angle in radians.
-
-    Returns:
-        - tuple of numpy.ndarray, the rotated spherical coordinates (r, phi, theta).
-    """
-    # Convert to Cartesian for rotation
-    x, y, z = spherical_to_cartesian(phi, theta)
-    # Apply rotation around the X-axis
-    yp = y * numpy.cos(angle) - z * numpy.sin(angle)
-    zp = y * numpy.sin(angle) + z * numpy.cos(angle)
-    # Convert back to spherical coordinates
-    return cartesian_to_spherical(x, yp, zp)
-
-
-# -
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import numpy
+
+
+def get_rotation_matrix(axis: numpy.ndarray, theta: float) -> numpy.ndarray:
+    """
+    Calculate the rotation matrix for a counterclockwise rotation around a given axis.
+
+    Parameters:
+        - axis: numpy.ndarray, the axis of rotation.
+        - theta: float, the angle of rotation in degrees.
+
+    Returns:
+        - numpy.ndarray, the rotation matrix.
+    """
+    theta_rad = numpy.deg2rad(theta)
+    axis = axis / numpy.linalg.norm(axis)
+    a, b, c = axis * numpy.sin(theta_rad / 2.0)
+    aa, bb, cc, dd = numpy.cos(theta_rad / 2.0), a * a, b * b, c * c
+    bc, ad, ac, ab, bd, cd = b * c, a * numpy.cos(theta_rad / 2.0), a * c, a * b, b * numpy.cos(theta_rad / 2.0), c * numpy.cos(theta_rad / 2.0)
+
+    return numpy.array([[aa + bb - cc - dd, 2 * (bc + ad), 2 * (bd - ac)],
+                        [2 * (bc - ad), aa + cc - bb - dd, 2 * (cd + ab)],
+                        [2 * (bd + ac), 2 * (cd - ab), aa + dd - bb - cc]])
+
+
+def NA_to_angle(NA: float) -> float:
+    """
+    Convert numerical aperture (NA) to angle in radians.
+
+    Parameters:
+        - NA: float, the numerical aperture.
+
+    Returns:
+        - float, the angle in radians.
+    """
+    return numpy.arcsin(NA) if NA <= 1.0 else numpy.arcsin(NA - 1) + numpy.pi / 2
+
+
+def angle_space_to_direct(angle_space: numpy.ndarray, k: float) -> numpy.ndarray:
+    """
+    Convert angle space to direct space.
+
+    Parameters:
+        - angle_space: numpy.ndarray, the angle space array.
+        - k: float, the wave number.
+
+    Returns:
+    - numpy.ndarray, the direct space array.
+    """
+    rad_space = numpy.deg2rad(angle_space)
+    fourier_space = numpy.sin(rad_space) * k / (2 * numpy.pi)
+    fourier_unit = numpy.abs(numpy.diff(fourier_space)[0])
+    return numpy.fft.fftshift(numpy.fft.fftfreq(angle_space.size, d=fourier_unit))
+
+
+def direct_space_to_angle(direct_space: numpy.ndarray, k: float) -> numpy.ndarray:
+    """
+    Convert direct space to angle space.
+
+    Parameters:
+        - direct_space: numpy.ndarray, the direct space array.
+        - k: float, the wave number.
+
+    Returns:
+    - numpy.ndarray, the angle space array in degrees.
+    """
+    direct_unit = numpy.abs(numpy.diff(direct_space)[0])
+    fourier_space = numpy.fft.fftshift(numpy.fft.fftfreq(direct_space.size, d=direct_unit))
+    angle_space = numpy.arcsin(2 * numpy.pi * fourier_space / k)
+    if numpy.isnan(angle_space).any():
+        raise ValueError("Magnification too large.")
+    return numpy.rad2deg(angle_space)
+
+
+def cartesian_to_spherical(x: numpy.ndarray, y: numpy.ndarray, z: numpy.ndarray) -> tuple:
+    """
+    Convert Cartesian coordinates to spherical coordinates.
+
+    Parameters:
+        - x: numpy.ndarray, the x coordinates.
+        - y: numpy.ndarray, the y coordinates.
+        - z: numpy.ndarray, the z coordinates.
+
+    Returns:
+        - tuple of numpy.ndarray, (r, phi, theta) the spherical coordinates.
+    """
+    r = numpy.sqrt(x**2 + y**2 + z**2)
+    phi = numpy.arcsin(z / r)
+    theta = numpy.arctan2(y, x)
+    return r, phi, theta
+
+
+def spherical_to_cartesian(phi: numpy.ndarray, theta: numpy.ndarray, r: numpy.ndarray = None) -> tuple:
+    """
+    Convert spherical coordinates to Cartesian coordinates.
+
+    Parameters:
+        - phi: numpy.ndarray, the phi angles.
+        - theta: numpy.ndarray, the theta angles.
+        - r: numpy.ndarray, the radial distances; defaults to unit radius if None.
+
+    Returns:
+        - tuple of numpy.ndarray, (x, y, z) the Cartesian coordinates.
+    """
+    if r is None:
+        r = numpy.ones_like(phi)
+
+    x = r * numpy.cos(phi) * numpy.cos(theta)
+    y = r * numpy.cos(phi) * numpy.sin(theta)
+    z = r * numpy.sin(phi)
+    return x, y, z
+
+
+def rotate_on_y(phi: numpy.ndarray, theta: numpy.ndarray, angle: float) -> tuple:
+    """
+    Rotate spherical coordinates around the Y-axis.
+
+    Parameters:
+        - phi: numpy.ndarray, the phi angles in radians.
+        - theta: numpy.ndarray, the theta angles in radians.
+        - angle: float, the rotation angle in radians.
+
+    Returns:
+        - tuple of numpy.ndarray, the rotated spherical coordinates (r, phi, theta).
+    """
+    # Convert to Cartesian coordinates for rotation
+    x, y, z = spherical_to_cartesian(phi, theta)
+    # Apply rotation around the Y-axis
+    xp = x * numpy.cos(angle) + z * numpy.sin(angle)
+    zp = -x * numpy.sin(angle) + z * numpy.cos(angle)
+    # Convert back to spherical coordinates
+    return cartesian_to_spherical(xp, y, zp)
+
+
+def rotate_on_z(phi: numpy.ndarray, theta: numpy.ndarray, angle: float) -> tuple:
+    """
+    Rotate spherical coordinates around the Z-axis.
+
+    Parameters:
+        - phi: numpy.ndarray, the phi angles in radians.
+        - theta: numpy.ndarray, the theta angles in radians.
+        - angle: float, the rotation angle in radians.
+
+    Returns:
+        - tuple of numpy.ndarray, the rotated spherical coordinates (r, phi, theta).
+    """
+    # Convert to Cartesian for rotation
+    x, y, z = spherical_to_cartesian(phi, theta)
+    # Apply rotation around the Z-axis
+    xp = x * numpy.cos(angle) - y * numpy.sin(angle)
+    yp = x * numpy.sin(angle) + y * numpy.cos(angle)
+    # Convert back to spherical coordinates
+    return cartesian_to_spherical(xp, yp, z)
+
+
+def rotate_on_x(phi: numpy.ndarray, theta: numpy.ndarray, angle: float) -> tuple:
+    """
+    Rotate spherical coordinates around the X-axis.
+
+    Parameters:
+        - phi: numpy.ndarray, the phi angles in radians.
+        - theta: numpy.ndarray, the theta angles in radians.
+        - angle: float, the rotation angle in radians.
+
+    Returns:
+        - tuple of numpy.ndarray, the rotated spherical coordinates (r, phi, theta).
+    """
+    # Convert to Cartesian for rotation
+    x, y, z = spherical_to_cartesian(phi, theta)
+    # Apply rotation around the X-axis
+    yp = y * numpy.cos(angle) - z * numpy.sin(angle)
+    zp = y * numpy.sin(angle) + z * numpy.cos(angle)
+    # Convert back to spherical coordinates
+    return cartesian_to_spherical(x, yp, zp)
+
+
+# -
```

## PyMieSim/validation_data/Figure810BH.csv

 * *Ordering differences only*

```diff
@@ -1,245 +1,245 @@
-0.2723807197945738, 6.05075037181526
-0.9038476450565485, 5.880858412208168
-1.5353145703185236, 5.532695484149393
-2.166781495580498, 5.007799968026051
-2.798248420842473, 4.423393711358749
-3.3770931023326165, 3.8300660225983747
-3.850693296279098, 3.320373994193902
-4.271671246453748, 2.867989187660259
-4.692649196628398, 2.4322982589362327
-5.0610049030312165, 2.0586033869431635
-5.376738365662204, 1.742322467717133
-5.639849584521359, 1.5110748362181181
-5.902960803380516, 1.278915430841805
-6.166072022239673, 1.0736527001710705
-6.376560997326997, 0.9502894525722584
-6.534427728642491, 0.8241634401850342
-6.744916703729816, 0.6772655014279776
-7.008027922588973, 0.5622401928092828
-7.165894653904466, 0.46817694265282295
-7.376383628991791, 0.37698231581105335
-7.551791108231228, 0.3066544425263056
-7.7271985874706655, 0.25954048673369157
-7.849983822938272, 0.22100971491990387
-8.007850554253766, 0.18217222842812408
-8.060472798025597, 0.15418354433766496
-8.21833952934109, 0.12567525434815244
-8.376206260656584, 0.09815416925800613
-8.463910000276302, 0.0762709344981608
-8.569154487819965, 0.05926651402786185
-8.674398975363628, 0.047191228325052834
-8.797184210831235, 0.03834845148171478
-8.77964346290729, 0.03258896862673974
-8.902428698374896, 0.02675312337041194
-9.00767318591856, 0.021086721612041143
-9.06029542969039, 0.016927577993140253
-9.095376925538277, 0.014210744026857788
-9.165539917234053, 0.012629199840147466
-9.165539917234053, 0.010908532789884393
-9.1940614585738, 0.008756934481747622
-9.28725559490142, 0.0064881689170031
-9.351928189889295, 0.005288840523413614
-9.489508974926894, 0.004690100570345879
-9.75948675486359, 0.0070813870765368166
-9.797006842496028, 0.009773704872412166
-9.867169834191802, 0.012475990755004402
-9.972414321735464, 0.015990343676002553
-10.060118061355183, 0.019478428786537962
-10.112740305127016, 0.023391915660156973
-10.217984792670677, 0.02896207240053967
-10.32322928021434, 0.034499090158582914
-10.37585152398617, 0.03977866513185824
-10.481096011529834, 0.046618735608968474
-10.586340499073495, 0.05430256949052585
-10.744207230388989, 0.06501402437783589
-10.919614709628426, 0.07783836760319955
-11.095022188867866, 0.09309763673241346
-11.340592659803077, 0.11317521164362031
-11.58616313073829, 0.13426486876083804
-11.901896593369276, 0.1573521483837173
-12.322874543543927, 0.18202405490254772
-12.90171922503407, 0.20332430262180098
-13.533186150296045, 0.20834873776933596
-14.16465307555802, 0.1956155849754043
-14.690875513276334, 0.17366837426311532
-15.111853463450982, 0.15046533021438405
-15.532831413625631, 0.1268309852696708
-15.848564876256619, 0.10888435344377859
-16.059053851343947, 0.0946251058209613
-16.26954282643127, 0.08123561797582518
-16.480031801518592, 0.06931643258935256
-16.690520776605922, 0.05807306279079222
-16.8834690037693, 0.04875248133607876
-17.05887648300874, 0.040144476472746826
-17.26936545809606, 0.03212819742211249
-17.4447729373355, 0.025738821235534684
-17.58509892072705, 0.022007050173132592
-17.690343408270714, 0.020081950850196997
-17.725424904118604, 0.016586706942634286
-17.848210139586207, 0.014095580167876553
-17.953454627129872, 0.011881516613110855
-18.041158366749592, 0.009576891539249874
-18.14640285429325, 0.007814083531826804
-18.300761436023954, 0.0064540499344168285
-18.374432577304518, 0.005341583947300534
-18.497217812772128, 0.004530116567691847
-18.848032771251, 0.003484083039004039
-19.105197248740815, 0.003960961986192785
-19.216388477653823, 0.00487432097659554
-19.37425520896931, 0.005835805299288252
-19.505810818398892, 0.00713779134492821
-19.532121940284803, 0.008442085122481999
-19.725070167448187, 0.009893729038137025
-19.865396150839736, 0.012374885335242773
-20.040803630079175, 0.015043671526347313
-20.268833353090443, 0.019242129393687833
-20.510895674440867, 0.022855687331039563
-20.689811303265095, 0.027247438375566455
-20.952922522124247, 0.032193620850771654
-21.268655984755235, 0.037883233475623106
-21.637011691158058, 0.04399281297420429
-22.16323412887637, 0.0508802801387172
-22.794701054138343, 0.05441314713154307
-23.42616797940032, 0.054082087894863726
-24.005012660890465, 0.04979488832769631
-24.531235098608775, 0.04301057699352742
-24.95221304878342, 0.037271710057961184
-25.267946511414408, 0.03206290694603538
-25.531057730273567, 0.02758204547715781
-25.794168949132725, 0.023631055240118038
-26.057280167991877, 0.019838329927526537
-26.21514689930737, 0.016927577993140253
-26.460717370242584, 0.014095580167876553
-26.688747093253852, 0.011454325122693853
-26.811532328721462, 0.009615934564588714
-26.95185831211301, 0.008288931299604594
-27.09218429550456, 0.007145055077909989
-27.267591774743998, 0.0059074708213726086
-27.47808074983132, 0.004585747822039247
-27.65348822907076, 0.003681255215609996
-27.8288957083102, 0.0031030219742959513
-28.235078108914855, 0.002690843362351632
-28.74101460035527, 0.003318479984376002
-28.898881331670765, 0.003889103379976889
-29.05674806298626, 0.0046110042710462654
-29.26723703807358, 0.005540799456131681
-29.47772601316091, 0.006694755098726052
-29.635592744476405, 0.007942290556936404
-29.898703963335556, 0.00965513676034537
-30.214437425966544, 0.011737377925510077
-30.53017088859753, 0.013755658125733991
-30.898526595000355, 0.0161702545507991
-31.424749032718665, 0.018588066709678486
-32.05621595798064, 0.020328563514318485
-32.687682883242616, 0.020453003212965472
-33.31914980850459, 0.018854650165232557
-33.89799448999473, 0.01623948055322804
-34.31897244016938, 0.014153044961270596
-34.63470590280037, 0.012175125930379616
-34.95043936543136, 0.010262717765828199
-35.266172828062345, 0.00854575657941992
-35.58190629069333, 0.007087151556894437
-35.792395265780655, 0.005835805299288252
-36.002884240867985, 0.004934179169197858
-36.26599545972714, 0.0041086869054911155
-36.458943686890514, 0.0034213001815453954
-36.63435116612996, 0.002919314572982075
-36.95008462876094, 0.0024309108258366656
-37.42368482270742, 0.0020616187099838446
-37.8972850166539, 0.0021868995619810706
-38.16039623551306, 0.0024758265420603866
-38.42350745437222, 0.0029074614481423176
-38.68661867323137, 0.0033797952344823195
-38.94972989209053, 0.003977110016956141
-39.26546335472152, 0.0047761666563219144
-39.581196817352506, 0.005597444002642453
-39.94955252375532, 0.006533307694809367
-40.423152717701804, 0.007638063054804783
-41.00199739919195, 0.008580595878716825
-41.633464324453925, 0.009102023219826826
-42.2649312497159, 0.00899160350455496
-42.896398174977875, 0.008255276229201535
-43.475242856468014, 0.007256378308090835
-43.89622080664267, 0.006349866571183192
-44.26457651304548, 0.005490309638933085
-44.63293221944831, 0.004642062245663648
-44.948665682079294, 0.003993323879933595
-45.26439914471028, 0.0033524053764260667
-45.58013260734127, 0.0028029257369359436
-45.89586606997226, 0.002333993938506481
-46.211599532603245, 0.001967381790957699
-46.63257748277789, 0.0016773549559758376
-47.211422164268036, 0.0015538413872342378
-47.73764460198635, 0.0016958822250511961
-48.10600030838916, 0.0019356236772416022
-48.47435601479199, 0.0022592499467270753
-48.89533396496663, 0.0026720843243456757
-49.316311915141284, 0.0031030219742959513
-49.842534352859595, 0.003607125689635629
-50.47400127812157, 0.004100337289090708
-51.105468203383545, 0.004367239444229374
-51.73693512864552, 0.004376132559970139
-52.368402053907495, 0.004117053524418173
-52.99986897916947, 0.003673774219946569
-53.52609141688778, 0.003179702097971211
-53.94706936706243, 0.0027717402772551632
-54.368047317237085, 0.002372288182260205
-54.7364030236399, 0.0020574291171070397
-55.05213648627089, 0.0017916338061870682
-55.420492192673706, 0.0015522617368592811
-55.89409238662019, 0.0013334296328738986
-56.47293706811033, 0.0011903447048946182
-57.10440399337231, 0.0011879257029363908
-57.735870918634284, 0.0013044537275959717
-58.31471560012443, 0.0015250314678075033
-58.89356028161457, 0.0017484276511429034
-59.525027206876544, 0.0019874946736282715
-60.15649413213852, 0.0021780202196313033
-60.787961057400494, 0.0022592499467270753
-61.41942798266247, 0.0022546587303989094
-62.050894907924445, 0.0021515979213466573
-62.68236183318642, 0.0019633837050374264
-63.313828758448395, 0.0017342583947637467
-63.892673439938534, 0.0015028576823079307
-64.47151812142869, 0.001296517199787768
-65.10298504669066, 0.001108540239856326
-65.73445197195264, 0.0009732170080510514
-66.36591889721461, 0.000900819985249052
-66.99738582247657, 0.0008844775742849831
-67.62885274773855, 0.0009268437494378811
-68.26031967300052, 0.00099929735440226
-68.8917865982625, 0.0010840101418580336
-69.52325352352447, 0.0011640044141113103
-70.15472044878645, 0.0012272264934945353
-70.78618737404842, 0.0012575530203700247
-71.4176542993104, 0.0012499018447818717
-72.04912122457237, 0.0012049625117544586
-72.68058814983435, 0.0011405648288621674
-73.31205507509632, 0.0010578686892370659
-73.9435220003583, 0.0009594568188809222
-74.57498892562027, 0.0008684316425292913
-75.20645585088225, 0.0007892467006457608
-75.83792277614423, 0.0007365037431861308
-76.4693897014062, 0.0006999843471647599
-77.10085662666818, 0.000691492600830788
-77.73232355193015, 0.000691492600830788
-78.36379047719213, 0.0007042692461522086
-78.9952574024541, 0.0007320227238023176
-79.62672432771608, 0.0007501120552537975
-80.25819125297805, 0.000770213617435098
-80.88965817824003, 0.0007812597477754691
-81.521125103502, 0.0007717820221292834
-82.15259202876398, 0.0007531701084707751
-82.78405895402595, 0.0007335133594523161
-83.41552587928793, 0.000698561848707332
-84.0469928045499, 0.000661228102657252
-84.67845972981188, 0.0006297209448978264
-85.30992665507385, 0.0005984963533293029
-85.94139358033583, 0.0005758053157075213
-86.5728605055978, 0.0005596379501038436
-87.20432743085978, 0.0005551026445741326
-87.83579435612175, 0.0005517253016436253
-88.46726128138373, 0.0005494851631747675
-89.0987282066457, 0.0005551026445741326
-89.73019513190768, 0.0005551026445741326
-90.09855083831049, 0.000561919479405594
+0.2723807197945738, 6.05075037181526
+0.9038476450565485, 5.880858412208168
+1.5353145703185236, 5.532695484149393
+2.166781495580498, 5.007799968026051
+2.798248420842473, 4.423393711358749
+3.3770931023326165, 3.8300660225983747
+3.850693296279098, 3.320373994193902
+4.271671246453748, 2.867989187660259
+4.692649196628398, 2.4322982589362327
+5.0610049030312165, 2.0586033869431635
+5.376738365662204, 1.742322467717133
+5.639849584521359, 1.5110748362181181
+5.902960803380516, 1.278915430841805
+6.166072022239673, 1.0736527001710705
+6.376560997326997, 0.9502894525722584
+6.534427728642491, 0.8241634401850342
+6.744916703729816, 0.6772655014279776
+7.008027922588973, 0.5622401928092828
+7.165894653904466, 0.46817694265282295
+7.376383628991791, 0.37698231581105335
+7.551791108231228, 0.3066544425263056
+7.7271985874706655, 0.25954048673369157
+7.849983822938272, 0.22100971491990387
+8.007850554253766, 0.18217222842812408
+8.060472798025597, 0.15418354433766496
+8.21833952934109, 0.12567525434815244
+8.376206260656584, 0.09815416925800613
+8.463910000276302, 0.0762709344981608
+8.569154487819965, 0.05926651402786185
+8.674398975363628, 0.047191228325052834
+8.797184210831235, 0.03834845148171478
+8.77964346290729, 0.03258896862673974
+8.902428698374896, 0.02675312337041194
+9.00767318591856, 0.021086721612041143
+9.06029542969039, 0.016927577993140253
+9.095376925538277, 0.014210744026857788
+9.165539917234053, 0.012629199840147466
+9.165539917234053, 0.010908532789884393
+9.1940614585738, 0.008756934481747622
+9.28725559490142, 0.0064881689170031
+9.351928189889295, 0.005288840523413614
+9.489508974926894, 0.004690100570345879
+9.75948675486359, 0.0070813870765368166
+9.797006842496028, 0.009773704872412166
+9.867169834191802, 0.012475990755004402
+9.972414321735464, 0.015990343676002553
+10.060118061355183, 0.019478428786537962
+10.112740305127016, 0.023391915660156973
+10.217984792670677, 0.02896207240053967
+10.32322928021434, 0.034499090158582914
+10.37585152398617, 0.03977866513185824
+10.481096011529834, 0.046618735608968474
+10.586340499073495, 0.05430256949052585
+10.744207230388989, 0.06501402437783589
+10.919614709628426, 0.07783836760319955
+11.095022188867866, 0.09309763673241346
+11.340592659803077, 0.11317521164362031
+11.58616313073829, 0.13426486876083804
+11.901896593369276, 0.1573521483837173
+12.322874543543927, 0.18202405490254772
+12.90171922503407, 0.20332430262180098
+13.533186150296045, 0.20834873776933596
+14.16465307555802, 0.1956155849754043
+14.690875513276334, 0.17366837426311532
+15.111853463450982, 0.15046533021438405
+15.532831413625631, 0.1268309852696708
+15.848564876256619, 0.10888435344377859
+16.059053851343947, 0.0946251058209613
+16.26954282643127, 0.08123561797582518
+16.480031801518592, 0.06931643258935256
+16.690520776605922, 0.05807306279079222
+16.8834690037693, 0.04875248133607876
+17.05887648300874, 0.040144476472746826
+17.26936545809606, 0.03212819742211249
+17.4447729373355, 0.025738821235534684
+17.58509892072705, 0.022007050173132592
+17.690343408270714, 0.020081950850196997
+17.725424904118604, 0.016586706942634286
+17.848210139586207, 0.014095580167876553
+17.953454627129872, 0.011881516613110855
+18.041158366749592, 0.009576891539249874
+18.14640285429325, 0.007814083531826804
+18.300761436023954, 0.0064540499344168285
+18.374432577304518, 0.005341583947300534
+18.497217812772128, 0.004530116567691847
+18.848032771251, 0.003484083039004039
+19.105197248740815, 0.003960961986192785
+19.216388477653823, 0.00487432097659554
+19.37425520896931, 0.005835805299288252
+19.505810818398892, 0.00713779134492821
+19.532121940284803, 0.008442085122481999
+19.725070167448187, 0.009893729038137025
+19.865396150839736, 0.012374885335242773
+20.040803630079175, 0.015043671526347313
+20.268833353090443, 0.019242129393687833
+20.510895674440867, 0.022855687331039563
+20.689811303265095, 0.027247438375566455
+20.952922522124247, 0.032193620850771654
+21.268655984755235, 0.037883233475623106
+21.637011691158058, 0.04399281297420429
+22.16323412887637, 0.0508802801387172
+22.794701054138343, 0.05441314713154307
+23.42616797940032, 0.054082087894863726
+24.005012660890465, 0.04979488832769631
+24.531235098608775, 0.04301057699352742
+24.95221304878342, 0.037271710057961184
+25.267946511414408, 0.03206290694603538
+25.531057730273567, 0.02758204547715781
+25.794168949132725, 0.023631055240118038
+26.057280167991877, 0.019838329927526537
+26.21514689930737, 0.016927577993140253
+26.460717370242584, 0.014095580167876553
+26.688747093253852, 0.011454325122693853
+26.811532328721462, 0.009615934564588714
+26.95185831211301, 0.008288931299604594
+27.09218429550456, 0.007145055077909989
+27.267591774743998, 0.0059074708213726086
+27.47808074983132, 0.004585747822039247
+27.65348822907076, 0.003681255215609996
+27.8288957083102, 0.0031030219742959513
+28.235078108914855, 0.002690843362351632
+28.74101460035527, 0.003318479984376002
+28.898881331670765, 0.003889103379976889
+29.05674806298626, 0.0046110042710462654
+29.26723703807358, 0.005540799456131681
+29.47772601316091, 0.006694755098726052
+29.635592744476405, 0.007942290556936404
+29.898703963335556, 0.00965513676034537
+30.214437425966544, 0.011737377925510077
+30.53017088859753, 0.013755658125733991
+30.898526595000355, 0.0161702545507991
+31.424749032718665, 0.018588066709678486
+32.05621595798064, 0.020328563514318485
+32.687682883242616, 0.020453003212965472
+33.31914980850459, 0.018854650165232557
+33.89799448999473, 0.01623948055322804
+34.31897244016938, 0.014153044961270596
+34.63470590280037, 0.012175125930379616
+34.95043936543136, 0.010262717765828199
+35.266172828062345, 0.00854575657941992
+35.58190629069333, 0.007087151556894437
+35.792395265780655, 0.005835805299288252
+36.002884240867985, 0.004934179169197858
+36.26599545972714, 0.0041086869054911155
+36.458943686890514, 0.0034213001815453954
+36.63435116612996, 0.002919314572982075
+36.95008462876094, 0.0024309108258366656
+37.42368482270742, 0.0020616187099838446
+37.8972850166539, 0.0021868995619810706
+38.16039623551306, 0.0024758265420603866
+38.42350745437222, 0.0029074614481423176
+38.68661867323137, 0.0033797952344823195
+38.94972989209053, 0.003977110016956141
+39.26546335472152, 0.0047761666563219144
+39.581196817352506, 0.005597444002642453
+39.94955252375532, 0.006533307694809367
+40.423152717701804, 0.007638063054804783
+41.00199739919195, 0.008580595878716825
+41.633464324453925, 0.009102023219826826
+42.2649312497159, 0.00899160350455496
+42.896398174977875, 0.008255276229201535
+43.475242856468014, 0.007256378308090835
+43.89622080664267, 0.006349866571183192
+44.26457651304548, 0.005490309638933085
+44.63293221944831, 0.004642062245663648
+44.948665682079294, 0.003993323879933595
+45.26439914471028, 0.0033524053764260667
+45.58013260734127, 0.0028029257369359436
+45.89586606997226, 0.002333993938506481
+46.211599532603245, 0.001967381790957699
+46.63257748277789, 0.0016773549559758376
+47.211422164268036, 0.0015538413872342378
+47.73764460198635, 0.0016958822250511961
+48.10600030838916, 0.0019356236772416022
+48.47435601479199, 0.0022592499467270753
+48.89533396496663, 0.0026720843243456757
+49.316311915141284, 0.0031030219742959513
+49.842534352859595, 0.003607125689635629
+50.47400127812157, 0.004100337289090708
+51.105468203383545, 0.004367239444229374
+51.73693512864552, 0.004376132559970139
+52.368402053907495, 0.004117053524418173
+52.99986897916947, 0.003673774219946569
+53.52609141688778, 0.003179702097971211
+53.94706936706243, 0.0027717402772551632
+54.368047317237085, 0.002372288182260205
+54.7364030236399, 0.0020574291171070397
+55.05213648627089, 0.0017916338061870682
+55.420492192673706, 0.0015522617368592811
+55.89409238662019, 0.0013334296328738986
+56.47293706811033, 0.0011903447048946182
+57.10440399337231, 0.0011879257029363908
+57.735870918634284, 0.0013044537275959717
+58.31471560012443, 0.0015250314678075033
+58.89356028161457, 0.0017484276511429034
+59.525027206876544, 0.0019874946736282715
+60.15649413213852, 0.0021780202196313033
+60.787961057400494, 0.0022592499467270753
+61.41942798266247, 0.0022546587303989094
+62.050894907924445, 0.0021515979213466573
+62.68236183318642, 0.0019633837050374264
+63.313828758448395, 0.0017342583947637467
+63.892673439938534, 0.0015028576823079307
+64.47151812142869, 0.001296517199787768
+65.10298504669066, 0.001108540239856326
+65.73445197195264, 0.0009732170080510514
+66.36591889721461, 0.000900819985249052
+66.99738582247657, 0.0008844775742849831
+67.62885274773855, 0.0009268437494378811
+68.26031967300052, 0.00099929735440226
+68.8917865982625, 0.0010840101418580336
+69.52325352352447, 0.0011640044141113103
+70.15472044878645, 0.0012272264934945353
+70.78618737404842, 0.0012575530203700247
+71.4176542993104, 0.0012499018447818717
+72.04912122457237, 0.0012049625117544586
+72.68058814983435, 0.0011405648288621674
+73.31205507509632, 0.0010578686892370659
+73.9435220003583, 0.0009594568188809222
+74.57498892562027, 0.0008684316425292913
+75.20645585088225, 0.0007892467006457608
+75.83792277614423, 0.0007365037431861308
+76.4693897014062, 0.0006999843471647599
+77.10085662666818, 0.000691492600830788
+77.73232355193015, 0.000691492600830788
+78.36379047719213, 0.0007042692461522086
+78.9952574024541, 0.0007320227238023176
+79.62672432771608, 0.0007501120552537975
+80.25819125297805, 0.000770213617435098
+80.88965817824003, 0.0007812597477754691
+81.521125103502, 0.0007717820221292834
+82.15259202876398, 0.0007531701084707751
+82.78405895402595, 0.0007335133594523161
+83.41552587928793, 0.000698561848707332
+84.0469928045499, 0.000661228102657252
+84.67845972981188, 0.0006297209448978264
+85.30992665507385, 0.0005984963533293029
+85.94139358033583, 0.0005758053157075213
+86.5728605055978, 0.0005596379501038436
+87.20432743085978, 0.0005551026445741326
+87.83579435612175, 0.0005517253016436253
+88.46726128138373, 0.0005494851631747675
+89.0987282066457, 0.0005551026445741326
+89.73019513190768, 0.0005551026445741326
+90.09855083831049, 0.000561919479405594
```

## PyMieSim/validation_data/Figure87BH.csv

 * *Ordering differences only*

```diff
@@ -1,2 +1,2 @@
-6.545775035328707178e-03,6.651612140085098358e-03,6.759162555737761348e-03,6.868454069790015312e-03,6.979514921632567169e-03,7.092373809915983145e-03,7.207059900043563151e-03,7.323602831786896541e-03,7.442032727025704730e-03,7.562380197614366334e-03,7.684676353376974911e-03,7.808952810232904287e-03,7.935241698455454060e-03,8.063575671065111375e-03,8.193987912360240974e-03,8.326512146586898325e-03,8.461182646750376596e-03,8.598034243570588236e-03,8.737102334583791291e-03,8.878422893392759474e-03,9.022032479068142069e-03,9.167968245703093585e-03,9.316267952123898424e-03,9.466969971759154473e-03,9.620113302669633729e-03,9.775737577742093370e-03,9.933883075049077319e-03,1.009459072837765210e-02,1.025790213792978842e-02,1.042385958119714136e-02,1.059250602401280369e-02,1.076388513178338537e-02,1.093804128090356334e-02,1.111501957035679507e-02,1.129486583350473514e-02,1.147762665006817756e-02,1.166334935830326026e-02,1.185208206737529968e-02,1.204387366993381510e-02,1.223877385489203183e-02,1.243683312041365778e-02,1.263810278711057639e-02,1.284263501145493230e-02,1.305048279940836282e-02,1.326170002027258175e-02,1.347634142076422660e-02,1.369446263931787394e-02,1.391612022062046518e-02,1.414137163038112731e-02,1.437027527033977840e-02,1.460289049351849201e-02,1.483927761971918016e-02,1.507949795127170277e-02,1.532361378903596139e-02,1.557168844866238348e-02,1.582378627711410884e-02,1.607997266945589143e-02,1.634031408591281667e-02,1.660487806920364628e-02,1.687373326215299563e-02,1.714694942558599167e-02,1.742459745651076322e-02,1.770674940659215310e-02,1.799347850092161694e-02,1.828485915708780857e-02,1.858096700455232064e-02,1.888187890433485824e-02,1.918767296901320585e-02,1.949842858304212320e-02,1.981422642339615917e-02,2.013514848054105341e-02,2.046127807973907933e-02,2.079269990269283497e-02,2.112950000953230101e-02,2.147176586115095639e-02,2.181958634189542362e-02,2.217305178261396933e-02,2.253225398406927607e-02,2.289728624072044985e-02,2.326824336487999870e-02,2.364522171125075026e-02,2.402831920184827011e-02,2.441763535131459203e-02,2.481327129262835690e-02,2.521532980321707432e-02,2.562391533147755085e-02,2.603913402370946345e-02,2.646109375146822942e-02,2.688990413934335549e-02,2.732567659316719952e-02,2.776852432866054599e-02,2.821856240052126111e-02,2.867590773196112761e-02,2.914067914469738174e-02,2.961299738940533985e-02,3.009298517663730813e-02,3.058076720821446479e-02,3.107647020909792140e-02,3.158022295974485111e-02,3.209215632895562331e-02,3.261240330721913716e-02,3.314109904056152661e-02,3.367838086490492627e-02,3.422438834094290727e-02,3.477926328953803714e-02,3.534314982764850954e-02,3.591619440479038028e-02,3.649854584004052355e-02,3.709035535958820490e-02,3.769177663483939261e-02,3.830296582108325826e-02,3.892408159672310769e-02,3.955528520308202595e-02,4.019674048478566464e-02,4.084861393073180302e-02,4.151107471564947915e-02,4.218429474225723202e-02,4.286844868402244629e-02,4.356371402853199265e-02,4.427027112147643995e-02,4.498830321125604076e-02,4.571799649421246642e-02,4.645954016049468061e-02,4.721312644055829233e-02,4.797895065231476408e-02,4.875721124892063579e-02,4.954810986722883032e-02,5.035185137689067447e-02,5.116864393012818951e-02,5.199869901216791490e-02,5.284223149235334205e-02,5.369945967592825581e-02,5.457060535650708200e-02,5.545589386922294972e-02,5.635555414457181500e-02,5.726981876294053725e-02,5.819892400983731062e-02,5.914310993181206427e-02,6.010262039308445631e-02,6.107770313286826902e-02,6.206860982340317578e-02,6.307559612869109711e-02,6.409892176393965080e-02,6.513885055571246030e-02,6.619565050278818086e-02,6.726959383772475320e-02,6.836095708913504654e-02,6.947002114466210854e-02,7.059707131466302910e-02,7.174239739659364623e-02,7.290629374008951447e-02,7.408905931274641088e-02,7.529099776658787491e-02,7.651241750522393137e-02,7.775363175168582830e-02,7.901495861693966227e-02,8.029672116906598489e-02,8.159924750309911767e-02,8.292287081151882011e-02,8.426792945538170987e-02,8.563476703608589868e-02,8.702373246775359228e-02,8.843518005022130146e-02,8.986946954262226006e-02,9.132696623754876786e-02,9.280804103577584840e-02,9.431307052153059534e-02,9.584243703828780603e-02,9.739652876507338963e-02,9.897573979325198501e-02,1.005804702037792764e-01,1.022111261448915981e-01,1.038681199102087643e-01,1.055518700172233260e-01,1.072628012861438912e-01,1.090013449190661426e-01,1.107679385794346216e-01,1.125630264717626811e-01,1.143870594215729564e-01,1.162404949555206068e-01,1.181237973816561537e-01,1.200374378697862676e-01,1.219818945318877773e-01,1.239576525025214149e-01,1.259652040192042743e-01,1.280050485026763829e-01,1.300776926370151299e-01,1.321836504495326470e-01,1.343234433903953418e-01,1.364976004119049791e-01,1.387066580473664823e-01,1.409511604894784775e-01,1.432316596681663945e-01,1.455487153277821022e-01,1.479028951035901707e-01,1.502947745974543003e-01,1.527249374526335191e-01,1.551939754275959427e-01,1.577024884687552031e-01,1.602510847820236284e-01,1.628403809030825045e-01,1.654710017662534283e-01,1.681435807718598685e-01,1.708587598519576423e-01,1.736171895343124327e-01,1.764195290044922315e-01,1.792664461659420061e-01,1.821586176978997884e-01,1.850967291110129087e-01,1.880814748004975834e-01,1.911135580966906999e-01,1.941936913128304021e-01,1.973225957898988581e-01,2.005010019383480779e-01,2.037296492765375555e-01,2.070092864656880027e-01,2.103406713411669904e-01,2.137245709399001048e-01,2.171617615237075027e-01,2.206530285983472062e-01,2.241991669280544996e-01,2.278009805453430903e-01,2.314592827558349386e-01,2.351748961378924141e-01,2.389486525367809366e-01,2.427813930531349251e-01,2.466739680254447786e-01,2.506272370063086230e-01,2.546420687321694354e-01,2.587193410862547172e-01,2.628599410544336656e-01,2.670647646736871716e-01,2.713347169729009023e-01,2.756707119056591160e-01,2.800736722747312890e-01,2.845445296479315878e-01,2.890842242650166760e-01,2.936937049352927320e-01,2.983739289255981086e-01,3.031258618383077530e-01,3.079504774790244315e-01,3.128487577135944941e-01,3.178216923141080619e-01,3.228702787935087137e-01,3.279955222284720584e-01,3.331984350701804876e-01,3.384800369426415045e-01,3.438413544281961887e-01,3.492834208398404860e-01,3.548072759800341980e-01,3.604139658856264083e-01,3.661045425585653934e-01,3.718800636820513983e-01,3.777415923218129801e-01,3.836901966121889496e-01,3.897269494267023293e-01,3.958529280328596522e-01,4.020692137308942704e-01,4.083768914761958246e-01,4.147770494852203726e-01,4.212707788246560781e-01,4.278591729836997426e-01,4.345433274292721526e-01,4.413243391440968555e-01,4.482033061475648728e-01,4.551813269993687516e-01,4.622595002859337665e-01,4.694389240897361981e-01,4.767206954416398079e-01,4.841059097564701097e-01,4.915956602520950569e-01,4.991910373523715805e-01,5.068931280743914636e-01,5.147030154005579616e-01,5.226217776361298251e-01,5.306504877529483188e-01,5.387902127202219837e-01,5.470420128233272061e-01,5.554069409717445893e-01,5.638860419973850124e-01,5.724803519447262401e-01,5.811908973543286061e-01,5.900186945415112350e-01,5.989647488721299151e-01,6.080300540376363250e-01,6.172155913318045917e-01,6.265223289317516375e-01,6.359512211861403363e-01,6.455032079137178469e-01,6.551792137156566831e-01,6.649801473054285372e-01,6.749069008603234554e-01,6.849603493990723546e-01,6.951413501903561665e-01,7.054507421974556269e-01,7.158893455646564430e-01,7.264579611515519231e-01,7.371573701217384311e-01,7.479883335930588295e-01,7.589515923569554179e-01,7.700478666751426893e-01,7.812778561623445750e-01,7.926422397645778162e-01,8.041416758429709155e-01,8.157768023740049612e-01,8.275482372776356010e-01,8.394565788856560573e-01,8.515024065634487771e-01,8.636862814990949877e-01,8.760087476748340540e-01,8.884703330366916507e-01,9.010715508792145334e-01,9.138129014632212499e-01,9.266948738856471968e-01,9.397179482216506674e-01,9.528825979604088614e-01,9.661892927572758305e-01,9.796385015262614182e-01,9.932306958981894640e-01,1.006966354071334058e+00,1.020845965082739504e+00,1.034870033530049582e+00,1.049039084775207797e+00,1.063353670663063966e+00,1.077814375789584833e+00,1.092421824356179849e+00,1.107176687648363966e+00,1.122079692178936217e+00,1.137131628537632722e+00,1.152333360991206312e+00,1.167685837879818278e+00,1.183190102857668569e+00,1.198847307027637754e+00,1.214658722021935588e+00,1.230625754082552259e+00,1.246749959197423374e+00,1.263033059350040954e+00,1.279476959942232428e+00,1.296083768451558926e+00,1.312855814386413966e+00,1.329795670603582503e+00,1.346906176054227355e+00,1.364190460025464180e+00,1.381651967945535464e+00,1.399294488821046567e+00,1.417122184374888461e+00,1.435139619953025747e+00,1.453351797267386836e+00,1.471764189040430271e+00,1.490382775614474742e+00,1.509214083585568744e+00,1.528265226516981601e+00,1.547543947781801377e+00,1.567058665576809062e+00,1.586818520140531819e+00,1.606833423197897348e+00,1.627114109640019457e+00,1.647672191432223210e+00,1.668520213724084655e+00,1.689671713113233942e+00,1.711141277987864306e+00,1.732944610842705124e+00,1.755098592426516335e+00,1.777621347538475227e+00,1.800532312241761357e+00,1.823852302208094356e+00,1.847603581842701237e+00,1.871809933767252687e+00,1.896496728154838607e+00,1.921690991317867692e+00,1.947421472842856938e+00,1.973718710447072366e+00,2.000615091597195416e+00,2.028144910780790511e+00,2.056344421154089552e+00,2.085251879105936901e+00,2.114907580074088855e+00,2.145353883729562927e+00,2.176635226403105694e+00,2.208798118370436825e+00,2.241891123335814751e+00,2.275964817164157328e+00,2.311071722608417200e+00,2.347266216471068034e+00,2.384604405327760190e+00,2.423143965640979225e+00,2.462943943807658798e+00,2.504064511435979412e+00,2.546566670944701460e+00,2.590511906448599078e+00,2.635961774855250628e+00,2.682977432184040278e+00,2.731619090355683177e+00,2.781945400129704815e+00,2.834012756523009102e+00,2.887874523971201590e+00,2.943580179732832480e+00,3.001174375632455149e+00,3.060695920222786359e+00,3.122176685856544953e+00,3.185640448006436198e+00,3.251101667467263923e+00,3.318564229789607634e+00,3.388020160389933366e+00,3.459448338165989512e+00,3.532813235005493269e+00,3.608063713133495387e+00,3.685131916595739909e+00,3.763932297052343223e+00,3.844360817167964850e+00,3.926294376891615201e+00,4.009590508486047256e+00,4.094087384947102670e+00,4.179604183156556907e+00,4.265941837493598676e+00,4.352884211572098039e+00,4.440199705265152730e+00,4.527643301408851961e+00,4.614959041885513535e+00,4.701882906728764411e+00,4.788146053180996731e+00,4.873478355145104857e+00,4.957612168166223299e+00,5.040286231949113294e+00,5.121249612401168605e+00,5.200265579088307000e+00,5.277115312385180168e+00,5.351601337790859780e+00,5.423550592844809337e+00,5.492817044456179687e+00,5.559283790581502238e+00,5.622864599121005114e+00,5.683504857533583809e+00,5.741181927794213991e+00,5.795904921739580828e+00,5.847713930481127420e+00,5.896678757507180180e+00,5.942897217681891497e+00,5.986493073187156178e+00,6.027613682419753260e+00,6.066427439076560013e+00,6.103121076470355177e+00,6.137896907005715441e+00,6.170970059295832755e+00,6.202565766243196776e+00,6.232916747158515847e+00,6.262260716222530554e+00,6.290838038798569620e+00,6.318889546681058178e+00,6.346654513623142257e+00,6.374368783639398295e+00,6.402263036761050685e+00,6.430561170207056421e+00,6.459478767352475614e+00,6.489221622441975867e+00,6.519984285720656025e+00,6.551948591578105940e+00,6.585282131501767999e+00,6.620136634255098684e+00,6.656646217944593324e+00,6.694925482812681850e+00,6.735067420064468457e+00,6.777141121250121358e+00,6.821189285175172756e+00,6.867225535493329147e+00,6.915231582484880235e+00,6.965154287312312675e+00,7.016902716259215467e+00,7.070345305644739398e+00,7.125307294175266648e+00,7.181568616556187834e+00,7.238862487366403364e+00,7.296874933564380328e+00,7.355245552588097979e+00,7.413569775086560121e+00,7.471402890835267208e+00,7.528266047802426364e+00,7.583654353666774206e+00,7.637047095189037904e+00,7.687919946624578671e+00,7.735758871776239332e+00,7.780075248630725859e+00,7.820421578825540898e+00,7.856407007457608671e+00,7.887711793076514155e+00,7.914099850740699438e+00,7.935428553275567509e+00,7.951655117903553283e+00,7.962839116518792615e+00,7.969140906947371761e+00,7.970816061019649013e+00,7.968206131740082299e+00,7.961726327101290579e+00,7.951850819877759768e+00,7.939096508794671436e+00,7.924006055594873921e+00,7.907130963546965319e+00,7.889015352059542074e+00,7.870180939435455159e+00,7.851113592000484864e+00,7.832251651066064468e+00,7.813976123360762749e+00,7.796602724548193919e+00,7.780375703105644192e+00,7.765463342702737748e+00,7.751955041447829764e+00,7.739859889687269678e+00,7.729106706564355278e+00,7.719545540389077587e+00,7.710950679621597637e+00,7.703025250416426495e+00,7.695407484157500200e+00,7.687678716503393517e+00,7.679373123004733515e+00,7.669989104430166016e+00,7.659002112702713916e+00,7.645878568636327088e+00,7.630090386648882728e+00,7.611129517707315273e+00,7.588521881862385854e+00,7.561840114612246033e+00,7.530714713186196896e+00,7.494843432624450408e+00,7.453999107745412189e+00,7.408036389937700861e+00,7.356898081283742563e+00,7.300621707271558236e+00,7.239346604393209539e+00,7.173321095750802456e+00,7.102908391464651139e+00,7.028588924364263413e+00,6.950956260528056596e+00,6.870703851891756919e+00,6.788600913115049096e+00,6.705457506203792661e+00,6.622081080433990685e+00,6.539228616905776725e+00,6.457559582044804181e+00,6.377594803653417799e+00,6.299685248918964753e+00,6.223992936672370746e+00,6.150484406829685113e+00,6.078935746443927535e+00,6.008947348050038606e+00,5.939966325385971579e+00,5.871314651549847774e+00,5.802221389921729866e+00,5.731857682166830337e+00,5.659373359415496019e+00,5.583934169570836659e+00,5.504758750116755195e+00,5.421154721534024112e+00,5.332553685387309450e+00,5.238545433059937473e+00,5.138912110221766305e+00,5.033663091706703341e+00,4.923070460107987323e+00,4.807702861472143319e+00,4.688452058661489730e+00,4.566542288693206331e+00,4.443509020664276221e+00,4.321133138559644316e+00,4.201321146743287827e+00,4.085932511129195532e+00,3.976569837436138677e+00,3.874361757524801053e+00,3.779776917400801128e+00,3.692507079400182857e+00,3.611448204315293342e+00,3.534793010136502822e+00,3.460229744561166942e+00,3.385222087714080175e+00,3.307327334142541986e+00,3.224499445257273056e+00,3.135325895947721708e+00,3.039164474654894033e+00,2.936173432010428463e+00,2.827255141071684186e+00,2.713949223946340972e+00,2.598310766706585451e+00,2.482794469719725505e+00,2.370142538587123759e+00,2.263250393340746847e+00,2.164967652862119785e+00,2.077791183067878578e+00,2.003432941097875730e+00,1.942307472406109792e+00,1.893079502425315974e+00,1.852504950339916023e+00,1.815804708640355924e+00,1.777637331610079308e+00,1.733405831720858936e+00,1.680368151976779245e+00,1.618088248555278552e+00,1.548155554961512026e+00,1.473488024507761063e+00,1.397633299931218653e+00,1.324318029213147341e+00,1.257269850041009995e+00,1.200186589512865165e+00,1.156657528078725017e+00,1.129805623879168275e+00,1.121417960547891779e+00,1.130492069948044964e+00,1.151701234810600161e+00,1.175257548786983186e+00,1.189852707118349784e+00,1.187974529050161099e+00,1.169512165212747146e+00,1.140502016928898632e+00,1.108845793184936701e+00,1.080940681004165294e+00,1.060838165870340744e+00,1.051121089787808938e+00,1.054206880044948669e+00,1.073247590803899421e+00,1.112067699380003605e+00,1.173285885728197586e+00,1.253526196337031218e+00,1.337347329646801697e+00,1.399550803289412393e+00,1.423693727638664308e+00,1.416991597369906319e+00,1.400145930612125333e+00,1.390032558058597711e+00,1.394423904049839180e+00,1.414919385880746283e+00,1.450899891790288665e+00,1.502525594852744728e+00,1.572729006047391964e+00,1.666721192533456408e+00,1.783142792974018009e+00,1.892798966809883465e+00,1.943814829106240261e+00,1.929540100052813401e+00,1.894114804467730284e+00,1.870193901185142726e+00,1.866312989058946270e+00,1.881150765632263022e+00,1.912102539223974329e+00,1.958696086467898390e+00,2.025259205990367573e+00,2.122059525223439103e+00,2.244831438575741966e+00,2.312826211813091781e+00,2.264624316296789619e+00,2.183747905470963424e+00,2.124223223325165222e+00,2.088606949445941829e+00,2.070823275789330786e+00,2.067066472699243818e+00,2.077696476066365872e+00,2.111479860562937017e+00,2.191320672079441145e+00,2.284919907610928558e+00,2.216190016178490652e+00,2.088755408804241931e+00,1.994171737239414099e+00,1.922254446753733470e+00,1.864090513548323669e+00,1.817952184345708933e+00,1.786584854966744684e+00,1.783964501033770800e+00,1.853978168303652252e+00,1.861069744744785703e+00,1.696016406974471424e+00,1.583413697543463172e+00,1.498293535505595964e+00,1.422060967090985839e+00,1.352391917236307473e+00,1.294283869440509438e+00,1.264610516547199026e+00,1.333834868091265724e+00,1.270742976653283840e+00,1.128802680286132620e+00,1.053817330077852388e+00,9.934677289883402374e-01,9.371103922357530980e-01,8.854236529125105726e-01,8.474021060517364923e-01,8.778896774008576598e-01,8.848124783189729170e-01,7.690043697405728462e-01,7.366413131557072447e-01,7.179397305436638899e-01,7.016442116179969490e-01,6.874187453766560374e-01,6.845198081842123194e-01,7.988382192337128984e-01,7.028771810249273555e-01,6.887193247791174588e-01,7.042838847950253500e-01,7.273306857922857693e-01,7.514725781349922418e-01,7.767982139539598707e-01,8.542571520929387319e-01,8.444896310307690168e-01,8.563127710808897675e-01,8.889291281037172698e-01,9.256613550688301828e-01,9.639020464061595073e-01,1.003889268314283267e+00,1.160432486921139983e+00,1.074696272932576635e+00,1.100717331764349494e+00,1.125889168250549410e+00,1.146634153185966065e+00,1.165909466533121108e+00,1.196516751042968840e+00,1.212163621390545121e+00,1.224477128052968267e+00,1.229587419734372800e+00,1.218501245732619198e+00,1.198549481433072383e+00,1.184779480079166447e+00,1.171796602815366795e+00,1.164268284671856168e+00,1.151406584607838068e+00,1.113370291176864368e+00,1.056502833369543648e+00,1.022209046463608439e+00,9.635576658943972861e-01,9.419245842446204442e-01,9.193883756241894023e-01,8.671867429803842287e-01,7.968232503367909114e-01,7.337445393187373988e-01,6.932322834404319734e-01,6.825261131482887045e-01,6.660714600272212849e-01,6.160810026947508566e-01,5.645909565297909660e-01,5.274871405812254777e-01,5.233011825630344838e-01,5.449611513639284199e-01,5.326001989015716198e-01,5.107890893195502491e-01,5.013997460052761479e-01,5.157907627032585207e-01,5.651989213622811148e-01,5.796364434227799789e-01,5.843637319043427647e-01,6.032219055628448290e-01,6.353555126679598652e-01,6.999318809249329698e-01,7.124793381996786801e-01,7.236781434406047708e-01,7.506850473380367594e-01,7.853692706879936702e-01,8.404294162918843902e-01,8.182096038468407162e-01,8.197267608457875498e-01,8.296877016305417296e-01,8.545270001661715575e-01,8.476939923189920068e-01,8.053453806849932839e-01,7.842965338087357630e-01,7.701530885586208575e-01,7.848053955079151711e-01,7.078889580551609439e-01,6.618000998672968205e-01,6.253095281985650011e-01,6.334545850017808677e-01,5.631378714834722743e-01,5.187197105718432955e-01,4.793475608989951064e-01,4.814395472697831635e-01,4.420748458247868995e-01,4.230017026297857585e-01,4.031633830291918574e-01,4.247633214188881734e-01,4.085637526643498552e-01,4.229510378899382639e-01,4.286092256850455584e-01,4.773674664866772721e-01,4.740772355015192563e-01,5.075843305468608069e-01,5.266081509935055527e-01,5.501499283933788398e-01,5.818018078589886066e-01,6.056965638262531426e-01,6.224192905788534791e-01,6.264877141228137880e-01,6.393809223850366319e-01,6.318171838129925666e-01,6.212907029967176253e-01,6.128873496847034863e-01,5.859327217820723410e-01,5.849311768968687986e-01,5.297638977110732394e-01,5.023877946644279557e-01,4.535365830816525667e-01,4.241173280092478959e-01,4.135531771469486140e-01,3.697235478496517791e-01,3.453059245289976098e-01,3.548550744710032290e-01,3.397746744415412468e-01,3.306862924100654744e-01,3.542566276767276645e-01
-3.820375748535051463e-02,3.882586397809122819e-02,3.945817243119797979e-02,4.010085218870074880e-02,4.075407546241004847e-02,4.141801738200714955e-02,4.209285604604721259e-02,4.277877257389544469e-02,4.347595115861003362e-02,4.418457912079380712e-02,4.490484696343189502e-02,4.563694842773285965e-02,4.638108054999638685e-02,4.713744371952288681e-02,4.790624173758912391e-02,4.868768187750800724e-02,4.948197494579370526e-02,5.028933534445549636e-02,5.110998113443961099e-02,5.194413410024283778e-02,5.279201981572129859e-02,5.365386771111533420e-02,5.452991114131582051e-02,5.542038745539779043e-02,5.632553806744015207e-02,5.724560852866469873e-02,5.818084860091312510e-02,5.913151233149181035e-02,6.009785812941044469e-02,6.108014884304163727e-02,6.207865183922853247e-02,6.309363908387043141e-02,6.412538722401296687e-02,6.517417767147482000e-02,6.624029668804051751e-02,6.732403547224719009e-02,6.842569024780126297e-02,6.954556235365312589e-02,7.068395833576396337e-02,7.184119004059896785e-02,7.301757471037813307e-02,7.421343508012137602e-02,7.542909947652345903e-02,7.666490191869185233e-02,7.792118222078821266e-02,7.919828609660693741e-02,8.049656526613285790e-02,8.181637756411234974e-02,8.315808705068182538e-02,8.452206412409239700e-02,8.590868563556956772e-02,8.731833500635464984e-02,8.875140234696697605e-02,9.020828457873104889e-02,9.168938555761617371e-02,9.319511620042870981e-02,9.472589461340895356e-02,9.628214622327499472e-02,9.786430391076406110e-02,9.947280814672082583e-02,1.011081071307785850e-01,1.027706569326915509e-01,1.044609216363611148e-01,1.061793734866152555e-01,1.079264930387929255e-01,1.097027693111876784e-01,1.115086999404054785e-01,1.133447913396966600e-01,1.152115588603146307e-01,1.171095269559676300e-01,1.190392293504123900e-01,1.210012092082645707e-01,1.229960193090750969e-01,1.250242222247435198e-01,1.270863905003295491e-01,1.291831068383292869e-01,1.313149642864804290e-01,1.334825664291680036e-01,1.356865275824941097e-01,1.379274729930879406e-01,1.402060390407198209e-01,1.425228734447971379e-01,1.448786354748132776e-01,1.472739961648258655e-01,1.497096385320332845e-01,1.521862577995380383e-01,1.547045616233634346e-01,1.572652703238090754e-01,1.598691171212245077e-01,1.625168483762819693e-01,1.652092238348282227e-01,1.679470168774070959e-01,1.707310147735260353e-01,1.735620189407624248e-01,1.764408452087941059e-01,1.793683240884381969e-01,1.823453010457929124e-01,1.853726367815681786e-01,1.884512075157024902e-01,1.915819052773470588e-01,1.947656382003240261e-01,1.980033308241430090e-01,2.012959244006731763e-01,2.046443772065714428e-01,2.080496648615525468e-01,2.115127806526110321e-01,2.150347358642833162e-01,2.186165601150520110e-01,2.222593016999944437e-01,2.259640279397615026e-01,2.297318255360111527e-01,2.335638009333655118e-01,2.374610806880218528e-01,2.414248118430903367e-01,2.454561623107829604e-01,2.495563212615323767e-01,2.537264995201579665e-01,2.579679299691617356e-01,2.622818679592666680e-01,2.666695917272857708e-01,2.711324028214218140e-01,2.756716265340913852e-01,2.802886123423771192e-01,2.849847343561678348e-01,2.897613917741431733e-01,2.946200093475955240e-01,2.995620378522840799e-01,3.045889545683015398e-01,3.097022637681209889e-01,3.149034972128281762e-01,3.201942146566767455e-01,3.255760043599758569e-01,3.310504836104376514e-01,3.366192992529750683e-01,3.422841282280857378e-01,3.480466781187878667e-01,3.539086877062350700e-01,3.598719275339645196e-01,3.659382004808863220e-01,3.721093423429769342e-01,3.783872224237211923e-01,3.847737441332975683e-01,3.912708455965089871e-01,3.978805002694305593e-01,4.046047175647635719e-01,4.114455434858346750e-01,4.184050612692277737e-01,4.254853920359268904e-01,4.326886954509403527e-01,4.400171703912871823e-01,4.474730556222202282e-01,4.550586304815923411e-01,4.627762155721661386e-01,4.706281734617413504e-01,4.786169093908692052e-01,4.867448719879682306e-01,4.950145539915722370e-01,5.034284929794621277e-01,5.119892721043808326e-01,5.206995208359898042e-01,5.295619157087373408e-01,5.385791810752249553e-01,5.477540898646477974e-01,5.570894643458553785e-01,5.665881768945115748e-01,5.762531507638217754e-01,5.860873608582234384e-01,5.960938345093977908e-01,6.062756522539298754e-01,6.166359486118423439e-01,6.271779128652412716e-01,6.379047898361727142e-01,6.488198806627990534e-01,6.599265435728927098e-01,6.712281946535845201e-01,6.827283086162416748e-01,6.944304195552599701e-01,7.063381216994711886e-01,7.184550701548018115e-01,7.307849816366919216e-01,7.433316351907169883e-01,7.560988728997416475e-01,7.690906005758404440e-01,7.823107884350707364e-01,7.957634717531339996e-01,8.094527514997496009e-01,8.233827949495321485e-01,8.375578362669381383e-01,8.519821770627601376e-01,8.666601869194922036e-01,8.815963038826954978e-01,8.967950349153811507e-01,9.122609563122110465e-01,9.279987140701473347e-01,9.440130242120291504e-01,9.603086730592874654e-01,9.768905174498760946e-01,9.937634848972090040e-01,1.010932573685746627e+00,1.028402852898552045e+00,1.046179462371998214e+00,1.064267612572416200e+00,1.082672584389353876e+00,1.101399728839711933e+00,1.120454466676846117e+00,1.139842287898318540e+00,1.159568751145760412e+00,1.179639482989927934e+00,1.200060177093747349e+00,1.220836593245740787e+00,1.241974556255923012e+00,1.263479954705877262e+00,1.285358739544316231e+00,1.307616922519046376e+00,1.330260574435886856e+00,1.353295823234650141e+00,1.376728851871862114e+00,1.400565895999475785e+00,1.424813241428411370e+00,1.449477221365225166e+00,1.474564213409889524e+00,1.500080636302012937e+00,1.526032946402504642e+00,1.552427633897172754e+00,1.579271218708176105e+00,1.606570246098891097e+00,1.634331281957177584e+00,1.662560907741566618e+00,1.691265715074442566e+00,1.720452299965774534e+00,1.750127256650512830e+00,1.780297171022268587e+00,1.810968613645578040e+00,1.842148132328442545e+00,1.873842244236628929e+00,1.906057427530720716e+00,1.938800112506665174e+00,1.972076672220138382e+00,2.005893412575010082e+00,2.040256561855706252e+00,2.075172259683421228e+00,2.110646545375764571e+00,2.146685345689690827e+00,2.183294461927379082e+00,2.220479556385063891e+00,2.258246138124987645e+00,2.296599548051075690e+00,2.335544943269384888e+00,2.375087280714872850e+00,2.415231300027103511e+00,2.455981505658080710e+00,2.497342148196652900e+00,2.539317204895212843e+00,2.581910359385761744e+00,2.625124980574231603e+00,2.668964100703594244e+00,2.713430392578795036e+00,2.758526145948587693e+00,2.804253243042153176e+00,2.850613133261431287e+00,2.897606807033109799e+00,2.945234768828072003e+00,2.993497009359738392e+00,3.042392976977233765e+00,3.091921548273762088e+00,3.142080997935674525e+00,3.192868967863012220e+00,3.244282435598311309e+00,3.296317682106220559e+00,3.348970258953660739e+00,3.402234954946830481e+00,3.456105762288958161e+00,3.510575842330688978e+00,3.565637490993029957e+00,3.621282103951722231e+00,3.677500141680707380e+00,3.734281094461939787e+00,3.791613447478570098e+00,3.849484646118474629e+00,3.907881061625509300e+00,3.966787957246513674e+00,4.026189455032635145e+00,4.086068503464530544e+00,4.146406846081783115e+00,4.207184991307862276e+00,4.268382183672392749e+00,4.329976376643290159e+00,4.391944207291287761e+00,4.454260973019143144e+00,4.516900610597045507e+00,4.579835677754127587e+00,4.643037337583664659e+00,4.706475346026224749e+00,4.770118042700501881e+00,4.833932345355950844e+00,4.897883748223877731e+00,4.961936324545377808e+00,5.026052733553082241e+00,5.090194232182111200e+00,5.154320691780461594e+00,5.218390620082403508e+00,5.282361188698954102e+00,5.346188266368861797e+00,5.409826458197398047e+00,5.473229151095134526e+00,5.536348565607567274e+00,5.599135814304829317e+00,5.661540966874626157e+00,5.723513122033231149e+00,5.785000486338763181e+00,5.845950459956547718e+00,5.906309729390097907e+00,5.966024367152820140e+00,6.025039938314055377e+00,6.083301613810294661e+00,6.140754290367976154e+00,6.197342716838002197e+00,6.253011626695808012e+00,6.307705876412796009e+00,6.361370589358657845e+00,6.413951304845965318e+00,6.465394131883804185e+00,6.515645907162101125e+00,6.564654356746354225e+00,6.612368260923074281e+00,6.658737621599863488e+00,6.703713831631449516e+00,6.747249845415435487e+00,6.789300350077581925e+00,6.829821936549073769e+00,6.868773269826016659e+00,6.906115257695478071e+00,6.941811217212561225e+00,6.975827038220845822e+00,7.008131343221906562e+00,7.038695642921020124e+00,7.067494486803623133e+00,7.094505608131965957e+00,7.119710062792245608e+00,7.143092361469690843e+00,7.164640594682527563e+00,7.184346550263419395e+00,7.202205822940520363e+00,7.218217915736707013e+00,7.232386332975804244e+00,7.244718664756947923e+00,7.255226662832103379e+00,7.263926307895670398e+00,7.270837868369061319e+00,7.275985950834923166e+00,7.279399542345210250e+00,7.281112044892203983e+00,7.281161302392844981e+00,7.279589620590876109e+00,7.276443780328224697e+00,7.271775044676726196e+00,7.265639160450514389e+00,7.258096354637841863e+00,7.249211326299509039e+00,7.239053234474384091e+00,7.227695682613259898e+00,7.215216700027854202e+00,7.201698720789518227e+00,7.187228560444302694e+00,7.171897390822072893e+00,7.155800713109267797e+00,7.139038329224320023e+00,7.121714311380642037e+00,7.103936969543244828e+00,7.085818816278483645e+00,7.067476528262688795e+00,7.049030903448891827e+00,7.030606812595157962e+00,7.012333143524942081e+00,6.994342736124050219e+00,6.976772305673952346e+00,6.959762351679501080e+00,6.943457048868744153e+00,6.928004116524268952e+00,6.913554661750660024e+00,6.900262991694827264e+00,6.888286389118256636e+00,6.877784845081689191e+00,6.868920741851252565e+00,6.861858478484403001e+00,6.856764030922177788e+00,6.853804437821383821e+00,6.853147202835775609e+00,6.854959603631439968e+00,6.859407897639864693e+00,6.866656414460371671e+00,6.876866524978397344e+00,6.890195477731078988e+00,6.906795093898770332e+00,6.926810313608638303e+00,6.950377588087705227e+00,6.977623114681660077e+00,7.008660914947173914e+00,7.043590760001873008e+00,7.082495952142321194e+00,7.125440977450059776e+00,7.172469050708071947e+00,7.223599581401083825e+00,7.278825597781581003e+00,7.338111174778155110e+00,7.401388920665243454e+00,7.468557586562128314e+00,7.539479871564614299e+00,7.613980504108552871e+00,7.691844686428447986e+00,7.772816993039000089e+00,7.856600815351259648e+00,7.942858442157097798e+00,8.031211859183503776e+00,8.121244339755444130e+00,8.212502882564582052e+00,8.304501531618507570e+00,8.396725587997162066e+00,8.488636693765039709e+00,8.579678736382636117e+00,8.669284488661762822e+00,8.756882866465682369e+00,8.841906655889452793e+00,8.923800535555001190e+00,9.002029199795902770e+00,9.076085376486529910e+00,9.145497530256573526e+00,9.209837048421006145e+00,9.268724723102115703e+00,9.321836368003108220e+00,9.368907440765617878e+00,9.409736579936259560e+00,9.444188007036530053e+00,9.472192786656687957e+00,9.493748978470575750e+00,9.508920752393633435e+00,9.517836569942254243e+00,9.520686559824573791e+00,9.517719233059166228e+00,9.509237692155577903e+00,9.495595490259919558e+00,9.477192290217617554e+00,9.454469461066475233e+00,9.427905731538402279e+00,9.398012997756204356e+00,9.365332356444545425e+00,9.330430406478944505e+00,9.293895831138573982e+00,9.256336241467090886e+00,9.218375227960702745e+00,9.180649533535419238e+00,9.143806225478270377e+00,9.108499708053594546e+00,9.075388381072691857e+00,9.045130714007148853e+00,9.018380471865155457e+00,8.995780800901162166e+00,8.977956863578009816e+00,8.965506709109790862e+00,8.958990086421783516e+00,8.958914960459621213e+00,8.965721591931183454e+00,8.979764196571814239e+00,9.001290422957755055e+00,9.030419182893705710e+00,9.067117731382726475e+00,9.111179305788136062e+00,9.162203058578215931e+00,9.219578395579596020e+00,9.282476081823052283e+00,9.349848506949054894e+00,9.420441222252128100e+00,9.492817209604902828e+00,9.565394311484492817e+00,9.636494912429382609e+00,9.704405474569242074e+00,9.767442126032484850e+00,9.824017446158142874e+00,9.872703121708511276e+00,9.912283405772789990e+00,9.941795296676893656e+00,9.960552917219704483e+00,9.968155444893392669e+00,9.964479797839803865e+00,9.949660819373546516e+00,9.924062714266987939e+00,9.888245882660919861e+00,9.842933102605639917e+00,9.788978351054719695e+00,9.727340595561166481e+00,9.659063812267509874e+00,9.585263443480913637e+00,9.507118611578269096e+00,9.425868717640767613e+00,9.342812587416567283e+00,9.259308055829633233e+00,9.176769743105927191e+00,9.096662690180785660e+00,9.020489408278200116e+00,8.949767704628591503e+00,8.885996382454990794e+00,8.830605690755557902e+00,8.784889474416537780e+00,8.749916775095964994e+00,8.726422736938081570e+00,8.714682690543813948e+00,8.714379587148817663e+00,8.724483170144033295e+00,8.743167735764187043e+00,8.767800729853325592e+00,8.795032246040584312e+00,8.821001841014817657e+00,8.841653631204392738e+00,8.853119130863808195e+00,8.852101170662701080e+00,8.836183871854084160e+00,8.804009172911127834e+00,8.755295054364715668e+00,8.690710692557390260e+00,8.611654262100557844e+00,8.519991358953499017e+00,8.417806566568708959e+00,8.307204475369479368e+00,8.190177758887958959e+00,8.068544500236805916e+00,7.943947022740166730e+00,7.817899399071538191e+00,7.691868683642894666e+00,7.567373719696007583e+00,7.446083627750327061e+00,7.329894994974323730e+00,7.220962226882359225e+00,7.121650088217442942e+00,7.034373002485503790e+00,6.961286683968350708e+00,6.903813254127785903e+00,6.862025354409414746e+00,6.834000539094287063e+00,6.815374654987656378e+00,6.799409517551695536e+00,6.777828723638050334e+00,6.742379629195706769e+00,6.686648269698929781e+00,6.607401440536063042e+00,6.504921978322090403e+00,6.382333260318238111e+00,6.244369617352263369e+00,6.096150228700314422e+00,5.942311416504465704e+00,5.786582654155847827e+00,5.631720637599243240e+00,5.479667156767984437e+00,5.331819699189256134e+00,5.189345854526624002e+00,5.053503856128381599e+00,4.925940295773807875e+00,4.808917301882154050e+00,4.705370950474016212e+00,4.618620889455383960e+00,4.551468626889074720e+00,4.504458469939324416e+00,4.473494693441884884e+00,4.448036933367712997e+00,4.412153679162700293e+00,4.349828145432644178e+00,4.252062742607497725e+00,4.120434868641010162e+00,3.964643602155061952e+00,3.796994191664775808e+00,3.628009210460608092e+00,3.464710956505624218e+00,3.310841123810986719e+00,3.167852408490075877e+00,3.035971511531964317e+00,2.915100656438236904e+00,2.805560817447973143e+00,2.708735346733127880e+00,2.627597683502874037e+00,2.566859825101112769e+00,2.531939543080930832e+00,2.525209227927327493e+00,2.538525847388012124e+00,2.546666396546271915e+00,2.515026490408437621e+00,2.424482083604630578e+00,2.285776571243644195e+00,2.125870699429293520e+00,1.968285449167867185e+00,1.826122506271679269e+00,1.704188465161830424e+00,1.602731451061865986e+00,1.520078649897381506e+00,1.454252951501963764e+00,1.404180319249615838e+00,1.370922093232872729e+00,1.359014621747701490e+00,1.377042477799682807e+00,1.433528450175018953e+00,1.519632145269110834e+00,1.584924302646769867e+00,1.566156919737646813e+00,1.466010161934174771e+00,1.338897485577849933e+00,1.224794510158476735e+00,1.136627534280441720e+00,1.074298867753504139e+00,1.034441652332996231e+00,1.014024523375070652e+00,1.011389274707795938e+00,1.026994105121321610e+00,1.065180315000350264e+00,1.137307678733987970e+00,1.260615190221634707e+00,1.423559434490430764e+00,1.518669556052892888e+00,1.473275440022423721e+00,1.379621716114117547e+00,1.310461047722130346e+00,1.275440758735585822e+00,1.266241518540361044e+00,1.274780602424514520e+00,1.296488119382064541e+00,1.330451804012689143e+00,1.380005969096724794e+00,1.456205795170006256e+00,1.585746182254813119e+00,1.789463328464005354e+00,1.916505078363759607e+00,1.854563362613594002e+00,1.786694872317738492e+00,1.765804849684211586e+00,1.774491049294073530e+00,1.796677574184149861e+00,1.823897165694082778e+00,1.853884890895103332e+00,1.889930178500934810e+00,1.944194071605660712e+00,2.053458459173319817e+00,2.261649580395814318e+00,2.286259098475774021e+00,2.178675352367300810e+00,2.142649722484142316e+00,2.147675043887137480e+00,2.164541773248396250e+00,2.177606163744557843e+00,2.181423941446312131e+00,2.179518289870422176e+00,2.186660864966971651e+00,2.255158219514517448e+00,2.424408481335913024e+00,2.272593007173665747e+00,2.177539551826238373e+00,2.149771615859254581e+00,2.142975470093402723e+00,2.134387440773473532e+00,2.111629715349844894e+00,2.073376809141121768e+00,2.031925985810380642e+00,2.050014411487568022e+00,2.122442313231660549e+00,1.901535578000885129e+00,1.818403151723315903e+00,1.779002143024479565e+00,1.751579745624661566e+00,1.715922088092996844e+00,1.663441072409076682e+00,1.599439205790184282e+00,1.565727277859941147e+00,1.612310976792155959e+00,1.383287954454023305e+00,1.299159700221168556e+00,1.253908229663463381e+00,1.223710078130546774e+00,1.186193269195744193e+00,1.134303739761665764e+00,1.079878517306884778e+00,1.178332293834059463e+00,9.625285639949897609e-01,8.851185636671964341e-01,8.489719519837315431e-01,8.359778846719300160e-01,8.212409969558639444e-01,7.940770163506205570e-01,7.687957863418226623e-01,8.899229272678035318e-01,7.129129021908870989e-01,6.915254415571125968e-01,6.998262811849145226e-01,7.255691205688250545e-01,7.356686926822498807e-01,7.311321295507522411e-01,7.847525854497955367e-01,7.475729294994902796e-01,7.610326708151018416e-01,7.969325094899504247e-01,8.548021957867191212e-01,8.971404537560679904e-01,9.063217881534453291e-01,9.935244436557728598e-01,9.396590327892549999e-01,9.741071698085532748e-01,1.027449406290320999e+00,1.101235461874237043e+00,1.142418277722037301e+00,1.138814660068548257e+00,1.140389413794488327e+00,1.147720815238148395e+00,1.173541243201270623e+00,1.221488715067933661e+00,1.278577806856491916e+00,1.267471416143046037e+00,1.237065807883966029e+00,1.205512888417914930e+00,1.192665311929050231e+00,1.197911753988686323e+00,1.231977000419564039e+00,1.202653687975261176e+00,1.139636662652281363e+00,1.087045338753395374e+00,1.042662596452621715e+00,1.014929000627767808e+00,1.025123776322035773e+00,9.646891061543381163e-01,8.895490153201816019e-01,8.366531286586023075e-01,7.873968794936503368e-01,7.600897244945408193e-01,7.526274344562058349e-01,6.712567145962370363e-01,6.280934622556036961e-01,5.997798431402170394e-01,5.740840671348590440e-01,5.955424227101829837e-01,5.372993072885473564e-01,5.085440114639332432e-01,5.158865668882360866e-01,5.216899396152523405e-01,5.624205399127776284e-01,5.425471740675752441e-01,5.332370555916164934e-01,5.675895724472427295e-01,6.013422225200814042e-01,6.674448062338342869e-01,6.562452647123838689e-01,6.673156889394813440e-01,7.102486859021754917e-01,7.451435156326343678e-01,8.247884674869052635e-01,7.888045053156524933e-01,8.061034539639199137e-01,8.296435806249572442e-01,8.435005837122351302e-01,8.551331687631444911e-01,8.358735187865746763e-01,8.393851982154122426e-01,8.187087119091216447e-01,8.401197543509585364e-01,7.657920730365798123e-01,7.508263963910092320e-01,7.189647756862329597e-01,6.885910709845599609e-01,6.227413796426488624e-01,5.980386037486531414e-01,5.753943047859191307e-01,5.282211608071198938e-01,4.768319490950545525e-01,4.585132665511530980e-01,4.582815727393892979e-01,4.308077472737184554e-01,4.015605437985086401e-01,4.047212673910911551e-01,4.277056556660817077e-01,4.568577183674872311e-01,4.295300599031842137e-01,4.590797303894100789e-01,4.886739919705078150e-01,5.061372965746743224e-01,5.309584519446792772e-01,5.745964067853932544e-01,5.832936301317118710e-01,6.026482680429495753e-01,6.255398784235532972e-01,6.481890538866176277e-01,6.294617157611017699e-01,6.334655615401925122e-01,6.434846813418890754e-01,6.067699257123151391e-01,5.790075198549858859e-01,5.609928930752995369e-01,5.397702392229905000e-01,4.861398641328858461e-01,4.569410119887090116e-01,4.501532261699614512e-01,3.938457895707645484e-01,3.728305702048046455e-01,3.690251928155652839e-01,3.401350764291020679e-01,3.424725739283499548e-01,3.459202122098165577e-01,3.468289651458203449e-01
+6.545775035328707178e-03,6.651612140085098358e-03,6.759162555737761348e-03,6.868454069790015312e-03,6.979514921632567169e-03,7.092373809915983145e-03,7.207059900043563151e-03,7.323602831786896541e-03,7.442032727025704730e-03,7.562380197614366334e-03,7.684676353376974911e-03,7.808952810232904287e-03,7.935241698455454060e-03,8.063575671065111375e-03,8.193987912360240974e-03,8.326512146586898325e-03,8.461182646750376596e-03,8.598034243570588236e-03,8.737102334583791291e-03,8.878422893392759474e-03,9.022032479068142069e-03,9.167968245703093585e-03,9.316267952123898424e-03,9.466969971759154473e-03,9.620113302669633729e-03,9.775737577742093370e-03,9.933883075049077319e-03,1.009459072837765210e-02,1.025790213792978842e-02,1.042385958119714136e-02,1.059250602401280369e-02,1.076388513178338537e-02,1.093804128090356334e-02,1.111501957035679507e-02,1.129486583350473514e-02,1.147762665006817756e-02,1.166334935830326026e-02,1.185208206737529968e-02,1.204387366993381510e-02,1.223877385489203183e-02,1.243683312041365778e-02,1.263810278711057639e-02,1.284263501145493230e-02,1.305048279940836282e-02,1.326170002027258175e-02,1.347634142076422660e-02,1.369446263931787394e-02,1.391612022062046518e-02,1.414137163038112731e-02,1.437027527033977840e-02,1.460289049351849201e-02,1.483927761971918016e-02,1.507949795127170277e-02,1.532361378903596139e-02,1.557168844866238348e-02,1.582378627711410884e-02,1.607997266945589143e-02,1.634031408591281667e-02,1.660487806920364628e-02,1.687373326215299563e-02,1.714694942558599167e-02,1.742459745651076322e-02,1.770674940659215310e-02,1.799347850092161694e-02,1.828485915708780857e-02,1.858096700455232064e-02,1.888187890433485824e-02,1.918767296901320585e-02,1.949842858304212320e-02,1.981422642339615917e-02,2.013514848054105341e-02,2.046127807973907933e-02,2.079269990269283497e-02,2.112950000953230101e-02,2.147176586115095639e-02,2.181958634189542362e-02,2.217305178261396933e-02,2.253225398406927607e-02,2.289728624072044985e-02,2.326824336487999870e-02,2.364522171125075026e-02,2.402831920184827011e-02,2.441763535131459203e-02,2.481327129262835690e-02,2.521532980321707432e-02,2.562391533147755085e-02,2.603913402370946345e-02,2.646109375146822942e-02,2.688990413934335549e-02,2.732567659316719952e-02,2.776852432866054599e-02,2.821856240052126111e-02,2.867590773196112761e-02,2.914067914469738174e-02,2.961299738940533985e-02,3.009298517663730813e-02,3.058076720821446479e-02,3.107647020909792140e-02,3.158022295974485111e-02,3.209215632895562331e-02,3.261240330721913716e-02,3.314109904056152661e-02,3.367838086490492627e-02,3.422438834094290727e-02,3.477926328953803714e-02,3.534314982764850954e-02,3.591619440479038028e-02,3.649854584004052355e-02,3.709035535958820490e-02,3.769177663483939261e-02,3.830296582108325826e-02,3.892408159672310769e-02,3.955528520308202595e-02,4.019674048478566464e-02,4.084861393073180302e-02,4.151107471564947915e-02,4.218429474225723202e-02,4.286844868402244629e-02,4.356371402853199265e-02,4.427027112147643995e-02,4.498830321125604076e-02,4.571799649421246642e-02,4.645954016049468061e-02,4.721312644055829233e-02,4.797895065231476408e-02,4.875721124892063579e-02,4.954810986722883032e-02,5.035185137689067447e-02,5.116864393012818951e-02,5.199869901216791490e-02,5.284223149235334205e-02,5.369945967592825581e-02,5.457060535650708200e-02,5.545589386922294972e-02,5.635555414457181500e-02,5.726981876294053725e-02,5.819892400983731062e-02,5.914310993181206427e-02,6.010262039308445631e-02,6.107770313286826902e-02,6.206860982340317578e-02,6.307559612869109711e-02,6.409892176393965080e-02,6.513885055571246030e-02,6.619565050278818086e-02,6.726959383772475320e-02,6.836095708913504654e-02,6.947002114466210854e-02,7.059707131466302910e-02,7.174239739659364623e-02,7.290629374008951447e-02,7.408905931274641088e-02,7.529099776658787491e-02,7.651241750522393137e-02,7.775363175168582830e-02,7.901495861693966227e-02,8.029672116906598489e-02,8.159924750309911767e-02,8.292287081151882011e-02,8.426792945538170987e-02,8.563476703608589868e-02,8.702373246775359228e-02,8.843518005022130146e-02,8.986946954262226006e-02,9.132696623754876786e-02,9.280804103577584840e-02,9.431307052153059534e-02,9.584243703828780603e-02,9.739652876507338963e-02,9.897573979325198501e-02,1.005804702037792764e-01,1.022111261448915981e-01,1.038681199102087643e-01,1.055518700172233260e-01,1.072628012861438912e-01,1.090013449190661426e-01,1.107679385794346216e-01,1.125630264717626811e-01,1.143870594215729564e-01,1.162404949555206068e-01,1.181237973816561537e-01,1.200374378697862676e-01,1.219818945318877773e-01,1.239576525025214149e-01,1.259652040192042743e-01,1.280050485026763829e-01,1.300776926370151299e-01,1.321836504495326470e-01,1.343234433903953418e-01,1.364976004119049791e-01,1.387066580473664823e-01,1.409511604894784775e-01,1.432316596681663945e-01,1.455487153277821022e-01,1.479028951035901707e-01,1.502947745974543003e-01,1.527249374526335191e-01,1.551939754275959427e-01,1.577024884687552031e-01,1.602510847820236284e-01,1.628403809030825045e-01,1.654710017662534283e-01,1.681435807718598685e-01,1.708587598519576423e-01,1.736171895343124327e-01,1.764195290044922315e-01,1.792664461659420061e-01,1.821586176978997884e-01,1.850967291110129087e-01,1.880814748004975834e-01,1.911135580966906999e-01,1.941936913128304021e-01,1.973225957898988581e-01,2.005010019383480779e-01,2.037296492765375555e-01,2.070092864656880027e-01,2.103406713411669904e-01,2.137245709399001048e-01,2.171617615237075027e-01,2.206530285983472062e-01,2.241991669280544996e-01,2.278009805453430903e-01,2.314592827558349386e-01,2.351748961378924141e-01,2.389486525367809366e-01,2.427813930531349251e-01,2.466739680254447786e-01,2.506272370063086230e-01,2.546420687321694354e-01,2.587193410862547172e-01,2.628599410544336656e-01,2.670647646736871716e-01,2.713347169729009023e-01,2.756707119056591160e-01,2.800736722747312890e-01,2.845445296479315878e-01,2.890842242650166760e-01,2.936937049352927320e-01,2.983739289255981086e-01,3.031258618383077530e-01,3.079504774790244315e-01,3.128487577135944941e-01,3.178216923141080619e-01,3.228702787935087137e-01,3.279955222284720584e-01,3.331984350701804876e-01,3.384800369426415045e-01,3.438413544281961887e-01,3.492834208398404860e-01,3.548072759800341980e-01,3.604139658856264083e-01,3.661045425585653934e-01,3.718800636820513983e-01,3.777415923218129801e-01,3.836901966121889496e-01,3.897269494267023293e-01,3.958529280328596522e-01,4.020692137308942704e-01,4.083768914761958246e-01,4.147770494852203726e-01,4.212707788246560781e-01,4.278591729836997426e-01,4.345433274292721526e-01,4.413243391440968555e-01,4.482033061475648728e-01,4.551813269993687516e-01,4.622595002859337665e-01,4.694389240897361981e-01,4.767206954416398079e-01,4.841059097564701097e-01,4.915956602520950569e-01,4.991910373523715805e-01,5.068931280743914636e-01,5.147030154005579616e-01,5.226217776361298251e-01,5.306504877529483188e-01,5.387902127202219837e-01,5.470420128233272061e-01,5.554069409717445893e-01,5.638860419973850124e-01,5.724803519447262401e-01,5.811908973543286061e-01,5.900186945415112350e-01,5.989647488721299151e-01,6.080300540376363250e-01,6.172155913318045917e-01,6.265223289317516375e-01,6.359512211861403363e-01,6.455032079137178469e-01,6.551792137156566831e-01,6.649801473054285372e-01,6.749069008603234554e-01,6.849603493990723546e-01,6.951413501903561665e-01,7.054507421974556269e-01,7.158893455646564430e-01,7.264579611515519231e-01,7.371573701217384311e-01,7.479883335930588295e-01,7.589515923569554179e-01,7.700478666751426893e-01,7.812778561623445750e-01,7.926422397645778162e-01,8.041416758429709155e-01,8.157768023740049612e-01,8.275482372776356010e-01,8.394565788856560573e-01,8.515024065634487771e-01,8.636862814990949877e-01,8.760087476748340540e-01,8.884703330366916507e-01,9.010715508792145334e-01,9.138129014632212499e-01,9.266948738856471968e-01,9.397179482216506674e-01,9.528825979604088614e-01,9.661892927572758305e-01,9.796385015262614182e-01,9.932306958981894640e-01,1.006966354071334058e+00,1.020845965082739504e+00,1.034870033530049582e+00,1.049039084775207797e+00,1.063353670663063966e+00,1.077814375789584833e+00,1.092421824356179849e+00,1.107176687648363966e+00,1.122079692178936217e+00,1.137131628537632722e+00,1.152333360991206312e+00,1.167685837879818278e+00,1.183190102857668569e+00,1.198847307027637754e+00,1.214658722021935588e+00,1.230625754082552259e+00,1.246749959197423374e+00,1.263033059350040954e+00,1.279476959942232428e+00,1.296083768451558926e+00,1.312855814386413966e+00,1.329795670603582503e+00,1.346906176054227355e+00,1.364190460025464180e+00,1.381651967945535464e+00,1.399294488821046567e+00,1.417122184374888461e+00,1.435139619953025747e+00,1.453351797267386836e+00,1.471764189040430271e+00,1.490382775614474742e+00,1.509214083585568744e+00,1.528265226516981601e+00,1.547543947781801377e+00,1.567058665576809062e+00,1.586818520140531819e+00,1.606833423197897348e+00,1.627114109640019457e+00,1.647672191432223210e+00,1.668520213724084655e+00,1.689671713113233942e+00,1.711141277987864306e+00,1.732944610842705124e+00,1.755098592426516335e+00,1.777621347538475227e+00,1.800532312241761357e+00,1.823852302208094356e+00,1.847603581842701237e+00,1.871809933767252687e+00,1.896496728154838607e+00,1.921690991317867692e+00,1.947421472842856938e+00,1.973718710447072366e+00,2.000615091597195416e+00,2.028144910780790511e+00,2.056344421154089552e+00,2.085251879105936901e+00,2.114907580074088855e+00,2.145353883729562927e+00,2.176635226403105694e+00,2.208798118370436825e+00,2.241891123335814751e+00,2.275964817164157328e+00,2.311071722608417200e+00,2.347266216471068034e+00,2.384604405327760190e+00,2.423143965640979225e+00,2.462943943807658798e+00,2.504064511435979412e+00,2.546566670944701460e+00,2.590511906448599078e+00,2.635961774855250628e+00,2.682977432184040278e+00,2.731619090355683177e+00,2.781945400129704815e+00,2.834012756523009102e+00,2.887874523971201590e+00,2.943580179732832480e+00,3.001174375632455149e+00,3.060695920222786359e+00,3.122176685856544953e+00,3.185640448006436198e+00,3.251101667467263923e+00,3.318564229789607634e+00,3.388020160389933366e+00,3.459448338165989512e+00,3.532813235005493269e+00,3.608063713133495387e+00,3.685131916595739909e+00,3.763932297052343223e+00,3.844360817167964850e+00,3.926294376891615201e+00,4.009590508486047256e+00,4.094087384947102670e+00,4.179604183156556907e+00,4.265941837493598676e+00,4.352884211572098039e+00,4.440199705265152730e+00,4.527643301408851961e+00,4.614959041885513535e+00,4.701882906728764411e+00,4.788146053180996731e+00,4.873478355145104857e+00,4.957612168166223299e+00,5.040286231949113294e+00,5.121249612401168605e+00,5.200265579088307000e+00,5.277115312385180168e+00,5.351601337790859780e+00,5.423550592844809337e+00,5.492817044456179687e+00,5.559283790581502238e+00,5.622864599121005114e+00,5.683504857533583809e+00,5.741181927794213991e+00,5.795904921739580828e+00,5.847713930481127420e+00,5.896678757507180180e+00,5.942897217681891497e+00,5.986493073187156178e+00,6.027613682419753260e+00,6.066427439076560013e+00,6.103121076470355177e+00,6.137896907005715441e+00,6.170970059295832755e+00,6.202565766243196776e+00,6.232916747158515847e+00,6.262260716222530554e+00,6.290838038798569620e+00,6.318889546681058178e+00,6.346654513623142257e+00,6.374368783639398295e+00,6.402263036761050685e+00,6.430561170207056421e+00,6.459478767352475614e+00,6.489221622441975867e+00,6.519984285720656025e+00,6.551948591578105940e+00,6.585282131501767999e+00,6.620136634255098684e+00,6.656646217944593324e+00,6.694925482812681850e+00,6.735067420064468457e+00,6.777141121250121358e+00,6.821189285175172756e+00,6.867225535493329147e+00,6.915231582484880235e+00,6.965154287312312675e+00,7.016902716259215467e+00,7.070345305644739398e+00,7.125307294175266648e+00,7.181568616556187834e+00,7.238862487366403364e+00,7.296874933564380328e+00,7.355245552588097979e+00,7.413569775086560121e+00,7.471402890835267208e+00,7.528266047802426364e+00,7.583654353666774206e+00,7.637047095189037904e+00,7.687919946624578671e+00,7.735758871776239332e+00,7.780075248630725859e+00,7.820421578825540898e+00,7.856407007457608671e+00,7.887711793076514155e+00,7.914099850740699438e+00,7.935428553275567509e+00,7.951655117903553283e+00,7.962839116518792615e+00,7.969140906947371761e+00,7.970816061019649013e+00,7.968206131740082299e+00,7.961726327101290579e+00,7.951850819877759768e+00,7.939096508794671436e+00,7.924006055594873921e+00,7.907130963546965319e+00,7.889015352059542074e+00,7.870180939435455159e+00,7.851113592000484864e+00,7.832251651066064468e+00,7.813976123360762749e+00,7.796602724548193919e+00,7.780375703105644192e+00,7.765463342702737748e+00,7.751955041447829764e+00,7.739859889687269678e+00,7.729106706564355278e+00,7.719545540389077587e+00,7.710950679621597637e+00,7.703025250416426495e+00,7.695407484157500200e+00,7.687678716503393517e+00,7.679373123004733515e+00,7.669989104430166016e+00,7.659002112702713916e+00,7.645878568636327088e+00,7.630090386648882728e+00,7.611129517707315273e+00,7.588521881862385854e+00,7.561840114612246033e+00,7.530714713186196896e+00,7.494843432624450408e+00,7.453999107745412189e+00,7.408036389937700861e+00,7.356898081283742563e+00,7.300621707271558236e+00,7.239346604393209539e+00,7.173321095750802456e+00,7.102908391464651139e+00,7.028588924364263413e+00,6.950956260528056596e+00,6.870703851891756919e+00,6.788600913115049096e+00,6.705457506203792661e+00,6.622081080433990685e+00,6.539228616905776725e+00,6.457559582044804181e+00,6.377594803653417799e+00,6.299685248918964753e+00,6.223992936672370746e+00,6.150484406829685113e+00,6.078935746443927535e+00,6.008947348050038606e+00,5.939966325385971579e+00,5.871314651549847774e+00,5.802221389921729866e+00,5.731857682166830337e+00,5.659373359415496019e+00,5.583934169570836659e+00,5.504758750116755195e+00,5.421154721534024112e+00,5.332553685387309450e+00,5.238545433059937473e+00,5.138912110221766305e+00,5.033663091706703341e+00,4.923070460107987323e+00,4.807702861472143319e+00,4.688452058661489730e+00,4.566542288693206331e+00,4.443509020664276221e+00,4.321133138559644316e+00,4.201321146743287827e+00,4.085932511129195532e+00,3.976569837436138677e+00,3.874361757524801053e+00,3.779776917400801128e+00,3.692507079400182857e+00,3.611448204315293342e+00,3.534793010136502822e+00,3.460229744561166942e+00,3.385222087714080175e+00,3.307327334142541986e+00,3.224499445257273056e+00,3.135325895947721708e+00,3.039164474654894033e+00,2.936173432010428463e+00,2.827255141071684186e+00,2.713949223946340972e+00,2.598310766706585451e+00,2.482794469719725505e+00,2.370142538587123759e+00,2.263250393340746847e+00,2.164967652862119785e+00,2.077791183067878578e+00,2.003432941097875730e+00,1.942307472406109792e+00,1.893079502425315974e+00,1.852504950339916023e+00,1.815804708640355924e+00,1.777637331610079308e+00,1.733405831720858936e+00,1.680368151976779245e+00,1.618088248555278552e+00,1.548155554961512026e+00,1.473488024507761063e+00,1.397633299931218653e+00,1.324318029213147341e+00,1.257269850041009995e+00,1.200186589512865165e+00,1.156657528078725017e+00,1.129805623879168275e+00,1.121417960547891779e+00,1.130492069948044964e+00,1.151701234810600161e+00,1.175257548786983186e+00,1.189852707118349784e+00,1.187974529050161099e+00,1.169512165212747146e+00,1.140502016928898632e+00,1.108845793184936701e+00,1.080940681004165294e+00,1.060838165870340744e+00,1.051121089787808938e+00,1.054206880044948669e+00,1.073247590803899421e+00,1.112067699380003605e+00,1.173285885728197586e+00,1.253526196337031218e+00,1.337347329646801697e+00,1.399550803289412393e+00,1.423693727638664308e+00,1.416991597369906319e+00,1.400145930612125333e+00,1.390032558058597711e+00,1.394423904049839180e+00,1.414919385880746283e+00,1.450899891790288665e+00,1.502525594852744728e+00,1.572729006047391964e+00,1.666721192533456408e+00,1.783142792974018009e+00,1.892798966809883465e+00,1.943814829106240261e+00,1.929540100052813401e+00,1.894114804467730284e+00,1.870193901185142726e+00,1.866312989058946270e+00,1.881150765632263022e+00,1.912102539223974329e+00,1.958696086467898390e+00,2.025259205990367573e+00,2.122059525223439103e+00,2.244831438575741966e+00,2.312826211813091781e+00,2.264624316296789619e+00,2.183747905470963424e+00,2.124223223325165222e+00,2.088606949445941829e+00,2.070823275789330786e+00,2.067066472699243818e+00,2.077696476066365872e+00,2.111479860562937017e+00,2.191320672079441145e+00,2.284919907610928558e+00,2.216190016178490652e+00,2.088755408804241931e+00,1.994171737239414099e+00,1.922254446753733470e+00,1.864090513548323669e+00,1.817952184345708933e+00,1.786584854966744684e+00,1.783964501033770800e+00,1.853978168303652252e+00,1.861069744744785703e+00,1.696016406974471424e+00,1.583413697543463172e+00,1.498293535505595964e+00,1.422060967090985839e+00,1.352391917236307473e+00,1.294283869440509438e+00,1.264610516547199026e+00,1.333834868091265724e+00,1.270742976653283840e+00,1.128802680286132620e+00,1.053817330077852388e+00,9.934677289883402374e-01,9.371103922357530980e-01,8.854236529125105726e-01,8.474021060517364923e-01,8.778896774008576598e-01,8.848124783189729170e-01,7.690043697405728462e-01,7.366413131557072447e-01,7.179397305436638899e-01,7.016442116179969490e-01,6.874187453766560374e-01,6.845198081842123194e-01,7.988382192337128984e-01,7.028771810249273555e-01,6.887193247791174588e-01,7.042838847950253500e-01,7.273306857922857693e-01,7.514725781349922418e-01,7.767982139539598707e-01,8.542571520929387319e-01,8.444896310307690168e-01,8.563127710808897675e-01,8.889291281037172698e-01,9.256613550688301828e-01,9.639020464061595073e-01,1.003889268314283267e+00,1.160432486921139983e+00,1.074696272932576635e+00,1.100717331764349494e+00,1.125889168250549410e+00,1.146634153185966065e+00,1.165909466533121108e+00,1.196516751042968840e+00,1.212163621390545121e+00,1.224477128052968267e+00,1.229587419734372800e+00,1.218501245732619198e+00,1.198549481433072383e+00,1.184779480079166447e+00,1.171796602815366795e+00,1.164268284671856168e+00,1.151406584607838068e+00,1.113370291176864368e+00,1.056502833369543648e+00,1.022209046463608439e+00,9.635576658943972861e-01,9.419245842446204442e-01,9.193883756241894023e-01,8.671867429803842287e-01,7.968232503367909114e-01,7.337445393187373988e-01,6.932322834404319734e-01,6.825261131482887045e-01,6.660714600272212849e-01,6.160810026947508566e-01,5.645909565297909660e-01,5.274871405812254777e-01,5.233011825630344838e-01,5.449611513639284199e-01,5.326001989015716198e-01,5.107890893195502491e-01,5.013997460052761479e-01,5.157907627032585207e-01,5.651989213622811148e-01,5.796364434227799789e-01,5.843637319043427647e-01,6.032219055628448290e-01,6.353555126679598652e-01,6.999318809249329698e-01,7.124793381996786801e-01,7.236781434406047708e-01,7.506850473380367594e-01,7.853692706879936702e-01,8.404294162918843902e-01,8.182096038468407162e-01,8.197267608457875498e-01,8.296877016305417296e-01,8.545270001661715575e-01,8.476939923189920068e-01,8.053453806849932839e-01,7.842965338087357630e-01,7.701530885586208575e-01,7.848053955079151711e-01,7.078889580551609439e-01,6.618000998672968205e-01,6.253095281985650011e-01,6.334545850017808677e-01,5.631378714834722743e-01,5.187197105718432955e-01,4.793475608989951064e-01,4.814395472697831635e-01,4.420748458247868995e-01,4.230017026297857585e-01,4.031633830291918574e-01,4.247633214188881734e-01,4.085637526643498552e-01,4.229510378899382639e-01,4.286092256850455584e-01,4.773674664866772721e-01,4.740772355015192563e-01,5.075843305468608069e-01,5.266081509935055527e-01,5.501499283933788398e-01,5.818018078589886066e-01,6.056965638262531426e-01,6.224192905788534791e-01,6.264877141228137880e-01,6.393809223850366319e-01,6.318171838129925666e-01,6.212907029967176253e-01,6.128873496847034863e-01,5.859327217820723410e-01,5.849311768968687986e-01,5.297638977110732394e-01,5.023877946644279557e-01,4.535365830816525667e-01,4.241173280092478959e-01,4.135531771469486140e-01,3.697235478496517791e-01,3.453059245289976098e-01,3.548550744710032290e-01,3.397746744415412468e-01,3.306862924100654744e-01,3.542566276767276645e-01
+3.820375748535051463e-02,3.882586397809122819e-02,3.945817243119797979e-02,4.010085218870074880e-02,4.075407546241004847e-02,4.141801738200714955e-02,4.209285604604721259e-02,4.277877257389544469e-02,4.347595115861003362e-02,4.418457912079380712e-02,4.490484696343189502e-02,4.563694842773285965e-02,4.638108054999638685e-02,4.713744371952288681e-02,4.790624173758912391e-02,4.868768187750800724e-02,4.948197494579370526e-02,5.028933534445549636e-02,5.110998113443961099e-02,5.194413410024283778e-02,5.279201981572129859e-02,5.365386771111533420e-02,5.452991114131582051e-02,5.542038745539779043e-02,5.632553806744015207e-02,5.724560852866469873e-02,5.818084860091312510e-02,5.913151233149181035e-02,6.009785812941044469e-02,6.108014884304163727e-02,6.207865183922853247e-02,6.309363908387043141e-02,6.412538722401296687e-02,6.517417767147482000e-02,6.624029668804051751e-02,6.732403547224719009e-02,6.842569024780126297e-02,6.954556235365312589e-02,7.068395833576396337e-02,7.184119004059896785e-02,7.301757471037813307e-02,7.421343508012137602e-02,7.542909947652345903e-02,7.666490191869185233e-02,7.792118222078821266e-02,7.919828609660693741e-02,8.049656526613285790e-02,8.181637756411234974e-02,8.315808705068182538e-02,8.452206412409239700e-02,8.590868563556956772e-02,8.731833500635464984e-02,8.875140234696697605e-02,9.020828457873104889e-02,9.168938555761617371e-02,9.319511620042870981e-02,9.472589461340895356e-02,9.628214622327499472e-02,9.786430391076406110e-02,9.947280814672082583e-02,1.011081071307785850e-01,1.027706569326915509e-01,1.044609216363611148e-01,1.061793734866152555e-01,1.079264930387929255e-01,1.097027693111876784e-01,1.115086999404054785e-01,1.133447913396966600e-01,1.152115588603146307e-01,1.171095269559676300e-01,1.190392293504123900e-01,1.210012092082645707e-01,1.229960193090750969e-01,1.250242222247435198e-01,1.270863905003295491e-01,1.291831068383292869e-01,1.313149642864804290e-01,1.334825664291680036e-01,1.356865275824941097e-01,1.379274729930879406e-01,1.402060390407198209e-01,1.425228734447971379e-01,1.448786354748132776e-01,1.472739961648258655e-01,1.497096385320332845e-01,1.521862577995380383e-01,1.547045616233634346e-01,1.572652703238090754e-01,1.598691171212245077e-01,1.625168483762819693e-01,1.652092238348282227e-01,1.679470168774070959e-01,1.707310147735260353e-01,1.735620189407624248e-01,1.764408452087941059e-01,1.793683240884381969e-01,1.823453010457929124e-01,1.853726367815681786e-01,1.884512075157024902e-01,1.915819052773470588e-01,1.947656382003240261e-01,1.980033308241430090e-01,2.012959244006731763e-01,2.046443772065714428e-01,2.080496648615525468e-01,2.115127806526110321e-01,2.150347358642833162e-01,2.186165601150520110e-01,2.222593016999944437e-01,2.259640279397615026e-01,2.297318255360111527e-01,2.335638009333655118e-01,2.374610806880218528e-01,2.414248118430903367e-01,2.454561623107829604e-01,2.495563212615323767e-01,2.537264995201579665e-01,2.579679299691617356e-01,2.622818679592666680e-01,2.666695917272857708e-01,2.711324028214218140e-01,2.756716265340913852e-01,2.802886123423771192e-01,2.849847343561678348e-01,2.897613917741431733e-01,2.946200093475955240e-01,2.995620378522840799e-01,3.045889545683015398e-01,3.097022637681209889e-01,3.149034972128281762e-01,3.201942146566767455e-01,3.255760043599758569e-01,3.310504836104376514e-01,3.366192992529750683e-01,3.422841282280857378e-01,3.480466781187878667e-01,3.539086877062350700e-01,3.598719275339645196e-01,3.659382004808863220e-01,3.721093423429769342e-01,3.783872224237211923e-01,3.847737441332975683e-01,3.912708455965089871e-01,3.978805002694305593e-01,4.046047175647635719e-01,4.114455434858346750e-01,4.184050612692277737e-01,4.254853920359268904e-01,4.326886954509403527e-01,4.400171703912871823e-01,4.474730556222202282e-01,4.550586304815923411e-01,4.627762155721661386e-01,4.706281734617413504e-01,4.786169093908692052e-01,4.867448719879682306e-01,4.950145539915722370e-01,5.034284929794621277e-01,5.119892721043808326e-01,5.206995208359898042e-01,5.295619157087373408e-01,5.385791810752249553e-01,5.477540898646477974e-01,5.570894643458553785e-01,5.665881768945115748e-01,5.762531507638217754e-01,5.860873608582234384e-01,5.960938345093977908e-01,6.062756522539298754e-01,6.166359486118423439e-01,6.271779128652412716e-01,6.379047898361727142e-01,6.488198806627990534e-01,6.599265435728927098e-01,6.712281946535845201e-01,6.827283086162416748e-01,6.944304195552599701e-01,7.063381216994711886e-01,7.184550701548018115e-01,7.307849816366919216e-01,7.433316351907169883e-01,7.560988728997416475e-01,7.690906005758404440e-01,7.823107884350707364e-01,7.957634717531339996e-01,8.094527514997496009e-01,8.233827949495321485e-01,8.375578362669381383e-01,8.519821770627601376e-01,8.666601869194922036e-01,8.815963038826954978e-01,8.967950349153811507e-01,9.122609563122110465e-01,9.279987140701473347e-01,9.440130242120291504e-01,9.603086730592874654e-01,9.768905174498760946e-01,9.937634848972090040e-01,1.010932573685746627e+00,1.028402852898552045e+00,1.046179462371998214e+00,1.064267612572416200e+00,1.082672584389353876e+00,1.101399728839711933e+00,1.120454466676846117e+00,1.139842287898318540e+00,1.159568751145760412e+00,1.179639482989927934e+00,1.200060177093747349e+00,1.220836593245740787e+00,1.241974556255923012e+00,1.263479954705877262e+00,1.285358739544316231e+00,1.307616922519046376e+00,1.330260574435886856e+00,1.353295823234650141e+00,1.376728851871862114e+00,1.400565895999475785e+00,1.424813241428411370e+00,1.449477221365225166e+00,1.474564213409889524e+00,1.500080636302012937e+00,1.526032946402504642e+00,1.552427633897172754e+00,1.579271218708176105e+00,1.606570246098891097e+00,1.634331281957177584e+00,1.662560907741566618e+00,1.691265715074442566e+00,1.720452299965774534e+00,1.750127256650512830e+00,1.780297171022268587e+00,1.810968613645578040e+00,1.842148132328442545e+00,1.873842244236628929e+00,1.906057427530720716e+00,1.938800112506665174e+00,1.972076672220138382e+00,2.005893412575010082e+00,2.040256561855706252e+00,2.075172259683421228e+00,2.110646545375764571e+00,2.146685345689690827e+00,2.183294461927379082e+00,2.220479556385063891e+00,2.258246138124987645e+00,2.296599548051075690e+00,2.335544943269384888e+00,2.375087280714872850e+00,2.415231300027103511e+00,2.455981505658080710e+00,2.497342148196652900e+00,2.539317204895212843e+00,2.581910359385761744e+00,2.625124980574231603e+00,2.668964100703594244e+00,2.713430392578795036e+00,2.758526145948587693e+00,2.804253243042153176e+00,2.850613133261431287e+00,2.897606807033109799e+00,2.945234768828072003e+00,2.993497009359738392e+00,3.042392976977233765e+00,3.091921548273762088e+00,3.142080997935674525e+00,3.192868967863012220e+00,3.244282435598311309e+00,3.296317682106220559e+00,3.348970258953660739e+00,3.402234954946830481e+00,3.456105762288958161e+00,3.510575842330688978e+00,3.565637490993029957e+00,3.621282103951722231e+00,3.677500141680707380e+00,3.734281094461939787e+00,3.791613447478570098e+00,3.849484646118474629e+00,3.907881061625509300e+00,3.966787957246513674e+00,4.026189455032635145e+00,4.086068503464530544e+00,4.146406846081783115e+00,4.207184991307862276e+00,4.268382183672392749e+00,4.329976376643290159e+00,4.391944207291287761e+00,4.454260973019143144e+00,4.516900610597045507e+00,4.579835677754127587e+00,4.643037337583664659e+00,4.706475346026224749e+00,4.770118042700501881e+00,4.833932345355950844e+00,4.897883748223877731e+00,4.961936324545377808e+00,5.026052733553082241e+00,5.090194232182111200e+00,5.154320691780461594e+00,5.218390620082403508e+00,5.282361188698954102e+00,5.346188266368861797e+00,5.409826458197398047e+00,5.473229151095134526e+00,5.536348565607567274e+00,5.599135814304829317e+00,5.661540966874626157e+00,5.723513122033231149e+00,5.785000486338763181e+00,5.845950459956547718e+00,5.906309729390097907e+00,5.966024367152820140e+00,6.025039938314055377e+00,6.083301613810294661e+00,6.140754290367976154e+00,6.197342716838002197e+00,6.253011626695808012e+00,6.307705876412796009e+00,6.361370589358657845e+00,6.413951304845965318e+00,6.465394131883804185e+00,6.515645907162101125e+00,6.564654356746354225e+00,6.612368260923074281e+00,6.658737621599863488e+00,6.703713831631449516e+00,6.747249845415435487e+00,6.789300350077581925e+00,6.829821936549073769e+00,6.868773269826016659e+00,6.906115257695478071e+00,6.941811217212561225e+00,6.975827038220845822e+00,7.008131343221906562e+00,7.038695642921020124e+00,7.067494486803623133e+00,7.094505608131965957e+00,7.119710062792245608e+00,7.143092361469690843e+00,7.164640594682527563e+00,7.184346550263419395e+00,7.202205822940520363e+00,7.218217915736707013e+00,7.232386332975804244e+00,7.244718664756947923e+00,7.255226662832103379e+00,7.263926307895670398e+00,7.270837868369061319e+00,7.275985950834923166e+00,7.279399542345210250e+00,7.281112044892203983e+00,7.281161302392844981e+00,7.279589620590876109e+00,7.276443780328224697e+00,7.271775044676726196e+00,7.265639160450514389e+00,7.258096354637841863e+00,7.249211326299509039e+00,7.239053234474384091e+00,7.227695682613259898e+00,7.215216700027854202e+00,7.201698720789518227e+00,7.187228560444302694e+00,7.171897390822072893e+00,7.155800713109267797e+00,7.139038329224320023e+00,7.121714311380642037e+00,7.103936969543244828e+00,7.085818816278483645e+00,7.067476528262688795e+00,7.049030903448891827e+00,7.030606812595157962e+00,7.012333143524942081e+00,6.994342736124050219e+00,6.976772305673952346e+00,6.959762351679501080e+00,6.943457048868744153e+00,6.928004116524268952e+00,6.913554661750660024e+00,6.900262991694827264e+00,6.888286389118256636e+00,6.877784845081689191e+00,6.868920741851252565e+00,6.861858478484403001e+00,6.856764030922177788e+00,6.853804437821383821e+00,6.853147202835775609e+00,6.854959603631439968e+00,6.859407897639864693e+00,6.866656414460371671e+00,6.876866524978397344e+00,6.890195477731078988e+00,6.906795093898770332e+00,6.926810313608638303e+00,6.950377588087705227e+00,6.977623114681660077e+00,7.008660914947173914e+00,7.043590760001873008e+00,7.082495952142321194e+00,7.125440977450059776e+00,7.172469050708071947e+00,7.223599581401083825e+00,7.278825597781581003e+00,7.338111174778155110e+00,7.401388920665243454e+00,7.468557586562128314e+00,7.539479871564614299e+00,7.613980504108552871e+00,7.691844686428447986e+00,7.772816993039000089e+00,7.856600815351259648e+00,7.942858442157097798e+00,8.031211859183503776e+00,8.121244339755444130e+00,8.212502882564582052e+00,8.304501531618507570e+00,8.396725587997162066e+00,8.488636693765039709e+00,8.579678736382636117e+00,8.669284488661762822e+00,8.756882866465682369e+00,8.841906655889452793e+00,8.923800535555001190e+00,9.002029199795902770e+00,9.076085376486529910e+00,9.145497530256573526e+00,9.209837048421006145e+00,9.268724723102115703e+00,9.321836368003108220e+00,9.368907440765617878e+00,9.409736579936259560e+00,9.444188007036530053e+00,9.472192786656687957e+00,9.493748978470575750e+00,9.508920752393633435e+00,9.517836569942254243e+00,9.520686559824573791e+00,9.517719233059166228e+00,9.509237692155577903e+00,9.495595490259919558e+00,9.477192290217617554e+00,9.454469461066475233e+00,9.427905731538402279e+00,9.398012997756204356e+00,9.365332356444545425e+00,9.330430406478944505e+00,9.293895831138573982e+00,9.256336241467090886e+00,9.218375227960702745e+00,9.180649533535419238e+00,9.143806225478270377e+00,9.108499708053594546e+00,9.075388381072691857e+00,9.045130714007148853e+00,9.018380471865155457e+00,8.995780800901162166e+00,8.977956863578009816e+00,8.965506709109790862e+00,8.958990086421783516e+00,8.958914960459621213e+00,8.965721591931183454e+00,8.979764196571814239e+00,9.001290422957755055e+00,9.030419182893705710e+00,9.067117731382726475e+00,9.111179305788136062e+00,9.162203058578215931e+00,9.219578395579596020e+00,9.282476081823052283e+00,9.349848506949054894e+00,9.420441222252128100e+00,9.492817209604902828e+00,9.565394311484492817e+00,9.636494912429382609e+00,9.704405474569242074e+00,9.767442126032484850e+00,9.824017446158142874e+00,9.872703121708511276e+00,9.912283405772789990e+00,9.941795296676893656e+00,9.960552917219704483e+00,9.968155444893392669e+00,9.964479797839803865e+00,9.949660819373546516e+00,9.924062714266987939e+00,9.888245882660919861e+00,9.842933102605639917e+00,9.788978351054719695e+00,9.727340595561166481e+00,9.659063812267509874e+00,9.585263443480913637e+00,9.507118611578269096e+00,9.425868717640767613e+00,9.342812587416567283e+00,9.259308055829633233e+00,9.176769743105927191e+00,9.096662690180785660e+00,9.020489408278200116e+00,8.949767704628591503e+00,8.885996382454990794e+00,8.830605690755557902e+00,8.784889474416537780e+00,8.749916775095964994e+00,8.726422736938081570e+00,8.714682690543813948e+00,8.714379587148817663e+00,8.724483170144033295e+00,8.743167735764187043e+00,8.767800729853325592e+00,8.795032246040584312e+00,8.821001841014817657e+00,8.841653631204392738e+00,8.853119130863808195e+00,8.852101170662701080e+00,8.836183871854084160e+00,8.804009172911127834e+00,8.755295054364715668e+00,8.690710692557390260e+00,8.611654262100557844e+00,8.519991358953499017e+00,8.417806566568708959e+00,8.307204475369479368e+00,8.190177758887958959e+00,8.068544500236805916e+00,7.943947022740166730e+00,7.817899399071538191e+00,7.691868683642894666e+00,7.567373719696007583e+00,7.446083627750327061e+00,7.329894994974323730e+00,7.220962226882359225e+00,7.121650088217442942e+00,7.034373002485503790e+00,6.961286683968350708e+00,6.903813254127785903e+00,6.862025354409414746e+00,6.834000539094287063e+00,6.815374654987656378e+00,6.799409517551695536e+00,6.777828723638050334e+00,6.742379629195706769e+00,6.686648269698929781e+00,6.607401440536063042e+00,6.504921978322090403e+00,6.382333260318238111e+00,6.244369617352263369e+00,6.096150228700314422e+00,5.942311416504465704e+00,5.786582654155847827e+00,5.631720637599243240e+00,5.479667156767984437e+00,5.331819699189256134e+00,5.189345854526624002e+00,5.053503856128381599e+00,4.925940295773807875e+00,4.808917301882154050e+00,4.705370950474016212e+00,4.618620889455383960e+00,4.551468626889074720e+00,4.504458469939324416e+00,4.473494693441884884e+00,4.448036933367712997e+00,4.412153679162700293e+00,4.349828145432644178e+00,4.252062742607497725e+00,4.120434868641010162e+00,3.964643602155061952e+00,3.796994191664775808e+00,3.628009210460608092e+00,3.464710956505624218e+00,3.310841123810986719e+00,3.167852408490075877e+00,3.035971511531964317e+00,2.915100656438236904e+00,2.805560817447973143e+00,2.708735346733127880e+00,2.627597683502874037e+00,2.566859825101112769e+00,2.531939543080930832e+00,2.525209227927327493e+00,2.538525847388012124e+00,2.546666396546271915e+00,2.515026490408437621e+00,2.424482083604630578e+00,2.285776571243644195e+00,2.125870699429293520e+00,1.968285449167867185e+00,1.826122506271679269e+00,1.704188465161830424e+00,1.602731451061865986e+00,1.520078649897381506e+00,1.454252951501963764e+00,1.404180319249615838e+00,1.370922093232872729e+00,1.359014621747701490e+00,1.377042477799682807e+00,1.433528450175018953e+00,1.519632145269110834e+00,1.584924302646769867e+00,1.566156919737646813e+00,1.466010161934174771e+00,1.338897485577849933e+00,1.224794510158476735e+00,1.136627534280441720e+00,1.074298867753504139e+00,1.034441652332996231e+00,1.014024523375070652e+00,1.011389274707795938e+00,1.026994105121321610e+00,1.065180315000350264e+00,1.137307678733987970e+00,1.260615190221634707e+00,1.423559434490430764e+00,1.518669556052892888e+00,1.473275440022423721e+00,1.379621716114117547e+00,1.310461047722130346e+00,1.275440758735585822e+00,1.266241518540361044e+00,1.274780602424514520e+00,1.296488119382064541e+00,1.330451804012689143e+00,1.380005969096724794e+00,1.456205795170006256e+00,1.585746182254813119e+00,1.789463328464005354e+00,1.916505078363759607e+00,1.854563362613594002e+00,1.786694872317738492e+00,1.765804849684211586e+00,1.774491049294073530e+00,1.796677574184149861e+00,1.823897165694082778e+00,1.853884890895103332e+00,1.889930178500934810e+00,1.944194071605660712e+00,2.053458459173319817e+00,2.261649580395814318e+00,2.286259098475774021e+00,2.178675352367300810e+00,2.142649722484142316e+00,2.147675043887137480e+00,2.164541773248396250e+00,2.177606163744557843e+00,2.181423941446312131e+00,2.179518289870422176e+00,2.186660864966971651e+00,2.255158219514517448e+00,2.424408481335913024e+00,2.272593007173665747e+00,2.177539551826238373e+00,2.149771615859254581e+00,2.142975470093402723e+00,2.134387440773473532e+00,2.111629715349844894e+00,2.073376809141121768e+00,2.031925985810380642e+00,2.050014411487568022e+00,2.122442313231660549e+00,1.901535578000885129e+00,1.818403151723315903e+00,1.779002143024479565e+00,1.751579745624661566e+00,1.715922088092996844e+00,1.663441072409076682e+00,1.599439205790184282e+00,1.565727277859941147e+00,1.612310976792155959e+00,1.383287954454023305e+00,1.299159700221168556e+00,1.253908229663463381e+00,1.223710078130546774e+00,1.186193269195744193e+00,1.134303739761665764e+00,1.079878517306884778e+00,1.178332293834059463e+00,9.625285639949897609e-01,8.851185636671964341e-01,8.489719519837315431e-01,8.359778846719300160e-01,8.212409969558639444e-01,7.940770163506205570e-01,7.687957863418226623e-01,8.899229272678035318e-01,7.129129021908870989e-01,6.915254415571125968e-01,6.998262811849145226e-01,7.255691205688250545e-01,7.356686926822498807e-01,7.311321295507522411e-01,7.847525854497955367e-01,7.475729294994902796e-01,7.610326708151018416e-01,7.969325094899504247e-01,8.548021957867191212e-01,8.971404537560679904e-01,9.063217881534453291e-01,9.935244436557728598e-01,9.396590327892549999e-01,9.741071698085532748e-01,1.027449406290320999e+00,1.101235461874237043e+00,1.142418277722037301e+00,1.138814660068548257e+00,1.140389413794488327e+00,1.147720815238148395e+00,1.173541243201270623e+00,1.221488715067933661e+00,1.278577806856491916e+00,1.267471416143046037e+00,1.237065807883966029e+00,1.205512888417914930e+00,1.192665311929050231e+00,1.197911753988686323e+00,1.231977000419564039e+00,1.202653687975261176e+00,1.139636662652281363e+00,1.087045338753395374e+00,1.042662596452621715e+00,1.014929000627767808e+00,1.025123776322035773e+00,9.646891061543381163e-01,8.895490153201816019e-01,8.366531286586023075e-01,7.873968794936503368e-01,7.600897244945408193e-01,7.526274344562058349e-01,6.712567145962370363e-01,6.280934622556036961e-01,5.997798431402170394e-01,5.740840671348590440e-01,5.955424227101829837e-01,5.372993072885473564e-01,5.085440114639332432e-01,5.158865668882360866e-01,5.216899396152523405e-01,5.624205399127776284e-01,5.425471740675752441e-01,5.332370555916164934e-01,5.675895724472427295e-01,6.013422225200814042e-01,6.674448062338342869e-01,6.562452647123838689e-01,6.673156889394813440e-01,7.102486859021754917e-01,7.451435156326343678e-01,8.247884674869052635e-01,7.888045053156524933e-01,8.061034539639199137e-01,8.296435806249572442e-01,8.435005837122351302e-01,8.551331687631444911e-01,8.358735187865746763e-01,8.393851982154122426e-01,8.187087119091216447e-01,8.401197543509585364e-01,7.657920730365798123e-01,7.508263963910092320e-01,7.189647756862329597e-01,6.885910709845599609e-01,6.227413796426488624e-01,5.980386037486531414e-01,5.753943047859191307e-01,5.282211608071198938e-01,4.768319490950545525e-01,4.585132665511530980e-01,4.582815727393892979e-01,4.308077472737184554e-01,4.015605437985086401e-01,4.047212673910911551e-01,4.277056556660817077e-01,4.568577183674872311e-01,4.295300599031842137e-01,4.590797303894100789e-01,4.886739919705078150e-01,5.061372965746743224e-01,5.309584519446792772e-01,5.745964067853932544e-01,5.832936301317118710e-01,6.026482680429495753e-01,6.255398784235532972e-01,6.481890538866176277e-01,6.294617157611017699e-01,6.334655615401925122e-01,6.434846813418890754e-01,6.067699257123151391e-01,5.790075198549858859e-01,5.609928930752995369e-01,5.397702392229905000e-01,4.861398641328858461e-01,4.569410119887090116e-01,4.501532261699614512e-01,3.938457895707645484e-01,3.728305702048046455e-01,3.690251928155652839e-01,3.401350764291020679e-01,3.424725739283499548e-01,3.459202122098165577e-01,3.468289651458203449e-01
```

## PyMieSim/validation_data/Figure88BH.csv

 * *Ordering differences only*

```diff
@@ -1,2 +1,2 @@
-8.445668404310932532e-04,8.581966066559704480e-04,8.720462482769042629e-04,8.861193088981916301e-04,9.004193891004240403e-04,9.149501473515135727e-04,9.297153009320621589e-04,9.447186268753538082e-04,9.599639629221371926e-04,9.754552084904918700e-04,9.911963256609391485e-04,1.007191340177057476e-03,1.023444342461862127e-03,1.039959488650156602e-03,1.056741001637098373e-03,1.073793172143254916e-03,1.091120359796344304e-03,1.108726994229988251e-03,1.126617576199664484e-03,1.144796678716145143e-03,1.163268948196704601e-03,1.182039105634314193e-03,1.201111947785144136e-03,1.220492348374612032e-03,1.240185259322286286e-03,1.260195711985863040e-03,1.280528818424599103e-03,1.301189772682395185e-03,1.322183852090870297e-03,1.343516418592724613e-03,1.365192920085662705e-03,1.387218891787210008e-03,1.409599957620699846e-03,1.432341831622779924e-03,1.455450319372726892e-03,1.478931319443871047e-03,1.502790824877497195e-03,1.527034924679561683e-03,1.551669805340420531e-03,1.576701752378132032e-03,1.602137151905430297e-03,1.627982492220957610e-03,1.654244365424815868e-03,1.680929469059102383e-03,1.708044607773516769e-03,1.735596695016566925e-03,1.763592754752668591e-03,1.792039923205518371e-03,1.820945450628119484e-03,1.850316703099793300e-03,1.880161164350673247e-03,1.910486437613873826e-03,1.941300247505964261e-03,1.972610441935842163e-03,2.004424994042799772e-03,2.036752004163660049e-03,2.069599701829974870e-03,2.102976447795198815e-03,2.136890736092534812e-03,2.171351196123780160e-03,2.206366594779561943e-03,2.241945838591488747e-03,2.278097975916524871e-03,2.314832199154080120e-03,2.352157846996301774e-03,2.390084406711923907e-03,2.428621516464082603e-03,2.467778967662740200e-03,2.507566707351958826e-03,2.547994840632559696e-03,2.589073633120639144e-03,2.630813513442403252e-03,2.673225075765793806e-03,2.716319082369260743e-03,2.760106466248315581e-03,2.804598333760325093e-03,2.849805967307818006e-03,2.895740828061038954e-03,2.942414558720102703e-03,2.989838986317254303e-03,3.038026125059723956e-03,3.086988179213631493e-03,3.136737546029548084e-03,3.187286818710053423e-03,3.238648789419912473e-03,3.290836452339249065e-03,3.343863006760357335e-03,3.397741860228528296e-03,3.452486631727443196e-03,3.508111154909607232e-03,3.564629481372463739e-03,3.622055883980335005e-03,3.680404860233267832e-03,3.739691135682518455e-03,3.799929667394118336e-03,3.861135647460026046e-03,3.923324506558118971e-03,3.986511917561223056e-03,4.050713799195699259e-03,4.115946319749887693e-03,4.182225900833402149e-03,4.249569221187318377e-03,4.317993220545750938e-03,4.387515103549612279e-03,4.458152343712743111e-03,4.529922687440957919e-03,4.602844158104588482e-03,4.676935060164730956e-03,4.752213983354024868e-03,4.828699806911906749e-03,4.906411703875300338e-03,4.985369145424804922e-03,5.065591905286995038e-03,5.147100064193022365e-03,5.229914014394248384e-03,5.314054464235004084e-03,5.399542442783097744e-03,5.486399304517989260e-03,5.574646734077788081e-03,5.664306751064407744e-03,5.755401714908067907e-03,5.847954329790861980e-03,5.941987649630258578e-03,6.037525083121744914e-03,6.134590398842578417e-03,6.233207730414841614e-03,6.333401581729921834e-03,6.435196832232883100e-03,6.538618742268738175e-03,6.643692958488486150e-03,6.750445519317690296e-03,6.858902860484984536e-03,6.969091820612878171e-03,7.081039646869054759e-03,7.194774000679763672e-03,7.310322963503724028e-03,7.427715042667849821e-03,7.546979177263258426e-03,7.668144744103302414e-03,7.791241563741181306e-03,7.916299906548917437e-03,8.043350498855900491e-03,8.172424529147941791e-03,8.303553654325274494e-03,8.436770006020022708e-03,8.572106196972083952e-03,8.709595327463454453e-03,8.849270991809403061e-03,8.991167284907224111e-03,9.135318808840773783e-03,9.281760679540330267e-03,9.430528533497285065e-03,9.581658534532043470e-03,9.735187380615191455e-03,9.891152310739509054e-03,1.004959111184310430e-02,1.021054212578137270e-02,1.037404425634707444e-02,1.054013697633689184e-02,1.070886033466290910e-02,1.088025496350804311e-02,1.105436208552263398e-02,1.123122352106137312e-02,1.141088169545867968e-02,1.159337964633936485e-02,1.177876103096420213e-02,1.196707013360678168e-02,1.215835187295976304e-02,1.235265180956832305e-02,1.255001615328795589e-02,1.275049177076323544e-02,1.295412619292608120e-02,1.316096762250928282e-02,1.337106494157209134e-02,1.358446771903558739e-02,1.380122621822306786e-02,1.402139140440260105e-02,1.424501495232732839e-02,1.447214925377029657e-02,1.470284742504812669e-02,1.493716331453101911e-02,1.517515151013280189e-02,1.541686734677720841e-02,1.566236691383468896e-02,1.591170706252558256e-02,1.616494541328227300e-02,1.642214036306704344e-02,1.668335109263758068e-02,1.694863757375480659e-02,1.721806057632764217e-02,1.749168167548480549e-02,1.776956325857132965e-02,1.805176853205804621e-02,1.833836152835937802e-02,1.862940711255046955e-02,1.892497098897545638e-02,1.922511970773971637e-02,1.952992067107460483e-02,1.983944213956923344e-02,2.015375323825633475e-02,2.047292396254491234e-02,2.079702518398883482e-02,2.112612865587999364e-02,2.146030701865623419e-02,2.179963380511283633e-02,2.214418344540495034e-02,2.249403127183001797e-02,2.284925352337682444e-02,2.320992735002902832e-02,2.357613081680990166e-02,2.394794290755323032e-02,2.432544352838790155e-02,2.470871351092150670e-02,2.509783461510506700e-02,2.549288953176779421e-02,2.589396188480160704e-02,2.630113623298172346e-02,2.671449807140430580e-02,2.713413383252544914e-02,2.756013088678152534e-02,2.799257754277356333e-02,2.843156304699591755e-02,2.887717758308949723e-02,2.932951227060043645e-02,2.978865916322072024e-02,3.025471124649302748e-02,3.072776243495399170e-02,3.120790756869683616e-02,3.169524240932774378e-02,3.218986363529413586e-02,3.269186883655861298e-02,3.320135650859571547e-02,3.371842604568497243e-02,3.424317773347430177e-02,3.477571274078698760e-02,3.531613311064606825e-02,3.586454175048764403e-02,3.642104242153331589e-02,3.698573972729664316e-02,3.755873910118984194e-02,3.814014679320340551e-02,3.873006985562839344e-02,3.932861612778724286e-02,3.993589421974572812e-02,4.055201349497111751e-02,4.117708405190424747e-02,4.181121670441315108e-02,4.245452296109772372e-02,4.310711500340357744e-02,4.376910566252073531e-02,4.444060839502702448e-02,4.512173725724134138e-02,4.581260687825434996e-02,4.651333243160036407e-02,4.722402960553515050e-02,4.794481457188415341e-02,4.867580395342554350e-02,4.941711478977546534e-02,5.016886450173439066e-02,5.093117085406730776e-02,5.170415191667717542e-02,5.248792602413947933e-02,5.328261173356481362e-02,5.408832778075426534e-02,5.490519303461856293e-02,5.573332644982361556e-02,5.657284701763816426e-02,5.742387371494968307e-02,5.828652545141934510e-02,5.916092101475398796e-02,6.004717901406324276e-02,6.094541782128214125e-02,6.185575551063602490e-02,6.277830979612782081e-02,6.371319796702905325e-02,6.466053682136192748e-02,6.562044259735802521e-02,6.659303090288530569e-02,6.757841664283825711e-02,6.857671394448390523e-02,6.958803608077437919e-02,7.061249539162180178e-02,7.165020320314957614e-02,7.270126974493743011e-02,7.376580406527449840e-02,7.484391394445072399e-02,7.593570580611529175e-02,7.704128462674042499e-02,7.816075384323423192e-02,7.929421525875846033e-02,8.044176894680175882e-02,8.160351315358603530e-02,8.277954419887607884e-02,8.396995637527801537e-02,8.517484184612582332e-02,8.639429054205577385e-02,8.762839005639444512e-02,8.887722553947491333e-02,9.014087959203699596e-02,9.141943215785514054e-02,9.271296041576293501e-02,9.402153867125843945e-02,9.534523824788568303e-02,9.668412737860221373e-02,9.803827109737126011e-02,9.940773113120972282e-02,1.007925657929753388e-01,1.021928298751660635e-01,1.036085745450368439e-01,1.050398472413662937e-01,1.064866915732155528e-01,1.079491472210531156e-01,1.094272498406380772e-01,1.109210309700829761e-01,1.124305179405438310e-01,1.139557337910046542e-01,1.154966971876644349e-01,1.170534223484478165e-01,1.186259189732060959e-01,1.202141921801951896e-01,1.218182424494548277e-01,1.234380655737399857e-01,1.250736526177045616e-01,1.267249898860503543e-01,1.283920589014060365e-01,1.300748363927384521e-01,1.317732942951222452e-01,1.334873997617480323e-01,1.352171151890819156e-01,1.369623982561218589e-01,1.387232019787534576e-01,1.404994747802349730e-01,1.422911605788865497e-01,1.440981988941076597e-01,1.459205249718700248e-01,1.477580699309091472e-01,1.496107609308348074e-01,1.514785213634628203e-01,1.533612710686989844e-01,1.552589265763196225e-01,1.571714013750890038e-01,1.590986062106362342e-01,1.610404494135892206e-01,1.629968372594808868e-01,1.649676743619819530e-01,1.669528641010504522e-01,1.689523090876105249e-01,1.709659116663914125e-01,1.729935744586121593e-01,1.750352009461676461e-01,1.770906960990295542e-01,1.791599670475597650e-01,1.812429238014370003e-01,1.833394800169243777e-01,1.854495538141385236e-01,1.875730686460340690e-01,1.897099542207395240e-01,1.918601474788607097e-01,1.940235936273422834e-01,1.962002472314011148e-01,1.983900733659813564e-01,2.005930488281373048e-01,2.028091634115813946e-01,2.050384212446389465e-01,2.072808421926085609e-01,2.095364633255019926e-01,2.118053404518753791e-01,2.140875497193904797e-01,2.163831892824431002e-01,2.186923810370834664e-01,2.210152724231091159e-01,2.233520382930367365e-01,2.257028828472780191e-01,2.280680416346058115e-01,2.304477836165694793e-01,2.328424132942153446e-01,2.352522728949448805e-01,2.376777446170366959e-01,2.401192529287098365e-01,2.425772669182340302e-01,2.450523026908860980e-01,2.475449258080903436e-01,2.500557537632811522e-01,2.525854584884696941e-01,2.551347688846404282e-01,2.577044733684255018e-01,2.602954224265504046e-01,2.629085311687792692e-01,2.655447818690545025e-01,2.682052264836046751e-01,2.708909891337144549e-01,2.736032685398025466e-01,2.763433403922700426e-01,2.791125596434538836e-01,2.819123627037209423e-01,2.847442695235290477e-01,2.876098855419074174e-01,2.905109034804984613e-01,2.934491049608888846e-01,2.964263619215750101e-01,2.994446378094319794e-01,3.025059885192284970e-01,3.056125630531253412e-01,3.087666038708864469e-01,3.119704468999436875e-01,3.152265211733007444e-01,3.185373480618182152e-01,3.219055400663688449e-01,3.253337991341673230e-01,3.288249144627241050e-01,3.323817597539973634e-01,3.360072898808341146e-01,3.397045369273243853e-01,3.434766055647585081e-01,3.473266677249234879e-01,3.512579565332675235e-01,3.552737594652563557e-01,3.593774106908533272e-01,3.635722825738856301e-01,3.678617762956841175e-01,3.722493115754070270e-01,3.767383154633556219e-01,3.813322101881165826e-01,3.860344000436333745e-01,3.908482573086036194e-01,3.957771071975267341e-01,4.008242118508782426e-01,4.059927533807398126e-01,4.112858159982916151e-01,4.167063672605317293e-01,4.222572384856332905e-01,4.279411043994079678e-01,4.337604620893064644e-01,4.397176093574030609e-01,4.458146225795509565e-01,4.520533341943828165e-01,4.584353099630409378e-01,4.649618261579728795e-01,4.716338468569507558e-01,4.784520015362510037e-01,4.854165631743416753e-01,4.925274270943984511e-01,4.997840907898386531e-01,5.071856349917527318e-01,5.147307062500543484e-01,5.224175013108987020e-01,5.302437535812970504e-01,5.382067219769368638e-01,5.463031824511481727e-01,5.545294225007918465e-01,5.628812389385596804e-01,5.713539392102380265e-01,5.799423465196213989e-01,5.886408090027247519e-01,5.974432131668406809e-01,6.063430017780983006e-01,6.153331963446299069e-01,6.244064243002448444e-01,6.335549509468958451e-01,6.427707161630791255e-01,6.520453758303851322e-01,6.613703478724970442e-01,6.707368627404534100e-01,6.801360181163386143e-01,6.895588375452583740e-01,6.989963326437377278e-01,7.084395684726993991e-01,7.178797316055525179e-01,7.273082003683312147e-01,7.367166166795005022e-01,7.460969588733786795e-01,7.554416148535780806e-01,7.647434548920452047e-01,7.739959033655452458e-01,7.831930087052421108e-01,7.923295108259109654e-01,8.014009052996590166e-01,8.104035035440411150e-01,8.193344883058781836e-01,8.281919637392330946e-01,8.369749993980206693e-01,8.456836674900450879e-01,8.543190727689555786e-01,8.628833744730557420e-01,8.713797997543072382e-01,8.798126480772103797e-01,8.881872861047126477e-01,8.965101326276194715e-01,9.047886331348904410e-01,9.130312236660326208e-01,9.212472836342100457e-01,9.294470773614318393e-01,9.376416841272061653e-01,9.458429166011798062e-01,9.540632276118621302e-01,9.623156052992690723e-01,9.706134568135099672e-01,9.789704808551676907e-01,9.874005295114314240e-01,9.959174600248613674e-01,1.004534977342417035e+00,1.013266468531098807e+00,1.022124830413044361e+00,1.031122292065148160e+00,1.040270234142999684e+00,1.049579007319354274e+00,1.059057752466763036e+00,1.068714225550144947e+00,1.078554630516169954e+00,1.088583463755514291e+00,1.098803373954796214e+00,1.109215041326314655e+00,1.119817080286535260e+00,1.130605969627588969e+00,1.141576014070851297e+00,1.152719340791779734e+00,1.164025934048127597e+00,1.175483710423661732e+00,1.187078636416236010e+00,1.198794889162699162e+00,1.210615060021326128e+00,1.222520399552819992e+00,1.234491101190393625e+00,1.246506619611617017e+00,1.258546018571017333e+00,1.270588341775015895e+00,1.282612999334515891e+00,1.294600161465913057e+00,1.306531150472076463e+00,1.318388821656572896e+00,1.330157923729101910e+00,1.341825429456452889e+00,1.353380827797196373e+00,1.364816369508958127e+00,1.376127259205220055e+00,1.387311788021920123e+00,1.398371402387467155e+00,1.409310705821865684e+00,1.420137392175149893e+00,1.430862110205658011e+00,1.441498260859670699e+00,1.452061730014654328e+00,1.462570560770140027e+00,1.473044570601274694e+00,1.483504919826622803e+00,1.493973638885351507e+00,1.504473122873738244e+00,1.515025602662032789e+00,1.525652602701840888e+00,1.536374396340723036e+00,1.547209470076812421e+00,1.558174008700399682e+00,1.569281413661735680e+00,1.580541867252788002e+00,1.591961955265630779e+00,1.603544360659032941e+00,1.615287640387600643e+00,1.627186096877222488e+00,1.639229754606960521e+00,1.651404450808247937e+00,1.663692047328748647e+00,1.676070768132495559e+00,1.688515663622502272e+00,1.700999198899129095e+00,1.713491958181949215e+00,1.725963451984432240e+00,1.738383007420284621e+00,1.750720715570540431e+00,1.762948403632924599e+00,1.775040594225721469e+00,1.786975410409691101e+00,1.798735383384691522e+00,1.810308120940367083e+00,1.821686798874597724e+00,1.832870444695150258e+00,1.843863992578435695e+00,1.854678100028152699e+00,1.865328728959354754e+00,1.875836505920848385e+00,1.886225886798899909e+00,1.896524159756240779e+00,1.906760325813463997e+00,1.916963899230430535e+00,1.927163669958414038e+00,1.937386468542736662e+00,1.947655970870626252e+00,1.957991577135745453e+00,1.968407397359166033e+00,1.978911375576663190e+00,1.989504586748611858e+00,2.000180744306722769e+00,2.010925960958559688e+00,2.021718809021045171e+00,2.032530726535437537e+00,2.043326808786221971e+00,2.054067008975621444e+00,2.064707745210152101e+00,2.075203874157983464e+00,2.085510947875590215e+00,2.095587625195358683e+00,2.105398070482668693e+00,2.114914148733259669e+00,2.124117223541603039e+00,2.132999386563451338e+00,2.141563992106751968e+00,2.149825432048176665e+00,2.157808154647355980e+00,2.165544995255989758e+00,2.173074938277934187e+00,2.180440462673927104e+00,2.187684637223493489e+00,2.194848130468591396e+00,2.201966290484165700e+00,2.209066438784502484e+00,2.216165516621488862e+00,2.223268222980772091e+00,2.230365789406942412e+00,2.237435540398399869e+00,2.244441379120678537e+00,2.251335305370739004e+00,2.258060007541922154e+00,2.264552470673338203e+00,2.270748415705559076e+00,2.276587248095369276e+00,2.282017072248071710e+00,2.286999249984730920e+00,2.291511970439692458e+00,2.295552367856323883e+00,2.299136868609206630e+00,2.302299647979477726e+00,2.305089296614038386e+00,2.307563998572639719e+00,2.309785676930019349e+00,2.311813653599182228e+00,2.313698398714843396e+00,2.315475924857937073e+00,2.317163329216425094e+00,2.318755914355547176e+00,2.320226228926919099e+00,2.321525259151885123e+00,2.322585862321096428e+00,2.323328356822065288e+00,2.323667963679377557e+00,2.323523532838465133e+00,2.322826699450772026e+00,2.321530346581026638e+00,2.319615083927816457e+00,2.317092493298398281e+00,2.314004224592613568e+00,2.310416653259694808e+00,2.306411617625775623e+00,2.302074535815907375e+00,2.297481737911473587e+00,2.292688998250701715e+00,2.287723002935771799e+00,2.282576943749949017e+00,2.277210758273643165e+00,2.271555896797780250e+00,2.265523987882743118e+00,2.259018404996834928e+00,2.251947438422410741e+00,2.244237466928710845e+00,2.235844203772922256e+00,2.226759920491544698e+00,2.217014812841886062e+00,2.206671596606356367e+00,2.195813948803403637e+00,2.184531084689137703e+00,2.172901885598825356e+00,2.160982015713698079e+00,2.148796344182375417e+00,2.136337255208445196e+00,2.123567891914708294e+00,2.110428657874221958e+00,2.096845493677030881e+00,2.082739147408910529e+00,2.068035252384083478e+00,2.052675058631286742e+00,2.036626057810174029e+00,2.019890787539017296e+00,2.002511329248019223e+00,1.984566992011782993e+00,1.966163738429189678e+00,1.947415889924390298e+00,1.928422894808974108e+00,1.909245730737940017e+00,1.889888467071754619e+00,1.870290540394567769e+00,1.850334195335721521e+00,1.829868872064962515e+00,1.808749840588585123e+00,1.786882728292793487e+00,1.764260638119270475e+00,1.740979091881580620e+00,1.717218551158154360e+00,1.693195079099214961e+00,1.669093382760600486e+00,1.645006471847341611e+00,1.620906305880615683e+00,1.596658472988115474e+00,1.572075808001935693e+00,1.546989644565509581e+00,1.521310961128631511e+00,1.495059286388932707e+00,1.468350857163610801e+00,1.441352954295741728e+00,1.414224049922045534e+00,1.387065682651140941e+00,1.359907134124930250e+00,1.332726401010190465e+00,1.305488951908485351e+00,1.278175123997187024e+00,1.250777450687782011e+00,1.223274508450553411e+00,1.195610473935922569e+00,1.167712019216318176e+00,1.139548887222207485e+00,1.111203509342192364e+00,1.082891048826543079e+00,1.054892600910474432e+00,1.027421706352511066e+00,1.000496688777255283e+00,9.739038646016834333e-01,9.472978354001466705e-01,9.204037949674278574e-01,8.932066267858651543e-01,8.659998321307342817e-01,8.392459442388990887e-01,8.133180574222919068e-01,7.882811651354066917e-01,7.638730929222699029e-01,7.397169257814998344e-01,7.156075038636824370e-01,6.916466125673288445e-01,6.681334969231391696e-01,6.453167897873380854e-01,6.232222297826721658e-01,6.017129517615038559e-01,5.807209416600787044e-01,5.603980434659936449e-01,5.410100840645019060e-01,5.226562750580626693e-01,5.050803168611390781e-01,4.878252758708664927e-01,4.706910609869334183e-01,4.540565279202654625e-01,4.386665874551139988e-01,4.250037169832239781e-01,4.127929033614134990e-01,4.011781845621266163e-01,3.895297386516926030e-01,3.780811438233172561e-01,3.677085107288340926e-01,3.590763665715396291e-01,3.519827290419697552e-01,3.456271503831113145e-01,3.395691207907183262e-01,3.342049302412156142e-01,3.302048299909782769e-01,3.275981265572011081e-01,3.256398757089477569e-01,3.238443045939238263e-01,3.228179497494169103e-01,3.235836477854923676e-01,3.261891104030179012e-01,3.293316226300874727e-01,3.318608858621558411e-01,3.343975529321978057e-01,3.386511626471325198e-01,3.452487147815151980e-01,3.527300442033109995e-01,3.593910140460265801e-01,3.656384161453798409e-01,3.732566402573913034e-01,3.827803596563238986e-01,3.925822436913811719e-01,4.014595109877670542e-01,4.105930721402806793e-01,4.214905928478800412e-01,4.332798220518229715e-01,4.436464233861397433e-01,4.528589062006714294e-01,4.635574924206647962e-01,4.764356631718666968e-01,4.885058074898813163e-01,4.977995826644542876e-01,5.068338503785626559e-01,5.182543018689287351e-01,5.301851686961593924e-01,5.392658205823009920e-01,5.469116715799460238e-01,5.562522551420520101e-01,5.661130769756763659e-01,5.728150154355765578e-01,5.779610888561985682e-01,5.851758048952534486e-01,5.926567626960226320e-01,5.957627673801190182e-01,5.970136287124350183e-01,6.010548745205200882e-01
-2.332025408162599796e-03,2.369713979894717739e-03,2.408012144008811126e-03,2.446929771992508579e-03,2.486476895421047689e-03,2.526663708556270253e-03,2.567500570987632513e-03,2.608998010316121614e-03,2.651166724881556195e-03,2.694017586534159289e-03,2.737561643450979031e-03,2.781810122997873183e-03,2.826774434637908777e-03,2.872466172886821347e-03,2.918897120316237166e-03,2.966079250605550138e-03,3.014024731643133795e-03,3.062745928677717156e-03,3.112255407520677763e-03,3.162565937800146994e-03,3.213690496267641947e-03,3.265642270158095137e-03,3.318434660604235257e-03,3.372081286105956064e-03,3.426595986055828730e-03,3.481992824321314493e-03,3.538286092884893215e-03,3.595490315542826908e-03,3.653620251663494516e-03,3.712690900006301517e-03,3.772717502602145750e-03,3.833715548696234408e-03,3.895700778754391906e-03,3.958689188533846132e-03,4.022697033219417226e-03,4.087740831626137175e-03,4.153837370469395246e-03,4.221003708703752882e-03,4.289257181931120655e-03,4.358615406879883664e-03,4.429096285955616379e-03,4.500718011864955972e-03,4.573499072313189258e-03,4.647458254777293157e-03,4.722614651355115656e-03,4.798987663692138791e-03,4.876597007986918295e-03,4.955462720076496581e-03,5.035605160602771822e-03,5.117045020261282856e-03,5.199803325133735277e-03,5.283901442105150802e-03,5.369361084367467452e-03,5.456204317010219379e-03,5.544453562700557558e-03,5.634131607452657307e-03,5.725261606489277788e-03,5.817867090195758852e-03,5.911971970168341736e-03,6.007600545358119000e-03,6.104777508312034424e-03,6.203527951512314599e-03,6.303877373815896905e-03,6.405851686995165349e-03,6.509477222381638770e-03,6.614780737614119749e-03,6.721789423492458698e-03,6.830530910939144017e-03,6.941033278069591757e-03,7.053325057373206058e-03,7.167435243006349196e-03,7.283393298199290766e-03,7.401229162778514246e-03,7.520973260805747899e-03,7.642656508335985560e-03,7.766310321295753251e-03,7.891966623483182008e-03,8.019657854691898333e-03,8.149416978960455707e-03,8.281277492948636854e-03,8.415273434442881867e-03,8.551439390991972395e-03,8.689810508675715334e-03,8.830422501007101355e-03,8.973311657970934122e-03,9.118514855200012675e-03,9.266069563290874056e-03,9.416013857261117115e-03,9.568386426149787238e-03,9.723226582762955691e-03,9.880574273566410451e-03,1.004047008872664681e-02,1.020295527230346937e-02,1.036807173259394858e-02,1.053586205263225967e-02,1.070636950084464731e-02,1.087963804186317836e-02,1.105571234749993560e-02,1.123463780788287215e-02,1.141646054275539598e-02,1.160122741294258332e-02,1.178898603198469223e-02,1.197978477794020384e-02,1.217367280536082487e-02,1.237070005743970760e-02,1.257091727833507810e-02,1.277437602567113237e-02,1.298112868321787440e-02,1.319122847375219475e-02,1.340472947210131528e-02,1.362168661837111390e-02,1.384215573136082095e-02,1.406619352216597132e-02,1.429385760797088380e-02,1.452520652603331644e-02,1.476029974786229743e-02,1.499919769359118332e-02,1.524196174654678972e-02,1.548865426801800983e-02,1.573933861222306593e-02,1.599407914147880222e-02,1.625294124157281028e-02,1.651599133734021549e-02,1.678329690844462471e-02,1.705492650536861998e-02,1.733094976560965728e-02,1.761143743008793811e-02,1.789646135976256935e-02,1.818609455246177065e-02,1.848041115992273692e-02,1.877948650504808123e-02,1.908339709937364320e-02,1.939222066075341547e-02,1.970603613125818804e-02,2.002492369529207741e-02,2.034896479792348833e-02,2.067824216343443905e-02,2.101283981408450657e-02,2.135284308909428733e-02,2.169833866384250631e-02,2.204941456928172575e-02,2.240616021156800405e-02,2.276866639190727043e-02,2.313702532661481015e-02,2.351133066738861008e-02,2.389167752179482268e-02,2.427816247396464774e-02,2.467088360549842679e-02,2.506994051657958356e-02,2.547543434729196421e-02,2.588746779914074050e-02,2.630614515677395099e-02,2.673157230990077030e-02,2.716385677540533727e-02,2.760310771965001145e-02,2.804943598096702045e-02,2.850295409233256569e-02,2.896377630421994448e-02,2.943201860762598848e-02,2.990779875726631495e-02,3.039123629493513043e-02,3.088245257301934499e-02,3.138157077816563362e-02,3.188871595509150392e-02,3.240401503053061405e-02,3.292759683730978743e-02,3.345959213854395042e-02,3.400013365194390347e-02,3.454935607422572608e-02,3.510739610561291330e-02,3.567439247441760858e-02,3.625048596169558324e-02,3.683581942595682418e-02,3.743053782792186979e-02,3.803478825531178553e-02,3.864871994765537583e-02,3.927248432109972653e-02,3.990623499320854889e-02,4.055012780773242093e-02,4.120432085933086602e-02,4.186897451823219651e-02,4.254425145480806442e-02,4.323031666404451856e-02,4.392733748988657261e-02,4.463548364943766000e-02,4.535492725698470062e-02,4.608584284783005802e-02,4.682840740190043899e-02,4.758280036710697825e-02,4.834920368243077887e-02,4.912780180069700048e-02,4.991878171101654660e-02,5.072233296085371795e-02,5.153864767769123639e-02,5.236792059025458662e-02,5.321034904925881631e-02,5.406613304764248951e-02,5.493547524023890266e-02,5.581858096285580856e-02,5.671565825070525729e-02,5.762691785614856843e-02,5.855257326570196402e-02,5.949284071625468573e-02,6.044793921044631230e-02,6.141809053115136752e-02,6.240351925501044089e-02,6.340445276495211557e-02,6.442112126164205310e-02,6.545375777379497384e-02,6.650259816728699980e-02,6.756788115299022790e-02,6.864984829326713223e-02,6.974874400704492161e-02,7.086481557338934756e-02,7.199831313350504858e-02,7.314948969106854770e-02,7.431860111081575737e-02,7.550590611528586182e-02,7.671166627963382778e-02,7.793614602440986083e-02,7.917961260620570707e-02,8.044233610606521534e-02,8.172458941554626433e-02,8.302664822032883307e-02,8.434879098124321850e-02,8.569129891260798826e-02,8.705445595774262413e-02,8.843854876153779687e-02,8.984386663993713940e-02,9.127070154620543774e-02,9.271934803382882173e-02,9.419010321590924606e-02,9.568326672089653984e-02,9.719914064450374536e-02,9.873802949764085013e-02,1.003002401502030433e-01,1.018860817705453531e-01,1.034958657604538312e-01,1.051299056854485825e-01,1.067885172002163707e-01,1.084720179689866587e-01,1.101807275806552661e-01,1.119149674584429682e-01,1.136750607638883914e-01,1.154613322949570725e-01,1.172741083780419885e-01,1.191137167536365921e-01,1.209804864554480386e-01,1.228747476827023871e-01,1.247968316654156640e-01,1.267470705223723293e-01,1.287257971115564337e-01,1.307333448727828196e-01,1.327700476622596382e-01,1.348362395788179069e-01,1.369322547815270408e-01,1.390584272984207725e-01,1.412150908260580706e-01,1.434025785196120228e-01,1.456212227732180953e-01,1.478713549902707092e-01,1.501533053433730114e-01,1.524674025236411601e-01,1.548139734790570377e-01,1.571933431415617755e-01,1.596058341425836968e-01,1.620517665166877341e-01,1.645314573930482527e-01,1.670452206744137691e-01,1.695933667032842873e-01,1.721762019149667144e-01,1.747940284772223074e-01,1.774471439161987019e-01,1.801358407283513707e-01,1.828604059780614688e-01,1.856211208806725632e-01,1.884182603706594517e-01,1.912520926546729394e-01,1.941228787492039476e-01,1.970308720026042737e-01,1.999763176012624988e-01,2.029594520597027829e-01,2.059805026944005468e-01,2.090396870811607466e-01,2.121372124958809668e-01,2.152732753385707687e-01,2.184480605405244857e-01,2.216617409545575124e-01,2.249144767282666157e-01,2.282064146602852950e-01,2.315376875395653844e-01,2.349084134677333069e-01,2.383186951646328877e-01,2.417686192571807113e-01,2.452582555517533458e-01,2.487876562903260369e-01,2.523568553906965217e-01,2.559658676711129566e-01,2.596146880597723916e-01,2.633032907896611374e-01,2.670316285792992961e-01,2.707996318000396863e-01,2.746072076306346199e-01,2.784542391998774957e-01,2.823405847182288153e-01,2.862660765993832457e-01,2.902305205729113768e-01,2.942336947891424637e-01,2.982753489175945516e-01,3.023552032403813983e-01,3.064729477421378467e-01,3.106282411981127201e-01,3.148207102622407327e-01,3.190499485571111071e-01,3.233155157679212244e-01,3.276169367426103318e-01,3.319537006005656155e-01,3.363252598524044679e-01,3.407310295335227446e-01,3.451703863542702200e-01,3.496426678697457380e-01,3.541471716724171603e-01,3.586831546109400803e-01,3.632498320386944868e-01,3.678463770957793866e-01,3.724719200283895248e-01,3.771255475496379517e-01,3.818063022461282152e-01,3.865131820347498803e-01,3.912451396743211740e-01,3.960010823369484734e-01,4.007798712441101863e-01,4.055803213726594803e-01,4.104012012361424322e-01,4.152412327469317543e-01,4.200990911649473691e-01,4.249734051387573652e-01,4.298627568451140468e-01,4.347656822330617232e-01,4.396806713788383725e-01,4.446061689580126375e-01,4.495405748412673042e-01,4.544822448204026699e-01,4.594294914711489763e-01,4.643805851594308143e-01,4.693337551977381783e-01,4.742871911582453026e-01,4.792390443492692276e-01,4.841874294616404506e-01,4.891304263913978656e-01,4.940660822451428680e-01,4.989924135342113098e-01,5.039074085635858458e-01,5.088090300213317096e-01,5.136952177739132486e-01,5.185638918725730129e-01,5.234129557755133888e-01,5.282402997902054809e-01,5.330438047397205725e-01,5.378213458564858884e-01,5.425707969062316671e-01,5.472900345444214887e-01,5.519769429065994881e-01,5.566294184336204598e-01,5.612453749316760332e-01,5.658227488664889782e-01,5.703595048898940645e-01,5.748536415963166890e-01,5.793031975054668825e-01,5.837062572667029992e-01,5.880609580792115487e-01,5.923654963211895108e-01,5.966181343798053760e-01,6.008172076726161492e-01,6.049611318496433965e-01,6.090484101640997183e-01,6.130776409981149033e-01,6.170475255286425043e-01,6.209568755168703991e-01,6.248046212032221103e-01,6.285898192881780311e-01,6.323116609777432728e-01,6.359694800704809303e-01,6.395627610615656211e-01,6.430911472373721516e-01,6.465544487325479706e-01,6.499526505195454273e-01,6.532859202989762526e-01,6.565546162571891387e-01,6.597592946557405691e-01,6.629007172155318983e-01,6.659798582565872316e-01,6.689979115525745978e-01,6.719562968573785655e-01,6.748566660591461819e-01,6.777009089155047183e-01,6.804911583217979620e-01,6.832297950624637295e-01,6.859194519940109425e-01,6.885630176063135544e-01,6.911636389074062858e-01,6.937247235755209518e-01,6.962499413204809029e-01,6.987432243955502553e-01,7.012087671994077231e-01,7.036510249071237233e-01,7.060747110680496430e-01,7.084847941080161249e-01,7.108864926728938327e-01,7.132852697505345230e-01,7.156868255083794761e-01,7.180970887848144857e-01,7.205222071733982103e-01,7.229685356409302210e-01,7.254426236223653346e-01,7.279512005387520635e-01,7.305011596878254743e-01,7.330995404614707445e-01,7.357535088496460762e-01,7.384703361967828172e-01,7.412573761840721698e-01,7.441220400198857998e-01,7.470717698305060495e-01,7.501140102546712818e-01,7.532561782584673571e-01,7.565056312013304085e-01,7.598696332002243814e-01,7.633553198566584985e-01,7.669696614308171290e-01,7.707194245683806066e-01,7.746111327085835052e-01,7.786510253268975612e-01,7.828450161920096351e-01,7.871986508447851305e-01,7.917170635360665232e-01,7.964049338905175857e-01,8.012664435949882202e-01,8.063052334414712030e-01,8.115243610865201518e-01,8.169262599203492847e-01,8.225126994691573934e-01,8.282847477830835858e-01,8.342427362886674080e-01,8.403862276081974780e-01,8.467139868680694237e-01,8.532239570331587863e-01,8.599132388139010263e-01,8.667780756956360300e-01,8.738138446357676115e-01,8.810150529618414605e-01,8.883753419825058950e-01,8.958874977925236349e-01,9.035434697120316994e-01,9.113343967486093877e-01,9.192506424084939676e-01,9.272818381095361273e-01,9.354169353647110441e-01,9.436442668101331366e-01,9.519516160473542321e-01,9.603262961565568467e-01,9.687552366163936224e-01,9.772250782393641089e-01,9.857222755998865660e-01,9.942332062981913410e-01,1.002744286268343998e+00,1.011242090205552779e+00,1.019713476058899948e+00,1.028145712412558810e+00,1.036526607464581806e+00,1.044844638208822341e+00,1.053089078335369688e+00,1.061250123289583236e+00,1.069319010871352393e+00,1.077288135715974482e+00,1.085151155977646331e+00,1.092903090536541111e+00,1.100540405072134575e+00,1.108061085389050460e+00,1.115464696447775683e+00,1.122752425641629248e+00,1.129927108973121763e+00,1.136993238918066806e+00,1.143956952924292558e+00,1.150826001674115640e+00,1.157609696445906389e+00,1.164318835141020081e+00,1.170965606797801373e+00,1.177563474695346279e+00,1.184127038455573544e+00,1.190671875883321684e+00,1.197214365639118316e+00,1.203771492216473060e+00,1.210360635092039949e+00,1.216999344327750698e+00,1.223705105323687370e+00,1.230495095839383879e+00,1.237385938810461328e+00,1.244393454872054772e+00,1.251532418847473904e+00,1.258816324750620108e+00,1.266257164066693974e+00,1.273865222197263503e+00,1.281648897963672873e+00,1.289614550938613213e+00,1.297766381104630051e+00,1.306106344907787875e+00,1.314634111180737364e+00,1.323347059651477142e+00,1.332240323843389307e+00,1.341306879125668594e+00,1.350537675520053549e+00,1.359921813644066280e+00,1.369446760917508943e+00,1.379098603925407840e+00,1.388862331667886085e+00,1.398722143385864536e+00,1.408661773776612947e+00,1.418664827743847168e+00,1.428715116389817519e+00,1.438796985767573977e+00,1.448895629971065580e+00,1.458997380436941382e+00,1.469089963842309388e+00,1.479162721675749914e+00,1.489206785402338307e+00,1.499215202104319911e+00,1.509183006534795979e+00,1.519107236660370397e+00,1.528986890992520165e+00,1.538822827335295074e+00,1.548617604038298623e+00,1.558375266474064880e+00,1.568101083291389308e+00,1.577801239045141468e+00,1.587482492057881167e+00,1.597151808772753201e+00,1.606815988305653864e+00,1.616481293231583516e+00,1.626153104628063506e+00,1.635835620780644817e+00,1.645531619445023574e+00,1.655242302870671756e+00,1.664967242679730841e+00,1.674704437999112949e+00,1.684450494920191943e+00,1.694200928517344718e+00,1.703950580571389928e+00,1.713694137265370676e+00,1.723426722045448223e+00,1.733144530277642259e+00,1.742845465038952879e+00,1.752529728099261552e+00,1.762200317524702964e+00,1.771863383856690399e+00,1.781528400776494658e+00,1.791208113602777319e+00,1.800918239694795808e+00,1.810676908426292142e+00,1.820503844234410362e+00,1.830419313553384386e+00,1.840442874308546584e+00,1.850591984077585961e+00,1.860880538966325437e+00,1.871317428601783739e+00,1.881905202317195158e+00,1.892638946523527377e+00,1.903505472448663083e+00,1.914482906067318968e+00,1.925540757592260732e+00,1.936640526192123346e+00,1.947736866993690530e+00,1.958779312894025182e+00,1.969714504928296250e+00,1.980488844291713013e+00,1.991051439584359706e+00,2.001357187802973225e+00,2.011369800461910273e+00,2.021064570040720820e+00,2.030430669005810707e+00,2.039472785121383858e+00,2.048211922599274537e+00,2.056685237651661780e+00,2.064944827193533339e+00,2.073055448398414491e+00,2.081091212175610217e+00,2.089131363295507526e+00,2.097255331871302531e+00,2.105537312902573621e+00,2.114040699182430316e+00,2.122812752709300810e+00,2.131879942993260002e+00,2.141244397159808965e+00,2.150881885288272954e+00,2.160741695006082264e+00,2.170748626530607517e+00,2.180807165498420463e+00,2.190807678606947917e+00,2.200634249162694900e+00,2.210173556435490294e+00,2.219324036667619016e+00,2.228004472348135589e+00,2.236161156803233130e+00,2.243772876004366257e+00,2.250853127859781644e+00,2.257449240543083935e+00,2.263638330982275182e+00,2.269520338817210714e+00,2.275208659636275499e+00,2.280819166211866644e+00,2.286458628564471240e+00,2.292213698343960715e+00,2.298141678538252464e+00,2.304264221034554971e+00,2.310564854527393575e+00,2.316990838671715291e+00,2.323459298922530891e+00,2.329866993956871468e+00,2.336102509980877429e+00,2.342059276639977039e+00,2.347647644818402934e+00,2.352804391291645203e+00,2.357498390449784598e+00,2.361731741320485689e+00,2.365536261246062200e+00,2.368965869847928118e+00,2.372085931988021201e+00,2.374961074738761724e+00,2.377643309704061902e+00,2.380162420602455420e+00,2.382520427621742432e+00,2.384691428884367248e+00,2.386627230035341718e+00,2.388268021240230965e+00,2.389556197805071225e+00,2.390450557115304964e+00,2.390937789504465449e+00,2.391038506447027867e+00,2.390805943748404605e+00,2.390316773328007294e+00,2.389654974748893324e+00,2.388891285623659488e+00,2.388062154505397938e+00,2.387153035322238992e+00,2.386090857786009156e+00,2.384749198019000982e+00,2.382966995065059823e+00,2.380578123102215837e+00,2.377445810072879251e+00,2.373494017753199792e+00,2.368728204752104549e+00,2.363240209141685977e+00,2.357195384465128551e+00,2.350803567930932036e+00,2.344278415496869439e+00,2.337792115350179500e+00,2.331434508889710155e+00,2.325186608857034543e+00,2.318917157634413861e+00,2.312406196442917228e+00,2.305392144055823600e+00,2.297631206418188743e+00,2.288953519104951262e+00,2.279301284465961253e+00,2.268739496523504595e+00,2.257436946775693620e+00,2.245621801166836295e+00,2.233521623232586517e+00,2.221302562208785858e+00,2.209025410618240315e+00,2.196634198285958295e+00,2.183983343630590657e+00,2.170894294145444103e+00,2.157219742879611601e+00,2.142890743044757684e+00,2.127930495142040801e+00,2.112432175161921055e+00,2.096510039994834429e+00,2.080240997281214810e+00,2.063618807055993987e+00,2.046543505504982097e+00,2.028858892868873998e+00,2.010428717966435741e+00,1.991217741226962490e+00,1.971335832252794740e+00,1.951020026172868072e+00,1.930558551110740151e+00,1.910183029096946594e+00,1.889964622003596384e+00,1.869753664253196890e+00,1.849200519747223659e+00,1.827873391254848823e+00,1.805439222899740903e+00,1.781824813492665749e+00,1.757273021370588051e+00,1.732261679195396864e+00,1.707318303644522972e+00,1.682803063578475644e+00,1.658746008907813430e+00,1.634820625015925843e+00,1.610493891416116652e+00,1.585297050091503124e+00,1.559068803487333010e+00,1.532030408254532627e+00,1.504660894858844467e+00,1.477446582167055267e+00,1.450622088049255742e+00,1.424030357952401626e+00,1.397210639829909784e+00,1.369708955463762035e+00,1.341418133248748479e+00,1.312694088289023675e+00,1.284164668682259869e+00,1.256356983509431036e+00,1.229342659398874771e+00,1.202600447915006532e+00,1.175262166077123194e+00,1.146693652425172738e+00,1.117014072060815932e+00,1.087117777492491610e+00,1.058167256159249225e+00,1.030889467628034240e+00,1.005068069652153673e+00,9.795766744482388155e-01,9.530947663655663371e-01,9.250803619851667436e-01,8.961962992561970376e-01,8.678626370188368133e-01,8.413105904113018507e-01,8.167208626825079865e-01,7.930299609828685981e-01,7.687630666815467029e-01,7.433162538826756371e-01,7.174576864584532032e-01,6.926609144817408303e-01,6.699176650116074327e-01,6.488441400373361478e-01,6.278898514312887258e-01,6.058267889239905557e-01,5.830652291066598103e-01,5.613359560205395393e-01,5.421957270725497047e-01,5.255873137457508504e-01,5.095986610980307585e-01,4.921882631498931682e-01,4.733600979953044297e-01,4.552178411396146651e-01,4.400590864472272989e-01,4.282523263905382849e-01,4.176044912022127686e-01,4.055688337931286913e-01,3.920905356399561059e-01,3.794755869040219443e-01,3.699831487075117553e-01,3.634585837073993075e-01,3.572576489750322604e-01,3.495717699568869352e-01,3.416951904336057999e-01,3.362596987552606276e-01,3.342257009013045455e-01,3.332864830706725456e-01,3.305355554586013600e-01,3.266804849680813860e-01,3.250561646237365987e-01,3.276409723100375260e-01,3.322455156492971629e-01,3.347189927609360849e-01,3.349918829525499464e-01,3.368898917790060787e-01,3.431837956216457486e-01,3.517964693897224215e-01,3.581109773219158243e-01,3.622930209978130200e-01,3.684357575651489580e-01,3.787059791987245072e-01,3.896891628667594198e-01,3.972088043441251992e-01,4.038166807490365939e-01,4.141751955742370983e-01,4.281732830585795457e-01,4.396092694864981443e-01,4.466714783453920035e-01,4.551429607986770542e-01,4.689278875816787484e-01,4.835612585331948154e-01,4.924948531669393614e-01,4.994609763444062822e-01,5.108151367928668307e-01,5.253538176957078809e-01,5.348191136377885568e-01,5.405797377000659543e-01,5.498523148416800677e-01,5.629832366793153797e-01,5.708021186830335436e-01,5.737076494789923320e-01,5.803258472764302178e-01,5.915810813701498638e-01,5.966861756586294696e-01,5.960232912316391074e-01,5.993628598323941237e-01,6.072432447360226471e-01
+8.445668404310932532e-04,8.581966066559704480e-04,8.720462482769042629e-04,8.861193088981916301e-04,9.004193891004240403e-04,9.149501473515135727e-04,9.297153009320621589e-04,9.447186268753538082e-04,9.599639629221371926e-04,9.754552084904918700e-04,9.911963256609391485e-04,1.007191340177057476e-03,1.023444342461862127e-03,1.039959488650156602e-03,1.056741001637098373e-03,1.073793172143254916e-03,1.091120359796344304e-03,1.108726994229988251e-03,1.126617576199664484e-03,1.144796678716145143e-03,1.163268948196704601e-03,1.182039105634314193e-03,1.201111947785144136e-03,1.220492348374612032e-03,1.240185259322286286e-03,1.260195711985863040e-03,1.280528818424599103e-03,1.301189772682395185e-03,1.322183852090870297e-03,1.343516418592724613e-03,1.365192920085662705e-03,1.387218891787210008e-03,1.409599957620699846e-03,1.432341831622779924e-03,1.455450319372726892e-03,1.478931319443871047e-03,1.502790824877497195e-03,1.527034924679561683e-03,1.551669805340420531e-03,1.576701752378132032e-03,1.602137151905430297e-03,1.627982492220957610e-03,1.654244365424815868e-03,1.680929469059102383e-03,1.708044607773516769e-03,1.735596695016566925e-03,1.763592754752668591e-03,1.792039923205518371e-03,1.820945450628119484e-03,1.850316703099793300e-03,1.880161164350673247e-03,1.910486437613873826e-03,1.941300247505964261e-03,1.972610441935842163e-03,2.004424994042799772e-03,2.036752004163660049e-03,2.069599701829974870e-03,2.102976447795198815e-03,2.136890736092534812e-03,2.171351196123780160e-03,2.206366594779561943e-03,2.241945838591488747e-03,2.278097975916524871e-03,2.314832199154080120e-03,2.352157846996301774e-03,2.390084406711923907e-03,2.428621516464082603e-03,2.467778967662740200e-03,2.507566707351958826e-03,2.547994840632559696e-03,2.589073633120639144e-03,2.630813513442403252e-03,2.673225075765793806e-03,2.716319082369260743e-03,2.760106466248315581e-03,2.804598333760325093e-03,2.849805967307818006e-03,2.895740828061038954e-03,2.942414558720102703e-03,2.989838986317254303e-03,3.038026125059723956e-03,3.086988179213631493e-03,3.136737546029548084e-03,3.187286818710053423e-03,3.238648789419912473e-03,3.290836452339249065e-03,3.343863006760357335e-03,3.397741860228528296e-03,3.452486631727443196e-03,3.508111154909607232e-03,3.564629481372463739e-03,3.622055883980335005e-03,3.680404860233267832e-03,3.739691135682518455e-03,3.799929667394118336e-03,3.861135647460026046e-03,3.923324506558118971e-03,3.986511917561223056e-03,4.050713799195699259e-03,4.115946319749887693e-03,4.182225900833402149e-03,4.249569221187318377e-03,4.317993220545750938e-03,4.387515103549612279e-03,4.458152343712743111e-03,4.529922687440957919e-03,4.602844158104588482e-03,4.676935060164730956e-03,4.752213983354024868e-03,4.828699806911906749e-03,4.906411703875300338e-03,4.985369145424804922e-03,5.065591905286995038e-03,5.147100064193022365e-03,5.229914014394248384e-03,5.314054464235004084e-03,5.399542442783097744e-03,5.486399304517989260e-03,5.574646734077788081e-03,5.664306751064407744e-03,5.755401714908067907e-03,5.847954329790861980e-03,5.941987649630258578e-03,6.037525083121744914e-03,6.134590398842578417e-03,6.233207730414841614e-03,6.333401581729921834e-03,6.435196832232883100e-03,6.538618742268738175e-03,6.643692958488486150e-03,6.750445519317690296e-03,6.858902860484984536e-03,6.969091820612878171e-03,7.081039646869054759e-03,7.194774000679763672e-03,7.310322963503724028e-03,7.427715042667849821e-03,7.546979177263258426e-03,7.668144744103302414e-03,7.791241563741181306e-03,7.916299906548917437e-03,8.043350498855900491e-03,8.172424529147941791e-03,8.303553654325274494e-03,8.436770006020022708e-03,8.572106196972083952e-03,8.709595327463454453e-03,8.849270991809403061e-03,8.991167284907224111e-03,9.135318808840773783e-03,9.281760679540330267e-03,9.430528533497285065e-03,9.581658534532043470e-03,9.735187380615191455e-03,9.891152310739509054e-03,1.004959111184310430e-02,1.021054212578137270e-02,1.037404425634707444e-02,1.054013697633689184e-02,1.070886033466290910e-02,1.088025496350804311e-02,1.105436208552263398e-02,1.123122352106137312e-02,1.141088169545867968e-02,1.159337964633936485e-02,1.177876103096420213e-02,1.196707013360678168e-02,1.215835187295976304e-02,1.235265180956832305e-02,1.255001615328795589e-02,1.275049177076323544e-02,1.295412619292608120e-02,1.316096762250928282e-02,1.337106494157209134e-02,1.358446771903558739e-02,1.380122621822306786e-02,1.402139140440260105e-02,1.424501495232732839e-02,1.447214925377029657e-02,1.470284742504812669e-02,1.493716331453101911e-02,1.517515151013280189e-02,1.541686734677720841e-02,1.566236691383468896e-02,1.591170706252558256e-02,1.616494541328227300e-02,1.642214036306704344e-02,1.668335109263758068e-02,1.694863757375480659e-02,1.721806057632764217e-02,1.749168167548480549e-02,1.776956325857132965e-02,1.805176853205804621e-02,1.833836152835937802e-02,1.862940711255046955e-02,1.892497098897545638e-02,1.922511970773971637e-02,1.952992067107460483e-02,1.983944213956923344e-02,2.015375323825633475e-02,2.047292396254491234e-02,2.079702518398883482e-02,2.112612865587999364e-02,2.146030701865623419e-02,2.179963380511283633e-02,2.214418344540495034e-02,2.249403127183001797e-02,2.284925352337682444e-02,2.320992735002902832e-02,2.357613081680990166e-02,2.394794290755323032e-02,2.432544352838790155e-02,2.470871351092150670e-02,2.509783461510506700e-02,2.549288953176779421e-02,2.589396188480160704e-02,2.630113623298172346e-02,2.671449807140430580e-02,2.713413383252544914e-02,2.756013088678152534e-02,2.799257754277356333e-02,2.843156304699591755e-02,2.887717758308949723e-02,2.932951227060043645e-02,2.978865916322072024e-02,3.025471124649302748e-02,3.072776243495399170e-02,3.120790756869683616e-02,3.169524240932774378e-02,3.218986363529413586e-02,3.269186883655861298e-02,3.320135650859571547e-02,3.371842604568497243e-02,3.424317773347430177e-02,3.477571274078698760e-02,3.531613311064606825e-02,3.586454175048764403e-02,3.642104242153331589e-02,3.698573972729664316e-02,3.755873910118984194e-02,3.814014679320340551e-02,3.873006985562839344e-02,3.932861612778724286e-02,3.993589421974572812e-02,4.055201349497111751e-02,4.117708405190424747e-02,4.181121670441315108e-02,4.245452296109772372e-02,4.310711500340357744e-02,4.376910566252073531e-02,4.444060839502702448e-02,4.512173725724134138e-02,4.581260687825434996e-02,4.651333243160036407e-02,4.722402960553515050e-02,4.794481457188415341e-02,4.867580395342554350e-02,4.941711478977546534e-02,5.016886450173439066e-02,5.093117085406730776e-02,5.170415191667717542e-02,5.248792602413947933e-02,5.328261173356481362e-02,5.408832778075426534e-02,5.490519303461856293e-02,5.573332644982361556e-02,5.657284701763816426e-02,5.742387371494968307e-02,5.828652545141934510e-02,5.916092101475398796e-02,6.004717901406324276e-02,6.094541782128214125e-02,6.185575551063602490e-02,6.277830979612782081e-02,6.371319796702905325e-02,6.466053682136192748e-02,6.562044259735802521e-02,6.659303090288530569e-02,6.757841664283825711e-02,6.857671394448390523e-02,6.958803608077437919e-02,7.061249539162180178e-02,7.165020320314957614e-02,7.270126974493743011e-02,7.376580406527449840e-02,7.484391394445072399e-02,7.593570580611529175e-02,7.704128462674042499e-02,7.816075384323423192e-02,7.929421525875846033e-02,8.044176894680175882e-02,8.160351315358603530e-02,8.277954419887607884e-02,8.396995637527801537e-02,8.517484184612582332e-02,8.639429054205577385e-02,8.762839005639444512e-02,8.887722553947491333e-02,9.014087959203699596e-02,9.141943215785514054e-02,9.271296041576293501e-02,9.402153867125843945e-02,9.534523824788568303e-02,9.668412737860221373e-02,9.803827109737126011e-02,9.940773113120972282e-02,1.007925657929753388e-01,1.021928298751660635e-01,1.036085745450368439e-01,1.050398472413662937e-01,1.064866915732155528e-01,1.079491472210531156e-01,1.094272498406380772e-01,1.109210309700829761e-01,1.124305179405438310e-01,1.139557337910046542e-01,1.154966971876644349e-01,1.170534223484478165e-01,1.186259189732060959e-01,1.202141921801951896e-01,1.218182424494548277e-01,1.234380655737399857e-01,1.250736526177045616e-01,1.267249898860503543e-01,1.283920589014060365e-01,1.300748363927384521e-01,1.317732942951222452e-01,1.334873997617480323e-01,1.352171151890819156e-01,1.369623982561218589e-01,1.387232019787534576e-01,1.404994747802349730e-01,1.422911605788865497e-01,1.440981988941076597e-01,1.459205249718700248e-01,1.477580699309091472e-01,1.496107609308348074e-01,1.514785213634628203e-01,1.533612710686989844e-01,1.552589265763196225e-01,1.571714013750890038e-01,1.590986062106362342e-01,1.610404494135892206e-01,1.629968372594808868e-01,1.649676743619819530e-01,1.669528641010504522e-01,1.689523090876105249e-01,1.709659116663914125e-01,1.729935744586121593e-01,1.750352009461676461e-01,1.770906960990295542e-01,1.791599670475597650e-01,1.812429238014370003e-01,1.833394800169243777e-01,1.854495538141385236e-01,1.875730686460340690e-01,1.897099542207395240e-01,1.918601474788607097e-01,1.940235936273422834e-01,1.962002472314011148e-01,1.983900733659813564e-01,2.005930488281373048e-01,2.028091634115813946e-01,2.050384212446389465e-01,2.072808421926085609e-01,2.095364633255019926e-01,2.118053404518753791e-01,2.140875497193904797e-01,2.163831892824431002e-01,2.186923810370834664e-01,2.210152724231091159e-01,2.233520382930367365e-01,2.257028828472780191e-01,2.280680416346058115e-01,2.304477836165694793e-01,2.328424132942153446e-01,2.352522728949448805e-01,2.376777446170366959e-01,2.401192529287098365e-01,2.425772669182340302e-01,2.450523026908860980e-01,2.475449258080903436e-01,2.500557537632811522e-01,2.525854584884696941e-01,2.551347688846404282e-01,2.577044733684255018e-01,2.602954224265504046e-01,2.629085311687792692e-01,2.655447818690545025e-01,2.682052264836046751e-01,2.708909891337144549e-01,2.736032685398025466e-01,2.763433403922700426e-01,2.791125596434538836e-01,2.819123627037209423e-01,2.847442695235290477e-01,2.876098855419074174e-01,2.905109034804984613e-01,2.934491049608888846e-01,2.964263619215750101e-01,2.994446378094319794e-01,3.025059885192284970e-01,3.056125630531253412e-01,3.087666038708864469e-01,3.119704468999436875e-01,3.152265211733007444e-01,3.185373480618182152e-01,3.219055400663688449e-01,3.253337991341673230e-01,3.288249144627241050e-01,3.323817597539973634e-01,3.360072898808341146e-01,3.397045369273243853e-01,3.434766055647585081e-01,3.473266677249234879e-01,3.512579565332675235e-01,3.552737594652563557e-01,3.593774106908533272e-01,3.635722825738856301e-01,3.678617762956841175e-01,3.722493115754070270e-01,3.767383154633556219e-01,3.813322101881165826e-01,3.860344000436333745e-01,3.908482573086036194e-01,3.957771071975267341e-01,4.008242118508782426e-01,4.059927533807398126e-01,4.112858159982916151e-01,4.167063672605317293e-01,4.222572384856332905e-01,4.279411043994079678e-01,4.337604620893064644e-01,4.397176093574030609e-01,4.458146225795509565e-01,4.520533341943828165e-01,4.584353099630409378e-01,4.649618261579728795e-01,4.716338468569507558e-01,4.784520015362510037e-01,4.854165631743416753e-01,4.925274270943984511e-01,4.997840907898386531e-01,5.071856349917527318e-01,5.147307062500543484e-01,5.224175013108987020e-01,5.302437535812970504e-01,5.382067219769368638e-01,5.463031824511481727e-01,5.545294225007918465e-01,5.628812389385596804e-01,5.713539392102380265e-01,5.799423465196213989e-01,5.886408090027247519e-01,5.974432131668406809e-01,6.063430017780983006e-01,6.153331963446299069e-01,6.244064243002448444e-01,6.335549509468958451e-01,6.427707161630791255e-01,6.520453758303851322e-01,6.613703478724970442e-01,6.707368627404534100e-01,6.801360181163386143e-01,6.895588375452583740e-01,6.989963326437377278e-01,7.084395684726993991e-01,7.178797316055525179e-01,7.273082003683312147e-01,7.367166166795005022e-01,7.460969588733786795e-01,7.554416148535780806e-01,7.647434548920452047e-01,7.739959033655452458e-01,7.831930087052421108e-01,7.923295108259109654e-01,8.014009052996590166e-01,8.104035035440411150e-01,8.193344883058781836e-01,8.281919637392330946e-01,8.369749993980206693e-01,8.456836674900450879e-01,8.543190727689555786e-01,8.628833744730557420e-01,8.713797997543072382e-01,8.798126480772103797e-01,8.881872861047126477e-01,8.965101326276194715e-01,9.047886331348904410e-01,9.130312236660326208e-01,9.212472836342100457e-01,9.294470773614318393e-01,9.376416841272061653e-01,9.458429166011798062e-01,9.540632276118621302e-01,9.623156052992690723e-01,9.706134568135099672e-01,9.789704808551676907e-01,9.874005295114314240e-01,9.959174600248613674e-01,1.004534977342417035e+00,1.013266468531098807e+00,1.022124830413044361e+00,1.031122292065148160e+00,1.040270234142999684e+00,1.049579007319354274e+00,1.059057752466763036e+00,1.068714225550144947e+00,1.078554630516169954e+00,1.088583463755514291e+00,1.098803373954796214e+00,1.109215041326314655e+00,1.119817080286535260e+00,1.130605969627588969e+00,1.141576014070851297e+00,1.152719340791779734e+00,1.164025934048127597e+00,1.175483710423661732e+00,1.187078636416236010e+00,1.198794889162699162e+00,1.210615060021326128e+00,1.222520399552819992e+00,1.234491101190393625e+00,1.246506619611617017e+00,1.258546018571017333e+00,1.270588341775015895e+00,1.282612999334515891e+00,1.294600161465913057e+00,1.306531150472076463e+00,1.318388821656572896e+00,1.330157923729101910e+00,1.341825429456452889e+00,1.353380827797196373e+00,1.364816369508958127e+00,1.376127259205220055e+00,1.387311788021920123e+00,1.398371402387467155e+00,1.409310705821865684e+00,1.420137392175149893e+00,1.430862110205658011e+00,1.441498260859670699e+00,1.452061730014654328e+00,1.462570560770140027e+00,1.473044570601274694e+00,1.483504919826622803e+00,1.493973638885351507e+00,1.504473122873738244e+00,1.515025602662032789e+00,1.525652602701840888e+00,1.536374396340723036e+00,1.547209470076812421e+00,1.558174008700399682e+00,1.569281413661735680e+00,1.580541867252788002e+00,1.591961955265630779e+00,1.603544360659032941e+00,1.615287640387600643e+00,1.627186096877222488e+00,1.639229754606960521e+00,1.651404450808247937e+00,1.663692047328748647e+00,1.676070768132495559e+00,1.688515663622502272e+00,1.700999198899129095e+00,1.713491958181949215e+00,1.725963451984432240e+00,1.738383007420284621e+00,1.750720715570540431e+00,1.762948403632924599e+00,1.775040594225721469e+00,1.786975410409691101e+00,1.798735383384691522e+00,1.810308120940367083e+00,1.821686798874597724e+00,1.832870444695150258e+00,1.843863992578435695e+00,1.854678100028152699e+00,1.865328728959354754e+00,1.875836505920848385e+00,1.886225886798899909e+00,1.896524159756240779e+00,1.906760325813463997e+00,1.916963899230430535e+00,1.927163669958414038e+00,1.937386468542736662e+00,1.947655970870626252e+00,1.957991577135745453e+00,1.968407397359166033e+00,1.978911375576663190e+00,1.989504586748611858e+00,2.000180744306722769e+00,2.010925960958559688e+00,2.021718809021045171e+00,2.032530726535437537e+00,2.043326808786221971e+00,2.054067008975621444e+00,2.064707745210152101e+00,2.075203874157983464e+00,2.085510947875590215e+00,2.095587625195358683e+00,2.105398070482668693e+00,2.114914148733259669e+00,2.124117223541603039e+00,2.132999386563451338e+00,2.141563992106751968e+00,2.149825432048176665e+00,2.157808154647355980e+00,2.165544995255989758e+00,2.173074938277934187e+00,2.180440462673927104e+00,2.187684637223493489e+00,2.194848130468591396e+00,2.201966290484165700e+00,2.209066438784502484e+00,2.216165516621488862e+00,2.223268222980772091e+00,2.230365789406942412e+00,2.237435540398399869e+00,2.244441379120678537e+00,2.251335305370739004e+00,2.258060007541922154e+00,2.264552470673338203e+00,2.270748415705559076e+00,2.276587248095369276e+00,2.282017072248071710e+00,2.286999249984730920e+00,2.291511970439692458e+00,2.295552367856323883e+00,2.299136868609206630e+00,2.302299647979477726e+00,2.305089296614038386e+00,2.307563998572639719e+00,2.309785676930019349e+00,2.311813653599182228e+00,2.313698398714843396e+00,2.315475924857937073e+00,2.317163329216425094e+00,2.318755914355547176e+00,2.320226228926919099e+00,2.321525259151885123e+00,2.322585862321096428e+00,2.323328356822065288e+00,2.323667963679377557e+00,2.323523532838465133e+00,2.322826699450772026e+00,2.321530346581026638e+00,2.319615083927816457e+00,2.317092493298398281e+00,2.314004224592613568e+00,2.310416653259694808e+00,2.306411617625775623e+00,2.302074535815907375e+00,2.297481737911473587e+00,2.292688998250701715e+00,2.287723002935771799e+00,2.282576943749949017e+00,2.277210758273643165e+00,2.271555896797780250e+00,2.265523987882743118e+00,2.259018404996834928e+00,2.251947438422410741e+00,2.244237466928710845e+00,2.235844203772922256e+00,2.226759920491544698e+00,2.217014812841886062e+00,2.206671596606356367e+00,2.195813948803403637e+00,2.184531084689137703e+00,2.172901885598825356e+00,2.160982015713698079e+00,2.148796344182375417e+00,2.136337255208445196e+00,2.123567891914708294e+00,2.110428657874221958e+00,2.096845493677030881e+00,2.082739147408910529e+00,2.068035252384083478e+00,2.052675058631286742e+00,2.036626057810174029e+00,2.019890787539017296e+00,2.002511329248019223e+00,1.984566992011782993e+00,1.966163738429189678e+00,1.947415889924390298e+00,1.928422894808974108e+00,1.909245730737940017e+00,1.889888467071754619e+00,1.870290540394567769e+00,1.850334195335721521e+00,1.829868872064962515e+00,1.808749840588585123e+00,1.786882728292793487e+00,1.764260638119270475e+00,1.740979091881580620e+00,1.717218551158154360e+00,1.693195079099214961e+00,1.669093382760600486e+00,1.645006471847341611e+00,1.620906305880615683e+00,1.596658472988115474e+00,1.572075808001935693e+00,1.546989644565509581e+00,1.521310961128631511e+00,1.495059286388932707e+00,1.468350857163610801e+00,1.441352954295741728e+00,1.414224049922045534e+00,1.387065682651140941e+00,1.359907134124930250e+00,1.332726401010190465e+00,1.305488951908485351e+00,1.278175123997187024e+00,1.250777450687782011e+00,1.223274508450553411e+00,1.195610473935922569e+00,1.167712019216318176e+00,1.139548887222207485e+00,1.111203509342192364e+00,1.082891048826543079e+00,1.054892600910474432e+00,1.027421706352511066e+00,1.000496688777255283e+00,9.739038646016834333e-01,9.472978354001466705e-01,9.204037949674278574e-01,8.932066267858651543e-01,8.659998321307342817e-01,8.392459442388990887e-01,8.133180574222919068e-01,7.882811651354066917e-01,7.638730929222699029e-01,7.397169257814998344e-01,7.156075038636824370e-01,6.916466125673288445e-01,6.681334969231391696e-01,6.453167897873380854e-01,6.232222297826721658e-01,6.017129517615038559e-01,5.807209416600787044e-01,5.603980434659936449e-01,5.410100840645019060e-01,5.226562750580626693e-01,5.050803168611390781e-01,4.878252758708664927e-01,4.706910609869334183e-01,4.540565279202654625e-01,4.386665874551139988e-01,4.250037169832239781e-01,4.127929033614134990e-01,4.011781845621266163e-01,3.895297386516926030e-01,3.780811438233172561e-01,3.677085107288340926e-01,3.590763665715396291e-01,3.519827290419697552e-01,3.456271503831113145e-01,3.395691207907183262e-01,3.342049302412156142e-01,3.302048299909782769e-01,3.275981265572011081e-01,3.256398757089477569e-01,3.238443045939238263e-01,3.228179497494169103e-01,3.235836477854923676e-01,3.261891104030179012e-01,3.293316226300874727e-01,3.318608858621558411e-01,3.343975529321978057e-01,3.386511626471325198e-01,3.452487147815151980e-01,3.527300442033109995e-01,3.593910140460265801e-01,3.656384161453798409e-01,3.732566402573913034e-01,3.827803596563238986e-01,3.925822436913811719e-01,4.014595109877670542e-01,4.105930721402806793e-01,4.214905928478800412e-01,4.332798220518229715e-01,4.436464233861397433e-01,4.528589062006714294e-01,4.635574924206647962e-01,4.764356631718666968e-01,4.885058074898813163e-01,4.977995826644542876e-01,5.068338503785626559e-01,5.182543018689287351e-01,5.301851686961593924e-01,5.392658205823009920e-01,5.469116715799460238e-01,5.562522551420520101e-01,5.661130769756763659e-01,5.728150154355765578e-01,5.779610888561985682e-01,5.851758048952534486e-01,5.926567626960226320e-01,5.957627673801190182e-01,5.970136287124350183e-01,6.010548745205200882e-01
+2.332025408162599796e-03,2.369713979894717739e-03,2.408012144008811126e-03,2.446929771992508579e-03,2.486476895421047689e-03,2.526663708556270253e-03,2.567500570987632513e-03,2.608998010316121614e-03,2.651166724881556195e-03,2.694017586534159289e-03,2.737561643450979031e-03,2.781810122997873183e-03,2.826774434637908777e-03,2.872466172886821347e-03,2.918897120316237166e-03,2.966079250605550138e-03,3.014024731643133795e-03,3.062745928677717156e-03,3.112255407520677763e-03,3.162565937800146994e-03,3.213690496267641947e-03,3.265642270158095137e-03,3.318434660604235257e-03,3.372081286105956064e-03,3.426595986055828730e-03,3.481992824321314493e-03,3.538286092884893215e-03,3.595490315542826908e-03,3.653620251663494516e-03,3.712690900006301517e-03,3.772717502602145750e-03,3.833715548696234408e-03,3.895700778754391906e-03,3.958689188533846132e-03,4.022697033219417226e-03,4.087740831626137175e-03,4.153837370469395246e-03,4.221003708703752882e-03,4.289257181931120655e-03,4.358615406879883664e-03,4.429096285955616379e-03,4.500718011864955972e-03,4.573499072313189258e-03,4.647458254777293157e-03,4.722614651355115656e-03,4.798987663692138791e-03,4.876597007986918295e-03,4.955462720076496581e-03,5.035605160602771822e-03,5.117045020261282856e-03,5.199803325133735277e-03,5.283901442105150802e-03,5.369361084367467452e-03,5.456204317010219379e-03,5.544453562700557558e-03,5.634131607452657307e-03,5.725261606489277788e-03,5.817867090195758852e-03,5.911971970168341736e-03,6.007600545358119000e-03,6.104777508312034424e-03,6.203527951512314599e-03,6.303877373815896905e-03,6.405851686995165349e-03,6.509477222381638770e-03,6.614780737614119749e-03,6.721789423492458698e-03,6.830530910939144017e-03,6.941033278069591757e-03,7.053325057373206058e-03,7.167435243006349196e-03,7.283393298199290766e-03,7.401229162778514246e-03,7.520973260805747899e-03,7.642656508335985560e-03,7.766310321295753251e-03,7.891966623483182008e-03,8.019657854691898333e-03,8.149416978960455707e-03,8.281277492948636854e-03,8.415273434442881867e-03,8.551439390991972395e-03,8.689810508675715334e-03,8.830422501007101355e-03,8.973311657970934122e-03,9.118514855200012675e-03,9.266069563290874056e-03,9.416013857261117115e-03,9.568386426149787238e-03,9.723226582762955691e-03,9.880574273566410451e-03,1.004047008872664681e-02,1.020295527230346937e-02,1.036807173259394858e-02,1.053586205263225967e-02,1.070636950084464731e-02,1.087963804186317836e-02,1.105571234749993560e-02,1.123463780788287215e-02,1.141646054275539598e-02,1.160122741294258332e-02,1.178898603198469223e-02,1.197978477794020384e-02,1.217367280536082487e-02,1.237070005743970760e-02,1.257091727833507810e-02,1.277437602567113237e-02,1.298112868321787440e-02,1.319122847375219475e-02,1.340472947210131528e-02,1.362168661837111390e-02,1.384215573136082095e-02,1.406619352216597132e-02,1.429385760797088380e-02,1.452520652603331644e-02,1.476029974786229743e-02,1.499919769359118332e-02,1.524196174654678972e-02,1.548865426801800983e-02,1.573933861222306593e-02,1.599407914147880222e-02,1.625294124157281028e-02,1.651599133734021549e-02,1.678329690844462471e-02,1.705492650536861998e-02,1.733094976560965728e-02,1.761143743008793811e-02,1.789646135976256935e-02,1.818609455246177065e-02,1.848041115992273692e-02,1.877948650504808123e-02,1.908339709937364320e-02,1.939222066075341547e-02,1.970603613125818804e-02,2.002492369529207741e-02,2.034896479792348833e-02,2.067824216343443905e-02,2.101283981408450657e-02,2.135284308909428733e-02,2.169833866384250631e-02,2.204941456928172575e-02,2.240616021156800405e-02,2.276866639190727043e-02,2.313702532661481015e-02,2.351133066738861008e-02,2.389167752179482268e-02,2.427816247396464774e-02,2.467088360549842679e-02,2.506994051657958356e-02,2.547543434729196421e-02,2.588746779914074050e-02,2.630614515677395099e-02,2.673157230990077030e-02,2.716385677540533727e-02,2.760310771965001145e-02,2.804943598096702045e-02,2.850295409233256569e-02,2.896377630421994448e-02,2.943201860762598848e-02,2.990779875726631495e-02,3.039123629493513043e-02,3.088245257301934499e-02,3.138157077816563362e-02,3.188871595509150392e-02,3.240401503053061405e-02,3.292759683730978743e-02,3.345959213854395042e-02,3.400013365194390347e-02,3.454935607422572608e-02,3.510739610561291330e-02,3.567439247441760858e-02,3.625048596169558324e-02,3.683581942595682418e-02,3.743053782792186979e-02,3.803478825531178553e-02,3.864871994765537583e-02,3.927248432109972653e-02,3.990623499320854889e-02,4.055012780773242093e-02,4.120432085933086602e-02,4.186897451823219651e-02,4.254425145480806442e-02,4.323031666404451856e-02,4.392733748988657261e-02,4.463548364943766000e-02,4.535492725698470062e-02,4.608584284783005802e-02,4.682840740190043899e-02,4.758280036710697825e-02,4.834920368243077887e-02,4.912780180069700048e-02,4.991878171101654660e-02,5.072233296085371795e-02,5.153864767769123639e-02,5.236792059025458662e-02,5.321034904925881631e-02,5.406613304764248951e-02,5.493547524023890266e-02,5.581858096285580856e-02,5.671565825070525729e-02,5.762691785614856843e-02,5.855257326570196402e-02,5.949284071625468573e-02,6.044793921044631230e-02,6.141809053115136752e-02,6.240351925501044089e-02,6.340445276495211557e-02,6.442112126164205310e-02,6.545375777379497384e-02,6.650259816728699980e-02,6.756788115299022790e-02,6.864984829326713223e-02,6.974874400704492161e-02,7.086481557338934756e-02,7.199831313350504858e-02,7.314948969106854770e-02,7.431860111081575737e-02,7.550590611528586182e-02,7.671166627963382778e-02,7.793614602440986083e-02,7.917961260620570707e-02,8.044233610606521534e-02,8.172458941554626433e-02,8.302664822032883307e-02,8.434879098124321850e-02,8.569129891260798826e-02,8.705445595774262413e-02,8.843854876153779687e-02,8.984386663993713940e-02,9.127070154620543774e-02,9.271934803382882173e-02,9.419010321590924606e-02,9.568326672089653984e-02,9.719914064450374536e-02,9.873802949764085013e-02,1.003002401502030433e-01,1.018860817705453531e-01,1.034958657604538312e-01,1.051299056854485825e-01,1.067885172002163707e-01,1.084720179689866587e-01,1.101807275806552661e-01,1.119149674584429682e-01,1.136750607638883914e-01,1.154613322949570725e-01,1.172741083780419885e-01,1.191137167536365921e-01,1.209804864554480386e-01,1.228747476827023871e-01,1.247968316654156640e-01,1.267470705223723293e-01,1.287257971115564337e-01,1.307333448727828196e-01,1.327700476622596382e-01,1.348362395788179069e-01,1.369322547815270408e-01,1.390584272984207725e-01,1.412150908260580706e-01,1.434025785196120228e-01,1.456212227732180953e-01,1.478713549902707092e-01,1.501533053433730114e-01,1.524674025236411601e-01,1.548139734790570377e-01,1.571933431415617755e-01,1.596058341425836968e-01,1.620517665166877341e-01,1.645314573930482527e-01,1.670452206744137691e-01,1.695933667032842873e-01,1.721762019149667144e-01,1.747940284772223074e-01,1.774471439161987019e-01,1.801358407283513707e-01,1.828604059780614688e-01,1.856211208806725632e-01,1.884182603706594517e-01,1.912520926546729394e-01,1.941228787492039476e-01,1.970308720026042737e-01,1.999763176012624988e-01,2.029594520597027829e-01,2.059805026944005468e-01,2.090396870811607466e-01,2.121372124958809668e-01,2.152732753385707687e-01,2.184480605405244857e-01,2.216617409545575124e-01,2.249144767282666157e-01,2.282064146602852950e-01,2.315376875395653844e-01,2.349084134677333069e-01,2.383186951646328877e-01,2.417686192571807113e-01,2.452582555517533458e-01,2.487876562903260369e-01,2.523568553906965217e-01,2.559658676711129566e-01,2.596146880597723916e-01,2.633032907896611374e-01,2.670316285792992961e-01,2.707996318000396863e-01,2.746072076306346199e-01,2.784542391998774957e-01,2.823405847182288153e-01,2.862660765993832457e-01,2.902305205729113768e-01,2.942336947891424637e-01,2.982753489175945516e-01,3.023552032403813983e-01,3.064729477421378467e-01,3.106282411981127201e-01,3.148207102622407327e-01,3.190499485571111071e-01,3.233155157679212244e-01,3.276169367426103318e-01,3.319537006005656155e-01,3.363252598524044679e-01,3.407310295335227446e-01,3.451703863542702200e-01,3.496426678697457380e-01,3.541471716724171603e-01,3.586831546109400803e-01,3.632498320386944868e-01,3.678463770957793866e-01,3.724719200283895248e-01,3.771255475496379517e-01,3.818063022461282152e-01,3.865131820347498803e-01,3.912451396743211740e-01,3.960010823369484734e-01,4.007798712441101863e-01,4.055803213726594803e-01,4.104012012361424322e-01,4.152412327469317543e-01,4.200990911649473691e-01,4.249734051387573652e-01,4.298627568451140468e-01,4.347656822330617232e-01,4.396806713788383725e-01,4.446061689580126375e-01,4.495405748412673042e-01,4.544822448204026699e-01,4.594294914711489763e-01,4.643805851594308143e-01,4.693337551977381783e-01,4.742871911582453026e-01,4.792390443492692276e-01,4.841874294616404506e-01,4.891304263913978656e-01,4.940660822451428680e-01,4.989924135342113098e-01,5.039074085635858458e-01,5.088090300213317096e-01,5.136952177739132486e-01,5.185638918725730129e-01,5.234129557755133888e-01,5.282402997902054809e-01,5.330438047397205725e-01,5.378213458564858884e-01,5.425707969062316671e-01,5.472900345444214887e-01,5.519769429065994881e-01,5.566294184336204598e-01,5.612453749316760332e-01,5.658227488664889782e-01,5.703595048898940645e-01,5.748536415963166890e-01,5.793031975054668825e-01,5.837062572667029992e-01,5.880609580792115487e-01,5.923654963211895108e-01,5.966181343798053760e-01,6.008172076726161492e-01,6.049611318496433965e-01,6.090484101640997183e-01,6.130776409981149033e-01,6.170475255286425043e-01,6.209568755168703991e-01,6.248046212032221103e-01,6.285898192881780311e-01,6.323116609777432728e-01,6.359694800704809303e-01,6.395627610615656211e-01,6.430911472373721516e-01,6.465544487325479706e-01,6.499526505195454273e-01,6.532859202989762526e-01,6.565546162571891387e-01,6.597592946557405691e-01,6.629007172155318983e-01,6.659798582565872316e-01,6.689979115525745978e-01,6.719562968573785655e-01,6.748566660591461819e-01,6.777009089155047183e-01,6.804911583217979620e-01,6.832297950624637295e-01,6.859194519940109425e-01,6.885630176063135544e-01,6.911636389074062858e-01,6.937247235755209518e-01,6.962499413204809029e-01,6.987432243955502553e-01,7.012087671994077231e-01,7.036510249071237233e-01,7.060747110680496430e-01,7.084847941080161249e-01,7.108864926728938327e-01,7.132852697505345230e-01,7.156868255083794761e-01,7.180970887848144857e-01,7.205222071733982103e-01,7.229685356409302210e-01,7.254426236223653346e-01,7.279512005387520635e-01,7.305011596878254743e-01,7.330995404614707445e-01,7.357535088496460762e-01,7.384703361967828172e-01,7.412573761840721698e-01,7.441220400198857998e-01,7.470717698305060495e-01,7.501140102546712818e-01,7.532561782584673571e-01,7.565056312013304085e-01,7.598696332002243814e-01,7.633553198566584985e-01,7.669696614308171290e-01,7.707194245683806066e-01,7.746111327085835052e-01,7.786510253268975612e-01,7.828450161920096351e-01,7.871986508447851305e-01,7.917170635360665232e-01,7.964049338905175857e-01,8.012664435949882202e-01,8.063052334414712030e-01,8.115243610865201518e-01,8.169262599203492847e-01,8.225126994691573934e-01,8.282847477830835858e-01,8.342427362886674080e-01,8.403862276081974780e-01,8.467139868680694237e-01,8.532239570331587863e-01,8.599132388139010263e-01,8.667780756956360300e-01,8.738138446357676115e-01,8.810150529618414605e-01,8.883753419825058950e-01,8.958874977925236349e-01,9.035434697120316994e-01,9.113343967486093877e-01,9.192506424084939676e-01,9.272818381095361273e-01,9.354169353647110441e-01,9.436442668101331366e-01,9.519516160473542321e-01,9.603262961565568467e-01,9.687552366163936224e-01,9.772250782393641089e-01,9.857222755998865660e-01,9.942332062981913410e-01,1.002744286268343998e+00,1.011242090205552779e+00,1.019713476058899948e+00,1.028145712412558810e+00,1.036526607464581806e+00,1.044844638208822341e+00,1.053089078335369688e+00,1.061250123289583236e+00,1.069319010871352393e+00,1.077288135715974482e+00,1.085151155977646331e+00,1.092903090536541111e+00,1.100540405072134575e+00,1.108061085389050460e+00,1.115464696447775683e+00,1.122752425641629248e+00,1.129927108973121763e+00,1.136993238918066806e+00,1.143956952924292558e+00,1.150826001674115640e+00,1.157609696445906389e+00,1.164318835141020081e+00,1.170965606797801373e+00,1.177563474695346279e+00,1.184127038455573544e+00,1.190671875883321684e+00,1.197214365639118316e+00,1.203771492216473060e+00,1.210360635092039949e+00,1.216999344327750698e+00,1.223705105323687370e+00,1.230495095839383879e+00,1.237385938810461328e+00,1.244393454872054772e+00,1.251532418847473904e+00,1.258816324750620108e+00,1.266257164066693974e+00,1.273865222197263503e+00,1.281648897963672873e+00,1.289614550938613213e+00,1.297766381104630051e+00,1.306106344907787875e+00,1.314634111180737364e+00,1.323347059651477142e+00,1.332240323843389307e+00,1.341306879125668594e+00,1.350537675520053549e+00,1.359921813644066280e+00,1.369446760917508943e+00,1.379098603925407840e+00,1.388862331667886085e+00,1.398722143385864536e+00,1.408661773776612947e+00,1.418664827743847168e+00,1.428715116389817519e+00,1.438796985767573977e+00,1.448895629971065580e+00,1.458997380436941382e+00,1.469089963842309388e+00,1.479162721675749914e+00,1.489206785402338307e+00,1.499215202104319911e+00,1.509183006534795979e+00,1.519107236660370397e+00,1.528986890992520165e+00,1.538822827335295074e+00,1.548617604038298623e+00,1.558375266474064880e+00,1.568101083291389308e+00,1.577801239045141468e+00,1.587482492057881167e+00,1.597151808772753201e+00,1.606815988305653864e+00,1.616481293231583516e+00,1.626153104628063506e+00,1.635835620780644817e+00,1.645531619445023574e+00,1.655242302870671756e+00,1.664967242679730841e+00,1.674704437999112949e+00,1.684450494920191943e+00,1.694200928517344718e+00,1.703950580571389928e+00,1.713694137265370676e+00,1.723426722045448223e+00,1.733144530277642259e+00,1.742845465038952879e+00,1.752529728099261552e+00,1.762200317524702964e+00,1.771863383856690399e+00,1.781528400776494658e+00,1.791208113602777319e+00,1.800918239694795808e+00,1.810676908426292142e+00,1.820503844234410362e+00,1.830419313553384386e+00,1.840442874308546584e+00,1.850591984077585961e+00,1.860880538966325437e+00,1.871317428601783739e+00,1.881905202317195158e+00,1.892638946523527377e+00,1.903505472448663083e+00,1.914482906067318968e+00,1.925540757592260732e+00,1.936640526192123346e+00,1.947736866993690530e+00,1.958779312894025182e+00,1.969714504928296250e+00,1.980488844291713013e+00,1.991051439584359706e+00,2.001357187802973225e+00,2.011369800461910273e+00,2.021064570040720820e+00,2.030430669005810707e+00,2.039472785121383858e+00,2.048211922599274537e+00,2.056685237651661780e+00,2.064944827193533339e+00,2.073055448398414491e+00,2.081091212175610217e+00,2.089131363295507526e+00,2.097255331871302531e+00,2.105537312902573621e+00,2.114040699182430316e+00,2.122812752709300810e+00,2.131879942993260002e+00,2.141244397159808965e+00,2.150881885288272954e+00,2.160741695006082264e+00,2.170748626530607517e+00,2.180807165498420463e+00,2.190807678606947917e+00,2.200634249162694900e+00,2.210173556435490294e+00,2.219324036667619016e+00,2.228004472348135589e+00,2.236161156803233130e+00,2.243772876004366257e+00,2.250853127859781644e+00,2.257449240543083935e+00,2.263638330982275182e+00,2.269520338817210714e+00,2.275208659636275499e+00,2.280819166211866644e+00,2.286458628564471240e+00,2.292213698343960715e+00,2.298141678538252464e+00,2.304264221034554971e+00,2.310564854527393575e+00,2.316990838671715291e+00,2.323459298922530891e+00,2.329866993956871468e+00,2.336102509980877429e+00,2.342059276639977039e+00,2.347647644818402934e+00,2.352804391291645203e+00,2.357498390449784598e+00,2.361731741320485689e+00,2.365536261246062200e+00,2.368965869847928118e+00,2.372085931988021201e+00,2.374961074738761724e+00,2.377643309704061902e+00,2.380162420602455420e+00,2.382520427621742432e+00,2.384691428884367248e+00,2.386627230035341718e+00,2.388268021240230965e+00,2.389556197805071225e+00,2.390450557115304964e+00,2.390937789504465449e+00,2.391038506447027867e+00,2.390805943748404605e+00,2.390316773328007294e+00,2.389654974748893324e+00,2.388891285623659488e+00,2.388062154505397938e+00,2.387153035322238992e+00,2.386090857786009156e+00,2.384749198019000982e+00,2.382966995065059823e+00,2.380578123102215837e+00,2.377445810072879251e+00,2.373494017753199792e+00,2.368728204752104549e+00,2.363240209141685977e+00,2.357195384465128551e+00,2.350803567930932036e+00,2.344278415496869439e+00,2.337792115350179500e+00,2.331434508889710155e+00,2.325186608857034543e+00,2.318917157634413861e+00,2.312406196442917228e+00,2.305392144055823600e+00,2.297631206418188743e+00,2.288953519104951262e+00,2.279301284465961253e+00,2.268739496523504595e+00,2.257436946775693620e+00,2.245621801166836295e+00,2.233521623232586517e+00,2.221302562208785858e+00,2.209025410618240315e+00,2.196634198285958295e+00,2.183983343630590657e+00,2.170894294145444103e+00,2.157219742879611601e+00,2.142890743044757684e+00,2.127930495142040801e+00,2.112432175161921055e+00,2.096510039994834429e+00,2.080240997281214810e+00,2.063618807055993987e+00,2.046543505504982097e+00,2.028858892868873998e+00,2.010428717966435741e+00,1.991217741226962490e+00,1.971335832252794740e+00,1.951020026172868072e+00,1.930558551110740151e+00,1.910183029096946594e+00,1.889964622003596384e+00,1.869753664253196890e+00,1.849200519747223659e+00,1.827873391254848823e+00,1.805439222899740903e+00,1.781824813492665749e+00,1.757273021370588051e+00,1.732261679195396864e+00,1.707318303644522972e+00,1.682803063578475644e+00,1.658746008907813430e+00,1.634820625015925843e+00,1.610493891416116652e+00,1.585297050091503124e+00,1.559068803487333010e+00,1.532030408254532627e+00,1.504660894858844467e+00,1.477446582167055267e+00,1.450622088049255742e+00,1.424030357952401626e+00,1.397210639829909784e+00,1.369708955463762035e+00,1.341418133248748479e+00,1.312694088289023675e+00,1.284164668682259869e+00,1.256356983509431036e+00,1.229342659398874771e+00,1.202600447915006532e+00,1.175262166077123194e+00,1.146693652425172738e+00,1.117014072060815932e+00,1.087117777492491610e+00,1.058167256159249225e+00,1.030889467628034240e+00,1.005068069652153673e+00,9.795766744482388155e-01,9.530947663655663371e-01,9.250803619851667436e-01,8.961962992561970376e-01,8.678626370188368133e-01,8.413105904113018507e-01,8.167208626825079865e-01,7.930299609828685981e-01,7.687630666815467029e-01,7.433162538826756371e-01,7.174576864584532032e-01,6.926609144817408303e-01,6.699176650116074327e-01,6.488441400373361478e-01,6.278898514312887258e-01,6.058267889239905557e-01,5.830652291066598103e-01,5.613359560205395393e-01,5.421957270725497047e-01,5.255873137457508504e-01,5.095986610980307585e-01,4.921882631498931682e-01,4.733600979953044297e-01,4.552178411396146651e-01,4.400590864472272989e-01,4.282523263905382849e-01,4.176044912022127686e-01,4.055688337931286913e-01,3.920905356399561059e-01,3.794755869040219443e-01,3.699831487075117553e-01,3.634585837073993075e-01,3.572576489750322604e-01,3.495717699568869352e-01,3.416951904336057999e-01,3.362596987552606276e-01,3.342257009013045455e-01,3.332864830706725456e-01,3.305355554586013600e-01,3.266804849680813860e-01,3.250561646237365987e-01,3.276409723100375260e-01,3.322455156492971629e-01,3.347189927609360849e-01,3.349918829525499464e-01,3.368898917790060787e-01,3.431837956216457486e-01,3.517964693897224215e-01,3.581109773219158243e-01,3.622930209978130200e-01,3.684357575651489580e-01,3.787059791987245072e-01,3.896891628667594198e-01,3.972088043441251992e-01,4.038166807490365939e-01,4.141751955742370983e-01,4.281732830585795457e-01,4.396092694864981443e-01,4.466714783453920035e-01,4.551429607986770542e-01,4.689278875816787484e-01,4.835612585331948154e-01,4.924948531669393614e-01,4.994609763444062822e-01,5.108151367928668307e-01,5.253538176957078809e-01,5.348191136377885568e-01,5.405797377000659543e-01,5.498523148416800677e-01,5.629832366793153797e-01,5.708021186830335436e-01,5.737076494789923320e-01,5.803258472764302178e-01,5.915810813701498638e-01,5.966861756586294696e-01,5.960232912316391074e-01,5.993628598323941237e-01,6.072432447360226471e-01
```

## PyMieSim/validation_data/PyMieScattQsca.csv

 * *Ordering differences only*

```diff
@@ -1,800 +1,800 @@
-9.520383331978630667e-07
-9.829900777468393830e-07
-1.014978994294080579e-06
-1.048008899969161071e-06
-1.082113670377542085e-06
-1.117328283473122196e-06
-1.153688855428642484e-06
-1.191232677673283173e-06
-1.229998255135369628e-06
-1.270025345729427134e-06
-1.311355001128102281e-06
-1.354029608860649971e-06
-1.398092935781291438e-06
-1.443590172951856623e-06
-1.490567981984877363e-06
-1.539074542894523956e-06
-1.589159603504481878e-06
-1.640874530463488140e-06
-1.694272361920666188e-06
-1.749407861914896978e-06
-1.806337576533740986e-06
-1.865119891899680693e-06
-1.925815094042965071e-06
-1.988485430722622422e-06
-2.053195175258795309e-06
-2.120010692442066348e-06
-2.189000506587136196e-06
-2.260235371800738850e-06
-2.333788344535827183e-06
-2.409734858506349956e-06
-2.488152802039389417e-06
-2.569122597944076893e-06
-2.652727285979050029e-06
-2.739052608002966935e-06
-2.828187095895511785e-06
-2.920222162338790455e-06
-3.015252194552363495e-06
-3.113374651077941188e-06
-3.214690161712807127e-06
-3.319302630694659914e-06
-3.427319343243364596e-06
-3.538851075569024230e-06
-3.654012208458972747e-06
-3.772920844560250173e-06
-3.895698929477550885e-06
-4.022472376810979608e-06
-4.153371197261750474e-06
-4.288529631937844322e-06
-4.428086289996650021e-06
-4.572184290765372626e-06
-4.720971410484971719e-06
-4.874600233827942716e-06
-5.033228310345325098e-06
-5.197018316002965798e-06
-5.366138219973190039e-06
-5.540761456851869829e-06
-5.721067104478278265e-06
-5.907240067539327616e-06
-6.099471267146566200e-06
-6.297957836580139252e-06
-6.502903323400260668e-06
-6.714517898133151210e-06
-6.933018569745827191e-06
-7.158629408129338023e-06
-7.391581773819672450e-06
-7.632114555191054760e-06
-7.880474413364205126e-06
-8.136916035081621587e-06
-8.401702393807653602e-06
-8.675105019321664845e-06
-8.957404276080188442e-06
-9.248889650633076678e-06
-9.549860048388260163e-06
-9.860624100029021730e-06
-1.018150047789736003e-05
-1.051281822266817155e-05
-1.085491708064744673e-05
-1.120814785204200589e-05
-1.157287275055505161e-05
-1.194946577467809926e-05
-1.233831309105713686e-05
-1.273981343032786379e-05
-1.315437849582364491e-05
-1.358243338557536158e-05
-1.402441702803533257e-05
-1.448078263197066811e-05
-1.495199815098787294e-05
-1.543854676316275737e-05
-1.594092736626820248e-05
-1.645965508910530924e-05
-1.699526181946191611e-05
-1.754829674923955631e-05
-1.811932693730540459e-05
-1.870893789064613933e-05
-1.931773416441863881e-05
-1.994633998151057707e-05
-2.059539987224622121e-05
-2.126557933489059749e-05
-2.195756551762906999e-05
-2.267206792271925681e-05
-2.340981913353541095e-05
-2.417157556525089554e-05
-2.495811823992341387e-05
-2.577025358677891072e-05
-2.660881426851076909e-05
-2.747466003443998047e-05
-2.836867860140854914e-05
-2.929178656330736383e-05
-3.024493033016777225e-05
-3.122908709777705852e-05
-3.224526584881061734e-05
-3.329450838650079470e-05
-3.437789040190344637e-05
-3.549652257584859485e-05
-3.665155171670504870e-05
-3.784416193511842347e-05
-3.907557585692551349e-05
-4.034705587548237388e-05
-4.165990544468697562e-05
-4.301547041401558932e-05
-4.441514040693712889e-05
-4.586035024411392176e-05
-4.735258141284222469e-05
-4.889336358422827049e-05
-5.048427617965955884e-05
-5.212694998815419075e-05
-5.382306883625788402e-05
-5.557437131217363532e-05
-5.738265254590245901e-05
-5.924976604719017412e-05
-6.117762560317992421e-05
-6.316820723767816522e-05
-6.522355123406157931e-05
-6.734576422385597783e-05
-6.953702134315102362e-05
-7.179956845901324118e-05
-7.413572446819937387e-05
-7.654788367048189195e-05
-7.903851821903605383e-05
-8.161018065035186844e-05
-8.426550649627542939e-05
-8.700721698081978852e-05
-8.983812180450475833e-05
-9.276112201904652054e-05
-9.577921299533483557e-05
-9.889548748770488767e-05
-1.021131387976367577e-04
-1.054354640400764070e-04
-1.088658675157266355e-04
-1.124078641927107560e-04
-1.160650833011636363e-04
-1.198412720443927976e-04
-1.237402994303827555e-04
-1.277661602275317594e-04
-1.319229790486357032e-04
-1.362150145672648438e-04
-1.406466638708084727e-04
-1.452224669546028327e-04
-1.499471113617000732e-04
-1.548254369729799992e-04
-1.598624409524519155e-04
-1.650632828527647715e-04
-1.704332898860883862e-04
-1.759779623656982121e-04
-1.817029793237704370e-04
-1.876142043110760969e-04
-1.937176913844169100e-04
-2.000196912878763722e-04
-2.065266578341054472e-04
-2.132452544921085481e-04
-2.201823611881511926e-04
-2.273450813266662124e-04
-2.347407490382343162e-04
-2.423769366619268244e-04
-2.502614624695693622e-04
-2.584023986396677950e-04
-2.668080794890495089e-04
-2.754871099704758546e-04
-2.844483744447573437e-04
-2.937010457362112582e-04
-3.032545944804933497e-04
-3.131187987742329887e-04
-3.233037541361081526e-04
-3.338198837893330143e-04
-3.446779492758692215e-04
-3.558890614129476648e-04
-3.674646916028613151e-04
-3.794166835073174639e-04
-3.917572650979888184e-04
-4.044990610952710450e-04
-4.176551058076399510e-04
-4.312388563843703938e-04
-4.452642064947975094e-04
-4.597455004476818947e-04
-4.746975477647059883e-04
-4.901356382225301048e-04
-5.060755573782845136e-04
-5.225336025938653699e-04
-5.395265995748341420e-04
-5.570719194402566979e-04
-5.751874963402773709e-04
-5.938918456387662966e-04
-6.132040826788936853e-04
-6.331439421500615998e-04
-6.537317980751347927e-04
-6.749886844375756895e-04
-6.969363164685468941e-04
-7.195971126148345467e-04
-7.429942172089071869e-04
-7.671515238631814457e-04
-7.920936996111857227e-04
-8.178462098189889003e-04
-8.444353438909912466e-04
-8.718882417948650796e-04
-9.002329214311901879e-04
-9.294983068740904396e-04
-9.597142575098997633e-04
-9.909115981018138709e-04
-1.023122149809114340e-03
-1.056378762190602477e-03
-1.090715346222538833e-03
-1.126166908362429388e-03
-1.162769585690792001e-03
-1.200560682164042523e-03
-1.239578706012507865e-03
-1.279863408318606798e-03
-1.321455822811224779e-03
-1.364398306913274482e-03
-1.408734584080521173e-03
-1.454509787470795916e-03
-1.501770504983794075e-03
-1.550564825712778035e-03
-1.600942387850620490e-03
-1.652954428093736557e-03
-1.706653832588726511e-03
-1.762095189467628199e-03
-1.819334843018995899e-03
-1.878430949543108798e-03
-1.939443534941103680e-03
-2.002434554088850308e-03
-2.067467952047858434e-03
-2.134609727166732630e-03
-2.203927996128065940e-03
-2.275493060996957445e-03
-2.349377478328779946e-03
-2.425656130395004682e-03
-2.504406298587746795e-03
-2.585707739064302835e-03
-2.669642760695174668e-03
-2.756296305379988317e-03
-2.845756030797220743e-03
-2.938112395655146768e-03
-3.033458747512723323e-03
-3.131891413240692462e-03
-3.233509792194247997e-03
-3.338416452170463265e-03
-3.446717228224484633e-03
-3.558521324420479016e-03
-3.673941418593841025e-03
-3.793093770203294357e-03
-3.916098331351997724e-03
-4.043078861058615331e-03
-4.174163042859745099e-03
-4.309482605826875541e-03
-4.449173449081640641e-03
-4.593375769894093158e-03
-4.742234195449500020e-03
-4.895897918370385564e-03
-5.054520836080479002e-03
-5.218261694098122808e-03
-5.387284233347187055e-03
-5.561757341573289257e-03
-5.741855208953773257e-03
-5.927757487989330880e-03
-6.119649457764935775e-03
-6.317722192667313101e-03
-6.522172735645486927e-03
-6.733204276099483132e-03
-6.951026332481626338e-03
-7.175854939692433848e-03
-7.407912841352251761e-03
-7.647429687025996715e-03
-7.894642234477371873e-03
-8.149794557024353861e-03
-8.413138256065053402e-03
-8.684932678838679088e-03
-8.965445141481884206e-03
-9.254951157435419712e-03
-9.553734671250398505e-03
-9.862088297837410741e-03
-1.018031356719358536e-02
-1.050872117463631274e-02
-1.084763123656241023e-02
-1.119737355174217457e-02
-1.155828786814841122e-02
-1.193072415530729846e-02
-1.231504288214710016e-02
-1.271161530030603427e-02
-1.312082373284599937e-02
-1.354306186830347807e-02
-1.397873505999058449e-02
-1.442826063044018274e-02
-1.489206818087062192e-02
-1.537059990551983141e-02
-1.586431091067973254e-02
-1.637366953823097757e-02
-1.689915769345552016e-02
-1.744127117687153949e-02
-1.800052001980516347e-02
-1.857742882338002041e-02
-1.917253710056749175e-02
-1.978639962090468496e-02
-2.041958675744351762e-02
-2.107268483545151130e-02
-2.174629648233796647e-02
-2.244104097822918753e-02
-2.315755460656462525e-02
-2.389649100402813781e-02
-2.465852150907115597e-02
-2.544433550822111645e-02
-2.625464077930198675e-02
-2.709016383062459385e-02
-2.795165023513183911e-02
-2.883986495840461239e-02
-2.975559267935537835e-02
-3.069963810235137869e-02
-3.167282625941948010e-02
-3.267600280109337479e-02
-3.371003427436795874e-02
-3.477580838612547715e-02
-3.587423425029236113e-02
-3.700624261688319205e-02
-3.817278608097313813e-02
-3.937483926953000424e-02
-4.061339900391933155e-02
-4.188948443577970165e-02
-4.320413715384103376e-02
-4.455842125914477592e-02
-4.595342340599226083e-02
-4.739025280583668287e-02
-4.887004119120524903e-02
-5.039394273662142765e-02
-5.196313393338557185e-02
-5.357881341495346339e-02
-5.524220172955337377e-02
-5.695454105658360328e-02
-5.871709486324004634e-02
-6.053114749775626718e-02
-6.239800371556449010e-02
-6.431898813465117271e-02
-6.629544461634820363e-02
-6.832873556779717195e-02
-7.042024116235297282e-02
-7.257135847423834552e-02
-7.478350052384315216e-02
-7.705809523021435459e-02
-7.939658426739940045e-02
-8.180042182159003028e-02
-8.427107324621167794e-02
-8.681001361250856307e-02
-8.941872615349953646e-02
-9.209870059972624645e-02
-9.485143140569225750e-02
-9.767841586660798436e-02
-1.005811521257201080e-01
-1.035611370734196846e-01
-1.066198641402030800e-01
-1.097588209867201847e-01
-1.129794870952580965e-01
-1.162833312684662945e-01
-1.196718090425074738e-01
-1.231463600235987166e-01
-1.267084051586055138e-01
-1.303593439524700914e-01
-1.341005516473217640e-01
-1.379333763805997703e-01
-1.418591363419642870e-01
-1.458791169516710229e-01
-1.499945680859104957e-01
-1.542067013779407358e-01
-1.585166876270627245e-01
-1.629256543512305200e-01
-1.674346835226985519e-01
-1.720448095302333502e-01
-1.767570174153945128e-01
-1.815722414348283631e-01
-1.864913640047911603e-01
-1.915152150887964866e-01
-1.966445720937450292e-01
-2.018801603446647164e-01
-2.072226542126873461e-01
-2.126726789755792046e-01
-2.182308134944568878e-01
-2.238975937946991179e-01
-2.296735176428806868e-01
-2.355590502153497856e-01
-2.415546309570155703e-01
-2.476606817317225928e-01
-2.538776163672324393e-01
-2.602058516991559989e-01
-2.666458202180232995e-01
-2.731979844228723531e-01
-2.798628529821543531e-01
-2.866409987991362374e-01
-2.935330790731434103e-01
-3.005398574407451839e-01
-3.076622282709711165e-01
-3.149012431767145292e-01
-3.222581397892890775e-01
-3.297343728251891926e-01
-3.373316474524013509e-01
-3.450519549384226115e-01
-3.528976105321923740e-01
-3.608712934980333742e-01
-3.689760891796728393e-01
-3.772155329272974256e-01
-3.855936556683879357e-01
-3.941150308445208750e-01
-4.027848223695671970e-01
-4.116088331900062958e-01
-4.205935539441528204e-01
-4.297462111235598181e-01
-4.390748140360561380e-01
-4.485881997552750300e-01
-4.582960751157981738e-01
-4.682090546760373506e-01
-4.783386934229485465e-01
-4.886975128342846419e-01
-4.992990187466624930e-01
-5.101577093032355625e-01
-5.212890710764620517e-01
-5.327095612835626159e-01
-5.444365738407146438e-01
-5.564883868445049675e-01
-5.688840889355425423e-01
-5.816434819016014224e-01
-5.947869568313284283e-01
-6.083353411520561194e-01
-6.223097139975047876e-01
-6.367311875765426787e-01
-6.516206525785361858e-01
-6.669984861816344868e-01
-6.828842219550409487e-01
-6.992961818912617478e-01
-7.162510719913259827e-01
-7.337635442702710176e-01
-7.518457297554985708e-01
-7.705067490058359336e-01
-7.897522088529770334e-01
-8.095836964034099914e-01
-8.299982837537176472e-01
-8.509880592491624318e-01
-8.725397033073145625e-01
-8.946341286581976915e-01
-9.172462061205048922e-01
-9.403445975291269132e-01
-9.638917169465652801e-01
-9.878438396492605911e-01
-1.012151375448671287e+00
-1.036759318629678850e+00
-1.061607881207327297e+00
-1.086633309473569176e+00
-1.111768876209481061e+00
-1.136946032873494827e+00
-1.162095698040519931e+00
-1.187149650919756771e+00
-1.212041992495242138e+00
-1.236710632242802532e+00
-1.261098755907712698e+00
-1.285156229750863188e+00
-1.308840899063465679e+00
-1.332119743474691864e+00
-1.354969858287361939e+00
-1.377379239250329013e+00
-1.399347357159035132e+00
-1.420885517748585736e+00
-1.442017010787781217e+00
-1.462777059442994521e+00
-1.483212586317985693e+00
-1.503381815699984747e+00
-1.523353732230702473e+00
-1.543207414417676393e+00
-1.563031257206909386e+00
-1.582922091491337335e+00
-1.602984200293971151e+00
-1.623328221917222924e+00
-1.644069920187920752e+00
-1.665328791785956497e+00
-1.687226471430279595e+00
-1.709884888528000024e+00
-1.733424125142527306e+00
-1.757959926446740040e+00
-1.783600823082956977e+00
-1.810444842073592353e+00
-1.838575811046971653e+00
-1.868059301024798557e+00
-1.898938306306431345e+00
-1.931228824806182853e+00
-1.964915574792463815e+00
-1.999948157433945717e+00
-2.036238038540994388e+00
-2.073656764063246616e+00
-2.112035827392591880e+00
-2.151168558565920819e+00
-2.190814297075642347e+00
-2.230704940958093907e+00
-2.270553746874239387e+00
-2.310066013699489940e+00
-2.348951050950047303e+00
-2.386934652996496542e+00
-2.423771206111305254e+00
-2.459254570355914993e+00
-2.493227004566233695e+00
-2.525585620864377656e+00
-2.556286127913300898e+00
-2.585343902870298471e+00
-2.612832675171542718e+00
-2.638881275856876929e+00
-2.663668985196447014e+00
-2.687419997085332302e+00
-2.710397423303833708e+00
-2.732897105406800087e+00
-2.755241311144707161e+00
-2.777772189627580435e+00
-2.800844666175423381e+00
-2.824818293671386815e+00
-2.850047463501859557e+00
-2.876869342887788505e+00
-2.905588983190005692e+00
-2.936461282360143255e+00
-2.969669934750707174e+00
-3.005304200214281796e+00
-3.043335264539547502e+00
-3.083595051043864554e+00
-3.125761359251231664e+00
-3.169353797946150575e+00
-3.213744718803537292e+00
-3.258187890855049673e+00
-3.301864924990372430e+00
-3.343945881614881710e+00
-3.383656990306340706e+00
-3.420346134593291509e+00
-3.453536626904881945e+00
-3.482962034600390222e+00
-3.508578766412467242e+00
-3.530557535869454533e+00
-3.549258379092767424e+00
-3.565195779082733551e+00
-3.579000482292188146e+00
-3.591383192708713867e+00
-3.603103148261137090e+00
-3.614942224786354519e+00
-3.627683060046870800e+00
-3.642087916113407875e+00
-3.658873676259023711e+00
-3.678677649031852681e+00
-3.702009118329919080e+00
-3.729183564859538613e+00
-3.760241146287013336e+00
-3.794859012338018367e+00
-3.832277625337818350e+00
-3.871271052561115145e+00
-3.910193733564877761e+00
-3.947124356556229063e+00
-3.980099103134647542e+00
-4.007390371053939582e+00
-4.027761704600949955e+00
-4.040632132883420269e+00
-4.046114988887183905e+00
-4.044940569386071161e+00
-4.038305588913932986e+00
-4.027702207828299130e+00
-4.014768033183057305e+00
-4.001177437385257996e+00
-3.988574538809147363e+00
-3.978534142007248420e+00
-3.972528567629420415e+00
-3.971873405471205487e+00
-3.977622993265990559e+00
-3.990390161041579731e+00
-4.010083389416391420e+00
-4.035599810434167267e+00
-4.064586251369608938e+00
-4.093450520563239436e+00
-4.117793279452694577e+00
-4.133264685670879679e+00
-4.136579616288826422e+00
-4.126261431047320904e+00
-4.102809183275476279e+00
-4.068314110539067663e+00
-4.025811191253592547e+00
-3.978675488077713318e+00
-3.930230556368065731e+00
-3.883581130814723892e+00
-3.841595129800815744e+00
-3.806932737579226789e+00
-3.782013796452698529e+00
-3.768803893943204475e+00
-3.768296716523356071e+00
-3.779644891225344416e+00
-3.799160056683698716e+00
-3.819875904060002547e+00
-3.832623705647778323e+00
-3.828826200825643511e+00
-3.803587612285824093e+00
-3.757000930406757533e+00
-3.693093112071492712e+00
-3.617704271628891632e+00
-3.536806696845753439e+00
-3.455788472383975574e+00
-3.379448471895794448e+00
-3.312272764266260161e+00
-3.258652970557853745e+00
-3.222744063844126039e+00
-3.207556222209515528e+00
-3.212844680838702338e+00
-3.232105888888600287e+00
-3.251182698932949311e+00
-3.252446239414288787e+00
-3.223839272556788149e+00
-3.164525196041766630e+00
-3.082103708372687656e+00
-2.986426008224128292e+00
-2.886024627172687484e+00
-2.787755010076554907e+00
-2.697754370789326117e+00
-2.622412981576205837e+00
-2.568809044481092485e+00
-2.543889519269462163e+00
-2.550810984297358530e+00
-2.581405226085877747e+00
-2.610890249798549778e+00
-2.609431253661014249e+00
-2.565392952948532201e+00
-2.488840351048399846e+00
-2.395352959782453439e+00
-2.296096676514958190e+00
-2.198623626210233439e+00
-2.110094575513692838e+00
-2.039173941944182555e+00
-1.996703804349609923e+00
-1.994245367210666586e+00
-2.035355411863186692e+00
-2.096487905580069366e+00
-2.127007703538352779e+00
-2.100649818942932345e+00
-2.036886110312422726e+00
-1.959731614541194711e+00
-1.879131255179263382e+00
-1.800650902773136774e+00
-1.733054739321496340e+00
-1.689322891475364186e+00
-1.686473091149155001e+00
-1.741034500588856115e+00
-1.840818321321056050e+00
-1.911542883654652858e+00
-1.903982398059034242e+00
-1.859388508194934175e+00
-1.810333455459484320e+00
-1.757372890742998628e+00
-1.703502217592461232e+00
-1.663727934811629394e+00
-1.659130874557500634e+00
-1.715800000427124772e+00
-1.847747390735326123e+00
-1.973432205761634251e+00
-1.988885323776850012e+00
-1.966044606563323249e+00
-1.951668308276001351e+00
-1.925716861003878844e+00
-1.888554514391621364e+00
-1.868170627723633404e+00
-1.896611274900546373e+00
-2.011793916331940935e+00
-2.199994835147474515e+00
-2.267498166928637371e+00
-2.251861115066236874e+00
-2.269387877791978703e+00
-2.271722096241203914e+00
-2.237625431526955033e+00
-2.214038492075535824e+00
-2.246422196783270930e+00
-2.385833352308615929e+00
-2.588305819124390172e+00
-2.584378865849479290e+00
-2.584142035154912254e+00
-2.632203346281836609e+00
-2.613396022874172608e+00
-2.560371785213039875e+00
-2.552384298131888052e+00
-2.643618690081422695e+00
-2.864011976765477474e+00
-2.834042346763810727e+00
-2.812417693078810732e+00
-2.879083826605217666e+00
-2.840860359456184536e+00
-2.759058920858145303e+00
-2.742243108698517950e+00
-2.856017004511548052e+00
-3.010166121500570835e+00
-2.868755228842627680e+00
-2.900057300805787719e+00
-2.928110679625365531e+00
-2.801737214121400310e+00
-2.729825927461904111e+00
-2.771230113407025630e+00
-2.965893558552545883e+00
-2.762983271007645403e+00
-2.758572417475742888e+00
-2.798997787143729710e+00
-2.627496681934418099e+00
-2.542315716617633115e+00
-2.595429735740884869e+00
-2.690200263427134697e+00
-2.487481153558356972e+00
-2.534706748960876777e+00
-2.474987231526139642e+00
-2.299484947628612108e+00
-2.265052291613387947e+00
-2.485366111615545659e+00
-2.232853201624330541e+00
-2.200532895356991592e+00
-2.272959962321765115e+00
-2.053371187890398630e+00
-2.007628172882389705e+00
-2.224334698819737888e+00
-2.001329655743270930e+00
-1.972431696035732207e+00
-2.075551558880317948e+00
-1.869645182424616525e+00
-1.868830734228396739e+00
-2.110851182494470901e+00
-1.881862568464153451e+00
-1.923748735025901047e+00
-1.915095200740227765e+00
-1.837024354657344372e+00
-1.943216776148942726e+00
-1.963774331206692203e+00
-1.942104181365738480e+00
-2.138956896378744421e+00
-1.941644256040882421e+00
-2.012875923612631013e+00
-2.148966650318580029e+00
-2.122790644122982240e+00
-2.290040951280146952e+00
-2.133107852855277820e+00
-2.196652432067295102e+00
-2.348618970034259679e+00
-2.345041167043720787e+00
-2.503775002747587575e+00
-2.334305820080575078e+00
-2.400343601068887889e+00
-2.514905193818851803e+00
-2.524015497865694790e+00
-2.644925481118350241e+00
-2.467818013299086566e+00
-2.586441972260880462e+00
-2.614555935303437550e+00
-2.588990061392741016e+00
-2.517446846438982533e+00
-2.484293460733774772e+00
-2.571738323145156269e+00
-2.569075079619895785e+00
-2.572340844269203064e+00
-2.379885456699784463e+00
-2.473581859212807377e+00
-2.456040330499389412e+00
-2.415849893506364587e+00
-2.234461171138444779e+00
-2.243647455900546372e+00
-2.277506706203085596e+00
-2.224226213757672710e+00
-2.078765664068040753e+00
-2.035886349580034782e+00
-2.108333340133040856e+00
-2.087363419095380035e+00
-1.958797423833283036e+00
-1.957562252772356626e+00
-2.025075681286107709e+00
-2.128922055808722735e+00
-1.918125278734467809e+00
-1.893682192907569783e+00
-2.063293668853648732e+00
-2.055674811682847825e+00
-1.973480330464091992e+00
-2.007932264515533749e+00
-2.189250830349129373e+00
-2.169660584982217255e+00
-2.104160520435589099e+00
-2.232281845097556783e+00
-2.340805453349341203e+00
-2.288800332131372794e+00
-2.260701783895127548e+00
-2.461690185755821769e+00
-2.456495247864540765e+00
-2.347582950391317258e+00
-2.437296311249882663e+00
-2.496980609618180136e+00
-2.405086800722554763e+00
-2.354962266399514448e+00
+9.520383331978630667e-07
+9.829900777468393830e-07
+1.014978994294080579e-06
+1.048008899969161071e-06
+1.082113670377542085e-06
+1.117328283473122196e-06
+1.153688855428642484e-06
+1.191232677673283173e-06
+1.229998255135369628e-06
+1.270025345729427134e-06
+1.311355001128102281e-06
+1.354029608860649971e-06
+1.398092935781291438e-06
+1.443590172951856623e-06
+1.490567981984877363e-06
+1.539074542894523956e-06
+1.589159603504481878e-06
+1.640874530463488140e-06
+1.694272361920666188e-06
+1.749407861914896978e-06
+1.806337576533740986e-06
+1.865119891899680693e-06
+1.925815094042965071e-06
+1.988485430722622422e-06
+2.053195175258795309e-06
+2.120010692442066348e-06
+2.189000506587136196e-06
+2.260235371800738850e-06
+2.333788344535827183e-06
+2.409734858506349956e-06
+2.488152802039389417e-06
+2.569122597944076893e-06
+2.652727285979050029e-06
+2.739052608002966935e-06
+2.828187095895511785e-06
+2.920222162338790455e-06
+3.015252194552363495e-06
+3.113374651077941188e-06
+3.214690161712807127e-06
+3.319302630694659914e-06
+3.427319343243364596e-06
+3.538851075569024230e-06
+3.654012208458972747e-06
+3.772920844560250173e-06
+3.895698929477550885e-06
+4.022472376810979608e-06
+4.153371197261750474e-06
+4.288529631937844322e-06
+4.428086289996650021e-06
+4.572184290765372626e-06
+4.720971410484971719e-06
+4.874600233827942716e-06
+5.033228310345325098e-06
+5.197018316002965798e-06
+5.366138219973190039e-06
+5.540761456851869829e-06
+5.721067104478278265e-06
+5.907240067539327616e-06
+6.099471267146566200e-06
+6.297957836580139252e-06
+6.502903323400260668e-06
+6.714517898133151210e-06
+6.933018569745827191e-06
+7.158629408129338023e-06
+7.391581773819672450e-06
+7.632114555191054760e-06
+7.880474413364205126e-06
+8.136916035081621587e-06
+8.401702393807653602e-06
+8.675105019321664845e-06
+8.957404276080188442e-06
+9.248889650633076678e-06
+9.549860048388260163e-06
+9.860624100029021730e-06
+1.018150047789736003e-05
+1.051281822266817155e-05
+1.085491708064744673e-05
+1.120814785204200589e-05
+1.157287275055505161e-05
+1.194946577467809926e-05
+1.233831309105713686e-05
+1.273981343032786379e-05
+1.315437849582364491e-05
+1.358243338557536158e-05
+1.402441702803533257e-05
+1.448078263197066811e-05
+1.495199815098787294e-05
+1.543854676316275737e-05
+1.594092736626820248e-05
+1.645965508910530924e-05
+1.699526181946191611e-05
+1.754829674923955631e-05
+1.811932693730540459e-05
+1.870893789064613933e-05
+1.931773416441863881e-05
+1.994633998151057707e-05
+2.059539987224622121e-05
+2.126557933489059749e-05
+2.195756551762906999e-05
+2.267206792271925681e-05
+2.340981913353541095e-05
+2.417157556525089554e-05
+2.495811823992341387e-05
+2.577025358677891072e-05
+2.660881426851076909e-05
+2.747466003443998047e-05
+2.836867860140854914e-05
+2.929178656330736383e-05
+3.024493033016777225e-05
+3.122908709777705852e-05
+3.224526584881061734e-05
+3.329450838650079470e-05
+3.437789040190344637e-05
+3.549652257584859485e-05
+3.665155171670504870e-05
+3.784416193511842347e-05
+3.907557585692551349e-05
+4.034705587548237388e-05
+4.165990544468697562e-05
+4.301547041401558932e-05
+4.441514040693712889e-05
+4.586035024411392176e-05
+4.735258141284222469e-05
+4.889336358422827049e-05
+5.048427617965955884e-05
+5.212694998815419075e-05
+5.382306883625788402e-05
+5.557437131217363532e-05
+5.738265254590245901e-05
+5.924976604719017412e-05
+6.117762560317992421e-05
+6.316820723767816522e-05
+6.522355123406157931e-05
+6.734576422385597783e-05
+6.953702134315102362e-05
+7.179956845901324118e-05
+7.413572446819937387e-05
+7.654788367048189195e-05
+7.903851821903605383e-05
+8.161018065035186844e-05
+8.426550649627542939e-05
+8.700721698081978852e-05
+8.983812180450475833e-05
+9.276112201904652054e-05
+9.577921299533483557e-05
+9.889548748770488767e-05
+1.021131387976367577e-04
+1.054354640400764070e-04
+1.088658675157266355e-04
+1.124078641927107560e-04
+1.160650833011636363e-04
+1.198412720443927976e-04
+1.237402994303827555e-04
+1.277661602275317594e-04
+1.319229790486357032e-04
+1.362150145672648438e-04
+1.406466638708084727e-04
+1.452224669546028327e-04
+1.499471113617000732e-04
+1.548254369729799992e-04
+1.598624409524519155e-04
+1.650632828527647715e-04
+1.704332898860883862e-04
+1.759779623656982121e-04
+1.817029793237704370e-04
+1.876142043110760969e-04
+1.937176913844169100e-04
+2.000196912878763722e-04
+2.065266578341054472e-04
+2.132452544921085481e-04
+2.201823611881511926e-04
+2.273450813266662124e-04
+2.347407490382343162e-04
+2.423769366619268244e-04
+2.502614624695693622e-04
+2.584023986396677950e-04
+2.668080794890495089e-04
+2.754871099704758546e-04
+2.844483744447573437e-04
+2.937010457362112582e-04
+3.032545944804933497e-04
+3.131187987742329887e-04
+3.233037541361081526e-04
+3.338198837893330143e-04
+3.446779492758692215e-04
+3.558890614129476648e-04
+3.674646916028613151e-04
+3.794166835073174639e-04
+3.917572650979888184e-04
+4.044990610952710450e-04
+4.176551058076399510e-04
+4.312388563843703938e-04
+4.452642064947975094e-04
+4.597455004476818947e-04
+4.746975477647059883e-04
+4.901356382225301048e-04
+5.060755573782845136e-04
+5.225336025938653699e-04
+5.395265995748341420e-04
+5.570719194402566979e-04
+5.751874963402773709e-04
+5.938918456387662966e-04
+6.132040826788936853e-04
+6.331439421500615998e-04
+6.537317980751347927e-04
+6.749886844375756895e-04
+6.969363164685468941e-04
+7.195971126148345467e-04
+7.429942172089071869e-04
+7.671515238631814457e-04
+7.920936996111857227e-04
+8.178462098189889003e-04
+8.444353438909912466e-04
+8.718882417948650796e-04
+9.002329214311901879e-04
+9.294983068740904396e-04
+9.597142575098997633e-04
+9.909115981018138709e-04
+1.023122149809114340e-03
+1.056378762190602477e-03
+1.090715346222538833e-03
+1.126166908362429388e-03
+1.162769585690792001e-03
+1.200560682164042523e-03
+1.239578706012507865e-03
+1.279863408318606798e-03
+1.321455822811224779e-03
+1.364398306913274482e-03
+1.408734584080521173e-03
+1.454509787470795916e-03
+1.501770504983794075e-03
+1.550564825712778035e-03
+1.600942387850620490e-03
+1.652954428093736557e-03
+1.706653832588726511e-03
+1.762095189467628199e-03
+1.819334843018995899e-03
+1.878430949543108798e-03
+1.939443534941103680e-03
+2.002434554088850308e-03
+2.067467952047858434e-03
+2.134609727166732630e-03
+2.203927996128065940e-03
+2.275493060996957445e-03
+2.349377478328779946e-03
+2.425656130395004682e-03
+2.504406298587746795e-03
+2.585707739064302835e-03
+2.669642760695174668e-03
+2.756296305379988317e-03
+2.845756030797220743e-03
+2.938112395655146768e-03
+3.033458747512723323e-03
+3.131891413240692462e-03
+3.233509792194247997e-03
+3.338416452170463265e-03
+3.446717228224484633e-03
+3.558521324420479016e-03
+3.673941418593841025e-03
+3.793093770203294357e-03
+3.916098331351997724e-03
+4.043078861058615331e-03
+4.174163042859745099e-03
+4.309482605826875541e-03
+4.449173449081640641e-03
+4.593375769894093158e-03
+4.742234195449500020e-03
+4.895897918370385564e-03
+5.054520836080479002e-03
+5.218261694098122808e-03
+5.387284233347187055e-03
+5.561757341573289257e-03
+5.741855208953773257e-03
+5.927757487989330880e-03
+6.119649457764935775e-03
+6.317722192667313101e-03
+6.522172735645486927e-03
+6.733204276099483132e-03
+6.951026332481626338e-03
+7.175854939692433848e-03
+7.407912841352251761e-03
+7.647429687025996715e-03
+7.894642234477371873e-03
+8.149794557024353861e-03
+8.413138256065053402e-03
+8.684932678838679088e-03
+8.965445141481884206e-03
+9.254951157435419712e-03
+9.553734671250398505e-03
+9.862088297837410741e-03
+1.018031356719358536e-02
+1.050872117463631274e-02
+1.084763123656241023e-02
+1.119737355174217457e-02
+1.155828786814841122e-02
+1.193072415530729846e-02
+1.231504288214710016e-02
+1.271161530030603427e-02
+1.312082373284599937e-02
+1.354306186830347807e-02
+1.397873505999058449e-02
+1.442826063044018274e-02
+1.489206818087062192e-02
+1.537059990551983141e-02
+1.586431091067973254e-02
+1.637366953823097757e-02
+1.689915769345552016e-02
+1.744127117687153949e-02
+1.800052001980516347e-02
+1.857742882338002041e-02
+1.917253710056749175e-02
+1.978639962090468496e-02
+2.041958675744351762e-02
+2.107268483545151130e-02
+2.174629648233796647e-02
+2.244104097822918753e-02
+2.315755460656462525e-02
+2.389649100402813781e-02
+2.465852150907115597e-02
+2.544433550822111645e-02
+2.625464077930198675e-02
+2.709016383062459385e-02
+2.795165023513183911e-02
+2.883986495840461239e-02
+2.975559267935537835e-02
+3.069963810235137869e-02
+3.167282625941948010e-02
+3.267600280109337479e-02
+3.371003427436795874e-02
+3.477580838612547715e-02
+3.587423425029236113e-02
+3.700624261688319205e-02
+3.817278608097313813e-02
+3.937483926953000424e-02
+4.061339900391933155e-02
+4.188948443577970165e-02
+4.320413715384103376e-02
+4.455842125914477592e-02
+4.595342340599226083e-02
+4.739025280583668287e-02
+4.887004119120524903e-02
+5.039394273662142765e-02
+5.196313393338557185e-02
+5.357881341495346339e-02
+5.524220172955337377e-02
+5.695454105658360328e-02
+5.871709486324004634e-02
+6.053114749775626718e-02
+6.239800371556449010e-02
+6.431898813465117271e-02
+6.629544461634820363e-02
+6.832873556779717195e-02
+7.042024116235297282e-02
+7.257135847423834552e-02
+7.478350052384315216e-02
+7.705809523021435459e-02
+7.939658426739940045e-02
+8.180042182159003028e-02
+8.427107324621167794e-02
+8.681001361250856307e-02
+8.941872615349953646e-02
+9.209870059972624645e-02
+9.485143140569225750e-02
+9.767841586660798436e-02
+1.005811521257201080e-01
+1.035611370734196846e-01
+1.066198641402030800e-01
+1.097588209867201847e-01
+1.129794870952580965e-01
+1.162833312684662945e-01
+1.196718090425074738e-01
+1.231463600235987166e-01
+1.267084051586055138e-01
+1.303593439524700914e-01
+1.341005516473217640e-01
+1.379333763805997703e-01
+1.418591363419642870e-01
+1.458791169516710229e-01
+1.499945680859104957e-01
+1.542067013779407358e-01
+1.585166876270627245e-01
+1.629256543512305200e-01
+1.674346835226985519e-01
+1.720448095302333502e-01
+1.767570174153945128e-01
+1.815722414348283631e-01
+1.864913640047911603e-01
+1.915152150887964866e-01
+1.966445720937450292e-01
+2.018801603446647164e-01
+2.072226542126873461e-01
+2.126726789755792046e-01
+2.182308134944568878e-01
+2.238975937946991179e-01
+2.296735176428806868e-01
+2.355590502153497856e-01
+2.415546309570155703e-01
+2.476606817317225928e-01
+2.538776163672324393e-01
+2.602058516991559989e-01
+2.666458202180232995e-01
+2.731979844228723531e-01
+2.798628529821543531e-01
+2.866409987991362374e-01
+2.935330790731434103e-01
+3.005398574407451839e-01
+3.076622282709711165e-01
+3.149012431767145292e-01
+3.222581397892890775e-01
+3.297343728251891926e-01
+3.373316474524013509e-01
+3.450519549384226115e-01
+3.528976105321923740e-01
+3.608712934980333742e-01
+3.689760891796728393e-01
+3.772155329272974256e-01
+3.855936556683879357e-01
+3.941150308445208750e-01
+4.027848223695671970e-01
+4.116088331900062958e-01
+4.205935539441528204e-01
+4.297462111235598181e-01
+4.390748140360561380e-01
+4.485881997552750300e-01
+4.582960751157981738e-01
+4.682090546760373506e-01
+4.783386934229485465e-01
+4.886975128342846419e-01
+4.992990187466624930e-01
+5.101577093032355625e-01
+5.212890710764620517e-01
+5.327095612835626159e-01
+5.444365738407146438e-01
+5.564883868445049675e-01
+5.688840889355425423e-01
+5.816434819016014224e-01
+5.947869568313284283e-01
+6.083353411520561194e-01
+6.223097139975047876e-01
+6.367311875765426787e-01
+6.516206525785361858e-01
+6.669984861816344868e-01
+6.828842219550409487e-01
+6.992961818912617478e-01
+7.162510719913259827e-01
+7.337635442702710176e-01
+7.518457297554985708e-01
+7.705067490058359336e-01
+7.897522088529770334e-01
+8.095836964034099914e-01
+8.299982837537176472e-01
+8.509880592491624318e-01
+8.725397033073145625e-01
+8.946341286581976915e-01
+9.172462061205048922e-01
+9.403445975291269132e-01
+9.638917169465652801e-01
+9.878438396492605911e-01
+1.012151375448671287e+00
+1.036759318629678850e+00
+1.061607881207327297e+00
+1.086633309473569176e+00
+1.111768876209481061e+00
+1.136946032873494827e+00
+1.162095698040519931e+00
+1.187149650919756771e+00
+1.212041992495242138e+00
+1.236710632242802532e+00
+1.261098755907712698e+00
+1.285156229750863188e+00
+1.308840899063465679e+00
+1.332119743474691864e+00
+1.354969858287361939e+00
+1.377379239250329013e+00
+1.399347357159035132e+00
+1.420885517748585736e+00
+1.442017010787781217e+00
+1.462777059442994521e+00
+1.483212586317985693e+00
+1.503381815699984747e+00
+1.523353732230702473e+00
+1.543207414417676393e+00
+1.563031257206909386e+00
+1.582922091491337335e+00
+1.602984200293971151e+00
+1.623328221917222924e+00
+1.644069920187920752e+00
+1.665328791785956497e+00
+1.687226471430279595e+00
+1.709884888528000024e+00
+1.733424125142527306e+00
+1.757959926446740040e+00
+1.783600823082956977e+00
+1.810444842073592353e+00
+1.838575811046971653e+00
+1.868059301024798557e+00
+1.898938306306431345e+00
+1.931228824806182853e+00
+1.964915574792463815e+00
+1.999948157433945717e+00
+2.036238038540994388e+00
+2.073656764063246616e+00
+2.112035827392591880e+00
+2.151168558565920819e+00
+2.190814297075642347e+00
+2.230704940958093907e+00
+2.270553746874239387e+00
+2.310066013699489940e+00
+2.348951050950047303e+00
+2.386934652996496542e+00
+2.423771206111305254e+00
+2.459254570355914993e+00
+2.493227004566233695e+00
+2.525585620864377656e+00
+2.556286127913300898e+00
+2.585343902870298471e+00
+2.612832675171542718e+00
+2.638881275856876929e+00
+2.663668985196447014e+00
+2.687419997085332302e+00
+2.710397423303833708e+00
+2.732897105406800087e+00
+2.755241311144707161e+00
+2.777772189627580435e+00
+2.800844666175423381e+00
+2.824818293671386815e+00
+2.850047463501859557e+00
+2.876869342887788505e+00
+2.905588983190005692e+00
+2.936461282360143255e+00
+2.969669934750707174e+00
+3.005304200214281796e+00
+3.043335264539547502e+00
+3.083595051043864554e+00
+3.125761359251231664e+00
+3.169353797946150575e+00
+3.213744718803537292e+00
+3.258187890855049673e+00
+3.301864924990372430e+00
+3.343945881614881710e+00
+3.383656990306340706e+00
+3.420346134593291509e+00
+3.453536626904881945e+00
+3.482962034600390222e+00
+3.508578766412467242e+00
+3.530557535869454533e+00
+3.549258379092767424e+00
+3.565195779082733551e+00
+3.579000482292188146e+00
+3.591383192708713867e+00
+3.603103148261137090e+00
+3.614942224786354519e+00
+3.627683060046870800e+00
+3.642087916113407875e+00
+3.658873676259023711e+00
+3.678677649031852681e+00
+3.702009118329919080e+00
+3.729183564859538613e+00
+3.760241146287013336e+00
+3.794859012338018367e+00
+3.832277625337818350e+00
+3.871271052561115145e+00
+3.910193733564877761e+00
+3.947124356556229063e+00
+3.980099103134647542e+00
+4.007390371053939582e+00
+4.027761704600949955e+00
+4.040632132883420269e+00
+4.046114988887183905e+00
+4.044940569386071161e+00
+4.038305588913932986e+00
+4.027702207828299130e+00
+4.014768033183057305e+00
+4.001177437385257996e+00
+3.988574538809147363e+00
+3.978534142007248420e+00
+3.972528567629420415e+00
+3.971873405471205487e+00
+3.977622993265990559e+00
+3.990390161041579731e+00
+4.010083389416391420e+00
+4.035599810434167267e+00
+4.064586251369608938e+00
+4.093450520563239436e+00
+4.117793279452694577e+00
+4.133264685670879679e+00
+4.136579616288826422e+00
+4.126261431047320904e+00
+4.102809183275476279e+00
+4.068314110539067663e+00
+4.025811191253592547e+00
+3.978675488077713318e+00
+3.930230556368065731e+00
+3.883581130814723892e+00
+3.841595129800815744e+00
+3.806932737579226789e+00
+3.782013796452698529e+00
+3.768803893943204475e+00
+3.768296716523356071e+00
+3.779644891225344416e+00
+3.799160056683698716e+00
+3.819875904060002547e+00
+3.832623705647778323e+00
+3.828826200825643511e+00
+3.803587612285824093e+00
+3.757000930406757533e+00
+3.693093112071492712e+00
+3.617704271628891632e+00
+3.536806696845753439e+00
+3.455788472383975574e+00
+3.379448471895794448e+00
+3.312272764266260161e+00
+3.258652970557853745e+00
+3.222744063844126039e+00
+3.207556222209515528e+00
+3.212844680838702338e+00
+3.232105888888600287e+00
+3.251182698932949311e+00
+3.252446239414288787e+00
+3.223839272556788149e+00
+3.164525196041766630e+00
+3.082103708372687656e+00
+2.986426008224128292e+00
+2.886024627172687484e+00
+2.787755010076554907e+00
+2.697754370789326117e+00
+2.622412981576205837e+00
+2.568809044481092485e+00
+2.543889519269462163e+00
+2.550810984297358530e+00
+2.581405226085877747e+00
+2.610890249798549778e+00
+2.609431253661014249e+00
+2.565392952948532201e+00
+2.488840351048399846e+00
+2.395352959782453439e+00
+2.296096676514958190e+00
+2.198623626210233439e+00
+2.110094575513692838e+00
+2.039173941944182555e+00
+1.996703804349609923e+00
+1.994245367210666586e+00
+2.035355411863186692e+00
+2.096487905580069366e+00
+2.127007703538352779e+00
+2.100649818942932345e+00
+2.036886110312422726e+00
+1.959731614541194711e+00
+1.879131255179263382e+00
+1.800650902773136774e+00
+1.733054739321496340e+00
+1.689322891475364186e+00
+1.686473091149155001e+00
+1.741034500588856115e+00
+1.840818321321056050e+00
+1.911542883654652858e+00
+1.903982398059034242e+00
+1.859388508194934175e+00
+1.810333455459484320e+00
+1.757372890742998628e+00
+1.703502217592461232e+00
+1.663727934811629394e+00
+1.659130874557500634e+00
+1.715800000427124772e+00
+1.847747390735326123e+00
+1.973432205761634251e+00
+1.988885323776850012e+00
+1.966044606563323249e+00
+1.951668308276001351e+00
+1.925716861003878844e+00
+1.888554514391621364e+00
+1.868170627723633404e+00
+1.896611274900546373e+00
+2.011793916331940935e+00
+2.199994835147474515e+00
+2.267498166928637371e+00
+2.251861115066236874e+00
+2.269387877791978703e+00
+2.271722096241203914e+00
+2.237625431526955033e+00
+2.214038492075535824e+00
+2.246422196783270930e+00
+2.385833352308615929e+00
+2.588305819124390172e+00
+2.584378865849479290e+00
+2.584142035154912254e+00
+2.632203346281836609e+00
+2.613396022874172608e+00
+2.560371785213039875e+00
+2.552384298131888052e+00
+2.643618690081422695e+00
+2.864011976765477474e+00
+2.834042346763810727e+00
+2.812417693078810732e+00
+2.879083826605217666e+00
+2.840860359456184536e+00
+2.759058920858145303e+00
+2.742243108698517950e+00
+2.856017004511548052e+00
+3.010166121500570835e+00
+2.868755228842627680e+00
+2.900057300805787719e+00
+2.928110679625365531e+00
+2.801737214121400310e+00
+2.729825927461904111e+00
+2.771230113407025630e+00
+2.965893558552545883e+00
+2.762983271007645403e+00
+2.758572417475742888e+00
+2.798997787143729710e+00
+2.627496681934418099e+00
+2.542315716617633115e+00
+2.595429735740884869e+00
+2.690200263427134697e+00
+2.487481153558356972e+00
+2.534706748960876777e+00
+2.474987231526139642e+00
+2.299484947628612108e+00
+2.265052291613387947e+00
+2.485366111615545659e+00
+2.232853201624330541e+00
+2.200532895356991592e+00
+2.272959962321765115e+00
+2.053371187890398630e+00
+2.007628172882389705e+00
+2.224334698819737888e+00
+2.001329655743270930e+00
+1.972431696035732207e+00
+2.075551558880317948e+00
+1.869645182424616525e+00
+1.868830734228396739e+00
+2.110851182494470901e+00
+1.881862568464153451e+00
+1.923748735025901047e+00
+1.915095200740227765e+00
+1.837024354657344372e+00
+1.943216776148942726e+00
+1.963774331206692203e+00
+1.942104181365738480e+00
+2.138956896378744421e+00
+1.941644256040882421e+00
+2.012875923612631013e+00
+2.148966650318580029e+00
+2.122790644122982240e+00
+2.290040951280146952e+00
+2.133107852855277820e+00
+2.196652432067295102e+00
+2.348618970034259679e+00
+2.345041167043720787e+00
+2.503775002747587575e+00
+2.334305820080575078e+00
+2.400343601068887889e+00
+2.514905193818851803e+00
+2.524015497865694790e+00
+2.644925481118350241e+00
+2.467818013299086566e+00
+2.586441972260880462e+00
+2.614555935303437550e+00
+2.588990061392741016e+00
+2.517446846438982533e+00
+2.484293460733774772e+00
+2.571738323145156269e+00
+2.569075079619895785e+00
+2.572340844269203064e+00
+2.379885456699784463e+00
+2.473581859212807377e+00
+2.456040330499389412e+00
+2.415849893506364587e+00
+2.234461171138444779e+00
+2.243647455900546372e+00
+2.277506706203085596e+00
+2.224226213757672710e+00
+2.078765664068040753e+00
+2.035886349580034782e+00
+2.108333340133040856e+00
+2.087363419095380035e+00
+1.958797423833283036e+00
+1.957562252772356626e+00
+2.025075681286107709e+00
+2.128922055808722735e+00
+1.918125278734467809e+00
+1.893682192907569783e+00
+2.063293668853648732e+00
+2.055674811682847825e+00
+1.973480330464091992e+00
+2.007932264515533749e+00
+2.189250830349129373e+00
+2.169660584982217255e+00
+2.104160520435589099e+00
+2.232281845097556783e+00
+2.340805453349341203e+00
+2.288800332131372794e+00
+2.260701783895127548e+00
+2.461690185755821769e+00
+2.456495247864540765e+00
+2.347582950391317258e+00
+2.437296311249882663e+00
+2.496980609618180136e+00
+2.405086800722554763e+00
+2.354962266399514448e+00
```

## PyMieSim/validation_data/PyMieScattQscaCoreShell.csv

 * *Ordering differences only*

```diff
@@ -1,400 +1,400 @@
-3.482239706071486918e+00
-3.482239693797805735e+00
-3.482239681151899191e+00
-3.482239668122356413e+00
-3.482239654697412146e+00
-3.482239640864935204e+00
-3.482239626612412486e+00
-3.482239611926944090e+00
-3.482239596795220660e+00
-3.482239581203522061e+00
-3.482239565137694282e+00
-3.482239548583140110e+00
-3.482239531524804477e+00
-3.482239513947157583e+00
-3.482239495834182463e+00
-3.482239477169356334e+00
-3.482239457935638605e+00
-3.482239438115446006e+00
-3.482239417690643712e+00
-3.482239396642519580e+00
-3.482239374951773936e+00
-3.482239352598492932e+00
-3.482239329562127672e+00
-3.482239305821483111e+00
-3.482239281354683857e+00
-3.482239256139161743e+00
-3.482239230151626952e+00
-3.482239203368050262e+00
-3.482239175763630179e+00
-3.482239147312772509e+00
-3.482239117989065491e+00
-3.482239087765247376e+00
-3.482239056613183781e+00
-3.482239024503832159e+00
-3.482238991407218709e+00
-3.482238957292400183e+00
-3.482238922127433689e+00
-3.482238885879345158e+00
-3.482238848514092933e+00
-3.482238809996531348e+00
-3.482238770290371210e+00
-3.482238729358144713e+00
-3.482238687161162805e+00
-3.482238643659477439e+00
-3.482238598811830066e+00
-3.482238552575615653e+00
-3.482238504906830734e+00
-3.482238455760030771e+00
-3.482238405088271094e+00
-3.482238352843064266e+00
-3.482238298974322799e+00
-3.482238243430303637e+00
-3.482238186157549986e+00
-3.482238127100832248e+00
-3.482238066203085847e+00
-3.482238003405347282e+00
-3.482237938646684849e+00
-3.482237871864134693e+00
-3.482237802992622200e+00
-3.482237731964893612e+00
-3.482237658711430317e+00
-3.482237583160380012e+00
-3.482237505237462116e+00
-3.482237424865887832e+00
-3.482237341966268218e+00
-3.482237256456518271e+00
-3.482237168251762771e+00
-3.482237077264235037e+00
-3.482236983403170338e+00
-3.482236886574699319e+00
-3.482236786681734309e+00
-3.482236683623849416e+00
-3.482236577297158409e+00
-3.482236467594192142e+00
-3.482236354403762224e+00
-3.482236237610824681e+00
-3.482236117096337402e+00
-3.482235992737112706e+00
-3.482235864405660131e+00
-3.482235731970026560e+00
-3.482235595293633690e+00
-3.482235454235099503e+00
-3.482235308648055749e+00
-3.482235158380963647e+00
-3.482235003276919816e+00
-3.482234843173444006e+00
-3.482234677902276587e+00
-3.482234507289152958e+00
-3.482234331153572615e+00
-3.482234149308559790e+00
-3.482233961560420088e+00
-3.482233767708470040e+00
-3.482233567544775976e+00
-3.482233360853867588e+00
-3.482233147412445273e+00
-3.482232926989074606e+00
-3.482232699343866145e+00
-3.482232464228149027e+00
-3.482232221384109483e+00
-3.482231970544450217e+00
-3.482231711431998278e+00
-3.482231443759323586e+00
-3.482231167228317492e+00
-3.482230881529780220e+00
-3.482230586342963008e+00
-3.482230281335116029e+00
-3.482229966160992340e+00
-3.482229640462353171e+00
-3.482229303867433678e+00
-3.482228955990397612e+00
-3.482228596430759548e+00
-3.482228224772791592e+00
-3.482227840584889655e+00
-3.482227443418933088e+00
-3.482227032809589229e+00
-3.482226608273617519e+00
-3.482226169309112773e+00
-3.482225715394738241e+00
-3.482225245988915141e+00
-3.482224760528973118e+00
-3.482224258430270947e+00
-3.482223739085270608e+00
-3.482223201862574058e+00
-3.482222646105920028e+00
-3.482222071133124874e+00
-3.482221476234985680e+00
-3.482220860674133167e+00
-3.482220223683826887e+00
-3.482219564466705553e+00
-3.482218882193465870e+00
-3.482218176001499188e+00
-3.482217444993454425e+00
-3.482216688235737045e+00
-3.482215904756943647e+00
-3.482215093546220164e+00
-3.482214253551556116e+00
-3.482213383677978058e+00
-3.482212482785688845e+00
-3.482211549688094099e+00
-3.482210583149765171e+00
-3.482209581884279537e+00
-3.482208544551988805e+00
-3.482207469757664597e+00
-3.482206356048043183e+00
-3.482205201909254644e+00
-3.482204005764140575e+00
-3.482202765969432345e+00
-3.482201480812813443e+00
-3.482200148509833948e+00
-3.482198767200693545e+00
-3.482197334946861123e+00
-3.482195849727550030e+00
-3.482194309436020152e+00
-3.482192711875708557e+00
-3.482191054756186510e+00
-3.482189335688919751e+00
-3.482187552182836487e+00
-3.482185701639680442e+00
-3.482183781349160068e+00
-3.482181788483855289e+00
-3.482179720093897313e+00
-3.482177573101394863e+00
-3.482175344294602404e+00
-3.482173030321809026e+00
-3.482170627684946229e+00
-3.482168132732898158e+00
-3.482165541654494767e+00
-3.482162850471174576e+00
-3.482160055029312140e+00
-3.482157150992177375e+00
-3.482154133831523612e+00
-3.482150998818779097e+00
-3.482147741015830356e+00
-3.482144355265370805e+00
-3.482140836180796395e+00
-3.482137178135636280e+00
-3.482133375252485230e+00
-3.482129421391413349e+00
-3.482125310137851759e+00
-3.482121034789892988e+00
-3.482116588345016250e+00
-3.482111963486187900e+00
-3.482107152567318398e+00
-3.482102147598038488e+00
-3.482096940227776827e+00
-3.482091521729097749e+00
-3.482085882980259228e+00
-3.482080014446977678e+00
-3.482073906163346777e+00
-3.482067547711870326e+00
-3.482060928202586503e+00
-3.482054036251224893e+00
-3.482046859956370533e+00
-3.482039386875569242e+00
-3.482031604000359160e+00
-3.482023497730148076e+00
-3.482015053844907282e+00
-3.482006257476629951e+00
-3.481997093079496786e+00
-3.481987544398678747e+00
-3.481977594437752899e+00
-3.481967225424640766e+00
-3.481956418776022577e+00
-3.481945155060165220e+00
-3.481933413958073764e+00
-3.481921174222942117e+00
-3.481908413637784694e+00
-3.481895108971208241e+00
-3.481881235931227003e+00
-3.481866769117062610e+00
-3.481851681968822998e+00
-3.481835946714999963e+00
-3.481819534317677878e+00
-3.481802414415387847e+00
-3.481784555263486958e+00
-3.481765923671994223e+00
-3.481746484940763331e+00
-3.481726202791914027e+00
-3.481705039299395565e+00
-3.481682954815593423e+00
-3.481659907894860684e+00
-3.481635855213875530e+00
-3.481610751488685818e+00
-3.481584549388350158e+00
-3.481557199445045381e+00
-3.481528649960506261e+00
-3.481498846908691380e+00
-3.481467733834545442e+00
-3.481435251748707493e+00
-3.481401339018060259e+00
-3.481365931251976242e+00
-3.481328961184108728e+00
-3.481290358549629094e+00
-3.481250049957723913e+00
-3.481207958759244825e+00
-3.481164004909369503e+00
-3.481118104825103199e+00
-3.481070171237508948e+00
-3.481020113038509667e+00
-3.480967835122119602e+00
-3.480913238219967010e+00
-3.480856218730965956e+00
-3.480796668544986705e+00
-3.480734474860411876e+00
-3.480669519995416294e+00
-3.480601681192854624e+00
-3.480530830418624433e+00
-3.480456834153374146e+00
-3.480379553177447516e+00
-3.480298842348940269e+00
-3.480214550374773452e+00
-3.480126519574658239e+00
-3.480034585637906464e+00
-3.479938577372947428e+00
-3.479838316449523905e+00
-3.479733617133472734e+00
-3.479624286014075363e+00
-3.479510121723893068e+00
-3.479390914651115718e+00
-3.479266446644378341e+00
-3.479136490710066365e+00
-3.479000810702154389e+00
-3.478859161004588252e+00
-3.478711286206314757e+00
-3.478556920769017680e+00
-3.478395788687695056e+00
-3.478227603144195879e+00
-3.478052066153886734e+00
-3.477868868205638897e+00
-3.477677687895359249e+00
-3.477478191553287523e+00
-3.477270032865386717e+00
-3.477052852489085133e+00
-3.476826277663772835e+00
-3.476589921816384265e+00
-3.476343384162524419e+00
-3.476086249303576903e+00
-3.475818086820293473e+00
-3.475538450863412177e+00
-3.475246879741848538e+00
-3.474942895509121499e+00
-3.474626003548627828e+00
-3.474295692158490212e+00
-3.473951432136709094e+00
-3.473592676367406096e+00
-3.473218859408952142e+00
-3.472829397084877812e+00
-3.472423686078431881e+00
-3.472001103531719757e+00
-3.471561006650396575e+00
-3.471102732314896855e+00
-3.470625596699218551e+00
-3.470128894898305116e+00
-3.469611900565082951e+00
-3.469073865558209846e+00
-3.468514019601620646e+00
-3.467931569956945737e+00
-3.467325701109843283e+00
-3.466695574471308383e+00
-3.466040328094971201e+00
-3.465359076411349104e+00
-3.464650909979994697e+00
-3.463914895260381321e+00
-3.463150074402340906e+00
-3.462355465056704329e+00
-3.461530060206769566e+00
-3.460672828021022163e+00
-3.459782711727418913e+00
-3.458858629509413696e+00
-3.457899474423626884e+00
-3.456904114338954503e+00
-3.455871391896602418e+00
-3.454800124490321700e+00
-3.453689104265802001e+00
-3.452537098137893778e+00
-3.451342847823996252e+00
-3.450105069891553633e+00
-3.448822455817242894e+00
-3.447493672054989577e+00
-3.446117360109521410e+00
-3.444692136611651634e+00
-3.443216593391031921e+00
-3.441689297541540071e+00
-3.440108791473924121e+00
-3.438473592949759183e+00
-3.436782195090155589e+00
-3.435033066352059183e+00
-3.433224650464348215e+00
-3.431355366315303357e+00
-3.429423607782406069e+00
-3.427427743494759760e+00
-3.425366116517853943e+00
-3.423237043949784120e+00
-3.421038816417453443e+00
-3.418769697460831480e+00
-3.416427922792808491e+00
-3.414011699421865664e+00
-3.411519204624424262e+00
-3.408948584753562994e+00
-3.406297953870693007e+00
-3.403565392186859828e+00
-3.400748944300501009e+00
-3.397846617218947873e+00
-3.394856378151471787e+00
-3.391776152062569771e+00
-3.388603818975160387e+00
-3.385337211014747272e+00
-3.381974109187187771e+00
-3.378512239884639001e+00
-3.374949271116483018e+00
-3.371282808464670211e+00
-3.367510390765824813e+00
-3.363629485525785778e+00
-3.359637484075995939e+00
-3.355531696485128723e+00
-3.351309346243831033e+00
-3.346967564745201962e+00
-3.342503385588720732e+00
-3.337913738740692970e+00
-3.333195444589958978e+00
-3.328345207943340878e+00
-3.323359612011330455e+00
-3.318235112440437451e+00
-3.312968031454638140e+00
-3.307554552174188700e+00
-3.301990713185682491e+00
-3.296272403442646493e+00
-3.290395357580772728e+00
-3.284355151736432443e+00
-3.278147199960910196e+00
-3.271766751326052880e+00
-3.265208887819585737e+00
-3.258468523130186867e+00
-3.251540402423640508e+00
-3.244419103211985789e+00
-3.237099037417700220e+00
-3.229574454734721822e+00
-3.221839447387838895e+00
-3.213887956391802803e+00
-3.205713779411808684e+00
-3.197310580328184493e+00
-3.188671900610554388e+00
-3.179791172610672678e+00
-3.170661734889412386e+00
-3.161276849701871949e+00
-3.151629722776047693e+00
-3.141713525535059226e+00
-3.131521419930666017e+00
-3.121046586077005358e+00
-3.110282252897631050e+00
-3.099221732025906118e+00
-3.087858455227930676e+00
-3.076186015647262462e+00
-3.064198213200876264e+00
-3.051889104484085902e+00
-3.039253057566464911e+00
-3.026284812079380160e+00
-3.012979545004549564e+00
-2.999332942570197336e+00
-2.985341278642001495e+00
+3.482239706071486918e+00
+3.482239693797805735e+00
+3.482239681151899191e+00
+3.482239668122356413e+00
+3.482239654697412146e+00
+3.482239640864935204e+00
+3.482239626612412486e+00
+3.482239611926944090e+00
+3.482239596795220660e+00
+3.482239581203522061e+00
+3.482239565137694282e+00
+3.482239548583140110e+00
+3.482239531524804477e+00
+3.482239513947157583e+00
+3.482239495834182463e+00
+3.482239477169356334e+00
+3.482239457935638605e+00
+3.482239438115446006e+00
+3.482239417690643712e+00
+3.482239396642519580e+00
+3.482239374951773936e+00
+3.482239352598492932e+00
+3.482239329562127672e+00
+3.482239305821483111e+00
+3.482239281354683857e+00
+3.482239256139161743e+00
+3.482239230151626952e+00
+3.482239203368050262e+00
+3.482239175763630179e+00
+3.482239147312772509e+00
+3.482239117989065491e+00
+3.482239087765247376e+00
+3.482239056613183781e+00
+3.482239024503832159e+00
+3.482238991407218709e+00
+3.482238957292400183e+00
+3.482238922127433689e+00
+3.482238885879345158e+00
+3.482238848514092933e+00
+3.482238809996531348e+00
+3.482238770290371210e+00
+3.482238729358144713e+00
+3.482238687161162805e+00
+3.482238643659477439e+00
+3.482238598811830066e+00
+3.482238552575615653e+00
+3.482238504906830734e+00
+3.482238455760030771e+00
+3.482238405088271094e+00
+3.482238352843064266e+00
+3.482238298974322799e+00
+3.482238243430303637e+00
+3.482238186157549986e+00
+3.482238127100832248e+00
+3.482238066203085847e+00
+3.482238003405347282e+00
+3.482237938646684849e+00
+3.482237871864134693e+00
+3.482237802992622200e+00
+3.482237731964893612e+00
+3.482237658711430317e+00
+3.482237583160380012e+00
+3.482237505237462116e+00
+3.482237424865887832e+00
+3.482237341966268218e+00
+3.482237256456518271e+00
+3.482237168251762771e+00
+3.482237077264235037e+00
+3.482236983403170338e+00
+3.482236886574699319e+00
+3.482236786681734309e+00
+3.482236683623849416e+00
+3.482236577297158409e+00
+3.482236467594192142e+00
+3.482236354403762224e+00
+3.482236237610824681e+00
+3.482236117096337402e+00
+3.482235992737112706e+00
+3.482235864405660131e+00
+3.482235731970026560e+00
+3.482235595293633690e+00
+3.482235454235099503e+00
+3.482235308648055749e+00
+3.482235158380963647e+00
+3.482235003276919816e+00
+3.482234843173444006e+00
+3.482234677902276587e+00
+3.482234507289152958e+00
+3.482234331153572615e+00
+3.482234149308559790e+00
+3.482233961560420088e+00
+3.482233767708470040e+00
+3.482233567544775976e+00
+3.482233360853867588e+00
+3.482233147412445273e+00
+3.482232926989074606e+00
+3.482232699343866145e+00
+3.482232464228149027e+00
+3.482232221384109483e+00
+3.482231970544450217e+00
+3.482231711431998278e+00
+3.482231443759323586e+00
+3.482231167228317492e+00
+3.482230881529780220e+00
+3.482230586342963008e+00
+3.482230281335116029e+00
+3.482229966160992340e+00
+3.482229640462353171e+00
+3.482229303867433678e+00
+3.482228955990397612e+00
+3.482228596430759548e+00
+3.482228224772791592e+00
+3.482227840584889655e+00
+3.482227443418933088e+00
+3.482227032809589229e+00
+3.482226608273617519e+00
+3.482226169309112773e+00
+3.482225715394738241e+00
+3.482225245988915141e+00
+3.482224760528973118e+00
+3.482224258430270947e+00
+3.482223739085270608e+00
+3.482223201862574058e+00
+3.482222646105920028e+00
+3.482222071133124874e+00
+3.482221476234985680e+00
+3.482220860674133167e+00
+3.482220223683826887e+00
+3.482219564466705553e+00
+3.482218882193465870e+00
+3.482218176001499188e+00
+3.482217444993454425e+00
+3.482216688235737045e+00
+3.482215904756943647e+00
+3.482215093546220164e+00
+3.482214253551556116e+00
+3.482213383677978058e+00
+3.482212482785688845e+00
+3.482211549688094099e+00
+3.482210583149765171e+00
+3.482209581884279537e+00
+3.482208544551988805e+00
+3.482207469757664597e+00
+3.482206356048043183e+00
+3.482205201909254644e+00
+3.482204005764140575e+00
+3.482202765969432345e+00
+3.482201480812813443e+00
+3.482200148509833948e+00
+3.482198767200693545e+00
+3.482197334946861123e+00
+3.482195849727550030e+00
+3.482194309436020152e+00
+3.482192711875708557e+00
+3.482191054756186510e+00
+3.482189335688919751e+00
+3.482187552182836487e+00
+3.482185701639680442e+00
+3.482183781349160068e+00
+3.482181788483855289e+00
+3.482179720093897313e+00
+3.482177573101394863e+00
+3.482175344294602404e+00
+3.482173030321809026e+00
+3.482170627684946229e+00
+3.482168132732898158e+00
+3.482165541654494767e+00
+3.482162850471174576e+00
+3.482160055029312140e+00
+3.482157150992177375e+00
+3.482154133831523612e+00
+3.482150998818779097e+00
+3.482147741015830356e+00
+3.482144355265370805e+00
+3.482140836180796395e+00
+3.482137178135636280e+00
+3.482133375252485230e+00
+3.482129421391413349e+00
+3.482125310137851759e+00
+3.482121034789892988e+00
+3.482116588345016250e+00
+3.482111963486187900e+00
+3.482107152567318398e+00
+3.482102147598038488e+00
+3.482096940227776827e+00
+3.482091521729097749e+00
+3.482085882980259228e+00
+3.482080014446977678e+00
+3.482073906163346777e+00
+3.482067547711870326e+00
+3.482060928202586503e+00
+3.482054036251224893e+00
+3.482046859956370533e+00
+3.482039386875569242e+00
+3.482031604000359160e+00
+3.482023497730148076e+00
+3.482015053844907282e+00
+3.482006257476629951e+00
+3.481997093079496786e+00
+3.481987544398678747e+00
+3.481977594437752899e+00
+3.481967225424640766e+00
+3.481956418776022577e+00
+3.481945155060165220e+00
+3.481933413958073764e+00
+3.481921174222942117e+00
+3.481908413637784694e+00
+3.481895108971208241e+00
+3.481881235931227003e+00
+3.481866769117062610e+00
+3.481851681968822998e+00
+3.481835946714999963e+00
+3.481819534317677878e+00
+3.481802414415387847e+00
+3.481784555263486958e+00
+3.481765923671994223e+00
+3.481746484940763331e+00
+3.481726202791914027e+00
+3.481705039299395565e+00
+3.481682954815593423e+00
+3.481659907894860684e+00
+3.481635855213875530e+00
+3.481610751488685818e+00
+3.481584549388350158e+00
+3.481557199445045381e+00
+3.481528649960506261e+00
+3.481498846908691380e+00
+3.481467733834545442e+00
+3.481435251748707493e+00
+3.481401339018060259e+00
+3.481365931251976242e+00
+3.481328961184108728e+00
+3.481290358549629094e+00
+3.481250049957723913e+00
+3.481207958759244825e+00
+3.481164004909369503e+00
+3.481118104825103199e+00
+3.481070171237508948e+00
+3.481020113038509667e+00
+3.480967835122119602e+00
+3.480913238219967010e+00
+3.480856218730965956e+00
+3.480796668544986705e+00
+3.480734474860411876e+00
+3.480669519995416294e+00
+3.480601681192854624e+00
+3.480530830418624433e+00
+3.480456834153374146e+00
+3.480379553177447516e+00
+3.480298842348940269e+00
+3.480214550374773452e+00
+3.480126519574658239e+00
+3.480034585637906464e+00
+3.479938577372947428e+00
+3.479838316449523905e+00
+3.479733617133472734e+00
+3.479624286014075363e+00
+3.479510121723893068e+00
+3.479390914651115718e+00
+3.479266446644378341e+00
+3.479136490710066365e+00
+3.479000810702154389e+00
+3.478859161004588252e+00
+3.478711286206314757e+00
+3.478556920769017680e+00
+3.478395788687695056e+00
+3.478227603144195879e+00
+3.478052066153886734e+00
+3.477868868205638897e+00
+3.477677687895359249e+00
+3.477478191553287523e+00
+3.477270032865386717e+00
+3.477052852489085133e+00
+3.476826277663772835e+00
+3.476589921816384265e+00
+3.476343384162524419e+00
+3.476086249303576903e+00
+3.475818086820293473e+00
+3.475538450863412177e+00
+3.475246879741848538e+00
+3.474942895509121499e+00
+3.474626003548627828e+00
+3.474295692158490212e+00
+3.473951432136709094e+00
+3.473592676367406096e+00
+3.473218859408952142e+00
+3.472829397084877812e+00
+3.472423686078431881e+00
+3.472001103531719757e+00
+3.471561006650396575e+00
+3.471102732314896855e+00
+3.470625596699218551e+00
+3.470128894898305116e+00
+3.469611900565082951e+00
+3.469073865558209846e+00
+3.468514019601620646e+00
+3.467931569956945737e+00
+3.467325701109843283e+00
+3.466695574471308383e+00
+3.466040328094971201e+00
+3.465359076411349104e+00
+3.464650909979994697e+00
+3.463914895260381321e+00
+3.463150074402340906e+00
+3.462355465056704329e+00
+3.461530060206769566e+00
+3.460672828021022163e+00
+3.459782711727418913e+00
+3.458858629509413696e+00
+3.457899474423626884e+00
+3.456904114338954503e+00
+3.455871391896602418e+00
+3.454800124490321700e+00
+3.453689104265802001e+00
+3.452537098137893778e+00
+3.451342847823996252e+00
+3.450105069891553633e+00
+3.448822455817242894e+00
+3.447493672054989577e+00
+3.446117360109521410e+00
+3.444692136611651634e+00
+3.443216593391031921e+00
+3.441689297541540071e+00
+3.440108791473924121e+00
+3.438473592949759183e+00
+3.436782195090155589e+00
+3.435033066352059183e+00
+3.433224650464348215e+00
+3.431355366315303357e+00
+3.429423607782406069e+00
+3.427427743494759760e+00
+3.425366116517853943e+00
+3.423237043949784120e+00
+3.421038816417453443e+00
+3.418769697460831480e+00
+3.416427922792808491e+00
+3.414011699421865664e+00
+3.411519204624424262e+00
+3.408948584753562994e+00
+3.406297953870693007e+00
+3.403565392186859828e+00
+3.400748944300501009e+00
+3.397846617218947873e+00
+3.394856378151471787e+00
+3.391776152062569771e+00
+3.388603818975160387e+00
+3.385337211014747272e+00
+3.381974109187187771e+00
+3.378512239884639001e+00
+3.374949271116483018e+00
+3.371282808464670211e+00
+3.367510390765824813e+00
+3.363629485525785778e+00
+3.359637484075995939e+00
+3.355531696485128723e+00
+3.351309346243831033e+00
+3.346967564745201962e+00
+3.342503385588720732e+00
+3.337913738740692970e+00
+3.333195444589958978e+00
+3.328345207943340878e+00
+3.323359612011330455e+00
+3.318235112440437451e+00
+3.312968031454638140e+00
+3.307554552174188700e+00
+3.301990713185682491e+00
+3.296272403442646493e+00
+3.290395357580772728e+00
+3.284355151736432443e+00
+3.278147199960910196e+00
+3.271766751326052880e+00
+3.265208887819585737e+00
+3.258468523130186867e+00
+3.251540402423640508e+00
+3.244419103211985789e+00
+3.237099037417700220e+00
+3.229574454734721822e+00
+3.221839447387838895e+00
+3.213887956391802803e+00
+3.205713779411808684e+00
+3.197310580328184493e+00
+3.188671900610554388e+00
+3.179791172610672678e+00
+3.170661734889412386e+00
+3.161276849701871949e+00
+3.151629722776047693e+00
+3.141713525535059226e+00
+3.131521419930666017e+00
+3.121046586077005358e+00
+3.110282252897631050e+00
+3.099221732025906118e+00
+3.087858455227930676e+00
+3.076186015647262462e+00
+3.064198213200876264e+00
+3.051889104484085902e+00
+3.039253057566464911e+00
+3.026284812079380160e+00
+3.012979545004549564e+00
+2.999332942570197336e+00
+2.985341278642001495e+00
```

## PyMieSim/validation_data/PyMieScattQscaCoreShellMedium.csv

 * *Ordering differences only*

```diff
@@ -1,400 +1,400 @@
-1.600483771217527273e+00
-1.600483563918864816e+00
-1.600483350435757846e+00
-1.600483130583772784e+00
-1.600482904172980669e+00
-1.600482671007791291e+00
-1.600482430886785989e+00
-1.600482183602544461e+00
-1.600481928941464682e+00
-1.600481666683580162e+00
-1.600481396602370321e+00
-1.600481118464562647e+00
-1.600480832029937517e+00
-1.600480537051117036e+00
-1.600480233273351649e+00
-1.600479920434304759e+00
-1.600479598263823355e+00
-1.600479266483706420e+00
-1.600478924807466008e+00
-1.600478572940081001e+00
-1.600478210577742422e+00
-1.600477837407591197e+00
-1.600477453107452819e+00
-1.600477057345554899e+00
-1.600476649780246285e+00
-1.600476230059701077e+00
-1.600475797821617086e+00
-1.600475352692902309e+00
-1.600474894289357408e+00
-1.600474422215344195e+00
-1.600473936063443015e+00
-1.600473435414106582e+00
-1.600472919835297159e+00
-1.600472388882117514e+00
-1.600471842096425235e+00
-1.600471279006441927e+00
-1.600470699126349317e+00
-1.600470101955867142e+00
-1.600469486979829936e+00
-1.600468853667739610e+00
-1.600468201473313590e+00
-1.600467529834014080e+00
-1.600466838170566453e+00
-1.600466125886461866e+00
-1.600465392367445894e+00
-1.600464636980991839e+00
-1.600463859075756945e+00
-1.600463057981028614e+00
-1.600462233006141988e+00
-1.600461383439896190e+00
-1.600460508549938599e+00
-1.600459607582140231e+00
-1.600458679759951375e+00
-1.600457724283733008e+00
-1.600456740330076455e+00
-1.600455727051091737e+00
-1.600454683573692360e+00
-1.600453608998837485e+00
-1.600452502400769195e+00
-1.600451362826218915e+00
-1.600450189293593839e+00
-1.600448980792134490e+00
-1.600447736281053857e+00
-1.600446454688646103e+00
-1.600445134911373080e+00
-1.600443775812918412e+00
-1.600442376223220720e+00
-1.600440934937472637e+00
-1.600439450715092082e+00
-1.600437922278665548e+00
-1.600436348312857859e+00
-1.600434727463288409e+00
-1.600433058335378300e+00
-1.600431339493161964e+00
-1.600429569458059698e+00
-1.600427746707624443e+00
-1.600425869674239721e+00
-1.600423936743785802e+00
-1.600421946254266814e+00
-1.600419896494398087e+00
-1.600417785702145990e+00
-1.600415612063231574e+00
-1.600413373709589804e+00
-1.600411068717779717e+00
-1.600408695107350399e+00
-1.600406250839159217e+00
-1.600403733813638985e+00
-1.600401141869019606e+00
-1.600398472779489101e+00
-1.600395724253308227e+00
-1.600392893930867366e+00
-1.600389979382685013e+00
-1.600386978107349201e+00
-1.600383887529400750e+00
-1.600380704997151238e+00
-1.600377427780438344e+00
-1.600374053068316149e+00
-1.600370577966679697e+00
-1.600366999495813625e+00
-1.600363314587880614e+00
-1.600359520084325915e+00
-1.600355612733210142e+00
-1.600351589186467027e+00
-1.600347445997077456e+00
-1.600343179616162237e+00
-1.600338786389992496e+00
-1.600334262556910581e+00
-1.600329604244161708e+00
-1.600324807464635457e+00
-1.600319868113508459e+00
-1.600314781964796262e+00
-1.600309544667799733e+00
-1.600304151743448644e+00
-1.600298598580541798e+00
-1.600292880431877451e+00
-1.600286992410269615e+00
-1.600280929484451553e+00
-1.600274686474859376e+00
-1.600268258049295289e+00
-1.600261638718460944e+00
-1.600254822831367330e+00
-1.600247804570610111e+00
-1.600240577947505738e+00
-1.600233136797091893e+00
-1.600225474772978274e+00
-1.600217585342055937e+00
-1.600209461779047215e+00
-1.600201097160903307e+00
-1.600192484361037115e+00
-1.600183616043394652e+00
-1.600174484656350593e+00
-1.600165082426433294e+00
-1.600155401351865958e+00
-1.600145433195923728e+00
-1.600135169480102260e+00
-1.600124601477085129e+00
-1.600113720203514944e+00
-1.600102516412553966e+00
-1.600090980586234668e+00
-1.600079102927588703e+00
-1.600066873352549379e+00
-1.600054281481629870e+00
-1.600041316631354738e+00
-1.600027967805451867e+00
-1.600014223685792825e+00
-1.600000072623073200e+00
-1.599985502627227385e+00
-1.599970501357571573e+00
-1.599955056112665419e+00
-1.599939153819885496e+00
-1.599922781024700091e+00
-1.599905923879642700e+00
-1.599888568132967981e+00
-1.599870699116991091e+00
-1.599852301736090165e+00
-1.599833360454371967e+00
-1.599813859282987138e+00
-1.599793781767085532e+00
-1.599773110972404710e+00
-1.599751829471473652e+00
-1.599729919329429650e+00
-1.599707362089438201e+00
-1.599684138757689889e+00
-1.599660229787984944e+00
-1.599635615065877259e+00
-1.599610273892368761e+00
-1.599584184967151490e+00
-1.599557326371369381e+00
-1.599529675549900443e+00
-1.599501209293134441e+00
-1.599471903718245658e+00
-1.599441734249930080e+00
-1.599410675600606346e+00
-1.599378701750063136e+00
-1.599345785924525254e+00
-1.599311900575142165e+00
-1.599277017355865915e+00
-1.599241107100715542e+00
-1.599204139800397106e+00
-1.599166084578270475e+00
-1.599126909665649077e+00
-1.599086582376398225e+00
-1.599045069080830883e+00
-1.599002335178869583e+00
-1.598958345072457377e+00
-1.598913062137201191e+00
-1.598866448693217368e+00
-1.598818465975170966e+00
-1.598769074101471066e+00
-1.598718232042610099e+00
-1.598665897588621432e+00
-1.598612027315627682e+00
-1.598556576551456221e+00
-1.598499499340298335e+00
-1.598440748406384060e+00
-1.598380275116646265e+00
-1.598318029442342469e+00
-1.598253959919616385e+00
-1.598188013608952351e+00
-1.598120136053516438e+00
-1.598050271236325592e+00
-1.597978361536239955e+00
-1.597904347682725268e+00
-1.597828168709366947e+00
-1.597749761906087418e+00
-1.597669062770046944e+00
-1.597586004955177552e+00
-1.597500520220323850e+00
-1.597412538375949431e+00
-1.597321987229363804e+00
-1.597228792528439856e+00
-1.597132877903778336e+00
-1.597034164809269408e+00
-1.596932572461021937e+00
-1.596828017774602815e+00
-1.596720415300554530e+00
-1.596609677158131957e+00
-1.596495712967223035e+00
-1.596378429778396724e+00
-1.596257732001032714e+00
-1.596133521329481830e+00
-1.596005696667208262e+00
-1.595874154048851468e+00
-1.595738786560169542e+00
-1.595599484255796119e+00
-1.595456134074759058e+00
-1.595308619753707191e+00
-1.595156821737782726e+00
-1.595000617089083583e+00
-1.594839879392653703e+00
-1.594674478659937167e+00
-1.594504281229646603e+00
-1.594329149665965062e+00
-1.594148942654029177e+00
-1.593963514892632105e+00
-1.593772716984067195e+00
-1.593576395321060879e+00
-1.593374391970715287e+00
-1.593166544555407294e+00
-1.592952686130560513e+00
-1.592732645059236951e+00
-1.592506244883468813e+00
-1.592273304192267425e+00
-1.592033636486234860e+00
-1.591787050038725226e+00
-1.591533347753458338e+00
-1.591272327018552923e+00
-1.591003779556878550e+00
-1.590727491272682537e+00
-1.590443242094418119e+00
-1.590150805813701940e+00
-1.589849949920346672e+00
-1.589540435433404619e+00
-1.589222016728150333e+00
-1.588894441358965182e+00
-1.588557449878038597e+00
-1.588210775649859796e+00
-1.587854144661423383e+00
-1.587487275328116176e+00
-1.587109878295231313e+00
-1.586721656235068556e+00
-1.586322303639581932e+00
-1.585911506608536303e+00
-1.585488942633146658e+00
-1.585054280375169267e+00
-1.584607179441424041e+00
-1.584147290153728127e+00
-1.583674253314235392e+00
-1.583187699966164264e+00
-1.582687251149922147e+00
-1.582172517654630184e+00
-1.581643099765047911e+00
-1.581098587003932465e+00
-1.580538557869832772e+00
-1.579962579570372894e+00
-1.579370207751033650e+00
-1.578760986219492235e+00
-1.578134446665559132e+00
-1.577490108376766731e+00
-1.576827477949661382e+00
-1.576146048996877713e+00
-1.575445301850043389e+00
-1.574724703258606917e+00
-1.573983706084644218e+00
-1.573221748993740343e+00
-1.572438256142014490e+00
-1.571632636859379373e+00
-1.570804285329100214e+00
-1.569952580263759723e+00
-1.569076884577672804e+00
-1.568176545055847138e+00
-1.567250892019545594e+00
-1.566299238988502429e+00
-1.565320882339850783e+00
-1.564315100963773464e+00
-1.563281155915918763e+00
-1.562218290066550441e+00
-1.561125727746436764e+00
-1.560002674389398658e+00
-1.558848316171467019e+00
-1.557661819646512624e+00
-1.556442331378226074e+00
-1.555188977568240150e+00
-1.553900863680179434e+00
-1.552577074059343865e+00
-1.551216671547702486e+00
-1.549818697093801489e+00
-1.548382169357122473e+00
-1.546906084306388873e+00
-1.545389414811197515e+00
-1.543831110226326686e+00
-1.542230095967941583e+00
-1.540585273080864681e+00
-1.538895517795974222e+00
-1.537159681076688322e+00
-1.535376588153403832e+00
-1.533545038044653586e+00
-1.531663803063628482e+00
-1.529731628308607760e+00
-1.527747231135731187e+00
-1.525709300612414276e+00
-1.523616496949633081e+00
-1.521467450911147656e+00
-1.519260763197649355e+00
-1.516995003803715658e+00
-1.514668711345341645e+00
-1.512280392355737080e+00
-1.509828520546987463e+00
-1.507311536035135457e+00
-1.504727844526152269e+00
-1.502075816460282764e+00
-1.499353786112199938e+00
-1.496560050644478279e+00
-1.493692869111902022e+00
-1.490750461414289241e+00
-1.487731007195585153e+00
-1.484632644687273739e+00
-1.481453469494329767e+00
-1.478191533322356310e+00
-1.474844842644929432e+00
-1.471411357310709045e+00
-1.467888989090507357e+00
-1.464275600165254820e+00
-1.460569001556704993e+00
-1.456766951503738250e+00
-1.452867153788393706e+00
-1.448867256017116301e+00
-1.444764847864379975e+00
-1.440557459287684638e+00
-1.436242558725057350e+00
-1.431817551288568913e+00
-1.427279776970156844e+00
-1.422626508878954255e+00
-1.417854951532861563e+00
-1.412962239230732830e+00
-1.407945434535776918e+00
-1.402801526905276264e+00
-1.397527431506720097e+00
-1.392119988265803965e+00
-1.386575961197558327e+00
-1.380892038078046502e+00
-1.375064830520614345e+00
-1.369090874527588042e+00
-1.362966631595460276e+00
-1.356688490458970442e+00
-1.350252769566961053e+00
-1.343655720390415587e+00
-1.336893531670301005e+00
-1.329962334720043771e+00
-1.322858209903880589e+00
-1.315577194418255713e+00
-1.308115291508394673e+00
-1.300468481255867337e+00
-1.292632733075281148e+00
-1.284604020058779827e+00
-1.276378335305409673e+00
-1.267951710368524054e+00
-1.259320235947669175e+00
-1.250480084941708148e+00
-1.241427537966858008e+00
-1.232159011426533723e+00
-1.222671088199396072e+00
-1.212960550987022490e+00
-1.203024418333714207e+00
-1.192859983297273496e+00
-1.182464854711568147e+00
-1.171837000939148332e+00
-1.160974795965072692e+00
-1.149877067632099292e+00
-1.138543147761995611e+00
-1.126972923849197006e+00
-1.115166891951270056e+00
-1.103126210336656143e+00
-1.090852753384676799e+00
-1.078349165166946344e+00
-1.065618912074050462e+00
-1.052666333788784936e+00
-1.039496691848043053e+00
-1.026116214982785380e+00
-1.012532140380437706e+00
+1.600483771217527273e+00
+1.600483563918864816e+00
+1.600483350435757846e+00
+1.600483130583772784e+00
+1.600482904172980669e+00
+1.600482671007791291e+00
+1.600482430886785989e+00
+1.600482183602544461e+00
+1.600481928941464682e+00
+1.600481666683580162e+00
+1.600481396602370321e+00
+1.600481118464562647e+00
+1.600480832029937517e+00
+1.600480537051117036e+00
+1.600480233273351649e+00
+1.600479920434304759e+00
+1.600479598263823355e+00
+1.600479266483706420e+00
+1.600478924807466008e+00
+1.600478572940081001e+00
+1.600478210577742422e+00
+1.600477837407591197e+00
+1.600477453107452819e+00
+1.600477057345554899e+00
+1.600476649780246285e+00
+1.600476230059701077e+00
+1.600475797821617086e+00
+1.600475352692902309e+00
+1.600474894289357408e+00
+1.600474422215344195e+00
+1.600473936063443015e+00
+1.600473435414106582e+00
+1.600472919835297159e+00
+1.600472388882117514e+00
+1.600471842096425235e+00
+1.600471279006441927e+00
+1.600470699126349317e+00
+1.600470101955867142e+00
+1.600469486979829936e+00
+1.600468853667739610e+00
+1.600468201473313590e+00
+1.600467529834014080e+00
+1.600466838170566453e+00
+1.600466125886461866e+00
+1.600465392367445894e+00
+1.600464636980991839e+00
+1.600463859075756945e+00
+1.600463057981028614e+00
+1.600462233006141988e+00
+1.600461383439896190e+00
+1.600460508549938599e+00
+1.600459607582140231e+00
+1.600458679759951375e+00
+1.600457724283733008e+00
+1.600456740330076455e+00
+1.600455727051091737e+00
+1.600454683573692360e+00
+1.600453608998837485e+00
+1.600452502400769195e+00
+1.600451362826218915e+00
+1.600450189293593839e+00
+1.600448980792134490e+00
+1.600447736281053857e+00
+1.600446454688646103e+00
+1.600445134911373080e+00
+1.600443775812918412e+00
+1.600442376223220720e+00
+1.600440934937472637e+00
+1.600439450715092082e+00
+1.600437922278665548e+00
+1.600436348312857859e+00
+1.600434727463288409e+00
+1.600433058335378300e+00
+1.600431339493161964e+00
+1.600429569458059698e+00
+1.600427746707624443e+00
+1.600425869674239721e+00
+1.600423936743785802e+00
+1.600421946254266814e+00
+1.600419896494398087e+00
+1.600417785702145990e+00
+1.600415612063231574e+00
+1.600413373709589804e+00
+1.600411068717779717e+00
+1.600408695107350399e+00
+1.600406250839159217e+00
+1.600403733813638985e+00
+1.600401141869019606e+00
+1.600398472779489101e+00
+1.600395724253308227e+00
+1.600392893930867366e+00
+1.600389979382685013e+00
+1.600386978107349201e+00
+1.600383887529400750e+00
+1.600380704997151238e+00
+1.600377427780438344e+00
+1.600374053068316149e+00
+1.600370577966679697e+00
+1.600366999495813625e+00
+1.600363314587880614e+00
+1.600359520084325915e+00
+1.600355612733210142e+00
+1.600351589186467027e+00
+1.600347445997077456e+00
+1.600343179616162237e+00
+1.600338786389992496e+00
+1.600334262556910581e+00
+1.600329604244161708e+00
+1.600324807464635457e+00
+1.600319868113508459e+00
+1.600314781964796262e+00
+1.600309544667799733e+00
+1.600304151743448644e+00
+1.600298598580541798e+00
+1.600292880431877451e+00
+1.600286992410269615e+00
+1.600280929484451553e+00
+1.600274686474859376e+00
+1.600268258049295289e+00
+1.600261638718460944e+00
+1.600254822831367330e+00
+1.600247804570610111e+00
+1.600240577947505738e+00
+1.600233136797091893e+00
+1.600225474772978274e+00
+1.600217585342055937e+00
+1.600209461779047215e+00
+1.600201097160903307e+00
+1.600192484361037115e+00
+1.600183616043394652e+00
+1.600174484656350593e+00
+1.600165082426433294e+00
+1.600155401351865958e+00
+1.600145433195923728e+00
+1.600135169480102260e+00
+1.600124601477085129e+00
+1.600113720203514944e+00
+1.600102516412553966e+00
+1.600090980586234668e+00
+1.600079102927588703e+00
+1.600066873352549379e+00
+1.600054281481629870e+00
+1.600041316631354738e+00
+1.600027967805451867e+00
+1.600014223685792825e+00
+1.600000072623073200e+00
+1.599985502627227385e+00
+1.599970501357571573e+00
+1.599955056112665419e+00
+1.599939153819885496e+00
+1.599922781024700091e+00
+1.599905923879642700e+00
+1.599888568132967981e+00
+1.599870699116991091e+00
+1.599852301736090165e+00
+1.599833360454371967e+00
+1.599813859282987138e+00
+1.599793781767085532e+00
+1.599773110972404710e+00
+1.599751829471473652e+00
+1.599729919329429650e+00
+1.599707362089438201e+00
+1.599684138757689889e+00
+1.599660229787984944e+00
+1.599635615065877259e+00
+1.599610273892368761e+00
+1.599584184967151490e+00
+1.599557326371369381e+00
+1.599529675549900443e+00
+1.599501209293134441e+00
+1.599471903718245658e+00
+1.599441734249930080e+00
+1.599410675600606346e+00
+1.599378701750063136e+00
+1.599345785924525254e+00
+1.599311900575142165e+00
+1.599277017355865915e+00
+1.599241107100715542e+00
+1.599204139800397106e+00
+1.599166084578270475e+00
+1.599126909665649077e+00
+1.599086582376398225e+00
+1.599045069080830883e+00
+1.599002335178869583e+00
+1.598958345072457377e+00
+1.598913062137201191e+00
+1.598866448693217368e+00
+1.598818465975170966e+00
+1.598769074101471066e+00
+1.598718232042610099e+00
+1.598665897588621432e+00
+1.598612027315627682e+00
+1.598556576551456221e+00
+1.598499499340298335e+00
+1.598440748406384060e+00
+1.598380275116646265e+00
+1.598318029442342469e+00
+1.598253959919616385e+00
+1.598188013608952351e+00
+1.598120136053516438e+00
+1.598050271236325592e+00
+1.597978361536239955e+00
+1.597904347682725268e+00
+1.597828168709366947e+00
+1.597749761906087418e+00
+1.597669062770046944e+00
+1.597586004955177552e+00
+1.597500520220323850e+00
+1.597412538375949431e+00
+1.597321987229363804e+00
+1.597228792528439856e+00
+1.597132877903778336e+00
+1.597034164809269408e+00
+1.596932572461021937e+00
+1.596828017774602815e+00
+1.596720415300554530e+00
+1.596609677158131957e+00
+1.596495712967223035e+00
+1.596378429778396724e+00
+1.596257732001032714e+00
+1.596133521329481830e+00
+1.596005696667208262e+00
+1.595874154048851468e+00
+1.595738786560169542e+00
+1.595599484255796119e+00
+1.595456134074759058e+00
+1.595308619753707191e+00
+1.595156821737782726e+00
+1.595000617089083583e+00
+1.594839879392653703e+00
+1.594674478659937167e+00
+1.594504281229646603e+00
+1.594329149665965062e+00
+1.594148942654029177e+00
+1.593963514892632105e+00
+1.593772716984067195e+00
+1.593576395321060879e+00
+1.593374391970715287e+00
+1.593166544555407294e+00
+1.592952686130560513e+00
+1.592732645059236951e+00
+1.592506244883468813e+00
+1.592273304192267425e+00
+1.592033636486234860e+00
+1.591787050038725226e+00
+1.591533347753458338e+00
+1.591272327018552923e+00
+1.591003779556878550e+00
+1.590727491272682537e+00
+1.590443242094418119e+00
+1.590150805813701940e+00
+1.589849949920346672e+00
+1.589540435433404619e+00
+1.589222016728150333e+00
+1.588894441358965182e+00
+1.588557449878038597e+00
+1.588210775649859796e+00
+1.587854144661423383e+00
+1.587487275328116176e+00
+1.587109878295231313e+00
+1.586721656235068556e+00
+1.586322303639581932e+00
+1.585911506608536303e+00
+1.585488942633146658e+00
+1.585054280375169267e+00
+1.584607179441424041e+00
+1.584147290153728127e+00
+1.583674253314235392e+00
+1.583187699966164264e+00
+1.582687251149922147e+00
+1.582172517654630184e+00
+1.581643099765047911e+00
+1.581098587003932465e+00
+1.580538557869832772e+00
+1.579962579570372894e+00
+1.579370207751033650e+00
+1.578760986219492235e+00
+1.578134446665559132e+00
+1.577490108376766731e+00
+1.576827477949661382e+00
+1.576146048996877713e+00
+1.575445301850043389e+00
+1.574724703258606917e+00
+1.573983706084644218e+00
+1.573221748993740343e+00
+1.572438256142014490e+00
+1.571632636859379373e+00
+1.570804285329100214e+00
+1.569952580263759723e+00
+1.569076884577672804e+00
+1.568176545055847138e+00
+1.567250892019545594e+00
+1.566299238988502429e+00
+1.565320882339850783e+00
+1.564315100963773464e+00
+1.563281155915918763e+00
+1.562218290066550441e+00
+1.561125727746436764e+00
+1.560002674389398658e+00
+1.558848316171467019e+00
+1.557661819646512624e+00
+1.556442331378226074e+00
+1.555188977568240150e+00
+1.553900863680179434e+00
+1.552577074059343865e+00
+1.551216671547702486e+00
+1.549818697093801489e+00
+1.548382169357122473e+00
+1.546906084306388873e+00
+1.545389414811197515e+00
+1.543831110226326686e+00
+1.542230095967941583e+00
+1.540585273080864681e+00
+1.538895517795974222e+00
+1.537159681076688322e+00
+1.535376588153403832e+00
+1.533545038044653586e+00
+1.531663803063628482e+00
+1.529731628308607760e+00
+1.527747231135731187e+00
+1.525709300612414276e+00
+1.523616496949633081e+00
+1.521467450911147656e+00
+1.519260763197649355e+00
+1.516995003803715658e+00
+1.514668711345341645e+00
+1.512280392355737080e+00
+1.509828520546987463e+00
+1.507311536035135457e+00
+1.504727844526152269e+00
+1.502075816460282764e+00
+1.499353786112199938e+00
+1.496560050644478279e+00
+1.493692869111902022e+00
+1.490750461414289241e+00
+1.487731007195585153e+00
+1.484632644687273739e+00
+1.481453469494329767e+00
+1.478191533322356310e+00
+1.474844842644929432e+00
+1.471411357310709045e+00
+1.467888989090507357e+00
+1.464275600165254820e+00
+1.460569001556704993e+00
+1.456766951503738250e+00
+1.452867153788393706e+00
+1.448867256017116301e+00
+1.444764847864379975e+00
+1.440557459287684638e+00
+1.436242558725057350e+00
+1.431817551288568913e+00
+1.427279776970156844e+00
+1.422626508878954255e+00
+1.417854951532861563e+00
+1.412962239230732830e+00
+1.407945434535776918e+00
+1.402801526905276264e+00
+1.397527431506720097e+00
+1.392119988265803965e+00
+1.386575961197558327e+00
+1.380892038078046502e+00
+1.375064830520614345e+00
+1.369090874527588042e+00
+1.362966631595460276e+00
+1.356688490458970442e+00
+1.350252769566961053e+00
+1.343655720390415587e+00
+1.336893531670301005e+00
+1.329962334720043771e+00
+1.322858209903880589e+00
+1.315577194418255713e+00
+1.308115291508394673e+00
+1.300468481255867337e+00
+1.292632733075281148e+00
+1.284604020058779827e+00
+1.276378335305409673e+00
+1.267951710368524054e+00
+1.259320235947669175e+00
+1.250480084941708148e+00
+1.241427537966858008e+00
+1.232159011426533723e+00
+1.222671088199396072e+00
+1.212960550987022490e+00
+1.203024418333714207e+00
+1.192859983297273496e+00
+1.182464854711568147e+00
+1.171837000939148332e+00
+1.160974795965072692e+00
+1.149877067632099292e+00
+1.138543147761995611e+00
+1.126972923849197006e+00
+1.115166891951270056e+00
+1.103126210336656143e+00
+1.090852753384676799e+00
+1.078349165166946344e+00
+1.065618912074050462e+00
+1.052666333788784936e+00
+1.039496691848043053e+00
+1.026116214982785380e+00
+1.012532140380437706e+00
```

## PyMieSim/validation_data/PyMieScattQscaMedium.csv

 * *Ordering differences only*

```diff
@@ -1,800 +1,800 @@
-3.570765892677944226e-07
-3.686918173802286181e-07
-3.806847881797232348e-07
-3.930677821616326927e-07
-4.058534788559287667e-07
-4.190549697830214062e-07
-4.326857718296484998e-07
-4.467598410585660985e-07
-4.612915869659853369e-07
-4.762958872013159146e-07
-4.917881027641049631e-07
-5.077840936936866674e-07
-5.243002352674178391e-07
-5.413534347240247875e-07
-5.589611485289707578e-07
-5.771414001994369660e-07
-5.959127987069691994e-07
-6.152945574765361959e-07
-6.353065140012116770e-07
-6.559691500924143160e-07
-6.773036127862818748e-07
-6.993317359273697308e-07
-7.220760624514965394e-07
-7.455598673904992429e-07
-7.698071816220020488e-07
-7.948428163885375995e-07
-8.206923886105834410e-07
-8.473823470194087528e-07
-8.749399991360763935e-07
-9.033935391239431198e-07
-9.327720765429460221e-07
-9.631056660346050557e-07
-9.944253379680822841e-07
-1.026763130077977154e-06
-1.060152120126161946e-06
-1.094626459620492736e-06
-1.130221408624652008e-06
-1.166973371694188472e-06
-1.204919934975196435e-06
-1.244099904503054084e-06
-1.284553345739946180e-06
-1.326321624391151764e-06
-1.369447448541177533e-06
-1.413974912152533884e-06
-1.459949539970784476e-06
-1.507418333881329175e-06
-1.556429820764795581e-06
-1.607034101898986307e-06
-1.659282903957555568e-06
-1.713229631656584770e-06
-1.768929422102212438e-06
-1.826439200894056085e-06
-1.885817740040856623e-06
-1.947125717746868727e-06
-2.010425780128879638e-06
-2.075782604926172181e-06
-2.143262967267502222e-06
-2.212935807561106810e-06
-2.284872301576094352e-06
-2.359145932785647794e-06
-2.435832567044613347e-06
-2.515010529676587504e-06
-2.596760685047787339e-06
-2.681166518707721585e-06
-2.768314222178762022e-06
-2.858292780480038009e-06
-2.951194062472979031e-06
-3.047112914119421966e-06
-3.146147254745283468e-06
-3.248398176406743367e-06
-3.353970046457581562e-06
-3.462970613421214813e-06
-3.575511116272427387e-06
-3.691706397238801849e-06
-3.811675018233798963e-06
-3.935539381038615676e-06
-4.063425851351983477e-06
-4.195464886832007216e-06
-4.331791169258157237e-06
-4.472543740944505912e-06
-4.617866145540372910e-06
-4.767906573358640247e-06
-4.922818011376795741e-06
-5.082758398058877186e-06
-5.247890783153397983e-06
-5.418383492625526544e-06
-5.594410298887544040e-06
-5.776150596495985015e-06
-5.963789583491066065e-06
-6.157518448556797027e-06
-6.357534564188251516e-06
-6.564041686057111178e-06
-6.777250158772482334e-06
-6.997377128241220748e-06
-7.224646760836952028e-06
-7.459290469595037191e-06
-7.701547147656713862e-06
-7.951663409192373218e-06
-8.209893838042061793e-06
-8.476501244317912568e-06
-8.751756929221668246e-06
-9.035940958337540817e-06
-9.329342443669119282e-06
-9.632259834698120182e-06
-9.945001218749855020e-06
-1.026788463096151360e-05
-1.060123837415568964e-05
-1.094540134893379927e-05
-1.130072339431165647e-05
-1.166756563923172225e-05
-1.204630086529388172e-05
-1.243731388106058760e-05
-1.284100190830034020e-05
-1.325777498054779719e-05
-1.368805635436582012e-05
-1.413228293371462901e-05
-1.459090570783384971e-05
-1.506439020306992031e-05
-1.555321694908255096e-05
-1.605788195988422311e-05
-1.657889723017794733e-05
-1.711679124747469958e-05
-1.767210952048412886e-05
-1.824541512428966839e-05
-1.883728926283446240e-05
-1.944833184925758401e-05
-2.007916210464462397e-05
-2.073041917575925446e-05
-2.140276277236163345e-05
-2.209687382470929020e-05
-2.281345516188803491e-05
-2.355323221160539915e-05
-2.431695372212837030e-05
-2.510539250704471682e-05
-2.591934621356818715e-05
-2.675963811510548342e-05
-2.762711792885565062e-05
-2.852266265919888827e-05
-2.944717746769481053e-05
-3.040159657049490405e-05
-3.138688416403080900e-05
-3.240403537984836005e-05
-3.345407726948408021e-05
-3.453806982031822851e-05
-3.565710700334959551e-05
-3.681231785388412215e-05
-3.800486758614774380e-05
-3.923595874285672441e-05
-4.050683238083417582e-05
-4.181876929376342872e-05
-4.317309127322567334e-05
-4.457116240918582861e-05
-4.601439043113824930e-05
-4.750422809114715706e-05
-4.904217459006448106e-05
-5.062977704823442475e-05
-5.226863202204160366e-05
-5.396038706769026904e-05
-5.570674235365460697e-05
-5.750945232326234270e-05
-5.937032740893763758e-05
-6.129123579966220549e-05
-6.327410526325170567e-05
-6.532092502510666138e-05
-6.743374770513276993e-05
-6.961469131457106020e-05
-7.186594131454660450e-05
-7.418975273816432543e-05
-7.658845237806876738e-05
-7.906444104140259127e-05
-8.162019587418631761e-05
-8.425827275716416377e-05
-8.698130877525564843e-05
-8.979202476277368331e-05
-9.269322792665819408e-05
-9.568781455002531040e-05
-9.877877277838652444e-05
-1.019691854909849976e-04
-1.052622332597159008e-04
-1.086611973982162848e-04
-1.121694631037457163e-04
-1.157905226945556213e-04
-1.195279789455254551e-04
-1.233855485249071892e-04
-1.273670655351167777e-04
-1.314764851605421385e-04
-1.357178874254686286e-04
-1.400954810652839280e-04
-1.446136075141727902e-04
-1.492767450126532389e-04
-1.540895128383471956e-04
-1.590566756634867788e-04
-1.641831480427240046e-04
-1.694739990349393649e-04
-1.749344569627867181e-04
-1.805699143138540916e-04
-1.863859327873698451e-04
-1.923882484905173221e-04
-1.985827772884885825e-04
-2.049756203125325767e-04
-2.115730696303339171e-04
-2.183816140831641695e-04
-2.254079452943676630e-04
-2.326589638538148572e-04
-2.401417856831070379e-04
-2.478637485863675037e-04
-2.558324189916316455e-04
-2.640555988878769177e-04
-2.725413329629227548e-04
-2.812979159474812327e-04
-2.903339001707813801e-04
-2.996581033333005849e-04
-3.092796165022452821e-04
-3.192078123355135888e-04
-3.294523535400436381e-04
-3.400232015705096397e-04
-3.509306255744422940e-04
-3.621852115900299506e-04
-3.737978720028826475e-04
-3.857798552681965904e-04
-3.981427559048790932e-04
-4.108985247682969948e-04
-4.240594796083574369e-04
-4.376383159198770235e-04
-4.516481180921125011e-04
-4.661023708646476168e-04
-4.810149710966906225e-04
-4.964002398571409078e-04
-5.122729348427748370e-04
-5.286482631319859788e-04
-5.455418942815964478e-04
-5.629699737744773636e-04
-5.809491368254916755e-04
-5.994965225536842777e-04
-6.186297885284646261e-04
-6.383671256976718167e-04
-6.587272737054575061e-04
-6.797295366079580568e-04
-7.013937989947304288e-04
-7.237405425240045140e-04
-7.467908628797323986e-04
-7.705664871584796613e-04
-7.950897916941756204e-04
-8.203838203286696260e-04
-8.464723031360284547e-04
-8.733796756084743042e-04
-9.011310983117605360e-04
-9.297524770176280326e-04
-9.592704833210338256e-04
-9.897125757494492151e-04
-1.021107021371759011e-03
-1.053482917913624566e-03
-1.086870216386418963e-03
-1.121299744236295285e-03
-1.156803229019883654e-03
-1.193413322612725969e-03
-1.231163625956254023e-03
-1.270088714348724434e-03
-1.310224163285312162e-03
-1.351606574851797011e-03
-1.394273604676168638e-03
-1.438263989441730109e-03
-1.483617574964775235e-03
-1.530375344839345064e-03
-1.578579449650952633e-03
-1.628273236760223366e-03
-1.679501280657029862e-03
-1.732309413884462312e-03
-1.786744758531313548e-03
-1.842855758290864359e-03
-1.900692211082612160e-03
-1.960305302232282464e-03
-2.021747638204990979e-03
-2.085073280884241001e-03
-2.150337782388930547e-03
-2.217598220418594279e-03
-2.286913234115896167e-03
-2.358343060433675149e-03
-2.431949570991965171e-03
-2.507796309409232247e-03
-2.585948529089110871e-03
-2.666473231443176189e-03
-2.749439204526913424e-03
-2.834917062064843014e-03
-2.922979282837425818e-03
-3.013700250400929825e-03
-3.107156293107501618e-03
-3.203425724391322730e-03
-3.302588883282447582e-03
-3.404728175107966416e-03
-3.509928112336245607e-03
-3.618275355516706142e-03
-3.729858754264375742e-03
-3.844769388234576483e-03
-3.963100608028988052e-03
-4.084948075970583695e-03
-4.210409806681118632e-03
-4.339586207389423654e-03
-4.472580117895119320e-03
-4.609496850107731858e-03
-4.750444227075075257e-03
-4.895532621411415562e-03
-5.044874993029432528e-03
-5.198586926074902359e-03
-5.356786664957707486e-03
-5.519595149366850022e-03
-5.687136048151137345e-03
-5.859535791941373507e-03
-6.036923604383780464e-03
-6.219431531847395209e-03
-6.407194471463066240e-03
-6.600350197343703498e-03
-6.799039384829684389e-03
-7.003405632596952993e-03
-7.213595482457194584e-03
-7.429758436674924367e-03
-7.652046972617474428e-03
-7.880616554549151401e-03
-8.115625642372023205e-03
-8.357235697112908382e-03
-8.605611182945076612e-03
-8.860919565532539288e-03
-9.123331306473992167e-03
-9.393019853622765203e-03
-9.670161627050151421e-03
-9.954936000418029493e-03
-1.024752527752135871e-02
-1.054811466375824708e-02
-1.085689223228271383e-02
-1.117404888459432727e-02
-1.149977830531728924e-02
-1.183427691092315062e-02
-1.217774379215200674e-02
-1.253038064989164639e-02
-1.289239172427602068e-02
-1.326398371677487906e-02
-1.364536570505060081e-02
-1.403674905037027333e-02
-1.443834729737461173e-02
-1.485037606601775917e-02
-1.527305293551139455e-02
-1.570659732012654949e-02
-1.615123033672979588e-02
-1.660717466395865080e-02
-1.707465439296870086e-02
-1.755389486972385935e-02
-1.804512252883535423e-02
-1.854856471900106010e-02
-1.906444952014410901e-02
-1.959300555240223521e-02
-2.013446177717746408e-02
-2.068904729051955146e-02
-2.125699110918911547e-02
-2.183852194981858799e-02
-2.243386800167401079e-02
-2.304325669361228374e-02
-2.366691445591928566e-02
-2.430506647782787119e-02
-2.495793646161434051e-02
-2.562574637430476560e-02
-2.630871619813632267e-02
-2.700706368106898722e-02
-2.772100408877072042e-02
-2.845074995966832831e-02
-2.919651086479674307e-02
-2.995849317437007664e-02
-3.073689983314632779e-02
-3.153193014687244444e-02
-3.234377958225220784e-02
-3.317263958310916888e-02
-3.401869740558834121e-02
-3.488213597547862310e-02
-3.576313377091380752e-02
-3.666186473396385731e-02
-3.757849821480227503e-02
-3.851319895238986685e-02
-3.946612709579036538e-02
-4.043743827048086603e-02
-4.142728369418353929e-02
-4.243581034697888749e-02
-4.346316120060178534e-02
-4.450947551203175701e-02
-4.557488918659580862e-02
-4.665953521596822445e-02
-4.776354419651734212e-02
-4.888704493354948527e-02
-5.003016513701231960e-02
-5.119303221423161798e-02
-5.237577416518709311e-02
-5.357852058575112569e-02
-5.480140378412416691e-02
-5.604456001551373634e-02
-5.730813083976440264e-02
-5.859226460631371952e-02
-5.989711807035652535e-02
-6.122285814357886213e-02
-6.256966378214262603e-02
-6.393772801387356819e-02
-6.532726010571003605e-02
-6.673848787149019857e-02
-6.817166011902391076e-02
-6.962704923414583802e-02
-7.110495389802326538e-02
-7.260570193247979642e-02
-7.412965326634488039e-02
-7.567720301402010297e-02
-7.724878465540246930e-02
-7.884487330413764150e-02
-8.046598904881201164e-02
-8.211270034920589711e-02
-8.378562746703195618e-02
-8.548544590781356756e-02
-8.721288984753980400e-02
-8.896875551471360166e-02
-9.075390449515394198e-02
-9.256926692366741760e-02
-9.441584452332182908e-02
-9.629471344969812996e-02
-9.820702689407292962e-02
-1.001540173961957825e-01
-1.021369988140509305e-01
-1.041573678949375970e-01
-1.062166053893386086e-01
-1.083162766465163435e-01
-1.104580316285917463e-01
-1.126436042782185398e-01
-1.148748111738769895e-01
-1.171535494064434024e-01
-1.194817936111878948e-01
-1.218615920908011629e-01
-1.242950619676230772e-01
-1.267843833071377047e-01
-1.293317921600708187e-01
-1.319395724773427814e-01
-1.346100468607751011e-01
-1.373455661230292280e-01
-1.401484976428636897e-01
-1.430212125165994108e-01
-1.459660715237534323e-01
-1.489854099442081414e-01
-1.520815212860358867e-01
-1.552566400071931640e-01
-1.585129233405941640e-01
-1.618524323604004778e-01
-1.652771124574878014e-01
-1.687887734235566095e-01
-1.723890693757991199e-01
-1.760794787868293909e-01
-1.798612849169904382e-01
-1.837355569774041519e-01
-1.877031323811893804e-01
-1.917646004662052484e-01
-1.959202880942458869e-01
-2.001702475476733190e-01
-2.045142471537780005e-01
-2.089517650684585837e-01
-2.134819866429331636e-01
-2.181038057790349316e-01
-2.228158306492935836e-01
-2.276163941166554350e-01
-2.325035691349946199e-01
-2.374751893451829410e-01
-2.425288750028120610e-01
-2.476620642830688890e-01
-2.528720499069468386e-01
-2.581560209221573365e-01
-2.635111093537453875e-01
-2.689344413155736468e-01
-2.744231920470849850e-01
-2.799746442128478452e-01
-2.855862486781429732e-01
-2.912556868555293277e-01
-2.969809336076587591e-01
-3.027603195938740610e-01
-3.085925918648860788e-01
-3.144769714438924169e-01
-3.204132065862055900e-01
-3.264016203849784414e-01
-3.324431513899618884e-01
-3.385393859311912612e-01
-3.446925808917116751e-01
-3.509056757546219485e-01
-3.571822928613523906e-01
-3.635267249619421048e-01
-3.699439093155749148e-01
-3.764393878124913662e-01
-3.830192528378055794e-01
-3.896900788845091834e-01
-3.964588402472112305e-01
-4.033328154885916228e-01
-4.103194797643838765e-01
-4.174263865147704866e-01
-4.246610404725136845e-01
-4.320307643898212424e-01
-4.395425623321628228e-01
-4.472029828095949733e-01
-4.550179853925331863e-01
-4.629928147644681302e-01
-4.711318863717230410e-01
-4.794386879125004386e-01
-4.879157008378808835e-01
-4.965643457936437244e-01
-5.053849554972169589e-01
-5.143767779111094729e-01
-5.235380117456132076e-01
-5.328658753151424010e-01
-5.423567086126497294e-01
-5.520061071971908984e-01
-5.618090851620368698e-01
-5.717602631277671765e-01
-5.818540759489815306e-01
-5.920849937012635511e-01
-6.024477485849205616e-01
-6.129375596948181126e-01
-6.235503471982704049e-01
-6.342829273588428407e-01
-6.451331800538531169e-01
-6.561001809540284446e-01
-6.671842913573668987e-01
-6.783871997826184108e-01
-6.897119108190100656e-01
-7.011626783929364448e-01
-7.127448825413974509e-01
-7.244648509815372339e-01
-7.363296292203298510e-01
-7.483467056403915185e-01
-7.605237008698806367e-01
-7.728680337004657508e-01
-7.853865787037909163e-01
-7.980853332995996308e-01
-8.109691140733702452e-01
-8.240413033113044294e-01
-8.373036666818587381e-01
-8.507562614399732936e-01
-8.643974512339211991e-01
-8.782240384571731173e-01
-8.922315181950852825e-01
-9.064144494608962210e-01
-9.207669301115679605e-01
-9.352831522804757602e-01
-9.499580061921290008e-01
-9.647876927010542447e-01
-9.797702996341124404e-01
-9.949062946671013430e-01
-1.010198888455206223e+00
-1.025654226224238519e+00
-1.041281373914173303e+00
-1.057092075931971076e+00
-1.073100275146794846e+00
-1.089321401387079336e+00
-1.105771451759281598e+00
-1.122465903925782271e+00
-1.139418521258736661e+00
-1.156640125521464446e+00
-1.174137427103661313e+00
-1.191912013169393436e+00
-1.209959598359727995e+00
-1.228269638778155093e+00
-1.246825395938612191e+00
-1.265604511937316046e+00
-1.284580120328563613e+00
-1.303722470755028784e+00
-1.323000992928140773e+00
-1.342386672426875593e+00
-1.361854563427273623e+00
-1.381386228425779183e+00
-1.400971877738157456e+00
-1.420611985425198620e+00
-1.440318184052697958e+00
-1.460113286489675088e+00
-1.480030345005743930e+00
-1.500110731540760911e+00
-1.520401303524237413e+00
-1.540950802928418684e+00
-1.561805718661826825e+00
-1.583005919777082271e+00
-1.604580433332775780e+00
-1.626543787290882781e+00
-1.648893353707172826e+00
-1.671608097304982277e+00
-1.694649047776520145e+00
-1.717961665885044953e+00
-1.741480070050906770e+00
-1.765132852077178072e+00
-1.788849971421401674e+00
-1.812570017509450793e+00
-1.836247007510712459e+00
-1.859855869478276968e+00
-1.883395856273945235e+00
-1.906891333653909504e+00
-1.930389661604122731e+00
-1.953956210705525054e+00
-1.977666895020754545e+00
-2.001598932846923695e+00
-2.025820839499786086e+00
-2.050382877993427222e+00
-2.075309298552249881e+00
-2.100593633133133853e+00
-2.126198031271393951e+00
-2.152057116276485438e+00
-2.178086151017549543e+00
-2.204192540990362659e+00
-2.230289026938272912e+00
-2.256306490584665259e+00
-2.282204225622471938e+00
-2.307975837455515489e+00
-2.333649569672131552e+00
-2.359282700569297120e+00
-2.384950586976624987e+00
-2.410731848714782632e+00
-2.436691988998189728e+00
-2.462868318805234491e+00
-2.489259239349125075e+00
-2.515820555994050522e+00
-2.542470427995465521e+00
-2.569102859638813019e+00
-2.595607630978892022e+00
-2.621892791006542378e+00
-2.647904856946097674e+00
-2.673642014188089444e+00
-2.699156849550112369e+00
-2.724547127381506950e+00
-2.749935405230344632e+00
-2.775440569990124562e+00
-2.801146457673657775e+00
-2.827074325447030745e+00
-2.853166531270586059e+00
-2.879287597724390135e+00
-2.905245383942625104e+00
-2.930829727202904689e+00
-2.955860194319016809e+00
-2.980230748351117231e+00
-3.003938929993193785e+00
-3.027090746068578753e+00
-3.049878429970820370e+00
-3.072534646858942509e+00
-3.095272268597062393e+00
-3.118223113811751102e+00
-3.141391598481034109e+00
-3.164638670871848358e+00
-3.187705706182845322e+00
-3.210276667506162251e+00
-3.232062902593582532e+00
-3.252884750738114228e+00
-3.272723291669451307e+00
-3.291724728338210504e+00
-3.310154486586482481e+00
-3.328312411626754397e+00
-3.346431494001850027e+00
-3.364589874425541804e+00
-3.382667733003008159e+00
-3.400372232159038610e+00
-3.417331381508721400e+00
-3.433227225285006234e+00
-3.447916471672247685e+00
-3.461487971360194482e+00
-3.474231396445125242e+00
-3.486525245607465351e+00
-3.498680118551078522e+00
-3.510790690580075868e+00
-3.522656823671812987e+00
-3.533822947810583148e+00
-3.543743270149903424e+00
-3.552015398463445273e+00
-3.558575376224220044e+00
-3.563754664985416820e+00
-3.568163165366480705e+00
-3.572438667686841374e+00
-3.576955277400160949e+00
-3.581607385879937766e+00
-3.585782503337198168e+00
-3.588581540204792475e+00
-3.589222962739963219e+00
-3.587437468168658938e+00
-3.583635594814758907e+00
-3.578747316928363009e+00
-3.573797762541257583e+00
-3.569397537850320656e+00
-3.565377298320753230e+00
-3.560786256911488312e+00
-3.554339962837818057e+00
-3.545125842840719521e+00
-3.533148408184997979e+00
-3.519366831844166210e+00
-3.505194756349923502e+00
-3.491716082845330416e+00
-3.479001269269337726e+00
-3.465934905817787293e+00
-3.450799663010268414e+00
-3.432372672013904058e+00
-3.410796998452813256e+00
-3.387585627709125191e+00
-3.364742300796372376e+00
-3.343505422532984106e+00
-3.323410207792999227e+00
-3.302358038854613209e+00
-3.277936046306667794e+00
-3.249196437368799817e+00
-3.217487117901304483e+00
-3.185659256011956320e+00
-3.156193655399508025e+00
-3.129381426170553038e+00
-3.102815922726287479e+00
-3.072983681710914183e+00
-3.038046281986985342e+00
-2.999431859142064116e+00
-2.960869243968534015e+00
-2.925662996466577237e+00
-2.894032651665287226e+00
-2.862567450660542523e+00
-2.826935252148275346e+00
-2.785823734101186222e+00
-2.742250780104197538e+00
-2.701131191121147967e+00
-2.665167764695868247e+00
-2.632096696537235214e+00
-2.596275785540487213e+00
-2.554182997144871514e+00
-2.508131798989799766e+00
-2.464304380667762029e+00
-2.427222790574699918e+00
-2.395066759356875075e+00
-2.360679895489033786e+00
-2.319017127883551854e+00
-2.272806435062084240e+00
-2.229952957258616753e+00
-2.195889673311775425e+00
-2.167424059569849959e+00
-2.135287506163613624e+00
-2.094943422742714390e+00
-2.052015833076830997e+00
-2.016179780902805252e+00
-1.990692678375093116e+00
-1.967450040533893052e+00
-1.936313761093351404e+00
-1.898488505469387633e+00
-1.865053679194754510e+00
-1.844170205989080547e+00
-1.830139519985589214e+00
-1.809083209061148390e+00
-1.778416110378959747e+00
-1.750493343507240285e+00
-1.737225929627545851e+00
-1.733935839638888421e+00
-1.723213036207195126e+00
-1.700737891262270596e+00
-1.681507867473235329e+00
-1.679658933621461792e+00
-1.687870517072945331e+00
-1.685207339683536976e+00
-1.670769059668138823e+00
-1.664589993588089012e+00
-1.678936584835657886e+00
-1.697108693794855849e+00
-1.697858325911367317e+00
-1.692225063823806330e+00
-1.705188267751498010e+00
-1.737189335076409824e+00
-1.757665719502260693e+00
-1.758912048464211342e+00
-1.769202840404282107e+00
-1.806789762633174146e+00
-1.844967220689669896e+00
-1.857135169556884513e+00
-1.867294552619461756e+00
-1.906487585603585000e+00
-1.956536431114944907e+00
-1.977846351225076349e+00
-1.989429707338134179e+00
-2.030755904068779039e+00
-2.088130080647031761e+00
-2.112987602199628334e+00
-2.124832035947302078e+00
-2.169837351452935881e+00
-2.230292047272674605e+00
-2.251698576675351227e+00
-2.263181267231351157e+00
-2.314017609903629591e+00
-2.369759607084989117e+00
-2.380150665271685728e+00
-2.394228531034656715e+00
-2.452378865843900968e+00
-2.489939505342363635e+00
-2.485948188056415820e+00
-2.510796342524031388e+00
-2.568027020948107086e+00
-2.572865490611247807e+00
-2.563667198114298440e+00
-2.607292235413114057e+00
-2.634936833658913180e+00
-2.609280777377994021e+00
-2.619137503452598548e+00
-2.660462574490833010e+00
-2.634390305332296123e+00
-2.612054497817455800e+00
-2.649431580718035750e+00
-2.630865617440476978e+00
-2.584101817952646041e+00
-2.606122286892166517e+00
-2.596557113770593617e+00
+3.570765892677944226e-07
+3.686918173802286181e-07
+3.806847881797232348e-07
+3.930677821616326927e-07
+4.058534788559287667e-07
+4.190549697830214062e-07
+4.326857718296484998e-07
+4.467598410585660985e-07
+4.612915869659853369e-07
+4.762958872013159146e-07
+4.917881027641049631e-07
+5.077840936936866674e-07
+5.243002352674178391e-07
+5.413534347240247875e-07
+5.589611485289707578e-07
+5.771414001994369660e-07
+5.959127987069691994e-07
+6.152945574765361959e-07
+6.353065140012116770e-07
+6.559691500924143160e-07
+6.773036127862818748e-07
+6.993317359273697308e-07
+7.220760624514965394e-07
+7.455598673904992429e-07
+7.698071816220020488e-07
+7.948428163885375995e-07
+8.206923886105834410e-07
+8.473823470194087528e-07
+8.749399991360763935e-07
+9.033935391239431198e-07
+9.327720765429460221e-07
+9.631056660346050557e-07
+9.944253379680822841e-07
+1.026763130077977154e-06
+1.060152120126161946e-06
+1.094626459620492736e-06
+1.130221408624652008e-06
+1.166973371694188472e-06
+1.204919934975196435e-06
+1.244099904503054084e-06
+1.284553345739946180e-06
+1.326321624391151764e-06
+1.369447448541177533e-06
+1.413974912152533884e-06
+1.459949539970784476e-06
+1.507418333881329175e-06
+1.556429820764795581e-06
+1.607034101898986307e-06
+1.659282903957555568e-06
+1.713229631656584770e-06
+1.768929422102212438e-06
+1.826439200894056085e-06
+1.885817740040856623e-06
+1.947125717746868727e-06
+2.010425780128879638e-06
+2.075782604926172181e-06
+2.143262967267502222e-06
+2.212935807561106810e-06
+2.284872301576094352e-06
+2.359145932785647794e-06
+2.435832567044613347e-06
+2.515010529676587504e-06
+2.596760685047787339e-06
+2.681166518707721585e-06
+2.768314222178762022e-06
+2.858292780480038009e-06
+2.951194062472979031e-06
+3.047112914119421966e-06
+3.146147254745283468e-06
+3.248398176406743367e-06
+3.353970046457581562e-06
+3.462970613421214813e-06
+3.575511116272427387e-06
+3.691706397238801849e-06
+3.811675018233798963e-06
+3.935539381038615676e-06
+4.063425851351983477e-06
+4.195464886832007216e-06
+4.331791169258157237e-06
+4.472543740944505912e-06
+4.617866145540372910e-06
+4.767906573358640247e-06
+4.922818011376795741e-06
+5.082758398058877186e-06
+5.247890783153397983e-06
+5.418383492625526544e-06
+5.594410298887544040e-06
+5.776150596495985015e-06
+5.963789583491066065e-06
+6.157518448556797027e-06
+6.357534564188251516e-06
+6.564041686057111178e-06
+6.777250158772482334e-06
+6.997377128241220748e-06
+7.224646760836952028e-06
+7.459290469595037191e-06
+7.701547147656713862e-06
+7.951663409192373218e-06
+8.209893838042061793e-06
+8.476501244317912568e-06
+8.751756929221668246e-06
+9.035940958337540817e-06
+9.329342443669119282e-06
+9.632259834698120182e-06
+9.945001218749855020e-06
+1.026788463096151360e-05
+1.060123837415568964e-05
+1.094540134893379927e-05
+1.130072339431165647e-05
+1.166756563923172225e-05
+1.204630086529388172e-05
+1.243731388106058760e-05
+1.284100190830034020e-05
+1.325777498054779719e-05
+1.368805635436582012e-05
+1.413228293371462901e-05
+1.459090570783384971e-05
+1.506439020306992031e-05
+1.555321694908255096e-05
+1.605788195988422311e-05
+1.657889723017794733e-05
+1.711679124747469958e-05
+1.767210952048412886e-05
+1.824541512428966839e-05
+1.883728926283446240e-05
+1.944833184925758401e-05
+2.007916210464462397e-05
+2.073041917575925446e-05
+2.140276277236163345e-05
+2.209687382470929020e-05
+2.281345516188803491e-05
+2.355323221160539915e-05
+2.431695372212837030e-05
+2.510539250704471682e-05
+2.591934621356818715e-05
+2.675963811510548342e-05
+2.762711792885565062e-05
+2.852266265919888827e-05
+2.944717746769481053e-05
+3.040159657049490405e-05
+3.138688416403080900e-05
+3.240403537984836005e-05
+3.345407726948408021e-05
+3.453806982031822851e-05
+3.565710700334959551e-05
+3.681231785388412215e-05
+3.800486758614774380e-05
+3.923595874285672441e-05
+4.050683238083417582e-05
+4.181876929376342872e-05
+4.317309127322567334e-05
+4.457116240918582861e-05
+4.601439043113824930e-05
+4.750422809114715706e-05
+4.904217459006448106e-05
+5.062977704823442475e-05
+5.226863202204160366e-05
+5.396038706769026904e-05
+5.570674235365460697e-05
+5.750945232326234270e-05
+5.937032740893763758e-05
+6.129123579966220549e-05
+6.327410526325170567e-05
+6.532092502510666138e-05
+6.743374770513276993e-05
+6.961469131457106020e-05
+7.186594131454660450e-05
+7.418975273816432543e-05
+7.658845237806876738e-05
+7.906444104140259127e-05
+8.162019587418631761e-05
+8.425827275716416377e-05
+8.698130877525564843e-05
+8.979202476277368331e-05
+9.269322792665819408e-05
+9.568781455002531040e-05
+9.877877277838652444e-05
+1.019691854909849976e-04
+1.052622332597159008e-04
+1.086611973982162848e-04
+1.121694631037457163e-04
+1.157905226945556213e-04
+1.195279789455254551e-04
+1.233855485249071892e-04
+1.273670655351167777e-04
+1.314764851605421385e-04
+1.357178874254686286e-04
+1.400954810652839280e-04
+1.446136075141727902e-04
+1.492767450126532389e-04
+1.540895128383471956e-04
+1.590566756634867788e-04
+1.641831480427240046e-04
+1.694739990349393649e-04
+1.749344569627867181e-04
+1.805699143138540916e-04
+1.863859327873698451e-04
+1.923882484905173221e-04
+1.985827772884885825e-04
+2.049756203125325767e-04
+2.115730696303339171e-04
+2.183816140831641695e-04
+2.254079452943676630e-04
+2.326589638538148572e-04
+2.401417856831070379e-04
+2.478637485863675037e-04
+2.558324189916316455e-04
+2.640555988878769177e-04
+2.725413329629227548e-04
+2.812979159474812327e-04
+2.903339001707813801e-04
+2.996581033333005849e-04
+3.092796165022452821e-04
+3.192078123355135888e-04
+3.294523535400436381e-04
+3.400232015705096397e-04
+3.509306255744422940e-04
+3.621852115900299506e-04
+3.737978720028826475e-04
+3.857798552681965904e-04
+3.981427559048790932e-04
+4.108985247682969948e-04
+4.240594796083574369e-04
+4.376383159198770235e-04
+4.516481180921125011e-04
+4.661023708646476168e-04
+4.810149710966906225e-04
+4.964002398571409078e-04
+5.122729348427748370e-04
+5.286482631319859788e-04
+5.455418942815964478e-04
+5.629699737744773636e-04
+5.809491368254916755e-04
+5.994965225536842777e-04
+6.186297885284646261e-04
+6.383671256976718167e-04
+6.587272737054575061e-04
+6.797295366079580568e-04
+7.013937989947304288e-04
+7.237405425240045140e-04
+7.467908628797323986e-04
+7.705664871584796613e-04
+7.950897916941756204e-04
+8.203838203286696260e-04
+8.464723031360284547e-04
+8.733796756084743042e-04
+9.011310983117605360e-04
+9.297524770176280326e-04
+9.592704833210338256e-04
+9.897125757494492151e-04
+1.021107021371759011e-03
+1.053482917913624566e-03
+1.086870216386418963e-03
+1.121299744236295285e-03
+1.156803229019883654e-03
+1.193413322612725969e-03
+1.231163625956254023e-03
+1.270088714348724434e-03
+1.310224163285312162e-03
+1.351606574851797011e-03
+1.394273604676168638e-03
+1.438263989441730109e-03
+1.483617574964775235e-03
+1.530375344839345064e-03
+1.578579449650952633e-03
+1.628273236760223366e-03
+1.679501280657029862e-03
+1.732309413884462312e-03
+1.786744758531313548e-03
+1.842855758290864359e-03
+1.900692211082612160e-03
+1.960305302232282464e-03
+2.021747638204990979e-03
+2.085073280884241001e-03
+2.150337782388930547e-03
+2.217598220418594279e-03
+2.286913234115896167e-03
+2.358343060433675149e-03
+2.431949570991965171e-03
+2.507796309409232247e-03
+2.585948529089110871e-03
+2.666473231443176189e-03
+2.749439204526913424e-03
+2.834917062064843014e-03
+2.922979282837425818e-03
+3.013700250400929825e-03
+3.107156293107501618e-03
+3.203425724391322730e-03
+3.302588883282447582e-03
+3.404728175107966416e-03
+3.509928112336245607e-03
+3.618275355516706142e-03
+3.729858754264375742e-03
+3.844769388234576483e-03
+3.963100608028988052e-03
+4.084948075970583695e-03
+4.210409806681118632e-03
+4.339586207389423654e-03
+4.472580117895119320e-03
+4.609496850107731858e-03
+4.750444227075075257e-03
+4.895532621411415562e-03
+5.044874993029432528e-03
+5.198586926074902359e-03
+5.356786664957707486e-03
+5.519595149366850022e-03
+5.687136048151137345e-03
+5.859535791941373507e-03
+6.036923604383780464e-03
+6.219431531847395209e-03
+6.407194471463066240e-03
+6.600350197343703498e-03
+6.799039384829684389e-03
+7.003405632596952993e-03
+7.213595482457194584e-03
+7.429758436674924367e-03
+7.652046972617474428e-03
+7.880616554549151401e-03
+8.115625642372023205e-03
+8.357235697112908382e-03
+8.605611182945076612e-03
+8.860919565532539288e-03
+9.123331306473992167e-03
+9.393019853622765203e-03
+9.670161627050151421e-03
+9.954936000418029493e-03
+1.024752527752135871e-02
+1.054811466375824708e-02
+1.085689223228271383e-02
+1.117404888459432727e-02
+1.149977830531728924e-02
+1.183427691092315062e-02
+1.217774379215200674e-02
+1.253038064989164639e-02
+1.289239172427602068e-02
+1.326398371677487906e-02
+1.364536570505060081e-02
+1.403674905037027333e-02
+1.443834729737461173e-02
+1.485037606601775917e-02
+1.527305293551139455e-02
+1.570659732012654949e-02
+1.615123033672979588e-02
+1.660717466395865080e-02
+1.707465439296870086e-02
+1.755389486972385935e-02
+1.804512252883535423e-02
+1.854856471900106010e-02
+1.906444952014410901e-02
+1.959300555240223521e-02
+2.013446177717746408e-02
+2.068904729051955146e-02
+2.125699110918911547e-02
+2.183852194981858799e-02
+2.243386800167401079e-02
+2.304325669361228374e-02
+2.366691445591928566e-02
+2.430506647782787119e-02
+2.495793646161434051e-02
+2.562574637430476560e-02
+2.630871619813632267e-02
+2.700706368106898722e-02
+2.772100408877072042e-02
+2.845074995966832831e-02
+2.919651086479674307e-02
+2.995849317437007664e-02
+3.073689983314632779e-02
+3.153193014687244444e-02
+3.234377958225220784e-02
+3.317263958310916888e-02
+3.401869740558834121e-02
+3.488213597547862310e-02
+3.576313377091380752e-02
+3.666186473396385731e-02
+3.757849821480227503e-02
+3.851319895238986685e-02
+3.946612709579036538e-02
+4.043743827048086603e-02
+4.142728369418353929e-02
+4.243581034697888749e-02
+4.346316120060178534e-02
+4.450947551203175701e-02
+4.557488918659580862e-02
+4.665953521596822445e-02
+4.776354419651734212e-02
+4.888704493354948527e-02
+5.003016513701231960e-02
+5.119303221423161798e-02
+5.237577416518709311e-02
+5.357852058575112569e-02
+5.480140378412416691e-02
+5.604456001551373634e-02
+5.730813083976440264e-02
+5.859226460631371952e-02
+5.989711807035652535e-02
+6.122285814357886213e-02
+6.256966378214262603e-02
+6.393772801387356819e-02
+6.532726010571003605e-02
+6.673848787149019857e-02
+6.817166011902391076e-02
+6.962704923414583802e-02
+7.110495389802326538e-02
+7.260570193247979642e-02
+7.412965326634488039e-02
+7.567720301402010297e-02
+7.724878465540246930e-02
+7.884487330413764150e-02
+8.046598904881201164e-02
+8.211270034920589711e-02
+8.378562746703195618e-02
+8.548544590781356756e-02
+8.721288984753980400e-02
+8.896875551471360166e-02
+9.075390449515394198e-02
+9.256926692366741760e-02
+9.441584452332182908e-02
+9.629471344969812996e-02
+9.820702689407292962e-02
+1.001540173961957825e-01
+1.021369988140509305e-01
+1.041573678949375970e-01
+1.062166053893386086e-01
+1.083162766465163435e-01
+1.104580316285917463e-01
+1.126436042782185398e-01
+1.148748111738769895e-01
+1.171535494064434024e-01
+1.194817936111878948e-01
+1.218615920908011629e-01
+1.242950619676230772e-01
+1.267843833071377047e-01
+1.293317921600708187e-01
+1.319395724773427814e-01
+1.346100468607751011e-01
+1.373455661230292280e-01
+1.401484976428636897e-01
+1.430212125165994108e-01
+1.459660715237534323e-01
+1.489854099442081414e-01
+1.520815212860358867e-01
+1.552566400071931640e-01
+1.585129233405941640e-01
+1.618524323604004778e-01
+1.652771124574878014e-01
+1.687887734235566095e-01
+1.723890693757991199e-01
+1.760794787868293909e-01
+1.798612849169904382e-01
+1.837355569774041519e-01
+1.877031323811893804e-01
+1.917646004662052484e-01
+1.959202880942458869e-01
+2.001702475476733190e-01
+2.045142471537780005e-01
+2.089517650684585837e-01
+2.134819866429331636e-01
+2.181038057790349316e-01
+2.228158306492935836e-01
+2.276163941166554350e-01
+2.325035691349946199e-01
+2.374751893451829410e-01
+2.425288750028120610e-01
+2.476620642830688890e-01
+2.528720499069468386e-01
+2.581560209221573365e-01
+2.635111093537453875e-01
+2.689344413155736468e-01
+2.744231920470849850e-01
+2.799746442128478452e-01
+2.855862486781429732e-01
+2.912556868555293277e-01
+2.969809336076587591e-01
+3.027603195938740610e-01
+3.085925918648860788e-01
+3.144769714438924169e-01
+3.204132065862055900e-01
+3.264016203849784414e-01
+3.324431513899618884e-01
+3.385393859311912612e-01
+3.446925808917116751e-01
+3.509056757546219485e-01
+3.571822928613523906e-01
+3.635267249619421048e-01
+3.699439093155749148e-01
+3.764393878124913662e-01
+3.830192528378055794e-01
+3.896900788845091834e-01
+3.964588402472112305e-01
+4.033328154885916228e-01
+4.103194797643838765e-01
+4.174263865147704866e-01
+4.246610404725136845e-01
+4.320307643898212424e-01
+4.395425623321628228e-01
+4.472029828095949733e-01
+4.550179853925331863e-01
+4.629928147644681302e-01
+4.711318863717230410e-01
+4.794386879125004386e-01
+4.879157008378808835e-01
+4.965643457936437244e-01
+5.053849554972169589e-01
+5.143767779111094729e-01
+5.235380117456132076e-01
+5.328658753151424010e-01
+5.423567086126497294e-01
+5.520061071971908984e-01
+5.618090851620368698e-01
+5.717602631277671765e-01
+5.818540759489815306e-01
+5.920849937012635511e-01
+6.024477485849205616e-01
+6.129375596948181126e-01
+6.235503471982704049e-01
+6.342829273588428407e-01
+6.451331800538531169e-01
+6.561001809540284446e-01
+6.671842913573668987e-01
+6.783871997826184108e-01
+6.897119108190100656e-01
+7.011626783929364448e-01
+7.127448825413974509e-01
+7.244648509815372339e-01
+7.363296292203298510e-01
+7.483467056403915185e-01
+7.605237008698806367e-01
+7.728680337004657508e-01
+7.853865787037909163e-01
+7.980853332995996308e-01
+8.109691140733702452e-01
+8.240413033113044294e-01
+8.373036666818587381e-01
+8.507562614399732936e-01
+8.643974512339211991e-01
+8.782240384571731173e-01
+8.922315181950852825e-01
+9.064144494608962210e-01
+9.207669301115679605e-01
+9.352831522804757602e-01
+9.499580061921290008e-01
+9.647876927010542447e-01
+9.797702996341124404e-01
+9.949062946671013430e-01
+1.010198888455206223e+00
+1.025654226224238519e+00
+1.041281373914173303e+00
+1.057092075931971076e+00
+1.073100275146794846e+00
+1.089321401387079336e+00
+1.105771451759281598e+00
+1.122465903925782271e+00
+1.139418521258736661e+00
+1.156640125521464446e+00
+1.174137427103661313e+00
+1.191912013169393436e+00
+1.209959598359727995e+00
+1.228269638778155093e+00
+1.246825395938612191e+00
+1.265604511937316046e+00
+1.284580120328563613e+00
+1.303722470755028784e+00
+1.323000992928140773e+00
+1.342386672426875593e+00
+1.361854563427273623e+00
+1.381386228425779183e+00
+1.400971877738157456e+00
+1.420611985425198620e+00
+1.440318184052697958e+00
+1.460113286489675088e+00
+1.480030345005743930e+00
+1.500110731540760911e+00
+1.520401303524237413e+00
+1.540950802928418684e+00
+1.561805718661826825e+00
+1.583005919777082271e+00
+1.604580433332775780e+00
+1.626543787290882781e+00
+1.648893353707172826e+00
+1.671608097304982277e+00
+1.694649047776520145e+00
+1.717961665885044953e+00
+1.741480070050906770e+00
+1.765132852077178072e+00
+1.788849971421401674e+00
+1.812570017509450793e+00
+1.836247007510712459e+00
+1.859855869478276968e+00
+1.883395856273945235e+00
+1.906891333653909504e+00
+1.930389661604122731e+00
+1.953956210705525054e+00
+1.977666895020754545e+00
+2.001598932846923695e+00
+2.025820839499786086e+00
+2.050382877993427222e+00
+2.075309298552249881e+00
+2.100593633133133853e+00
+2.126198031271393951e+00
+2.152057116276485438e+00
+2.178086151017549543e+00
+2.204192540990362659e+00
+2.230289026938272912e+00
+2.256306490584665259e+00
+2.282204225622471938e+00
+2.307975837455515489e+00
+2.333649569672131552e+00
+2.359282700569297120e+00
+2.384950586976624987e+00
+2.410731848714782632e+00
+2.436691988998189728e+00
+2.462868318805234491e+00
+2.489259239349125075e+00
+2.515820555994050522e+00
+2.542470427995465521e+00
+2.569102859638813019e+00
+2.595607630978892022e+00
+2.621892791006542378e+00
+2.647904856946097674e+00
+2.673642014188089444e+00
+2.699156849550112369e+00
+2.724547127381506950e+00
+2.749935405230344632e+00
+2.775440569990124562e+00
+2.801146457673657775e+00
+2.827074325447030745e+00
+2.853166531270586059e+00
+2.879287597724390135e+00
+2.905245383942625104e+00
+2.930829727202904689e+00
+2.955860194319016809e+00
+2.980230748351117231e+00
+3.003938929993193785e+00
+3.027090746068578753e+00
+3.049878429970820370e+00
+3.072534646858942509e+00
+3.095272268597062393e+00
+3.118223113811751102e+00
+3.141391598481034109e+00
+3.164638670871848358e+00
+3.187705706182845322e+00
+3.210276667506162251e+00
+3.232062902593582532e+00
+3.252884750738114228e+00
+3.272723291669451307e+00
+3.291724728338210504e+00
+3.310154486586482481e+00
+3.328312411626754397e+00
+3.346431494001850027e+00
+3.364589874425541804e+00
+3.382667733003008159e+00
+3.400372232159038610e+00
+3.417331381508721400e+00
+3.433227225285006234e+00
+3.447916471672247685e+00
+3.461487971360194482e+00
+3.474231396445125242e+00
+3.486525245607465351e+00
+3.498680118551078522e+00
+3.510790690580075868e+00
+3.522656823671812987e+00
+3.533822947810583148e+00
+3.543743270149903424e+00
+3.552015398463445273e+00
+3.558575376224220044e+00
+3.563754664985416820e+00
+3.568163165366480705e+00
+3.572438667686841374e+00
+3.576955277400160949e+00
+3.581607385879937766e+00
+3.585782503337198168e+00
+3.588581540204792475e+00
+3.589222962739963219e+00
+3.587437468168658938e+00
+3.583635594814758907e+00
+3.578747316928363009e+00
+3.573797762541257583e+00
+3.569397537850320656e+00
+3.565377298320753230e+00
+3.560786256911488312e+00
+3.554339962837818057e+00
+3.545125842840719521e+00
+3.533148408184997979e+00
+3.519366831844166210e+00
+3.505194756349923502e+00
+3.491716082845330416e+00
+3.479001269269337726e+00
+3.465934905817787293e+00
+3.450799663010268414e+00
+3.432372672013904058e+00
+3.410796998452813256e+00
+3.387585627709125191e+00
+3.364742300796372376e+00
+3.343505422532984106e+00
+3.323410207792999227e+00
+3.302358038854613209e+00
+3.277936046306667794e+00
+3.249196437368799817e+00
+3.217487117901304483e+00
+3.185659256011956320e+00
+3.156193655399508025e+00
+3.129381426170553038e+00
+3.102815922726287479e+00
+3.072983681710914183e+00
+3.038046281986985342e+00
+2.999431859142064116e+00
+2.960869243968534015e+00
+2.925662996466577237e+00
+2.894032651665287226e+00
+2.862567450660542523e+00
+2.826935252148275346e+00
+2.785823734101186222e+00
+2.742250780104197538e+00
+2.701131191121147967e+00
+2.665167764695868247e+00
+2.632096696537235214e+00
+2.596275785540487213e+00
+2.554182997144871514e+00
+2.508131798989799766e+00
+2.464304380667762029e+00
+2.427222790574699918e+00
+2.395066759356875075e+00
+2.360679895489033786e+00
+2.319017127883551854e+00
+2.272806435062084240e+00
+2.229952957258616753e+00
+2.195889673311775425e+00
+2.167424059569849959e+00
+2.135287506163613624e+00
+2.094943422742714390e+00
+2.052015833076830997e+00
+2.016179780902805252e+00
+1.990692678375093116e+00
+1.967450040533893052e+00
+1.936313761093351404e+00
+1.898488505469387633e+00
+1.865053679194754510e+00
+1.844170205989080547e+00
+1.830139519985589214e+00
+1.809083209061148390e+00
+1.778416110378959747e+00
+1.750493343507240285e+00
+1.737225929627545851e+00
+1.733935839638888421e+00
+1.723213036207195126e+00
+1.700737891262270596e+00
+1.681507867473235329e+00
+1.679658933621461792e+00
+1.687870517072945331e+00
+1.685207339683536976e+00
+1.670769059668138823e+00
+1.664589993588089012e+00
+1.678936584835657886e+00
+1.697108693794855849e+00
+1.697858325911367317e+00
+1.692225063823806330e+00
+1.705188267751498010e+00
+1.737189335076409824e+00
+1.757665719502260693e+00
+1.758912048464211342e+00
+1.769202840404282107e+00
+1.806789762633174146e+00
+1.844967220689669896e+00
+1.857135169556884513e+00
+1.867294552619461756e+00
+1.906487585603585000e+00
+1.956536431114944907e+00
+1.977846351225076349e+00
+1.989429707338134179e+00
+2.030755904068779039e+00
+2.088130080647031761e+00
+2.112987602199628334e+00
+2.124832035947302078e+00
+2.169837351452935881e+00
+2.230292047272674605e+00
+2.251698576675351227e+00
+2.263181267231351157e+00
+2.314017609903629591e+00
+2.369759607084989117e+00
+2.380150665271685728e+00
+2.394228531034656715e+00
+2.452378865843900968e+00
+2.489939505342363635e+00
+2.485948188056415820e+00
+2.510796342524031388e+00
+2.568027020948107086e+00
+2.572865490611247807e+00
+2.563667198114298440e+00
+2.607292235413114057e+00
+2.634936833658913180e+00
+2.609280777377994021e+00
+2.619137503452598548e+00
+2.660462574490833010e+00
+2.634390305332296123e+00
+2.612054497817455800e+00
+2.649431580718035750e+00
+2.630865617440476978e+00
+2.584101817952646041e+00
+2.606122286892166517e+00
+2.596557113770593617e+00
```

## development/debugging.py

```diff
@@ -1,41 +1,9 @@
-import numpy as np
-from PyMieSim.experiment import Sphere, Gaussian, Photodiode, Setup
-from PyMieSim import measure
-
-source = Gaussian(
-    wavelength=400e-9,
-    polarization_value=0,
-    polarization_type='linear',
-    optical_power=1e-3,
-    NA=0.3
-)
-
-scatterer_set = Sphere(
-    diameter=800e-9,
-    index=1.44,
-    medium_index=1,
-    source=source
-)
-
-detector_set = Photodiode(
-    NA=[0.1, 0.2],
-    phi_offset=np.linspace(-180, 180, 200),
-    gamma_offset=0,
-    sampling=[100, 300],
-    polarization_filter=None
-)
-
-setup = Setup(
-    source=source,
-    scatterer=scatterer_set,
-    detector=detector_set
-)
-
-data_set = setup.get(measure.coupling)
-
-figure = data_set.plot(
-    x=setup.phi_offset,
-)
-
-
-_ = figure.show()
+from pydantic.dataclasses import dataclass
+from typing import List
+
+import numpy
+
+
+@dataclass
+class ComplexNumbersDataClass:
+    numbers: List[int]
```

## development/fcm.py

 * *Ordering differences only*

```diff
@@ -1,48 +1,48 @@
-import numpy
-from PyMieSim.experiment.detector import CoherentMode
-from PyMieSim.experiment.scatterer import Sphere
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-from PyOptik import UsualMaterial
-from PyMieSim import measure
-
-source_set = Gaussian(
-    wavelength=600e-9,
-    polarization_value=0,
-    polarization_type='linear',
-    optical_power=1e-3,
-    NA=0.2
-)
-
-scatterer_set = Sphere(
-    diameter=3e-6,
-    index=1.5,
-    medium_material=UsualMaterial.Water,
-    source_set=source_set
-)
-
-detector_set = CoherentMode(
-    mode_number='LP11',
-    NA=[0.1],
-    phi_offset=0,
-    gamma_offset=0,
-    sampling=800,
-    rotation=numpy.linspace(0, 180, 100),
-    polarization_filter=None
-)
-
-experiment = Setup(
-    scatterer_set=scatterer_set,
-    source_set=source_set,
-    detector_set=detector_set
-)
-
-data = experiment.get(measure.coupling)
-
-figure = data.plot(
-    x=experiment.rotation,
-    # y_scale='log',
-    # std=experiment.index
-)
-
-_ = figure.show()
+import numpy
+from PyMieSim.experiment.detector import CoherentMode
+from PyMieSim.experiment.scatterer import Sphere
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+from PyOptik import UsualMaterial
+from PyMieSim import measure
+
+source_set = Gaussian(
+    wavelength=600e-9,
+    polarization_value=0,
+    polarization_type='linear',
+    optical_power=1e-3,
+    NA=0.2
+)
+
+scatterer_set = Sphere(
+    diameter=3e-6,
+    index=1.5,
+    medium_material=UsualMaterial.Water,
+    source_set=source_set
+)
+
+detector_set = CoherentMode(
+    mode_number='LP11',
+    NA=[0.1],
+    phi_offset=0,
+    gamma_offset=0,
+    sampling=800,
+    rotation=numpy.linspace(0, 180, 100),
+    polarization_filter=None
+)
+
+experiment = Setup(
+    scatterer_set=scatterer_set,
+    source_set=source_set,
+    detector_set=detector_set
+)
+
+data = experiment.get(measure.coupling)
+
+figure = data.plot(
+    x=experiment.rotation,
+    # y_scale='log',
+    # std=experiment.index
+)
+
+_ = figure.show()
```

## development/gui.py

 * *Ordering differences only*

```diff
@@ -1,363 +1,363 @@
-
-from typing import NoReturn
-import tkinter as tk
-from tkinter import ttk, filedialog, messagebox
-import numpy as np
-from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
-# Assuming PyMieSim and its dependencies are installed
-from PyMieSim.experiment.scatterer import Cylinder
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment.detector import Photodiode
-from PyMieSim.experiment import Setup
-from PyMieSim import measure
-
-
-class PyMieSimGUI:
-    """
-    Graphical User Interface for computing and visualizing the B1 scattering coefficient
-    for cylindrical scatterers using PyMieSim.
-
-    Attributes:
-        master (tk.Tk): The main tkinter window.
-    """
-
-    def __init__(self, master: tk.Tk):
-        """
-        Initializes the GUI, setting up variables, plot frame, notebook, and controls.
-
-        Parameters:
-            master (tk.Tk): The root window of the application.
-        """
-        self.master = master
-        self.master.title("PyMieSim Graphic Interface")
-        self.customize_notebook_style()
-        self.setup_variables()
-        self.setup_plot_frame()
-        self.setup_notebook()
-        self.setup_controls()  # Setup controls outside of the tabs
-
-    def customize_notebook_style(self) -> NoReturn:
-        """
-        Customizes the ttk Notebook style for a unique appearance of tabs, making them larger.
-        """
-        style = ttk.Style()
-        style.configure("TNotebook", background="#f0f0f0")
-
-        style.configure(
-            "TNotebook.Tab",
-            background="#d0d0d0",
-            padding=[10, 20, 10, 20],  # Increase padding for larger tabs
-            font=('Helvetica', 12)     # Larger font for tabs
-        )
-        style.map(
-            "TNotebook.Tab",
-            background=[("selected", "#e0e0e0")],
-            expand=[("selected", [1, 1, 1, 0])]
-        )
-
-        # Style for larger buttons
-        style.configure(
-            "Large.TButton", 
-            font=('Helvetica', 18),    # Font size for buttons
-            padding=[20, 15]           # Increased padding for top and bottom to make the button taller
-        )
-
-    def setup_variables(self) -> NoReturn:
-        """
-        Sets up the Tkinter variables for source, scatterer, and detector configurations.
-        """
-        self.source_vars = {
-            'Wavelength (nm)': tk.StringVar(value='400'),
-            'Polarization Value (radians)': tk.StringVar(value='0'),
-            'Optical Power (mW)': tk.StringVar(value='1'),
-            'Numerical Aperture (NA)': tk.StringVar(value='0.2'),
-        }
-
-        self.scatterer_vars = {
-            'Diameter (nm)': tk.StringVar(value='100'),  # Accepts both single value and range
-            'Index': tk.StringVar(value='1.4'),
-            'Medium Refractive Index': tk.StringVar(value='1'),
-        }
-
-        self.detector_vars = {
-            'NA': tk.StringVar(value='0.2'),  # Can be ranged
-            'Gamma': tk.StringVar(value='0'),  # Can be ranged
-            'Phi': tk.StringVar(value='0'),  # Can be ranged
-            'Filter': tk.StringVar(value='0'),  # Can be ranged
-            'Coherent': tk.BooleanVar(value=True),  # True or False
-        }
-
-        self.axis_options = ["Wavelength", "Diameter", "Index", "N_medium", "Gamma", "Phi"]
-
-        self.axis_config_vars = {
-            'x axis': tk.StringVar(value=self.axis_options[0]),
-            'y axis': tk.StringVar(value=self.axis_options[1]),
-        }
-
-    def setup_notebook(self) -> NoReturn:
-        """
-        Sets up the notebook widget with tabs for Source, Scatterer, and Detector configurations.
-        """
-        self.notebook = ttk.Notebook(self.master)
-        self.notebook.pack(fill=tk.BOTH, expand=True, side=tk.TOP)
-
-        self.source_tab = ttk.Frame(self.notebook)
-        self.scatterer_tab = ttk.Frame(self.notebook)
-        self.detector_tab = ttk.Frame(self.notebook)
-        self.axis_config_tab = ttk.Frame(self.notebook)
-
-        self.notebook.add(self.source_tab, text='Source')
-        self.notebook.add(self.scatterer_tab, text='Scatterer')
-        self.notebook.add(self.detector_tab, text='Detector')
-        self.notebook.add(self.axis_config_tab, text='Axis Configuration')
-
-        self.setup_source_tab()
-        self.setup_scatterer_tab()
-        self.setup_detector_tab()
-        self.setup_axis_config_tab()
-
-    def setup_controls(self) -> NoReturn:
-        """
-        Sets up control buttons for calculating results and saving data.
-        """
-        self.controls_frame = ttk.Frame(self.master)
-        self.controls_frame.pack(fill=tk.X, side=tk.BOTTOM)
-
-        ttk.Button(
-            self.controls_frame,
-            text="Calculate",
-            style="Large.TButton",  # Apply the custom style for larger buttons
-            command=self.update_plot
-        ).pack(side=tk.LEFT, padx=5, pady=5)
-
-        ttk.Button(
-            self.controls_frame,
-            text="Save as CSV",
-            style="Large.TButton",  # Apply the custom style for larger buttons
-            command=self.save_data_as_csv
-        ).pack(side=tk.LEFT, padx=5, pady=5)
-
-    def setup_axis_config_tab(self):
-        ttk.Label(
-            self.axis_config_tab,
-            text="x axis"
-        ).grid(column=0, row=0, sticky=tk.W, padx=5, pady=5)
-
-        ttk.Combobox(
-            self.axis_config_tab,
-            textvariable=self.axis_config_vars['x axis'],
-            values=self.axis_options,
-            state="readonly"
-        ).grid(column=1, row=0, padx=5, pady=5)
-
-        ttk.Label(
-            self.axis_config_tab,
-            text="y axis"
-        ).grid(column=0, row=1, sticky=tk.W, padx=5, pady=5)
-
-        ttk.Combobox(
-            self.axis_config_tab,
-            textvariable=self.axis_config_vars['y axis'],
-            values=self.axis_options,
-            state="readonly"
-        ).grid(column=1, row=1, padx=5, pady=5)
-
-    def setup_source_tab(self) -> NoReturn:
-        """
-        Sets up widgets for the Source configuration tab.
-        """
-        row = 0
-        for label, var in self.source_vars.items():
-            ttk.Label(self.source_tab, text=label).grid(column=0, row=row, sticky=tk.W)
-            ttk.Entry(self.source_tab, textvariable=var).grid(column=1, row=row)
-            row += 1
-
-    def setup_scatterer_tab(self) -> NoReturn:
-        """
-        Sets up widgets for the Scatterer configuration tab.
-        """
-        row = 0
-        for label, var in self.scatterer_vars.items():
-            ttk.Label(self.scatterer_tab, text=label).grid(column=0, row=row, sticky=tk.W)
-            ttk.Entry(self.scatterer_tab, textvariable=var).grid(column=1, row=row)
-            row += 1
-
-    def setup_detector_tab(self) -> NoReturn:
-        """
-        Sets up widgets for the Detector configuration tab, including a special case for the Coherent boolean input.
-        """
-        row = 0
-        for label, var in self.detector_vars.items():
-            ttk.Label(self.detector_tab, text=label).grid(column=0, row=row, sticky=tk.W)
-
-            if label == 'Coherent':  # Special case for Boolean input
-                ttk.Checkbutton(
-                    self.detector_tab,
-                    text='',
-                    variable=var,
-                    onvalue=True,
-                    offvalue=False
-                ).grid(column=1, row=row)
-            else:
-                ttk.Entry(self.detector_tab, textvariable=var).grid(column=1, row=row)
-            row += 1
-
-    def setup_plot_frame(self) -> NoReturn:
-        """
-        Sets up the frame for displaying plots.
-        """
-        self.plot_frame = tk.Frame(self.master)
-        self.plot_frame.pack(fill=tk.BOTH, expand=True)
-
-    def parse_input(self, input_str: str, factor: float = 1) -> float | np.ndarray:
-        """
-        Parses input strings to handle single values or ranges. Supports notation for ranges (e.g., "start:end:points").
-
-        Parameters:
-            input_str (str): The input string to parse.
-            factor (float): Multiplication factor for unit conversion.
-
-        Returns:
-            float | np.ndarray: The parsed input as a single float or a numpy array.
-        """
-        if ":" in input_str:
-            parts = input_str.split(':')
-            start, end, points = map(float, parts)
-            return np.linspace(start, end, int(points)) * factor
-
-        if "," in input_str:
-            parts = input_str.split(',')
-            values = [float(value) for value in parts]
-            return np.asarray(values) * factor
-
-        return np.asarray(float(input_str)) * factor
-
-    def set_source(self) -> NoReturn:
-        wavelength_input = self.source_vars['Wavelength (nm)'].get()
-        polarization_value_input = self.source_vars['Polarization Value (radians)'].get()
-        optical_power_input = self.source_vars['Optical Power (mW)'].get()
-        NA_input = self.source_vars['Numerical Aperture (NA)'].get()
-
-        # Process inputs
-        wavelength = self.parse_input(input_str=wavelength_input, factor=1e-9)
-        polarization_value = self.parse_input(input_str=polarization_value_input, factor=1)
-        optical_power = self.parse_input(input_str=optical_power_input, factor=1e-3)
-        NA = self.parse_input(input_str=NA_input, factor=1)
-
-        self.source_set = Gaussian(
-            wavelength=wavelength,
-            polarization_value=polarization_value,
-            polarization_type='linear',
-            optical_power=optical_power,
-            NA=NA
-        )
-
-    def set_scatterer(self) -> NoReturn:
-        diameter_input = self.scatterer_vars['Diameter (nm)'].get()
-        index_input = self.scatterer_vars['Index'].get()
-        n_medium_input = self.scatterer_vars['Medium Refractive Index'].get()
-
-        diameters = self.parse_input(input_str=diameter_input, factor=1e-9)
-        index = self.parse_input(input_str=index_input, factor=1)
-        n_medium = self.parse_input(input_str=n_medium_input, factor=1)
-
-        self.scatterer_set = Cylinder(
-            diameter=diameters,
-            index=index,
-            n_medium=n_medium,
-            source_set=self.source_set
-        )
-
-    def set_detector(self) -> NoReturn:
-        NA_input = self.detector_vars['NA'].get()
-        gamma_input = self.detector_vars['Gamma'].get()
-        phi_input = self.detector_vars['Phi'].get()
-        filter_input = self.detector_vars['Filter'].get()
-
-        NA = self.parse_input(input_str=NA_input, factor=1)
-        gamma = self.parse_input(input_str=gamma_input, factor=1)
-        phi = self.parse_input(input_str=phi_input, factor=1)
-        polarization_filter = self.parse_input(input_str=filter_input, factor=1)
-
-        self.detector_set = Photodiode(
-            NA=NA,
-            gamma_offset=gamma,
-            phi_offset=phi,
-            polarization_filter=polarization_filter,
-            sampling=300
-        )
-
-    def get_data_from_PyMieSim(self) -> NoReturn:
-        """
-        Compute the B1 scattering data using either a single diameter or a range of diameters.
-        """
-        self.set_source()
-
-        self.set_scatterer()
-
-        self.set_detector()
-
-        self.axis_mapping = {
-            'Diameter': self.scatterer_set.diameter,
-            'Index': self.scatterer_set.index,
-            'N_medium': self.scatterer_set.n_medium,
-            'Wavelength': self.source_set.wavelength,
-            "Gamma": self.detector_set.gamma_offset,
-            "Phi": self.detector_set.phi_offset
-        }
-
-        self.experiment = Setup(
-            scatterer_set=self.scatterer_set,
-            source_set=self.source_set,
-            detector_set=self.detector_set
-        )
-
-    def save_data_as_csv(self) -> NoReturn:
-        """
-        Triggered by the "Save as CSV" button. Opens a file dialog to save the computed data as a CSV file.
-        """
-        if hasattr(self, 'data'):
-            filepath = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV files", "*.csv")])
-            if filepath:
-                # Assuming self.data is a pandas DataFrame or can be converted to one
-                np.savetxt(filepath, self.data.y.values.squeeze(), delimiter=",")
-                print(f"Data saved to {filepath}")
-        else:
-            print("No data to save. Please calculate first.")
-
-    def update_plot(self) -> NoReturn:
-        try:
-            # Parse inputs from the GUI
-            self.get_data_from_PyMieSim()
-
-            # Assuming measure.Qsca can be plotted directly
-            self.data = self.experiment.get(measure.coupling)
-
-            x_axis = self.axis_config_vars['x axis'].get()
-            x_axis = self.axis_mapping[x_axis]
-
-            figure = self.data.plot(x=x_axis)
-            figure.unit_size = (7, 4)
-            figure._render_()
-            figure = figure._mpl_figure
-
-            # Embed the plot
-            for widget in self.plot_frame.winfo_children():
-                widget.destroy()
-
-            canvas = FigureCanvasTkAgg(figure, master=self.plot_frame)
-            canvas.draw()
-            canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=1)
-
-        except ValueError as e:
-            messagebox.showerror("Input Error", str(e))
-
-
-def main():
-    root = tk.Tk()
-    PyMieSimGUI(root)
-    root.mainloop()
-
-
-if __name__ == "__main__":
-    main()
+
+from typing import NoReturn
+import tkinter as tk
+from tkinter import ttk, filedialog, messagebox
+import numpy as np
+from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
+# Assuming PyMieSim and its dependencies are installed
+from PyMieSim.experiment.scatterer import Cylinder
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment.detector import Photodiode
+from PyMieSim.experiment import Setup
+from PyMieSim import measure
+
+
+class PyMieSimGUI:
+    """
+    Graphical User Interface for computing and visualizing the B1 scattering coefficient
+    for cylindrical scatterers using PyMieSim.
+
+    Attributes:
+        master (tk.Tk): The main tkinter window.
+    """
+
+    def __init__(self, master: tk.Tk):
+        """
+        Initializes the GUI, setting up variables, plot frame, notebook, and controls.
+
+        Parameters:
+            master (tk.Tk): The root window of the application.
+        """
+        self.master = master
+        self.master.title("PyMieSim Graphic Interface")
+        self.customize_notebook_style()
+        self.setup_variables()
+        self.setup_plot_frame()
+        self.setup_notebook()
+        self.setup_controls()  # Setup controls outside of the tabs
+
+    def customize_notebook_style(self) -> NoReturn:
+        """
+        Customizes the ttk Notebook style for a unique appearance of tabs, making them larger.
+        """
+        style = ttk.Style()
+        style.configure("TNotebook", background="#f0f0f0")
+
+        style.configure(
+            "TNotebook.Tab",
+            background="#d0d0d0",
+            padding=[10, 20, 10, 20],  # Increase padding for larger tabs
+            font=('Helvetica', 12)     # Larger font for tabs
+        )
+        style.map(
+            "TNotebook.Tab",
+            background=[("selected", "#e0e0e0")],
+            expand=[("selected", [1, 1, 1, 0])]
+        )
+
+        # Style for larger buttons
+        style.configure(
+            "Large.TButton", 
+            font=('Helvetica', 18),    # Font size for buttons
+            padding=[20, 15]           # Increased padding for top and bottom to make the button taller
+        )
+
+    def setup_variables(self) -> NoReturn:
+        """
+        Sets up the Tkinter variables for source, scatterer, and detector configurations.
+        """
+        self.source_vars = {
+            'Wavelength (nm)': tk.StringVar(value='400'),
+            'Polarization Value (radians)': tk.StringVar(value='0'),
+            'Optical Power (mW)': tk.StringVar(value='1'),
+            'Numerical Aperture (NA)': tk.StringVar(value='0.2'),
+        }
+
+        self.scatterer_vars = {
+            'Diameter (nm)': tk.StringVar(value='100'),  # Accepts both single value and range
+            'Index': tk.StringVar(value='1.4'),
+            'Medium Refractive Index': tk.StringVar(value='1'),
+        }
+
+        self.detector_vars = {
+            'NA': tk.StringVar(value='0.2'),  # Can be ranged
+            'Gamma': tk.StringVar(value='0'),  # Can be ranged
+            'Phi': tk.StringVar(value='0'),  # Can be ranged
+            'Filter': tk.StringVar(value='0'),  # Can be ranged
+            'Coherent': tk.BooleanVar(value=True),  # True or False
+        }
+
+        self.axis_options = ["Wavelength", "Diameter", "Index", "N_medium", "Gamma", "Phi"]
+
+        self.axis_config_vars = {
+            'x axis': tk.StringVar(value=self.axis_options[0]),
+            'y axis': tk.StringVar(value=self.axis_options[1]),
+        }
+
+    def setup_notebook(self) -> NoReturn:
+        """
+        Sets up the notebook widget with tabs for Source, Scatterer, and Detector configurations.
+        """
+        self.notebook = ttk.Notebook(self.master)
+        self.notebook.pack(fill=tk.BOTH, expand=True, side=tk.TOP)
+
+        self.source_tab = ttk.Frame(self.notebook)
+        self.scatterer_tab = ttk.Frame(self.notebook)
+        self.detector_tab = ttk.Frame(self.notebook)
+        self.axis_config_tab = ttk.Frame(self.notebook)
+
+        self.notebook.add(self.source_tab, text='Source')
+        self.notebook.add(self.scatterer_tab, text='Scatterer')
+        self.notebook.add(self.detector_tab, text='Detector')
+        self.notebook.add(self.axis_config_tab, text='Axis Configuration')
+
+        self.setup_source_tab()
+        self.setup_scatterer_tab()
+        self.setup_detector_tab()
+        self.setup_axis_config_tab()
+
+    def setup_controls(self) -> NoReturn:
+        """
+        Sets up control buttons for calculating results and saving data.
+        """
+        self.controls_frame = ttk.Frame(self.master)
+        self.controls_frame.pack(fill=tk.X, side=tk.BOTTOM)
+
+        ttk.Button(
+            self.controls_frame,
+            text="Calculate",
+            style="Large.TButton",  # Apply the custom style for larger buttons
+            command=self.update_plot
+        ).pack(side=tk.LEFT, padx=5, pady=5)
+
+        ttk.Button(
+            self.controls_frame,
+            text="Save as CSV",
+            style="Large.TButton",  # Apply the custom style for larger buttons
+            command=self.save_data_as_csv
+        ).pack(side=tk.LEFT, padx=5, pady=5)
+
+    def setup_axis_config_tab(self):
+        ttk.Label(
+            self.axis_config_tab,
+            text="x axis"
+        ).grid(column=0, row=0, sticky=tk.W, padx=5, pady=5)
+
+        ttk.Combobox(
+            self.axis_config_tab,
+            textvariable=self.axis_config_vars['x axis'],
+            values=self.axis_options,
+            state="readonly"
+        ).grid(column=1, row=0, padx=5, pady=5)
+
+        ttk.Label(
+            self.axis_config_tab,
+            text="y axis"
+        ).grid(column=0, row=1, sticky=tk.W, padx=5, pady=5)
+
+        ttk.Combobox(
+            self.axis_config_tab,
+            textvariable=self.axis_config_vars['y axis'],
+            values=self.axis_options,
+            state="readonly"
+        ).grid(column=1, row=1, padx=5, pady=5)
+
+    def setup_source_tab(self) -> NoReturn:
+        """
+        Sets up widgets for the Source configuration tab.
+        """
+        row = 0
+        for label, var in self.source_vars.items():
+            ttk.Label(self.source_tab, text=label).grid(column=0, row=row, sticky=tk.W)
+            ttk.Entry(self.source_tab, textvariable=var).grid(column=1, row=row)
+            row += 1
+
+    def setup_scatterer_tab(self) -> NoReturn:
+        """
+        Sets up widgets for the Scatterer configuration tab.
+        """
+        row = 0
+        for label, var in self.scatterer_vars.items():
+            ttk.Label(self.scatterer_tab, text=label).grid(column=0, row=row, sticky=tk.W)
+            ttk.Entry(self.scatterer_tab, textvariable=var).grid(column=1, row=row)
+            row += 1
+
+    def setup_detector_tab(self) -> NoReturn:
+        """
+        Sets up widgets for the Detector configuration tab, including a special case for the Coherent boolean input.
+        """
+        row = 0
+        for label, var in self.detector_vars.items():
+            ttk.Label(self.detector_tab, text=label).grid(column=0, row=row, sticky=tk.W)
+
+            if label == 'Coherent':  # Special case for Boolean input
+                ttk.Checkbutton(
+                    self.detector_tab,
+                    text='',
+                    variable=var,
+                    onvalue=True,
+                    offvalue=False
+                ).grid(column=1, row=row)
+            else:
+                ttk.Entry(self.detector_tab, textvariable=var).grid(column=1, row=row)
+            row += 1
+
+    def setup_plot_frame(self) -> NoReturn:
+        """
+        Sets up the frame for displaying plots.
+        """
+        self.plot_frame = tk.Frame(self.master)
+        self.plot_frame.pack(fill=tk.BOTH, expand=True)
+
+    def parse_input(self, input_str: str, factor: float = 1) -> float | np.ndarray:
+        """
+        Parses input strings to handle single values or ranges. Supports notation for ranges (e.g., "start:end:points").
+
+        Parameters:
+            input_str (str): The input string to parse.
+            factor (float): Multiplication factor for unit conversion.
+
+        Returns:
+            float | np.ndarray: The parsed input as a single float or a numpy array.
+        """
+        if ":" in input_str:
+            parts = input_str.split(':')
+            start, end, points = map(float, parts)
+            return np.linspace(start, end, int(points)) * factor
+
+        if "," in input_str:
+            parts = input_str.split(',')
+            values = [float(value) for value in parts]
+            return np.asarray(values) * factor
+
+        return np.asarray(float(input_str)) * factor
+
+    def set_source(self) -> NoReturn:
+        wavelength_input = self.source_vars['Wavelength (nm)'].get()
+        polarization_value_input = self.source_vars['Polarization Value (radians)'].get()
+        optical_power_input = self.source_vars['Optical Power (mW)'].get()
+        NA_input = self.source_vars['Numerical Aperture (NA)'].get()
+
+        # Process inputs
+        wavelength = self.parse_input(input_str=wavelength_input, factor=1e-9)
+        polarization_value = self.parse_input(input_str=polarization_value_input, factor=1)
+        optical_power = self.parse_input(input_str=optical_power_input, factor=1e-3)
+        NA = self.parse_input(input_str=NA_input, factor=1)
+
+        self.source_set = Gaussian(
+            wavelength=wavelength,
+            polarization_value=polarization_value,
+            polarization_type='linear',
+            optical_power=optical_power,
+            NA=NA
+        )
+
+    def set_scatterer(self) -> NoReturn:
+        diameter_input = self.scatterer_vars['Diameter (nm)'].get()
+        index_input = self.scatterer_vars['Index'].get()
+        n_medium_input = self.scatterer_vars['Medium Refractive Index'].get()
+
+        diameters = self.parse_input(input_str=diameter_input, factor=1e-9)
+        index = self.parse_input(input_str=index_input, factor=1)
+        n_medium = self.parse_input(input_str=n_medium_input, factor=1)
+
+        self.scatterer_set = Cylinder(
+            diameter=diameters,
+            index=index,
+            n_medium=n_medium,
+            source_set=self.source_set
+        )
+
+    def set_detector(self) -> NoReturn:
+        NA_input = self.detector_vars['NA'].get()
+        gamma_input = self.detector_vars['Gamma'].get()
+        phi_input = self.detector_vars['Phi'].get()
+        filter_input = self.detector_vars['Filter'].get()
+
+        NA = self.parse_input(input_str=NA_input, factor=1)
+        gamma = self.parse_input(input_str=gamma_input, factor=1)
+        phi = self.parse_input(input_str=phi_input, factor=1)
+        polarization_filter = self.parse_input(input_str=filter_input, factor=1)
+
+        self.detector_set = Photodiode(
+            NA=NA,
+            gamma_offset=gamma,
+            phi_offset=phi,
+            polarization_filter=polarization_filter,
+            sampling=300
+        )
+
+    def get_data_from_PyMieSim(self) -> NoReturn:
+        """
+        Compute the B1 scattering data using either a single diameter or a range of diameters.
+        """
+        self.set_source()
+
+        self.set_scatterer()
+
+        self.set_detector()
+
+        self.axis_mapping = {
+            'Diameter': self.scatterer_set.diameter,
+            'Index': self.scatterer_set.index,
+            'N_medium': self.scatterer_set.n_medium,
+            'Wavelength': self.source_set.wavelength,
+            "Gamma": self.detector_set.gamma_offset,
+            "Phi": self.detector_set.phi_offset
+        }
+
+        self.experiment = Setup(
+            scatterer_set=self.scatterer_set,
+            source_set=self.source_set,
+            detector_set=self.detector_set
+        )
+
+    def save_data_as_csv(self) -> NoReturn:
+        """
+        Triggered by the "Save as CSV" button. Opens a file dialog to save the computed data as a CSV file.
+        """
+        if hasattr(self, 'data'):
+            filepath = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV files", "*.csv")])
+            if filepath:
+                # Assuming self.data is a pandas DataFrame or can be converted to one
+                np.savetxt(filepath, self.data.y.values.squeeze(), delimiter=",")
+                print(f"Data saved to {filepath}")
+        else:
+            print("No data to save. Please calculate first.")
+
+    def update_plot(self) -> NoReturn:
+        try:
+            # Parse inputs from the GUI
+            self.get_data_from_PyMieSim()
+
+            # Assuming measure.Qsca can be plotted directly
+            self.data = self.experiment.get(measure.coupling)
+
+            x_axis = self.axis_config_vars['x axis'].get()
+            x_axis = self.axis_mapping[x_axis]
+
+            figure = self.data.plot(x=x_axis)
+            figure.unit_size = (7, 4)
+            figure._render_()
+            figure = figure._mpl_figure
+
+            # Embed the plot
+            for widget in self.plot_frame.winfo_children():
+                widget.destroy()
+
+            canvas = FigureCanvasTkAgg(figure, master=self.plot_frame)
+            canvas.draw()
+            canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=1)
+
+        except ValueError as e:
+            messagebox.showerror("Input Error", str(e))
+
+
+def main():
+    root = tk.Tk()
+    PyMieSimGUI(root)
+    root.mainloop()
+
+
+if __name__ == "__main__":
+    main()
```

## development/matthew_singe-2.py

 * *Ordering differences only*

```diff
@@ -1,55 +1,55 @@
-"""
-Sphere: Goniometer
-==================
-
-"""
-
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy
-from PyMieSim.experiment.scatterer import Sphere
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-from PyOptik import UsualMaterial
-from PyMieSim import measure
-
-# %%
-# Defining the source to be employed.
-source_set = Gaussian(
-    wavelength=635e-9,
-    polarization_value=0,
-    polarization_type='linear',
-    optical_power=1e-3,
-    NA=0.2
-)
-# %%
-# Defining the ranging parameters for the scatterer distribution
-scatterer_set = Sphere(
-    diameter=numpy.linspace(100e-9, 10e-6, 200),
-    index=numpy.linspace(1.4, 1.6, 4),
-    medium_material=UsualMaterial.Water,
-    source_set=source_set
-)
-
-# %%
-# Defining the experiment setup
-experiment = Setup(
-    scatterer_set=scatterer_set,
-    source_set=source_set,
-    detector_set=None
-)
-
-# %%
-# Measuring the properties
-data = experiment.get(measure.Qback)
-
-# %%
-# Plotting the results
-figure = data.plot(
-    x=experiment.diameter,
-    # y_scale='log',
-    # normalize=True
-)
-
-_ = figure.show()
+"""
+Sphere: Goniometer
+==================
+
+"""
+
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy
+from PyMieSim.experiment.scatterer import Sphere
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+from PyOptik import UsualMaterial
+from PyMieSim import measure
+
+# %%
+# Defining the source to be employed.
+source_set = Gaussian(
+    wavelength=635e-9,
+    polarization_value=0,
+    polarization_type='linear',
+    optical_power=1e-3,
+    NA=0.2
+)
+# %%
+# Defining the ranging parameters for the scatterer distribution
+scatterer_set = Sphere(
+    diameter=numpy.linspace(100e-9, 10e-6, 200),
+    index=numpy.linspace(1.4, 1.6, 4),
+    medium_material=UsualMaterial.Water,
+    source_set=source_set
+)
+
+# %%
+# Defining the experiment setup
+experiment = Setup(
+    scatterer_set=scatterer_set,
+    source_set=source_set,
+    detector_set=None
+)
+
+# %%
+# Measuring the properties
+data = experiment.get(measure.Qback)
+
+# %%
+# Plotting the results
+figure = data.plot(
+    x=experiment.diameter,
+    # y_scale='log',
+    # normalize=True
+)
+
+_ = figure.show()
```

## development/matthew_singer.py

 * *Ordering differences only*

```diff
@@ -1,67 +1,67 @@
-"""
-Sphere: Goniometer
-==================
-
-"""
-
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy
-from PyMieSim.experiment.detector import Photodiode
-from PyMieSim.experiment.scatterer import Sphere
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-from PyOptik import UsualMaterial
-from PyMieSim import measure
-
-# %%
-# Defining the source to be employed.
-source_set = Gaussian(
-    wavelength=635e-9,
-    polarization_value=[0, 90],
-    polarization_type='linear',
-    optical_power=1e-3,
-    NA=0.2
-)
-# %%
-# Defining the ranging parameters for the scatterer distribution
-scatterer_set = Sphere(
-    diameter=numpy.linspace(1000e-9 - 100e-9, 1000e-9 + 100e-9, 10),
-    material=UsualMaterial.Polystyrene,
-    medium_material=UsualMaterial.Water,
-    source_set=source_set
-)
-
-# %%
-# Defining the detector to be employed.
-detector_set = Photodiode(
-    NA=[0.1, 0.01],
-    phi_offset=numpy.linspace(-165, 165, 200),
-    gamma_offset=0,
-    sampling=1000,
-    polarization_filter=None
-)
-
-# %%
-# Defining the experiment setup
-experiment = Setup(
-    scatterer_set=scatterer_set,
-    source_set=source_set,
-    detector_set=detector_set
-)
-
-# %%
-# Measuring the properties
-data = experiment.get(measure.coupling)
-
-# %%
-# Plotting the results
-figure = data.plot(
-    x=experiment.phi_offset,
-    y_scale='log',
-    std=experiment.diameter
-    # normalize=True
-)
-
-_ = figure.show()
+"""
+Sphere: Goniometer
+==================
+
+"""
+
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy
+from PyMieSim.experiment.detector import Photodiode
+from PyMieSim.experiment.scatterer import Sphere
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+from PyOptik import UsualMaterial
+from PyMieSim import measure
+
+# %%
+# Defining the source to be employed.
+source_set = Gaussian(
+    wavelength=635e-9,
+    polarization_value=[0, 90],
+    polarization_type='linear',
+    optical_power=1e-3,
+    NA=0.2
+)
+# %%
+# Defining the ranging parameters for the scatterer distribution
+scatterer_set = Sphere(
+    diameter=numpy.linspace(1000e-9 - 100e-9, 1000e-9 + 100e-9, 10),
+    material=UsualMaterial.Polystyrene,
+    medium_material=UsualMaterial.Water,
+    source_set=source_set
+)
+
+# %%
+# Defining the detector to be employed.
+detector_set = Photodiode(
+    NA=[0.1, 0.01],
+    phi_offset=numpy.linspace(-165, 165, 200),
+    gamma_offset=0,
+    sampling=1000,
+    polarization_filter=None
+)
+
+# %%
+# Defining the experiment setup
+experiment = Setup(
+    scatterer_set=scatterer_set,
+    source_set=source_set,
+    detector_set=detector_set
+)
+
+# %%
+# Measuring the properties
+data = experiment.get(measure.coupling)
+
+# %%
+# Plotting the results
+figure = data.plot(
+    x=experiment.phi_offset,
+    y_scale='log',
+    std=experiment.diameter
+    # normalize=True
+)
+
+_ = figure.show()
```

## docs/examples/detector/plot_HG01.py

 * *Ordering differences only*

```diff
@@ -1,33 +1,33 @@
-"""
-Hermite-Gauss 01 Mode Detector
-==============================
-
-This example demonstrates the initialization and visualization of HG01 Mode detector using PyMieSim.
-"""
-
-# %%
-# Importing the package: PyMieSim
-from PyMieSim.single.detector import CoherentMode
-
-# %%
-# Initializing the detector
-detector = CoherentMode(
-    mode_number="HG01",  # Specifying LP01 mode
-    sampling=500,  # Number of sampling points
-    NA=0.5,  # Numerical Aperture
-    gamma_offset=0,  # Gamma offset
-    phi_offset=40,  # Phi offset in degrees
-)
-
-# %%
-# Plotting the detector
-figure = detector.plot()
-
-# %%
-# Customizing the plot appearance
-figure.background_color = 'black'  # Setting the background color to black
-figure.unit_size = (1200, 1200)  # Adjusting the size of the plot
-
-# %%
-# Displaying the plot
-_ = figure.show()
+"""
+Hermite-Gauss 01 Mode Detector
+==============================
+
+This example demonstrates the initialization and visualization of HG01 Mode detector using PyMieSim.
+"""
+
+# %%
+# Importing the package: PyMieSim
+from PyMieSim.single.detector import CoherentMode
+
+# %%
+# Initializing the detector
+detector = CoherentMode(
+    mode_number="HG01",  # Specifying LP01 mode
+    sampling=500,  # Number of sampling points
+    NA=0.5,  # Numerical Aperture
+    gamma_offset=0,  # Gamma offset
+    phi_offset=40,  # Phi offset in degrees
+)
+
+# %%
+# Plotting the detector
+figure = detector.plot()
+
+# %%
+# Customizing the plot appearance
+figure.background_color = 'black'  # Setting the background color to black
+figure.unit_size = (1200, 1200)  # Adjusting the size of the plot
+
+# %%
+# Displaying the plot
+_ = figure.show()
```

## docs/examples/detector/plot_HG11.py

 * *Ordering differences only*

```diff
@@ -1,34 +1,34 @@
-"""
-Hermite-Gauss 31 Mode Detector
-==============================
-
-This example demonstrates the initialization and visualization of HG31 Mode detector using PyMieSim.
-"""
-
-# %%
-# Importing the package: PyMieSim
-from PyMieSim.single.detector import CoherentMode
-
-# %%
-# Initializing the detector
-detector = CoherentMode(
-    mode_number="HG31",  # Specifying HG31 mode
-    sampling=500,  # Number of sampling points
-    NA=0.5,  # Numerical Aperture
-    gamma_offset=0,  # Gamma offset
-    phi_offset=40,  # Phi offset in degrees
-    rotation=0,
-)
-
-# %%
-# Plotting the detector
-figure = detector.plot()
-
-# %%
-# Customizing the plot appearance
-figure.background_color = 'black'  # Setting the background color to black
-figure.unit_size = (1200, 1200)  # Adjusting the size of the plot
-
-# %%
-# Displaying the plot
-_ = figure.show()
+"""
+Hermite-Gauss 31 Mode Detector
+==============================
+
+This example demonstrates the initialization and visualization of HG31 Mode detector using PyMieSim.
+"""
+
+# %%
+# Importing the package: PyMieSim
+from PyMieSim.single.detector import CoherentMode
+
+# %%
+# Initializing the detector
+detector = CoherentMode(
+    mode_number="HG31",  # Specifying HG31 mode
+    sampling=500,  # Number of sampling points
+    NA=0.5,  # Numerical Aperture
+    gamma_offset=0,  # Gamma offset
+    phi_offset=40,  # Phi offset in degrees
+    rotation=0,
+)
+
+# %%
+# Plotting the detector
+figure = detector.plot()
+
+# %%
+# Customizing the plot appearance
+figure.background_color = 'black'  # Setting the background color to black
+figure.unit_size = (1200, 1200)  # Adjusting the size of the plot
+
+# %%
+# Displaying the plot
+_ = figure.show()
```

## docs/examples/detector/plot_LG11.py

 * *Ordering differences only*

```diff
@@ -1,33 +1,33 @@
-"""
-Laguerre-Gauss 2-3 Mode Detector
-================================
-
-This example demonstrates the initialization and visualization of HG01 Mode detector using PyMieSim.
-"""
-
-# %%
-# Importing the package: PyMieSim
-from PyMieSim.single.detector import CoherentMode
-
-# %%
-# Initializing the detector
-detector = CoherentMode(
-    mode_number="LG23",  # Specifying LP23 mode
-    sampling=900,  # Number of sampling points
-    NA=0.4,  # Numerical Aperture
-    gamma_offset=0,  # Gamma offset
-    phi_offset=40,  # Phi offset in degrees
-)
-
-# %%
-# Plotting the detector
-figure = detector.plot()
-
-# %%
-# Customizing the plot appearance
-figure.background_color = 'black'  # Setting the background color to black
-figure.unit_size = (1200, 1200)  # Adjusting the size of the plot
-
-# %%
-# Displaying the plot
-_ = figure.show()
+"""
+Laguerre-Gauss 2-3 Mode Detector
+================================
+
+This example demonstrates the initialization and visualization of HG01 Mode detector using PyMieSim.
+"""
+
+# %%
+# Importing the package: PyMieSim
+from PyMieSim.single.detector import CoherentMode
+
+# %%
+# Initializing the detector
+detector = CoherentMode(
+    mode_number="LG23",  # Specifying LP23 mode
+    sampling=900,  # Number of sampling points
+    NA=0.4,  # Numerical Aperture
+    gamma_offset=0,  # Gamma offset
+    phi_offset=40,  # Phi offset in degrees
+)
+
+# %%
+# Plotting the detector
+figure = detector.plot()
+
+# %%
+# Customizing the plot appearance
+figure.background_color = 'black'  # Setting the background color to black
+figure.unit_size = (1200, 1200)  # Adjusting the size of the plot
+
+# %%
+# Displaying the plot
+_ = figure.show()
```

## docs/examples/detector/plot_LP01.py

 * *Ordering differences only*

```diff
@@ -1,33 +1,33 @@
-"""
-LP01 Mode Detector
-==================
-
-This example demonstrates the initialization and visualization of an LP01 Mode detector using PyMieSim.
-"""
-
-# %%
-# Importing the package: PyMieSim
-from PyMieSim.single.detector import CoherentMode
-
-# %%
-# Initializing the detector
-detector = CoherentMode(
-    mode_number="LP01",  # Specifying LP01 mode
-    sampling=500,  # Number of sampling points
-    NA=0.5,  # Numerical Aperture
-    gamma_offset=0,  # Gamma offset
-    phi_offset=40,  # Phi offset in degrees
-)
-
-# %%
-# Plotting the detector
-figure = detector.plot()
-
-# %%
-# Customizing the plot appearance
-figure.background_color = 'black'  # Setting the background color to black
-figure.unit_size = (1200, 1200)  # Adjusting the size of the plot
-
-# %%
-# Displaying the plot
-_ = figure.show()
+"""
+LP01 Mode Detector
+==================
+
+This example demonstrates the initialization and visualization of an LP01 Mode detector using PyMieSim.
+"""
+
+# %%
+# Importing the package: PyMieSim
+from PyMieSim.single.detector import CoherentMode
+
+# %%
+# Initializing the detector
+detector = CoherentMode(
+    mode_number="LP01",  # Specifying LP01 mode
+    sampling=500,  # Number of sampling points
+    NA=0.5,  # Numerical Aperture
+    gamma_offset=0,  # Gamma offset
+    phi_offset=40,  # Phi offset in degrees
+)
+
+# %%
+# Plotting the detector
+figure = detector.plot()
+
+# %%
+# Customizing the plot appearance
+figure.background_color = 'black'  # Setting the background color to black
+figure.unit_size = (1200, 1200)  # Adjusting the size of the plot
+
+# %%
+# Displaying the plot
+_ = figure.show()
```

## docs/examples/detector/plot_LP02.py

 * *Ordering differences only*

```diff
@@ -1,28 +1,28 @@
-"""
-LP02 Mode Detector
-==================
-
-This example demonstrates the initialization and visualization of an LP02 Mode detector using PyMieSim.
-"""
-
-# %%
-# Importing the package: PyMieSim
-from PyMieSim.single.detector import CoherentMode
-
-# %%
-# Initializing the detector
-detector = CoherentMode(
-    mode_number="LP02",  # Specifying LP02 mode
-    sampling=500,  # Number of sampling points
-    NA=0.3,  # Numerical Aperture
-    gamma_offset=0,  # Gamma offset
-    phi_offset=40,  # Phi offset in degrees
-)
-
-# %%
-# Plotting the detector
-figure = detector.plot()
-
-# %%
-# Displaying the plot
-_ = figure.show()
+"""
+LP02 Mode Detector
+==================
+
+This example demonstrates the initialization and visualization of an LP02 Mode detector using PyMieSim.
+"""
+
+# %%
+# Importing the package: PyMieSim
+from PyMieSim.single.detector import CoherentMode
+
+# %%
+# Initializing the detector
+detector = CoherentMode(
+    mode_number="LP02",  # Specifying LP02 mode
+    sampling=500,  # Number of sampling points
+    NA=0.3,  # Numerical Aperture
+    gamma_offset=0,  # Gamma offset
+    phi_offset=40,  # Phi offset in degrees
+)
+
+# %%
+# Plotting the detector
+figure = detector.plot()
+
+# %%
+# Displaying the plot
+_ = figure.show()
```

## docs/examples/detector/plot_LP11.py

 * *Ordering differences only*

```diff
@@ -1,28 +1,28 @@
-"""
-LP11 Mode Detector
-==================
-
-This example demonstrates the initialization and visualization of an LP11 Mode detector using PyMieSim.
-"""
-
-# %%
-# Importing the package: PyMieSim
-from PyMieSim.single.detector import CoherentMode
-
-# %%
-# Initializing the detector
-detector = CoherentMode(
-    mode_number="LP11",  # Specifying LP11 mode
-    sampling=300,  # Number of sampling points
-    NA=0.3,  # Numerical Aperture
-    gamma_offset=0,  # Gamma offset
-    phi_offset=30,  # Phi offset in degrees
-)
-
-# %%
-# Plotting the detector
-figure = detector.plot()
-
-# %%
-# Displaying the plot
-_ = figure.show()
+"""
+LP11 Mode Detector
+==================
+
+This example demonstrates the initialization and visualization of an LP11 Mode detector using PyMieSim.
+"""
+
+# %%
+# Importing the package: PyMieSim
+from PyMieSim.single.detector import CoherentMode
+
+# %%
+# Initializing the detector
+detector = CoherentMode(
+    mode_number="LP11",  # Specifying LP11 mode
+    sampling=300,  # Number of sampling points
+    NA=0.3,  # Numerical Aperture
+    gamma_offset=0,  # Gamma offset
+    phi_offset=30,  # Phi offset in degrees
+)
+
+# %%
+# Plotting the detector
+figure = detector.plot()
+
+# %%
+# Displaying the plot
+_ = figure.show()
```

## docs/examples/detector/plot_integrating_sphere.py

 * *Ordering differences only*

```diff
@@ -1,25 +1,25 @@
-"""
-Photodiode Detector
-===================
-
-This example demonstrates the initialization and visualization of an Integrating Sphere detector using PyMieSim.
-"""
-
-# %%
-# Importing the package: PyMieSim
-from PyMieSim.single.detector import IntegratingSphere
-
-# %%
-# Initializing the detector
-detector = IntegratingSphere(
-    sampling=500,  # Number of sampling points
-    polarization_filter=None  # No polarization filter applied
-)
-
-# %%
-# Plotting the detector
-figure = detector.plot()
-
-# %%
-# Displaying the plot
-_ = figure.show()
+"""
+Photodiode Detector
+===================
+
+This example demonstrates the initialization and visualization of an Integrating Sphere detector using PyMieSim.
+"""
+
+# %%
+# Importing the package: PyMieSim
+from PyMieSim.single.detector import IntegratingSphere
+
+# %%
+# Initializing the detector
+detector = IntegratingSphere(
+    sampling=500,  # Number of sampling points
+    polarization_filter=None  # No polarization filter applied
+)
+
+# %%
+# Plotting the detector
+figure = detector.plot()
+
+# %%
+# Displaying the plot
+_ = figure.show()
```

## docs/examples/detector/plot_photodiode.py

 * *Ordering differences only*

```diff
@@ -1,28 +1,28 @@
-"""
-Photodiode Detector
-===================
-
-This example demonstrates the initialization and visualization of a Photodiode detector using PyMieSim.
-"""
-
-# %%
-# Importing the package: PyMieSim
-from PyMieSim.single.detector import Photodiode
-
-# %%
-# Initializing the detector
-detector = Photodiode(
-    NA=0.3,  # Numerical Aperture
-    sampling=500,  # Number of sampling points
-    gamma_offset=-45,  # Gamma offset in degrees
-    phi_offset=20,  # Phi offset in degrees
-    polarization_filter=None  # No polarization filter applied
-)
-
-# %%
-# Plotting the detector
-figure = detector.plot()
-
-# %%
-# Displaying the plot
-_ = figure.show()
+"""
+Photodiode Detector
+===================
+
+This example demonstrates the initialization and visualization of a Photodiode detector using PyMieSim.
+"""
+
+# %%
+# Importing the package: PyMieSim
+from PyMieSim.single.detector import Photodiode
+
+# %%
+# Initializing the detector
+detector = Photodiode(
+    NA=0.3,  # Numerical Aperture
+    sampling=500,  # Number of sampling points
+    gamma_offset=-45,  # Gamma offset in degrees
+    phi_offset=20,  # Phi offset in degrees
+    polarization_filter=None  # No polarization filter applied
+)
+
+# %%
+# Plotting the detector
+figure = detector.plot()
+
+# %%
+# Displaying the plot
+_ = figure.show()
```

## docs/examples/experiment/plot_coreshell_Qback_vs_corediameter.py

 * *Ordering differences only*

```diff
@@ -1,61 +1,61 @@
-"""
-CoreShell: Qback vs Core Diameter
-=======================================
-
-This example demonstrates how to compute and visualize the backscattering efficiency (Qback)
-as functions of core diameter for CoreShell scatterers using PyMieSim.
-"""
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy
-from PyMieSim.experiment.scatterer import CoreShell
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-from PyOptik import UsualMaterial
-from PyMieSim import measure
-
-# %%
-# Defining the source
-source = Gaussian(
-    wavelength=[800e-9, 900e-9, 1000e-9],  # Array of wavelengths: 800 nm, 900 nm, 1000 nm
-    polarization_value=0,  # Linear polarization angle in radians
-    polarization_type='linear',
-    optical_power=1e-3,  # 1 milliwatt
-    NA=0.2  # Numerical Aperture
-)
-
-# %%
-# Defining the scatterer distribution
-scatterer = CoreShell(
-    core_diameter=numpy.geomspace(100e-9, 600e-9, 400),  # Core diameters from 100 nm to 600 nm
-    shell_width=800e-9,  # Shell width of 800 nm
-    core_material=UsualMaterial.Silver,  # Core material
-    shell_material=UsualMaterial.BK7,  # Shell material
-    medium_index=1,  # Surrounding medium's refractive index
-    source=source
-)
-
-# %%
-# Setting up the experiment
-experiment = Setup(
-    scatterer=scatterer,
-    source=source
-)
-
-# %%
-# Measuring the backscattering efficiency (Qback)
-# For demonstrating the measurement of Qsca, a separate call to `experiment.get()` with `measure.Qsca` is needed.
-data = experiment.get(measure.Qback)
-
-# %%
-# Plotting the results
-# Visualizing how the backscattering efficiency varies with the core diameter.
-figure = data.plot(
-    x=experiment.core_diameter,  # Core diameter as the x-axis
-    y_scale='log'  # Logarithmic scale for the y-axis
-)
-
-# %%
-# Displaying the plot
-_ = figure.show()
+"""
+CoreShell: Qback vs Core Diameter
+=======================================
+
+This example demonstrates how to compute and visualize the backscattering efficiency (Qback)
+as functions of core diameter for CoreShell scatterers using PyMieSim.
+"""
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy
+from PyMieSim.experiment.scatterer import CoreShell
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+from PyOptik import UsualMaterial
+from PyMieSim import measure
+
+# %%
+# Defining the source
+source = Gaussian(
+    wavelength=[800e-9, 900e-9, 1000e-9],  # Array of wavelengths: 800 nm, 900 nm, 1000 nm
+    polarization_value=0,  # Linear polarization angle in radians
+    polarization_type='linear',
+    optical_power=1e-3,  # 1 milliwatt
+    NA=0.2  # Numerical Aperture
+)
+
+# %%
+# Defining the scatterer distribution
+scatterer = CoreShell(
+    core_diameter=numpy.geomspace(100e-9, 600e-9, 400),  # Core diameters from 100 nm to 600 nm
+    shell_width=800e-9,  # Shell width of 800 nm
+    core_material=UsualMaterial.Silver,  # Core material
+    shell_material=UsualMaterial.BK7,  # Shell material
+    medium_index=1,  # Surrounding medium's refractive index
+    source=source
+)
+
+# %%
+# Setting up the experiment
+experiment = Setup(
+    scatterer=scatterer,
+    source=source
+)
+
+# %%
+# Measuring the backscattering efficiency (Qback)
+# For demonstrating the measurement of Qsca, a separate call to `experiment.get()` with `measure.Qsca` is needed.
+data = experiment.get(measure.Qback)
+
+# %%
+# Plotting the results
+# Visualizing how the backscattering efficiency varies with the core diameter.
+figure = data.plot(
+    x=experiment.core_diameter,  # Core diameter as the x-axis
+    y_scale='log'  # Logarithmic scale for the y-axis
+)
+
+# %%
+# Displaying the plot
+_ = figure.show()
```

## docs/examples/experiment/plot_coreshell_a1_vs_corediameter.py

 * *Ordering differences only*

```diff
@@ -1,63 +1,63 @@
-"""
-CoreShell: B1 vs Core Diameter
-==============================
-
-This example demonstrates how to compute and visualize the B1 scattering parameter as a function of core diameter for CoreShell scatterers using PyMieSim.
-"""
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy as np
-from PyMieSim.experiment.scatterer import CoreShell
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-from PyOptik import UsualMaterial
-from PyMieSim import measure
-
-# %%
-# Defining the source
-# In the LMT framework, the source is always considered a plane wave with a default amplitude of one.
-source = Gaussian(
-    wavelength=800e-9,  # 800 nm
-    polarization_value=0,  # Linear polarization angle in radians
-    polarization_type='linear',
-    optical_power=1e-3,  # 1 milliwatt
-    NA=0.2  # Numerical Aperture
-)
-
-# %%
-# Defining the scatterer distribution
-# Here, we explore core/shell scatterers with a constant shell diameter and variable core diameter.
-scatterer = CoreShell(
-    core_diameter=np.geomspace(100e-9, 3000e-9, 5000),  # Geometrically spaced core diameters
-    shell_width=800e-9,  # Shell width of 800 nm
-    core_index=1.6,  # Refractive index of the core
-    shell_material=[UsualMaterial.BK7, UsualMaterial.Silver],  # BK7 glass material for the shell
-    medium_index=1,  # Refractive index of the surrounding medium
-    source=source
-)
-
-# %%
-# Defining the experiment setup
-# Integrating the defined source and scatterers into a single experimental setup.
-experiment = Setup(
-    scatterer=scatterer,
-    source=source
-)
-
-# %%
-# Measuring the B1 scattering parameter
-# Here, we're interested in the a3 (first magnetic coefficient) parameter, which seems to be a typo for B1.
-data = experiment.get(measure.a3)
-
-# %%
-# Plotting the results
-# Visualizing how the B1 (a3) parameter varies with the core diameter.
-figure = data.plot(
-    x=experiment.core_diameter,  # Core diameter as the x-axis
-    y_scale='linear'  # Linear scale for the y-axis
-)
-
-# %%
-# Displaying the plot
-_ = figure.show()
+"""
+CoreShell: B1 vs Core Diameter
+==============================
+
+This example demonstrates how to compute and visualize the B1 scattering parameter as a function of core diameter for CoreShell scatterers using PyMieSim.
+"""
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy as np
+from PyMieSim.experiment.scatterer import CoreShell
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+from PyOptik import UsualMaterial
+from PyMieSim import measure
+
+# %%
+# Defining the source
+# In the LMT framework, the source is always considered a plane wave with a default amplitude of one.
+source = Gaussian(
+    wavelength=800e-9,  # 800 nm
+    polarization_value=0,  # Linear polarization angle in radians
+    polarization_type='linear',
+    optical_power=1e-3,  # 1 milliwatt
+    NA=0.2  # Numerical Aperture
+)
+
+# %%
+# Defining the scatterer distribution
+# Here, we explore core/shell scatterers with a constant shell diameter and variable core diameter.
+scatterer = CoreShell(
+    core_diameter=np.geomspace(100e-9, 3000e-9, 5000),  # Geometrically spaced core diameters
+    shell_width=800e-9,  # Shell width of 800 nm
+    core_index=1.6,  # Refractive index of the core
+    shell_material=[UsualMaterial.BK7, UsualMaterial.Silver],  # BK7 glass material for the shell
+    medium_index=1,  # Refractive index of the surrounding medium
+    source=source
+)
+
+# %%
+# Defining the experiment setup
+# Integrating the defined source and scatterers into a single experimental setup.
+experiment = Setup(
+    scatterer=scatterer,
+    source=source
+)
+
+# %%
+# Measuring the B1 scattering parameter
+# Here, we're interested in the a3 (first magnetic coefficient) parameter, which seems to be a typo for B1.
+data = experiment.get(measure.a3)
+
+# %%
+# Plotting the results
+# Visualizing how the B1 (a3) parameter varies with the core diameter.
+figure = data.plot(
+    x=experiment.core_diameter,  # Core diameter as the x-axis
+    y_scale='linear'  # Linear scale for the y-axis
+)
+
+# %%
+# Displaying the plot
+_ = figure.show()
```

## docs/examples/experiment/plot_coreshell_b1_vs_corediameter.py

 * *Ordering differences only*

```diff
@@ -1,64 +1,64 @@
-"""
-CoreShell: B1 vs Core Diameter
-==============================
-
-This example demonstrates how to compute and visualize the B1 scattering parameter as a function of core diameter for CoreShell scatterers using PyMieSim.
-"""
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy as np
-from PyMieSim.experiment.scatterer import CoreShell
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-from PyOptik import UsualMaterial
-from PyMieSim import measure
-
-# %%
-# Defining the source to be employed.
-# The source is always a plane wave in the LMT framework.
-# The amplitude is set to one per default.
-source = Gaussian(
-    wavelength=800e-9,  # 800 nm
-    polarization_value=0,  # Linear polarization angle in radians
-    polarization_type='linear',
-    optical_power=1e-3,  # 1 milliwatt
-    NA=0.2  # Numerical Aperture
-)
-
-# %%
-# Defining the ranging parameters for the scatterer distribution
-# Here we look at core/shell scatterers and use constant shell diameter
-# with variable core diameter
-scatterer = CoreShell(
-    core_diameter=np.geomspace(100e-9, 3000e-9, 5000),  # Geometrically spaced core diameters
-    shell_width=800e-9,  # Shell width of 800 nm
-    core_index=1.6,  # Refractive index of the core
-    shell_material=UsualMaterial.BK7,  # BK7 glass material for the shell
-    medium_index=1,  # Refractive index of the surrounding medium
-    source=source
-)
-
-# %%
-# Defining the experiment setup
-# Integrating the defined source and scatterers into a single experimental setup.
-experiment = Setup(
-    scatterer=scatterer,
-    source=source
-)
-
-# %%
-# Measuring the B1 scattering parameter
-data = experiment.get(measure.b1)
-
-# %%
-# Plotting the results
-# Visualizing how the B1 parameter varies with the core diameter.
-figure = data.plot(
-    x=experiment.core_diameter,  # Core diameter as the x-axis
-    y_scale='linear'  # Linear scale for the y-axis
-)
-
-# %%
-# Displaying the plot
-_ = figure.show()
+"""
+CoreShell: B1 vs Core Diameter
+==============================
+
+This example demonstrates how to compute and visualize the B1 scattering parameter as a function of core diameter for CoreShell scatterers using PyMieSim.
+"""
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy as np
+from PyMieSim.experiment.scatterer import CoreShell
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+from PyOptik import UsualMaterial
+from PyMieSim import measure
+
+# %%
+# Defining the source to be employed.
+# The source is always a plane wave in the LMT framework.
+# The amplitude is set to one per default.
+source = Gaussian(
+    wavelength=800e-9,  # 800 nm
+    polarization_value=0,  # Linear polarization angle in radians
+    polarization_type='linear',
+    optical_power=1e-3,  # 1 milliwatt
+    NA=0.2  # Numerical Aperture
+)
+
+# %%
+# Defining the ranging parameters for the scatterer distribution
+# Here we look at core/shell scatterers and use constant shell diameter
+# with variable core diameter
+scatterer = CoreShell(
+    core_diameter=np.geomspace(100e-9, 3000e-9, 5000),  # Geometrically spaced core diameters
+    shell_width=800e-9,  # Shell width of 800 nm
+    core_index=1.6,  # Refractive index of the core
+    shell_material=UsualMaterial.BK7,  # BK7 glass material for the shell
+    medium_index=1,  # Refractive index of the surrounding medium
+    source=source
+)
+
+# %%
+# Defining the experiment setup
+# Integrating the defined source and scatterers into a single experimental setup.
+experiment = Setup(
+    scatterer=scatterer,
+    source=source
+)
+
+# %%
+# Measuring the B1 scattering parameter
+data = experiment.get(measure.b1)
+
+# %%
+# Plotting the results
+# Visualizing how the B1 parameter varies with the core diameter.
+figure = data.plot(
+    x=experiment.core_diameter,  # Core diameter as the x-axis
+    y_scale='linear'  # Linear scale for the y-axis
+)
+
+# %%
+# Displaying the plot
+_ = figure.show()
```

## docs/examples/experiment/plot_coreshell_coupling_vs_corediameter.py

 * *Ordering differences only*

```diff
@@ -1,72 +1,72 @@
-"""
-CoreShell: Coupling vs Diameter
-===============================
-
-This example demonstrates how to compute and visualize the coupling efficiency as a function of core diameter for CoreShell scatterers using PyMieSim.
-"""
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy
-from PyMieSim.experiment.detector import Photodiode
-from PyMieSim.experiment.scatterer import CoreShell
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-from PyMieSim import measure
-from PyOptik import UsualMaterial
-
-# %%
-# Defining the source
-source = Gaussian(
-    wavelength=1.2e-6,  # 1200 nm
-    polarization_value=90,  # Polarization angle in degrees
-    polarization_type='linear',
-    optical_power=1e-3,  # 1 milliwatt
-    NA=0.2  # Numerical Aperture
-)
-
-# %%
-# Defining the scatterer distribution
-scatterer = CoreShell(
-    core_diameter=numpy.geomspace(100e-9, 600e-9, 400),  # Core diameters from 100 nm to 600 nm
-    shell_width=800e-9,  # Shell width of 800 nm
-    core_material=UsualMaterial.Silver,  # Core material
-    shell_material=UsualMaterial.BK7,  # Shell material
-    medium_index=1,  # Surrounding medium's refractive index
-    source=source
-)
-
-# %%
-# Defining the detector
-detector = Photodiode(
-    NA=[0.1, 0.05],  # Numerical Apertures for the detector
-    phi_offset=-180.0,  # Phi offset in degrees
-    gamma_offset=0.0,  # Gamma offset in degrees
-    sampling=600,  # Number of sampling points
-    polarization_filter=None  # No polarization filter
-)
-
-# %%
-# Setting up the experiment
-experiment = Setup(
-    scatterer=scatterer,
-    source=source,
-    detector=detector
-)
-
-# %%
-# Measuring the coupling efficiency
-data = experiment.get(measure.coupling)
-
-# %%
-# Plotting the results
-# Visualizing how the coupling efficiency varies with the core diameter.
-figure = data.plot(
-    x=experiment.core_diameter,  # Core diameter as the x-axis
-    y_scale='linear',  # Linear scale for the y-axis
-    normalize=True,  # Normalizing the results
-)
-
-# %%
-# Displaying the plot
-_ = figure.show()
+"""
+CoreShell: Coupling vs Diameter
+===============================
+
+This example demonstrates how to compute and visualize the coupling efficiency as a function of core diameter for CoreShell scatterers using PyMieSim.
+"""
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy
+from PyMieSim.experiment.detector import Photodiode
+from PyMieSim.experiment.scatterer import CoreShell
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+from PyMieSim import measure
+from PyOptik import UsualMaterial
+
+# %%
+# Defining the source
+source = Gaussian(
+    wavelength=1.2e-6,  # 1200 nm
+    polarization_value=90,  # Polarization angle in degrees
+    polarization_type='linear',
+    optical_power=1e-3,  # 1 milliwatt
+    NA=0.2  # Numerical Aperture
+)
+
+# %%
+# Defining the scatterer distribution
+scatterer = CoreShell(
+    core_diameter=numpy.geomspace(100e-9, 600e-9, 400),  # Core diameters from 100 nm to 600 nm
+    shell_width=800e-9,  # Shell width of 800 nm
+    core_material=UsualMaterial.Silver,  # Core material
+    shell_material=UsualMaterial.BK7,  # Shell material
+    medium_index=1,  # Surrounding medium's refractive index
+    source=source
+)
+
+# %%
+# Defining the detector
+detector = Photodiode(
+    NA=[0.1, 0.05],  # Numerical Apertures for the detector
+    phi_offset=-180.0,  # Phi offset in degrees
+    gamma_offset=0.0,  # Gamma offset in degrees
+    sampling=600,  # Number of sampling points
+    polarization_filter=None  # No polarization filter
+)
+
+# %%
+# Setting up the experiment
+experiment = Setup(
+    scatterer=scatterer,
+    source=source,
+    detector=detector
+)
+
+# %%
+# Measuring the coupling efficiency
+data = experiment.get(measure.coupling)
+
+# %%
+# Plotting the results
+# Visualizing how the coupling efficiency varies with the core diameter.
+figure = data.plot(
+    x=experiment.core_diameter,  # Core diameter as the x-axis
+    y_scale='linear',  # Linear scale for the y-axis
+    normalize=True,  # Normalizing the results
+)
+
+# %%
+# Displaying the plot
+_ = figure.show()
```

## docs/examples/experiment/plot_cylinder_Qabs_vs_diameter.py

 * *Ordering differences only*

```diff
@@ -1,59 +1,59 @@
-"""
-Cylinder: Qabs vs Diameter
-==========================
-
-This example demonstrates how to compute and visualize the scattering efficiency (Qsca) as a function of diameter for cylindrical scatterers using PyMieSim.
-"""
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy as np
-from PyMieSim.experiment.scatterer import Cylinder
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-from PyMieSim import measure
-from PyOptik import UsualMaterial
-
-# %%
-# Defining the source
-source = Gaussian(
-    wavelength=400e-9,  # 400 nm
-    polarization_value=0,  # Linear polarization angle in radians
-    polarization_type='linear',
-    optical_power=1e-3,  # 1 milliwatt
-    NA=0.2  # Numerical Aperture
-)
-
-# %%
-# Defining the scatterer distribution
-scatterer = Cylinder(
-    diameter=np.linspace(1e-9, 800e-9, 300),  # Diameters ranging from 1 nm to 800 nm
-    material=[UsualMaterial.Silver, UsualMaterial.Gold, UsualMaterial.Aluminium],  # Scatterer materials
-    medium_index=1,  # Refractive index of the surrounding medium
-    source=source
-)
-
-# %%
-# Setting up the experiment
-experiment = Setup(
-    scatterer=scatterer,
-    source=source
-)
-
-# %%
-# Measuring the scattering efficiency (Qsca)
-# Note: The original request mentioned Qsca, but the measurement code uses Qabs. 
-# If Qsca measurement is intended, ensure to use the correct measure object from PyMieSim.
-data = experiment.get(measure.Qabs)  # Assuming Qabs was intended, replace with measure.Qsca if needed
-
-# %%
-# Plotting the results
-# Visualizing how the scattering efficiency varies with the cylinder diameter.
-figure = data.plot(
-    x=experiment.diameter,  # Cylinder diameter as the x-axis
-    y_scale="linear"  # Linear scale for the y-axis
-)
-
-# %%
-# Displaying the plot
-_ = figure.show()
+"""
+Cylinder: Qabs vs Diameter
+==========================
+
+This example demonstrates how to compute and visualize the scattering efficiency (Qsca) as a function of diameter for cylindrical scatterers using PyMieSim.
+"""
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy as np
+from PyMieSim.experiment.scatterer import Cylinder
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+from PyMieSim import measure
+from PyOptik import UsualMaterial
+
+# %%
+# Defining the source
+source = Gaussian(
+    wavelength=400e-9,  # 400 nm
+    polarization_value=0,  # Linear polarization angle in radians
+    polarization_type='linear',
+    optical_power=1e-3,  # 1 milliwatt
+    NA=0.2  # Numerical Aperture
+)
+
+# %%
+# Defining the scatterer distribution
+scatterer = Cylinder(
+    diameter=np.linspace(1e-9, 800e-9, 300),  # Diameters ranging from 1 nm to 800 nm
+    material=[UsualMaterial.Silver, UsualMaterial.Gold, UsualMaterial.Aluminium],  # Scatterer materials
+    medium_index=1,  # Refractive index of the surrounding medium
+    source=source
+)
+
+# %%
+# Setting up the experiment
+experiment = Setup(
+    scatterer=scatterer,
+    source=source
+)
+
+# %%
+# Measuring the scattering efficiency (Qsca)
+# Note: The original request mentioned Qsca, but the measurement code uses Qabs. 
+# If Qsca measurement is intended, ensure to use the correct measure object from PyMieSim.
+data = experiment.get(measure.Qabs)  # Assuming Qabs was intended, replace with measure.Qsca if needed
+
+# %%
+# Plotting the results
+# Visualizing how the scattering efficiency varies with the cylinder diameter.
+figure = data.plot(
+    x=experiment.diameter,  # Cylinder diameter as the x-axis
+    y_scale="linear"  # Linear scale for the y-axis
+)
+
+# %%
+# Displaying the plot
+_ = figure.show()
```

## docs/examples/experiment/plot_cylinder_Qsca_vs_diameter.py

 * *Ordering differences only*

```diff
@@ -1,56 +1,56 @@
-"""
-Cylinder: Qsca vs Diameter
-==========================
-
-This example demonstrates how to compute and visualize the scattering efficiency (Qsca) as a function of diameter for cylindrical scatterers using PyMieSim, considering multiple wavelengths.
-"""
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy as np
-from PyMieSim.experiment.scatterer import Cylinder
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-from PyMieSim import measure
-
-# %%
-# Defining the source
-source = Gaussian(
-    wavelength=[500e-9, 1000e-9, 1500e-9],  # Array of wavelengths: 500 nm, 1000 nm, 1500 nm
-    polarization_value=30,  # Polarization angle in degrees
-    polarization_type='linear',
-    optical_power=1e-3,  # 1 milliwatt
-    NA=0.2  # Numerical Aperture
-)
-
-# %%
-# Defining the scatterer distribution
-scatterer = Cylinder(
-    diameter=np.geomspace(6.36e-9, 10000e-9, 1000),  # Diameters ranging from ~6.36 nm to 10000 nm
-    index=[1.4],  # Refractive index of the cylinder
-    medium_index=1,  # Refractive index of the surrounding medium
-    source=source
-)
-
-# %%
-# Setting up the experiment
-experiment = Setup(
-    scatterer=scatterer,
-    source=source
-)
-
-# %%
-# Measuring the scattering efficiency (Qsca)
-data = experiment.get(measure.Qsca)
-
-# %%
-# Plotting the results
-# Visualizing how the Qsca varies with the cylinder diameter.
-figure = data.plot(
-    x=experiment.diameter,  # Cylinder diameter as the x-axis
-    y_scale='linear'  # Linear scale for the y-axis
-)
-
-# %%
-# Displaying the plot
-_ = figure.show()
+"""
+Cylinder: Qsca vs Diameter
+==========================
+
+This example demonstrates how to compute and visualize the scattering efficiency (Qsca) as a function of diameter for cylindrical scatterers using PyMieSim, considering multiple wavelengths.
+"""
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy as np
+from PyMieSim.experiment.scatterer import Cylinder
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+from PyMieSim import measure
+
+# %%
+# Defining the source
+source = Gaussian(
+    wavelength=[500e-9, 1000e-9, 1500e-9],  # Array of wavelengths: 500 nm, 1000 nm, 1500 nm
+    polarization_value=30,  # Polarization angle in degrees
+    polarization_type='linear',
+    optical_power=1e-3,  # 1 milliwatt
+    NA=0.2  # Numerical Aperture
+)
+
+# %%
+# Defining the scatterer distribution
+scatterer = Cylinder(
+    diameter=np.geomspace(6.36e-9, 10000e-9, 1000),  # Diameters ranging from ~6.36 nm to 10000 nm
+    index=[1.4],  # Refractive index of the cylinder
+    medium_index=1,  # Refractive index of the surrounding medium
+    source=source
+)
+
+# %%
+# Setting up the experiment
+experiment = Setup(
+    scatterer=scatterer,
+    source=source
+)
+
+# %%
+# Measuring the scattering efficiency (Qsca)
+data = experiment.get(measure.Qsca)
+
+# %%
+# Plotting the results
+# Visualizing how the Qsca varies with the cylinder diameter.
+figure = data.plot(
+    x=experiment.diameter,  # Cylinder diameter as the x-axis
+    y_scale='linear'  # Linear scale for the y-axis
+)
+
+# %%
+# Displaying the plot
+_ = figure.show()
```

## docs/examples/experiment/plot_cylinder_Qsca_vs_index.py

 * *Ordering differences only*

```diff
@@ -1,56 +1,56 @@
-"""
-Cylinder: Qsca vs Index
-=======================
-
-This example demonstrates how to compute and visualize the scattering efficiency (Qsca) as a function of refractive index for cylindrical scatterers using PyMieSim, considering multiple wavelengths.
-"""
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy as np
-from PyMieSim.experiment.scatterer import Cylinder
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-from PyMieSim import measure
-
-# %%
-# Defining the source
-source = Gaussian(
-    wavelength=[500e-9, 1000e-9, 1500e-9],  # Array of wavelengths: 500 nm, 1000 nm, 1500 nm
-    polarization_value=30,  # Polarization angle in degrees
-    polarization_type='linear',
-    optical_power=1e-3,  # 1 milliwatt
-    NA=0.2  # Numerical Aperture
-)
-
-# %%
-# Defining the scatterer distribution
-scatterer = Cylinder(
-    diameter=800e-9,  # Fixed diameter of 800 nm
-    index=np.linspace(1.3, 1.9, 1500),  # Refractive index ranging from 1.3 to 1.9
-    medium_index=1,  # Refractive index of the surrounding medium
-    source=source
-)
-
-# %%
-# Setting up the experiment
-experiment = Setup(
-    scatterer=scatterer,
-    source=source
-)
-
-# %%
-# Measuring the scattering efficiency (Qsca)
-data = experiment.get(measure.Qsca)
-
-# %%
-# Plotting the results
-# Visualizing how the Qsca varies with the refractive index of the cylinder.
-figure = data.plot(
-    x=experiment.index,  # Refractive index as the x-axis
-    y_scale='linear'  # Linear scale for the y-axis
-)
-
-# %%
-# Displaying the plot
-_ = figure.show()
+"""
+Cylinder: Qsca vs Index
+=======================
+
+This example demonstrates how to compute and visualize the scattering efficiency (Qsca) as a function of refractive index for cylindrical scatterers using PyMieSim, considering multiple wavelengths.
+"""
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy as np
+from PyMieSim.experiment.scatterer import Cylinder
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+from PyMieSim import measure
+
+# %%
+# Defining the source
+source = Gaussian(
+    wavelength=[500e-9, 1000e-9, 1500e-9],  # Array of wavelengths: 500 nm, 1000 nm, 1500 nm
+    polarization_value=30,  # Polarization angle in degrees
+    polarization_type='linear',
+    optical_power=1e-3,  # 1 milliwatt
+    NA=0.2  # Numerical Aperture
+)
+
+# %%
+# Defining the scatterer distribution
+scatterer = Cylinder(
+    diameter=800e-9,  # Fixed diameter of 800 nm
+    index=np.linspace(1.3, 1.9, 1500),  # Refractive index ranging from 1.3 to 1.9
+    medium_index=1,  # Refractive index of the surrounding medium
+    source=source
+)
+
+# %%
+# Setting up the experiment
+experiment = Setup(
+    scatterer=scatterer,
+    source=source
+)
+
+# %%
+# Measuring the scattering efficiency (Qsca)
+data = experiment.get(measure.Qsca)
+
+# %%
+# Plotting the results
+# Visualizing how the Qsca varies with the refractive index of the cylinder.
+figure = data.plot(
+    x=experiment.index,  # Refractive index as the x-axis
+    y_scale='linear'  # Linear scale for the y-axis
+)
+
+# %%
+# Displaying the plot
+_ = figure.show()
```

## docs/examples/experiment/plot_cylinder_Qsca_vs_wavelength.py

 * *Ordering differences only*

```diff
@@ -1,60 +1,60 @@
-"""
-Cylinder: Qsca vs Wavelength
-============================
-
-This example demonstrates how to compute and visualize the scattering efficiency (Qsca) as a function of wavelength for cylindrical scatterers using PyMieSim, considering cylinders with different diameters and refractive indices.
-"""
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy as np
-from PyMieSim.experiment.scatterer import Cylinder
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-from PyMieSim import measure
-
-# %%
-# Defining the source
-# Studying the scattering efficiency across a range of wavelengths.
-source = Gaussian(
-    wavelength=np.linspace(400e-9, 1000e-9, 500),  # Wavelengths ranging from 400 nm to 1000 nm
-    polarization_value=0,  # Linear polarization angle in radians
-    polarization_type='linear',
-    optical_power=1e-3,  # 1 milliwatt
-    NA=0.2  # Numerical Aperture
-)
-
-# %%
-# Defining the scatterer distribution
-# Considering cylinders with specific diameters and refractive indices.
-scatterer = Cylinder(
-    diameter=[200e-9, 150e-9, 100e-9],  # Array of diameters: 200 nm, 150 nm, 100 nm
-    index=[2, 3, 4],  # Array of refractive indices: 2, 3, 4
-    medium_index=1,  # Refractive index of the surrounding medium
-    source=source
-)
-
-# %%
-# Setting up the experiment
-experiment = Setup(
-    scatterer=scatterer,
-    source=source
-)
-
-# %%
-# Measuring the scattering efficiency (Qsca)
-# Averaging the data across the different indices to simplify visualization.
-data = experiment.get(measure.Qsca)
-data = data.mean(experiment.index)
-
-# %%
-# Plotting the results
-# Visualizing how the Qsca varies with wavelength for the given cylinder configurations.
-figure = data.plot(
-    x=experiment.wavelength,  # Wavelength as the x-axis
-    y_scale='linear'  # Linear scale for the y-axis
-)
-
-# %%
-# Displaying the plot
-_ = figure.show()
+"""
+Cylinder: Qsca vs Wavelength
+============================
+
+This example demonstrates how to compute and visualize the scattering efficiency (Qsca) as a function of wavelength for cylindrical scatterers using PyMieSim, considering cylinders with different diameters and refractive indices.
+"""
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy as np
+from PyMieSim.experiment.scatterer import Cylinder
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+from PyMieSim import measure
+
+# %%
+# Defining the source
+# Studying the scattering efficiency across a range of wavelengths.
+source = Gaussian(
+    wavelength=np.linspace(400e-9, 1000e-9, 500),  # Wavelengths ranging from 400 nm to 1000 nm
+    polarization_value=0,  # Linear polarization angle in radians
+    polarization_type='linear',
+    optical_power=1e-3,  # 1 milliwatt
+    NA=0.2  # Numerical Aperture
+)
+
+# %%
+# Defining the scatterer distribution
+# Considering cylinders with specific diameters and refractive indices.
+scatterer = Cylinder(
+    diameter=[200e-9, 150e-9, 100e-9],  # Array of diameters: 200 nm, 150 nm, 100 nm
+    index=[2, 3, 4],  # Array of refractive indices: 2, 3, 4
+    medium_index=1,  # Refractive index of the surrounding medium
+    source=source
+)
+
+# %%
+# Setting up the experiment
+experiment = Setup(
+    scatterer=scatterer,
+    source=source
+)
+
+# %%
+# Measuring the scattering efficiency (Qsca)
+# Averaging the data across the different indices to simplify visualization.
+data = experiment.get(measure.Qsca)
+data = data.mean(experiment.index)
+
+# %%
+# Plotting the results
+# Visualizing how the Qsca varies with wavelength for the given cylinder configurations.
+figure = data.plot(
+    x=experiment.wavelength,  # Wavelength as the x-axis
+    y_scale='linear'  # Linear scale for the y-axis
+)
+
+# %%
+# Displaying the plot
+_ = figure.show()
```

## docs/examples/experiment/plot_cylinder_Qsca_vs_wavelength_std.py

 * *Ordering differences only*

```diff
@@ -1,57 +1,57 @@
-"""
-Cylinder: Qsca vs wavelength std
-================================
-
-"""
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy as np
-
-from PyMieSim.experiment.scatterer import Cylinder
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-
-
-from PyOptik import UsualMaterial
-from PyMieSim import measure
-
-# %%
-# Defining the source to be employed.
-source = Gaussian(
-    wavelength=np.linspace(200e-9, 1800e-9, 300),
-    polarization_value=0,
-    polarization_type='linear',
-    optical_power=1e-3,
-    NA=0.2
-)
-# %%
-# Defining the ranging parameters for the scatterer distribution
-scatterer = Cylinder(
-    diameter=np.linspace(400e-9, 1400e-9, 10),
-    material=UsualMaterial.Silver,
-    medium_index=1,
-    source=source
-)
-
-
-# %%
-# Defining the experiment setup
-experiment = Setup(
-    scatterer=scatterer,
-    source=source
-)
-
-# %%
-# Measuring the properties
-data = experiment.get(measure.Qsca)
-
-# %%
-# Plotting the results
-figure = data.plot(
-    x=experiment.wavelength,
-    y_scale='log',
-    std=experiment.diameter
-)
-
-_ = figure.show()
+"""
+Cylinder: Qsca vs wavelength std
+================================
+
+"""
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy as np
+
+from PyMieSim.experiment.scatterer import Cylinder
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+
+
+from PyOptik import UsualMaterial
+from PyMieSim import measure
+
+# %%
+# Defining the source to be employed.
+source = Gaussian(
+    wavelength=np.linspace(200e-9, 1800e-9, 300),
+    polarization_value=0,
+    polarization_type='linear',
+    optical_power=1e-3,
+    NA=0.2
+)
+# %%
+# Defining the ranging parameters for the scatterer distribution
+scatterer = Cylinder(
+    diameter=np.linspace(400e-9, 1400e-9, 10),
+    material=UsualMaterial.Silver,
+    medium_index=1,
+    source=source
+)
+
+
+# %%
+# Defining the experiment setup
+experiment = Setup(
+    scatterer=scatterer,
+    source=source
+)
+
+# %%
+# Measuring the properties
+data = experiment.get(measure.Qsca)
+
+# %%
+# Plotting the results
+figure = data.plot(
+    x=experiment.wavelength,
+    y_scale='log',
+    std=experiment.diameter
+)
+
+_ = figure.show()
```

## docs/examples/experiment/plot_cylinder_a11_vs_diameter.py

 * *Ordering differences only*

```diff
@@ -1,56 +1,56 @@
-"""
-Cylinder: A1 Scattering Coefficient
-===================================
-
-This example demonstrates how to compute and visualize the A1 scattering coefficient as a function of diameter for cylindrical scatterers using PyMieSim.
-"""
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy as np
-from PyMieSim.experiment.scatterer import Cylinder
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-from PyMieSim import measure
-
-# %%
-# Defining the source
-source = Gaussian(
-    wavelength=400e-9,  # 400 nm
-    polarization_value=90,  # Polarization angle in degrees
-    polarization_type='linear',
-    optical_power=1e-3,  # 1 milliwatt
-    NA=0.2  # Numerical Aperture
-)
-
-# %%
-# Defining the scatterer distribution
-scatterer = Cylinder(
-    diameter=np.linspace(100e-9, 10000e-9, 800),  # Diameters ranging from 100 nm to 10000 nm
-    index=1.4,  # Refractive index of the cylinder
-    medium_index=1,  # Refractive index of the surrounding medium
-    source=source
-)
-
-# %%
-# Setting up the experiment
-experiment = Setup(
-    scatterer=scatterer,
-    source=source
-)
-
-# %%
-# Measuring the A1 scattering coefficient
-# Note: The original request was for "a21"; assuming it meant A1, as "a21" might be a typo.
-data = experiment.get(measure.a21)
-
-# %%
-# Plotting the results
-# Visualizing how the A1 scattering coefficient varies with the cylinder diameter.
-figure = data.plot(
-    x=experiment.diameter  # Cylinder diameter as the x-axis
-)
-
-# %%
-# Displaying the plot
-_ = figure.show()
+"""
+Cylinder: A1 Scattering Coefficient
+===================================
+
+This example demonstrates how to compute and visualize the A1 scattering coefficient as a function of diameter for cylindrical scatterers using PyMieSim.
+"""
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy as np
+from PyMieSim.experiment.scatterer import Cylinder
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+from PyMieSim import measure
+
+# %%
+# Defining the source
+source = Gaussian(
+    wavelength=400e-9,  # 400 nm
+    polarization_value=90,  # Polarization angle in degrees
+    polarization_type='linear',
+    optical_power=1e-3,  # 1 milliwatt
+    NA=0.2  # Numerical Aperture
+)
+
+# %%
+# Defining the scatterer distribution
+scatterer = Cylinder(
+    diameter=np.linspace(100e-9, 10000e-9, 800),  # Diameters ranging from 100 nm to 10000 nm
+    index=1.4,  # Refractive index of the cylinder
+    medium_index=1,  # Refractive index of the surrounding medium
+    source=source
+)
+
+# %%
+# Setting up the experiment
+experiment = Setup(
+    scatterer=scatterer,
+    source=source
+)
+
+# %%
+# Measuring the A1 scattering coefficient
+# Note: The original request was for "a21"; assuming it meant A1, as "a21" might be a typo.
+data = experiment.get(measure.a21)
+
+# %%
+# Plotting the results
+# Visualizing how the A1 scattering coefficient varies with the cylinder diameter.
+figure = data.plot(
+    x=experiment.diameter  # Cylinder diameter as the x-axis
+)
+
+# %%
+# Displaying the plot
+_ = figure.show()
```

## docs/examples/experiment/plot_cylinder_b11_vs_diameter.py

 * *Ordering differences only*

```diff
@@ -1,55 +1,55 @@
-"""
-Cylinder: B1 Scattering Coefficient
-===================================
-
-This example demonstrates how to compute and visualize the B1 scattering coefficient as a function of diameter for cylindrical scatterers using PyMieSim.
-"""
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy as np
-from PyMieSim.experiment.scatterer import Cylinder
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-from PyMieSim import measure
-
-# %%
-# Defining the source
-source = Gaussian(
-    wavelength=400e-9,  # 400 nm
-    polarization_value=0,  # Linear polarization angle in radians
-    polarization_type='linear',
-    optical_power=1e-3,  # 1 milliwatt
-    NA=0.2  # Numerical Aperture
-)
-
-# %%
-# Defining the scatterer distribution
-scatterer = Cylinder(
-    diameter=np.linspace(100e-9, 10000e-9, 800),  # Diameters ranging from 100 nm to 10000 nm
-    index=1.4,  # Refractive index of the cylinder
-    medium_index=1,  # Refractive index of the surrounding medium
-    source=source
-)
-
-# %%
-# Setting up the experiment
-experiment = Setup(
-    scatterer=scatterer,
-    source=source
-)
-
-# %%
-# Measuring the B1 scattering coefficient
-data = experiment.get(measure.b11)
-
-# %%
-# Plotting the results
-# Visualizing how the B1 scattering coefficient varies with the cylinder diameter.
-figure = data.plot(
-    x=experiment.diameter  # Cylinder diameter as the x-axis
-)
-
-# %%
-# Displaying the plot
-_ = figure.show()
+"""
+Cylinder: B1 Scattering Coefficient
+===================================
+
+This example demonstrates how to compute and visualize the B1 scattering coefficient as a function of diameter for cylindrical scatterers using PyMieSim.
+"""
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy as np
+from PyMieSim.experiment.scatterer import Cylinder
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+from PyMieSim import measure
+
+# %%
+# Defining the source
+source = Gaussian(
+    wavelength=400e-9,  # 400 nm
+    polarization_value=0,  # Linear polarization angle in radians
+    polarization_type='linear',
+    optical_power=1e-3,  # 1 milliwatt
+    NA=0.2  # Numerical Aperture
+)
+
+# %%
+# Defining the scatterer distribution
+scatterer = Cylinder(
+    diameter=np.linspace(100e-9, 10000e-9, 800),  # Diameters ranging from 100 nm to 10000 nm
+    index=1.4,  # Refractive index of the cylinder
+    medium_index=1,  # Refractive index of the surrounding medium
+    source=source
+)
+
+# %%
+# Setting up the experiment
+experiment = Setup(
+    scatterer=scatterer,
+    source=source
+)
+
+# %%
+# Measuring the B1 scattering coefficient
+data = experiment.get(measure.b11)
+
+# %%
+# Plotting the results
+# Visualizing how the B1 scattering coefficient varies with the cylinder diameter.
+figure = data.plot(
+    x=experiment.diameter  # Cylinder diameter as the x-axis
+)
+
+# %%
+# Displaying the plot
+_ = figure.show()
```

## docs/examples/experiment/plot_cylinder_coupling_vs_diameter.py

 * *Ordering differences only*

```diff
@@ -1,70 +1,70 @@
-"""
-Cylinder: Coupling vs Diameter
-==============================
-
-This example demonstrates how to compute and visualize the coupling efficiency as a function of diameter for cylindrical scatterers using PyMieSim.
-"""
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy as np
-from PyMieSim.experiment.detector import Photodiode
-from PyMieSim.experiment.scatterer import Cylinder
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-from PyMieSim import measure
-from PyOptik import UsualMaterial
-
-# %%
-# Defining the source
-source = Gaussian(
-    wavelength=1.2e-6,  # 1200 nm
-    polarization_value=90,  # Polarization angle in degrees
-    polarization_type='linear',
-    optical_power=1e-3,  # 1 milliwatt
-    NA=0.2  # Numerical Aperture
-)
-
-# %%
-# Defining the scatterer distribution
-scatterer = Cylinder(
-    diameter=np.linspace(100e-9, 3000e-9, 200),  # Diameters ranging from 100 nm to 3000 nm
-    material=UsualMaterial.BK7,  # Material of the cylinder
-    medium_index=1.0,  # Refractive index of the surrounding medium
-    source=source
-)
-
-# %%
-# Defining the detector
-detector = Photodiode(
-    NA=[0.1, 0.05],  # Numerical Apertures for the detector
-    phi_offset=-180.0,  # Phi offset in degrees
-    gamma_offset=0.0,  # Gamma offset in degrees
-    sampling=600,  # Number of sampling points
-    polarization_filter=None  # No polarization filter
-)
-
-# %%
-# Setting up the experiment
-experiment = Setup(
-    scatterer=scatterer,
-    source=source,
-    detector=detector
-)
-
-# %%
-# Measuring the coupling efficiency
-data = experiment.get(measure.coupling)
-
-# %%
-# Plotting the results
-# Visualizing how the coupling efficiency varies with the cylinder diameter.
-figure = data.plot(
-    x=experiment.diameter,  # Cylinder diameter as the x-axis
-    y_scale='linear',  # Linear scale for the y-axis
-    normalize=True  # Normalizing the results
-)
-
-# %%
-# Displaying the plot
-_ = figure.show()
+"""
+Cylinder: Coupling vs Diameter
+==============================
+
+This example demonstrates how to compute and visualize the coupling efficiency as a function of diameter for cylindrical scatterers using PyMieSim.
+"""
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy as np
+from PyMieSim.experiment.detector import Photodiode
+from PyMieSim.experiment.scatterer import Cylinder
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+from PyMieSim import measure
+from PyOptik import UsualMaterial
+
+# %%
+# Defining the source
+source = Gaussian(
+    wavelength=1.2e-6,  # 1200 nm
+    polarization_value=90,  # Polarization angle in degrees
+    polarization_type='linear',
+    optical_power=1e-3,  # 1 milliwatt
+    NA=0.2  # Numerical Aperture
+)
+
+# %%
+# Defining the scatterer distribution
+scatterer = Cylinder(
+    diameter=np.linspace(100e-9, 3000e-9, 200),  # Diameters ranging from 100 nm to 3000 nm
+    material=UsualMaterial.BK7,  # Material of the cylinder
+    medium_index=1.0,  # Refractive index of the surrounding medium
+    source=source
+)
+
+# %%
+# Defining the detector
+detector = Photodiode(
+    NA=[0.1, 0.05],  # Numerical Apertures for the detector
+    phi_offset=-180.0,  # Phi offset in degrees
+    gamma_offset=0.0,  # Gamma offset in degrees
+    sampling=600,  # Number of sampling points
+    polarization_filter=None  # No polarization filter
+)
+
+# %%
+# Setting up the experiment
+experiment = Setup(
+    scatterer=scatterer,
+    source=source,
+    detector=detector
+)
+
+# %%
+# Measuring the coupling efficiency
+data = experiment.get(measure.coupling)
+
+# %%
+# Plotting the results
+# Visualizing how the coupling efficiency varies with the cylinder diameter.
+figure = data.plot(
+    x=experiment.diameter,  # Cylinder diameter as the x-axis
+    y_scale='linear',  # Linear scale for the y-axis
+    normalize=True  # Normalizing the results
+)
+
+# %%
+# Displaying the plot
+_ = figure.show()
```

## docs/examples/experiment/plot_cylinder_coupling_vs_phioffset.py

 * *Ordering differences only*

```diff
@@ -1,70 +1,70 @@
-"""
-Cylinder: Goniometer
-====================
-
-This example demonstrates how to use a goniometer setup to measure and visualize the coupling efficiency as a function of angular displacement for cylindrical scatterers using PyMieSim.
-"""
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy as np
-from PyMieSim.experiment.detector import Photodiode
-from PyMieSim.experiment.scatterer import Cylinder
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-from PyOptik import UsualMaterial
-from PyMieSim import measure
-
-# %%
-# Defining the source
-source = Gaussian(
-    wavelength=1.2e-6,  # 1200 nm
-    polarization_value=90,  # Polarization angle in degrees
-    polarization_type='linear',
-    optical_power=1e-3,  # 1 milliwatt
-    NA=0.2  # Numerical Aperture
-)
-
-# %%
-# Defining the scatterer distribution
-scatterer = Cylinder(
-    diameter=2e-6,  # 2000 nm
-    material=UsualMaterial.BK7,  # Material of the cylinder
-    medium_index=1,  # Refractive index of the surrounding medium
-    source=source
-)
-
-# %%
-# Defining the detector
-detector = Photodiode(
-    NA=[0.5, 0.3, 0.1, 0.05],  # Array of Numerical Apertures for the detector
-    phi_offset=np.linspace(-180, 180, 400),  # Angular displacement from -180 to 180 degrees
-    gamma_offset=0,  # Gamma offset in degrees
-    sampling=400,  # Number of sampling points
-    polarization_filter=None  # No polarization filter
-)
-
-# %%
-# Setting up the experiment
-experiment = Setup(
-    scatterer=scatterer,
-    source=source,
-    detector=detector
-)
-
-# %%
-# Measuring the coupling efficiency
-data = experiment.get(measure.coupling)
-
-# %%
-# Plotting the results
-# Visualizing how the coupling efficiency varies with angular displacement.
-figure = data.plot(
-    x=experiment.phi_offset,  # Angular displacement as the x-axis
-    y_scale='log',  # Logarithmic scale for the y-axis
-    normalize=True  # Normalizing the results
-)
-
-# %%
-# Displaying the plot
-_ = figure.show()
+"""
+Cylinder: Goniometer
+====================
+
+This example demonstrates how to use a goniometer setup to measure and visualize the coupling efficiency as a function of angular displacement for cylindrical scatterers using PyMieSim.
+"""
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy as np
+from PyMieSim.experiment.detector import Photodiode
+from PyMieSim.experiment.scatterer import Cylinder
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+from PyOptik import UsualMaterial
+from PyMieSim import measure
+
+# %%
+# Defining the source
+source = Gaussian(
+    wavelength=1.2e-6,  # 1200 nm
+    polarization_value=90,  # Polarization angle in degrees
+    polarization_type='linear',
+    optical_power=1e-3,  # 1 milliwatt
+    NA=0.2  # Numerical Aperture
+)
+
+# %%
+# Defining the scatterer distribution
+scatterer = Cylinder(
+    diameter=2e-6,  # 2000 nm
+    material=UsualMaterial.BK7,  # Material of the cylinder
+    medium_index=1,  # Refractive index of the surrounding medium
+    source=source
+)
+
+# %%
+# Defining the detector
+detector = Photodiode(
+    NA=[0.5, 0.3, 0.1, 0.05],  # Array of Numerical Apertures for the detector
+    phi_offset=np.linspace(-180, 180, 400),  # Angular displacement from -180 to 180 degrees
+    gamma_offset=0,  # Gamma offset in degrees
+    sampling=400,  # Number of sampling points
+    polarization_filter=None  # No polarization filter
+)
+
+# %%
+# Setting up the experiment
+experiment = Setup(
+    scatterer=scatterer,
+    source=source,
+    detector=detector
+)
+
+# %%
+# Measuring the coupling efficiency
+data = experiment.get(measure.coupling)
+
+# %%
+# Plotting the results
+# Visualizing how the coupling efficiency varies with angular displacement.
+figure = data.plot(
+    x=experiment.phi_offset,  # Angular displacement as the x-axis
+    y_scale='log',  # Logarithmic scale for the y-axis
+    normalize=True  # Normalizing the results
+)
+
+# %%
+# Displaying the plot
+_ = figure.show()
```

## docs/examples/experiment/plot_cylinder_coupling_vs_wavelength.py

 * *Ordering differences only*

```diff
@@ -1,72 +1,72 @@
-"""
-Cylinder: Coupling vs Wavelength
-================================
-
-This example demonstrates how to compute and visualize the coupling efficiency as a function of wavelength for cylindrical scatterers using PyMieSim.
-"""
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy as np
-from PyMieSim.experiment.detector import CoherentMode
-from PyMieSim.experiment.scatterer import Cylinder
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-from PyMieSim import measure
-from PyOptik import UsualMaterial
-
-# %%
-# Defining the source
-source = Gaussian(
-    wavelength=np.linspace(950e-9, 1050e-9, 300),  # Wavelengths ranging from 950 nm to 1050 nm
-    polarization_value=0,  # Linear polarization angle in radians
-    polarization_type='linear',
-    optical_power=1e-3,  # 1 milliwatt
-    NA=0.2  # Numerical Aperture
-)
-
-# %%
-# Defining the scatterer distribution
-# Here we look at cylinders with a set diameter, refractive index, and medium.
-scatterer = Cylinder(
-    diameter=np.linspace(100e-9, 8000e-9, 5),  # Diameters ranging from 100 nm to 8000 nm
-    material=UsualMaterial.BK7,  # Material of the cylinder
-    medium_index=1,  # Refractive index of the surrounding medium
-    source=source
-)
-
-# %%
-# Defining the detector
-detector = CoherentMode(
-    mode_number="LP11",  # Specifying the LP11 mode
-    NA=[0.05, 0.01],  # Array of Numerical Apertures for the detector
-    phi_offset=-180,  # Phi offset in degrees
-    gamma_offset=0,  # Gamma offset in degrees
-    polarization_filter=None,  # No polarization filter
-    sampling=300,  # Number of sampling points
-    rotation=0,  # Rotation of the mode field
-)
-
-# %%
-# Setting up the experiment
-experiment = Setup(
-    scatterer=scatterer,
-    source=source,
-    detector=detector
-)
-
-# %%
-# Measuring the coupling efficiency
-data = experiment.get(measure.coupling)
-
-# %%
-# Plotting the results
-# Visualizing how the coupling efficiency varies with the wavelength.
-figure = data.plot(
-    x=experiment.wavelength,  # Wavelength as the x-axis
-    std=experiment.diameter  # Standard deviation with respect to cylinder diameter
-)
-
-# %%
-# Displaying the plot
-_ = figure.show()
+"""
+Cylinder: Coupling vs Wavelength
+================================
+
+This example demonstrates how to compute and visualize the coupling efficiency as a function of wavelength for cylindrical scatterers using PyMieSim.
+"""
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy as np
+from PyMieSim.experiment.detector import CoherentMode
+from PyMieSim.experiment.scatterer import Cylinder
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+from PyMieSim import measure
+from PyOptik import UsualMaterial
+
+# %%
+# Defining the source
+source = Gaussian(
+    wavelength=np.linspace(950e-9, 1050e-9, 300),  # Wavelengths ranging from 950 nm to 1050 nm
+    polarization_value=0,  # Linear polarization angle in radians
+    polarization_type='linear',
+    optical_power=1e-3,  # 1 milliwatt
+    NA=0.2  # Numerical Aperture
+)
+
+# %%
+# Defining the scatterer distribution
+# Here we look at cylinders with a set diameter, refractive index, and medium.
+scatterer = Cylinder(
+    diameter=np.linspace(100e-9, 8000e-9, 5),  # Diameters ranging from 100 nm to 8000 nm
+    material=UsualMaterial.BK7,  # Material of the cylinder
+    medium_index=1,  # Refractive index of the surrounding medium
+    source=source
+)
+
+# %%
+# Defining the detector
+detector = CoherentMode(
+    mode_number="LP11",  # Specifying the LP11 mode
+    NA=[0.05, 0.01],  # Array of Numerical Apertures for the detector
+    phi_offset=-180,  # Phi offset in degrees
+    gamma_offset=0,  # Gamma offset in degrees
+    polarization_filter=None,  # No polarization filter
+    sampling=300,  # Number of sampling points
+    rotation=0,  # Rotation of the mode field
+)
+
+# %%
+# Setting up the experiment
+experiment = Setup(
+    scatterer=scatterer,
+    source=source,
+    detector=detector
+)
+
+# %%
+# Measuring the coupling efficiency
+data = experiment.get(measure.coupling)
+
+# %%
+# Plotting the results
+# Visualizing how the coupling efficiency varies with the wavelength.
+figure = data.plot(
+    x=experiment.wavelength,  # Wavelength as the x-axis
+    std=experiment.diameter  # Standard deviation with respect to cylinder diameter
+)
+
+# %%
+# Displaying the plot
+_ = figure.show()
```

## docs/examples/experiment/plot_sphere_Qabs_vs_diameter.py

 * *Ordering differences only*

```diff
@@ -1,53 +1,53 @@
-"""
-Sphere: Qsca vs diameter
-========================
-
-"""
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy as np
-
-from PyMieSim.experiment.scatterer import Sphere
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-from PyOptik import UsualMaterial
-from PyMieSim import measure
-
-# %%
-# Defining the source to be employed.
-source = Gaussian(
-    wavelength=400e-9,
-    polarization_value=0,
-    polarization_type='linear',
-    optical_power=1e-3,
-    NA=0.2
-)
-# %%
-# Defining the ranging parameters for the scatterer distribution
-scatterer = Sphere(
-    diameter=np.linspace(1e-09, 800e-9, 300),
-    material=[UsualMaterial.Silver, UsualMaterial.Gold, UsualMaterial.Aluminium],
-    medium_index=1,
-    source=source
-)
-
-# %%
-# Defining the experiment setup
-experiment = Setup(
-    scatterer=scatterer,
-    source=source
-)
-
-# %%
-# Measuring the properties
-data = experiment.get(measure.Qabs)
-
-# %%
-# Plotting the results
-figure = data.plot(
-    x=experiment.diameter,
-    y_scale="log"
-)
-
-_ = figure.show()
+"""
+Sphere: Qsca vs diameter
+========================
+
+"""
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy as np
+
+from PyMieSim.experiment.scatterer import Sphere
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+from PyOptik import UsualMaterial
+from PyMieSim import measure
+
+# %%
+# Defining the source to be employed.
+source = Gaussian(
+    wavelength=400e-9,
+    polarization_value=0,
+    polarization_type='linear',
+    optical_power=1e-3,
+    NA=0.2
+)
+# %%
+# Defining the ranging parameters for the scatterer distribution
+scatterer = Sphere(
+    diameter=np.linspace(1e-09, 800e-9, 300),
+    material=[UsualMaterial.Silver, UsualMaterial.Gold, UsualMaterial.Aluminium],
+    medium_index=1,
+    source=source
+)
+
+# %%
+# Defining the experiment setup
+experiment = Setup(
+    scatterer=scatterer,
+    source=source
+)
+
+# %%
+# Measuring the properties
+data = experiment.get(measure.Qabs)
+
+# %%
+# Plotting the results
+figure = data.plot(
+    x=experiment.diameter,
+    y_scale="log"
+)
+
+_ = figure.show()
```

## docs/examples/experiment/plot_sphere_Qsca_vs_diameter.py

 * *Ordering differences only*

```diff
@@ -1,51 +1,51 @@
-"""
-Sphere: Qsca vs diameter
-========================
-
-"""
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy as np
-
-from PyMieSim.experiment.scatterer import Sphere
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-from PyMieSim import measure
-
-# %%
-# Defining the source to be employed.
-source = Gaussian(
-    wavelength=[500e-9, 1000e-9, 1500e-9],
-    polarization_value=30,
-    polarization_type='linear',
-    optical_power=1e-3,
-    NA=0.2
-)
-# %%
-# Defining the ranging parameters for the scatterer distribution
-scatterer = Sphere(
-    diameter=np.geomspace(6.36e-09, 10000e-9, 1500),
-    index=1.4,
-    medium_index=1,
-    source=source
-)
-
-# %%
-# Defining the experiment setup
-experiment = Setup(
-    scatterer=scatterer,
-    source=source
-)
-
-# %%
-# Measuring the properties
-data = experiment.get(measure.Csca)
-
-# %%
-# Plotting the results
-figure = data.plot(
-    x=experiment.diameter
-)
-
-_ = figure.show()
+"""
+Sphere: Qsca vs diameter
+========================
+
+"""
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy as np
+
+from PyMieSim.experiment.scatterer import Sphere
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+from PyMieSim import measure
+
+# %%
+# Defining the source to be employed.
+source = Gaussian(
+    wavelength=[500e-9, 1000e-9, 1500e-9],
+    polarization_value=30,
+    polarization_type='linear',
+    optical_power=1e-3,
+    NA=0.2
+)
+# %%
+# Defining the ranging parameters for the scatterer distribution
+scatterer = Sphere(
+    diameter=np.geomspace(6.36e-09, 10000e-9, 1500),
+    index=1.4,
+    medium_index=1,
+    source=source
+)
+
+# %%
+# Defining the experiment setup
+experiment = Setup(
+    scatterer=scatterer,
+    source=source
+)
+
+# %%
+# Measuring the properties
+data = experiment.get(measure.Csca)
+
+# %%
+# Plotting the results
+figure = data.plot(
+    x=experiment.diameter
+)
+
+_ = figure.show()
```

## docs/examples/experiment/plot_sphere_Qsca_vs_index.py

 * *Ordering differences only*

```diff
@@ -1,51 +1,51 @@
-"""
-Sphere: Qsca vs index
-=====================
-
-"""
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy as np
-
-from PyMieSim.experiment.scatterer import Sphere
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-from PyMieSim import measure
-
-# %%
-# Defining the source to be employed.
-source = Gaussian(
-    wavelength=[500e-9, 1000e-9, 1500e-9],
-    polarization_value=30,
-    polarization_type='linear',
-    optical_power=1e-3,
-    NA=0.2
-)
-# %%
-# Defining the ranging parameters for the scatterer distribution
-scatterer = Sphere(
-    diameter=800e-9,
-    index=np.linspace(1.3, 1.9, 1500),
-    medium_index=1,
-    source=source
-)
-
-# %%
-# Defining the experiment setup
-experiment = Setup(
-    scatterer=scatterer,
-    source=source
-)
-
-# %%
-# Measuring the properties
-data = experiment.get(measure.Qsca)
-
-# %%
-# Plotting the results
-figure = data.plot(
-    x=experiment.index
-)
-
-_ = figure.show()
+"""
+Sphere: Qsca vs index
+=====================
+
+"""
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy as np
+
+from PyMieSim.experiment.scatterer import Sphere
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+from PyMieSim import measure
+
+# %%
+# Defining the source to be employed.
+source = Gaussian(
+    wavelength=[500e-9, 1000e-9, 1500e-9],
+    polarization_value=30,
+    polarization_type='linear',
+    optical_power=1e-3,
+    NA=0.2
+)
+# %%
+# Defining the ranging parameters for the scatterer distribution
+scatterer = Sphere(
+    diameter=800e-9,
+    index=np.linspace(1.3, 1.9, 1500),
+    medium_index=1,
+    source=source
+)
+
+# %%
+# Defining the experiment setup
+experiment = Setup(
+    scatterer=scatterer,
+    source=source
+)
+
+# %%
+# Measuring the properties
+data = experiment.get(measure.Qsca)
+
+# %%
+# Plotting the results
+figure = data.plot(
+    x=experiment.index
+)
+
+_ = figure.show()
```

## docs/examples/experiment/plot_sphere_Qsca_vs_wavelength.py

 * *Ordering differences only*

```diff
@@ -1,51 +1,51 @@
-"""
-Sphere: Qsca vs wavelength mean
-===============================
-
-"""
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy as np
-
-from PyMieSim.experiment.scatterer import Sphere
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-from PyMieSim import measure
-
-# %%
-# Defining the source to be employed.
-source = Gaussian(
-    wavelength=np.linspace(400e-9, 1000e-9, 500),
-    polarization_value=0,
-    polarization_type='linear',
-    optical_power=1e-3,
-    NA=0.2
-)
-# %%
-# Defining the ranging parameters for the scatterer distribution
-scatterer = Sphere(
-    diameter=[200e-9, 150e-9, 100e-9],
-    index=[2, 4],
-    medium_index=1,
-    source=source
-)
-
-# %%
-# Defining the experiment setup
-experiment = Setup(
-    scatterer=scatterer,
-    source=source
-)
-
-# %%
-# Measuring the properties
-data = experiment.get(measure.Csca)
-
-# %%
-# Plotting the results
-figure = data.plot(
-    x=experiment.wavelength
-)
-
-_ = figure.show()
+"""
+Sphere: Qsca vs wavelength mean
+===============================
+
+"""
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy as np
+
+from PyMieSim.experiment.scatterer import Sphere
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+from PyMieSim import measure
+
+# %%
+# Defining the source to be employed.
+source = Gaussian(
+    wavelength=np.linspace(400e-9, 1000e-9, 500),
+    polarization_value=0,
+    polarization_type='linear',
+    optical_power=1e-3,
+    NA=0.2
+)
+# %%
+# Defining the ranging parameters for the scatterer distribution
+scatterer = Sphere(
+    diameter=[200e-9, 150e-9, 100e-9],
+    index=[2, 4],
+    medium_index=1,
+    source=source
+)
+
+# %%
+# Defining the experiment setup
+experiment = Setup(
+    scatterer=scatterer,
+    source=source
+)
+
+# %%
+# Measuring the properties
+data = experiment.get(measure.Csca)
+
+# %%
+# Plotting the results
+figure = data.plot(
+    x=experiment.wavelength
+)
+
+_ = figure.show()
```

## docs/examples/experiment/plot_sphere_Qsca_vs_wavelength_std.py

 * *Ordering differences only*

```diff
@@ -1,57 +1,57 @@
-"""
-Sphere: Qsca vs wavelength STD
-==============================
-
-"""
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy as np
-
-from PyMieSim.experiment.scatterer import Sphere
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-from PyOptik import UsualMaterial
-from PyMieSim import measure
-
-# %%
-# Defining the source to be employed.
-source = Gaussian(
-    wavelength=np.linspace(200e-9, 1800e-9, 300),
-    polarization_value=0,
-    polarization_type='linear',
-    optical_power=1e-3,
-    NA=0.2
-)
-# %%
-# Defining the ranging parameters for the scatterer distribution
-scatterer = Sphere(
-    diameter=np.linspace(400e-9, 1400e-9, 10),
-    material=UsualMaterial.Silver,
-    medium_index=1,
-    source=source
-)
-
-
-# %%
-# Defining the experiment setup
-experiment = Setup(
-    scatterer=scatterer,
-    source=source
-)
-
-# %%
-# Measuring the properties
-data = experiment.get(measure.Qsca)
-
-# %%
-# Plotting the results
-figure = data.plot(
-    x=experiment.wavelength,
-    y_scale='log',
-    std=experiment.diameter
-)
-
-_ = figure.show()
-
-# -
+"""
+Sphere: Qsca vs wavelength STD
+==============================
+
+"""
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy as np
+
+from PyMieSim.experiment.scatterer import Sphere
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+from PyOptik import UsualMaterial
+from PyMieSim import measure
+
+# %%
+# Defining the source to be employed.
+source = Gaussian(
+    wavelength=np.linspace(200e-9, 1800e-9, 300),
+    polarization_value=0,
+    polarization_type='linear',
+    optical_power=1e-3,
+    NA=0.2
+)
+# %%
+# Defining the ranging parameters for the scatterer distribution
+scatterer = Sphere(
+    diameter=np.linspace(400e-9, 1400e-9, 10),
+    material=UsualMaterial.Silver,
+    medium_index=1,
+    source=source
+)
+
+
+# %%
+# Defining the experiment setup
+experiment = Setup(
+    scatterer=scatterer,
+    source=source
+)
+
+# %%
+# Measuring the properties
+data = experiment.get(measure.Qsca)
+
+# %%
+# Plotting the results
+figure = data.plot(
+    x=experiment.wavelength,
+    y_scale='log',
+    std=experiment.diameter
+)
+
+_ = figure.show()
+
+# -
```

## docs/examples/experiment/plot_sphere_a1_vs_diameter.py

 * *Ordering differences only*

```diff
@@ -1,53 +1,53 @@
-"""
-Sphere: A1 scattering coefficient
-===================================
-
-"""
-
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy as np
-
-from PyMieSim.experiment.scatterer import Sphere
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-
-from PyMieSim import measure
-
-# %%
-# Defining the source to be employed.
-source = Gaussian(
-    wavelength=400e-9,
-    polarization_value=0,
-    polarization_type='linear',
-    optical_power=1e-3,
-    NA=0.2
-)
-# %%
-# Defining the ranging parameters for the scatterer distribution
-scatterer = Sphere(
-    diameter=np.linspace(100e-9, 10000e-9, 1000),
-    index=1.4,
-    medium_index=1,
-    source=source
-)
-
-# %%
-# Defining the experiment setup
-experiment = Setup(
-    scatterer=scatterer,
-    source=source
-)
-
-# %%
-# Measuring the properties
-data = experiment.get(measure.a1)
-
-# %%
-# Plotting the results
-figure = data.plot(
-    x=experiment.diameter
-)
-
-_ = figure.show()
+"""
+Sphere: A1 scattering coefficient
+===================================
+
+"""
+
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy as np
+
+from PyMieSim.experiment.scatterer import Sphere
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+
+from PyMieSim import measure
+
+# %%
+# Defining the source to be employed.
+source = Gaussian(
+    wavelength=400e-9,
+    polarization_value=0,
+    polarization_type='linear',
+    optical_power=1e-3,
+    NA=0.2
+)
+# %%
+# Defining the ranging parameters for the scatterer distribution
+scatterer = Sphere(
+    diameter=np.linspace(100e-9, 10000e-9, 1000),
+    index=1.4,
+    medium_index=1,
+    source=source
+)
+
+# %%
+# Defining the experiment setup
+experiment = Setup(
+    scatterer=scatterer,
+    source=source
+)
+
+# %%
+# Measuring the properties
+data = experiment.get(measure.a1)
+
+# %%
+# Plotting the results
+figure = data.plot(
+    x=experiment.diameter
+)
+
+_ = figure.show()
```

## docs/examples/experiment/plot_sphere_b1_vs_diameter.py

 * *Ordering differences only*

```diff
@@ -1,53 +1,53 @@
-"""
-Sphere: B1 scattering coefficient
-=================================
-
-"""
-
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy as np
-
-from PyMieSim.experiment.scatterer import Sphere
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-
-from PyMieSim import measure
-
-# %%
-# Defining the source to be employed.
-source = Gaussian(
-    wavelength=400e-9,
-    polarization_value=0,
-    polarization_type='linear',
-    optical_power=1e-3,
-    NA=0.2
-)
-# %%
-# Defining the ranging parameters for the scatterer distribution
-scatterer = Sphere(
-    diameter=np.linspace(100e-9, 10000e-9, 800),
-    index=1.4,
-    medium_index=1,
-    source=source
-)
-
-# %%
-# Defining the experiment setup
-experiment = Setup(
-    scatterer=scatterer,
-    source=source
-)
-
-# %%
-# Measuring the properties
-data = experiment.get(measure.b1)
-
-# %%
-# Plotting the results
-figure = data.plot(
-    x=experiment.diameter
-)
-
-_ = figure.show()
+"""
+Sphere: B1 scattering coefficient
+=================================
+
+"""
+
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy as np
+
+from PyMieSim.experiment.scatterer import Sphere
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+
+from PyMieSim import measure
+
+# %%
+# Defining the source to be employed.
+source = Gaussian(
+    wavelength=400e-9,
+    polarization_value=0,
+    polarization_type='linear',
+    optical_power=1e-3,
+    NA=0.2
+)
+# %%
+# Defining the ranging parameters for the scatterer distribution
+scatterer = Sphere(
+    diameter=np.linspace(100e-9, 10000e-9, 800),
+    index=1.4,
+    medium_index=1,
+    source=source
+)
+
+# %%
+# Defining the experiment setup
+experiment = Setup(
+    scatterer=scatterer,
+    source=source
+)
+
+# %%
+# Measuring the properties
+data = experiment.get(measure.b1)
+
+# %%
+# Plotting the results
+figure = data.plot(
+    x=experiment.diameter
+)
+
+_ = figure.show()
```

## docs/examples/experiment/plot_sphere_coherent_coupling_vs_phioffset.py

 * *Ordering differences only*

```diff
@@ -1,68 +1,68 @@
-"""
-Sphere: Coherent Goniometer
-===========================
-
-"""
-
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy
-from PyMieSim.experiment.detector import CoherentMode
-from PyMieSim.experiment.scatterer import Sphere
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-from PyOptik import UsualMaterial
-from PyMieSim import measure
-
-# %%
-# Defining the source to be employed.
-source = Gaussian(
-    wavelength=1200e-9,
-    polarization_value=90,
-    polarization_type='linear',
-    optical_power=1e-3,
-    NA=0.2
-)
-# %%
-# Defining the ranging parameters for the scatterer distribution
-scatterer = Sphere(
-    diameter=2000e-9,
-    material=UsualMaterial.BK7,
-    medium_index=1,
-    source=source
-)
-
-# %%
-# Defining the detector to be employed.
-detector = CoherentMode(
-    mode_number='LP11',
-    NA=[0.5, 0.3, 0.1, 0.05],
-    phi_offset=numpy.linspace(-180, 180, 400),
-    gamma_offset=0,
-    sampling=400,
-    polarization_filter=None,
-    rotation=0,  # Rotation of the mode field
-)
-
-# %%
-# Defining the experiment setup
-experiment = Setup(
-    scatterer=scatterer,
-    source=source,
-    detector=detector
-)
-
-# %%
-# Measuring the properties
-data = experiment.get(measure.coupling)
-
-# %%
-# Plotting the results
-figure = data.plot(
-    x=experiment.phi_offset,
-    y_scale='log',
-    normalize=True
-)
-
-_ = figure.show()
+"""
+Sphere: Coherent Goniometer
+===========================
+
+"""
+
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy
+from PyMieSim.experiment.detector import CoherentMode
+from PyMieSim.experiment.scatterer import Sphere
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+from PyOptik import UsualMaterial
+from PyMieSim import measure
+
+# %%
+# Defining the source to be employed.
+source = Gaussian(
+    wavelength=1200e-9,
+    polarization_value=90,
+    polarization_type='linear',
+    optical_power=1e-3,
+    NA=0.2
+)
+# %%
+# Defining the ranging parameters for the scatterer distribution
+scatterer = Sphere(
+    diameter=2000e-9,
+    material=UsualMaterial.BK7,
+    medium_index=1,
+    source=source
+)
+
+# %%
+# Defining the detector to be employed.
+detector = CoherentMode(
+    mode_number='LP11',
+    NA=[0.5, 0.3, 0.1, 0.05],
+    phi_offset=numpy.linspace(-180, 180, 400),
+    gamma_offset=0,
+    sampling=400,
+    polarization_filter=None,
+    rotation=0,  # Rotation of the mode field
+)
+
+# %%
+# Defining the experiment setup
+experiment = Setup(
+    scatterer=scatterer,
+    source=source,
+    detector=detector
+)
+
+# %%
+# Measuring the properties
+data = experiment.get(measure.coupling)
+
+# %%
+# Plotting the results
+figure = data.plot(
+    x=experiment.phi_offset,
+    y_scale='log',
+    normalize=True
+)
+
+_ = figure.show()
```

## docs/examples/experiment/plot_sphere_coherent_coupling_vs_rotation.py

 * *Ordering differences only*

```diff
@@ -1,64 +1,64 @@
-"""
-Sphere: Coherent mode field rotation
-====================================
-
-"""
-
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy
-from PyMieSim.experiment.detector import CoherentMode
-from PyMieSim.experiment.scatterer import Sphere
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-from PyOptik import UsualMaterial
-from PyMieSim import measure
-
-# %%
-# Defining the source to be employed.
-source = Gaussian(
-    wavelength=1200e-9,
-    polarization_value=90,
-    polarization_type='linear',
-    optical_power=1e-3,
-    NA=0.2
-)
-# %%
-# Defining the ranging parameters for the scatterer distribution
-scatterer = Sphere(
-    diameter=[2000e-9, 2300e-9],
-    material=UsualMaterial.BK7,
-    medium_index=1,
-    source=source
-)
-
-# %%
-# Defining the detector to be employed.
-detector = CoherentMode(
-    mode_number='HG11',
-    NA=[0.05],
-    phi_offset=0,
-    gamma_offset=20,
-    sampling=400,
-    rotation=numpy.linspace(0, 180, 200),
-    polarization_filter=None
-)
-
-# %%
-# Defining the experiment setup
-experiment = Setup(
-    scatterer=scatterer,
-    source=source,
-    detector=detector
-)
-
-# %%
-# Measuring the properties
-data = experiment.get(measure.coupling)
-
-# %%
-# Plotting the results
-figure = data.plot(x=experiment.rotation)
-
-_ = figure.show()
+"""
+Sphere: Coherent mode field rotation
+====================================
+
+"""
+
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy
+from PyMieSim.experiment.detector import CoherentMode
+from PyMieSim.experiment.scatterer import Sphere
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+from PyOptik import UsualMaterial
+from PyMieSim import measure
+
+# %%
+# Defining the source to be employed.
+source = Gaussian(
+    wavelength=1200e-9,
+    polarization_value=90,
+    polarization_type='linear',
+    optical_power=1e-3,
+    NA=0.2
+)
+# %%
+# Defining the ranging parameters for the scatterer distribution
+scatterer = Sphere(
+    diameter=[2000e-9, 2300e-9],
+    material=UsualMaterial.BK7,
+    medium_index=1,
+    source=source
+)
+
+# %%
+# Defining the detector to be employed.
+detector = CoherentMode(
+    mode_number='HG11',
+    NA=[0.05],
+    phi_offset=0,
+    gamma_offset=20,
+    sampling=400,
+    rotation=numpy.linspace(0, 180, 200),
+    polarization_filter=None
+)
+
+# %%
+# Defining the experiment setup
+experiment = Setup(
+    scatterer=scatterer,
+    source=source,
+    detector=detector
+)
+
+# %%
+# Measuring the properties
+data = experiment.get(measure.coupling)
+
+# %%
+# Plotting the results
+figure = data.plot(x=experiment.rotation)
+
+_ = figure.show()
```

## docs/examples/experiment/plot_sphere_coupling_vs_diameter.py

```diff
@@ -1,66 +1,66 @@
-"""
-Sphere: Coupling vs diameter
-============================
-
-"""
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy
-from PyMieSim.experiment.detector import Photodiode
-from PyMieSim.experiment.scatterer import Sphere
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-
-from PyMieSim import measure
-from PyOptik import UsualMaterial
-
-# %%
-# Defining the source to be employed.
-source = Gaussian(
-    wavelength=1200e-9,
-    polarization_value=90,
-    polarization_type='linear',
-    optical_power=1e-3,
-    NA=0.2
-)
-# %%
-# Defining the ranging parameters for the scatterer distribution
-scatterer = Sphere(
-    diameter=numpy.linspace(100e-9, 3000e-9, 600),
-    material=UsualMaterial.BK7,
-    medium_index=1.0,
-    source=source
-)
-
-# %%
-# Defining the detector to be employed.
-detector = Photodiode(
-    NA=[0.15, 0.1, 0.05],
-    phi_offset=-180.0,
-    gamma_offset=0.0,
-    sampling=600,
-    polarization_filter=None
-)
-
-# %%
-# Defining the experiment setup
-experiment = Setup(
-    scatterer=scatterer,
-    source=source,
-    detector=detector
-)
-
-# %%
-# Measuring the properties
-data = experiment.get(measure.coupling)
-
-# %%
-# Plotting the results
-figure = data.plot(
-    x=experiment.diameter,
-    y_scale='linear',
-    normalize=True
-)
-
-_ = figure.show()
+"""
+Sphere: Coupling vs diameter
+============================
+
+"""
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy
+from PyMieSim.experiment.detector import Photodiode
+from PyMieSim.experiment.scatterer import Sphere
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+
+from PyMieSim import measure
+from PyOptik import UsualMaterial
+
+# %%
+# Defining the source to be employed.
+source = Gaussian(
+    wavelength=1200e-9,
+    polarization_value=90,
+    polarization_type='linear',
+    optical_power=1e-3,
+    NA=0.2
+)
+# %%
+# Defining the ranging parameters for the scatterer distribution
+scatterer = Sphere(
+    diameter=numpy.linspace(100e-9, 3000e-9, 600),
+    material=UsualMaterial.BK7,
+    medium_index=1.0,
+    source=source
+)
+
+# %%
+# Defining the detector to be employed.
+detector = Photodiode(
+    NA=numpy.linspace(0.3, 0.2, 3),
+    phi_offset=[-180.0],
+    gamma_offset=[0.0],
+    sampling=[600],
+    polarization_filter=[None]
+)
+
+# %%
+# Defining the experiment setup
+experiment = Setup(
+    scatterer=scatterer,
+    source=source,
+    detector=detector
+)
+
+# %%
+# Measuring the properties
+data = experiment.get(measure.coupling)
+
+# %%
+# Plotting the results
+figure = data.plot(
+    x=experiment.diameter,
+    y_scale='linear',
+    normalize=True
+)
+
+_ = figure.show()
```

## docs/examples/experiment/plot_sphere_coupling_vs_filter.py

 * *Ordering differences only*

```diff
@@ -1,69 +1,69 @@
-"""
-Sphere: Coupling vs polarization filter
-=======================================
-"""
-
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy as np
-
-from PyMieSim.experiment.detector import CoherentMode
-from PyMieSim.experiment.scatterer import Sphere
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-
-from PyMieSim import measure
-from PyOptik import UsualMaterial
-
-# %%
-# Defining the source to be employed.
-source = Gaussian(
-    wavelength=950e-9,
-    polarization_value=0,
-    polarization_type='linear',
-    optical_power=1e-3,
-    NA=0.2
-)
-
-# %%
-# Defining the ranging parameters for the scatterer distribution
-scatterer = Sphere(
-    diameter=np.linspace(100e-9, 2000e-9, 20),
-    material=UsualMaterial.BK7,
-    medium_index=1,
-    source=source
-)
-
-# %%
-# Defining the detector to be employed.
-detector = CoherentMode(
-    mode_number="HG11:00",
-    NA=[0.1],
-    phi_offset=-180,
-    gamma_offset=0,
-    polarization_filter=np.linspace(-180, 180, 100),
-    sampling=300,
-    rotation=0,  # Rotation of the mode field
-)
-
-# %%
-# Defining the experiment setup
-experiment = Setup(
-    scatterer=scatterer,
-    source=source,
-    detector=detector
-)
-
-# %%
-# Measuring the properties
-data = experiment.get(measure.coupling)
-
-# %%
-# Plotting the results
-figure = data.plot(
-    x=experiment.polarization_filter,
-    std=experiment.diameter
-)
-
-_ = figure.show()
+"""
+Sphere: Coupling vs polarization filter
+=======================================
+"""
+
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy as np
+
+from PyMieSim.experiment.detector import CoherentMode
+from PyMieSim.experiment.scatterer import Sphere
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+
+from PyMieSim import measure
+from PyOptik import UsualMaterial
+
+# %%
+# Defining the source to be employed.
+source = Gaussian(
+    wavelength=950e-9,
+    polarization_value=0,
+    polarization_type='linear',
+    optical_power=1e-3,
+    NA=0.2
+)
+
+# %%
+# Defining the ranging parameters for the scatterer distribution
+scatterer = Sphere(
+    diameter=np.linspace(100e-9, 2000e-9, 20),
+    material=UsualMaterial.BK7,
+    medium_index=1,
+    source=source
+)
+
+# %%
+# Defining the detector to be employed.
+detector = CoherentMode(
+    mode_number="HG11:00",
+    NA=[0.1],
+    phi_offset=-180,
+    gamma_offset=0,
+    polarization_filter=np.linspace(-180, 180, 100),
+    sampling=300,
+    rotation=0,  # Rotation of the mode field
+)
+
+# %%
+# Defining the experiment setup
+experiment = Setup(
+    scatterer=scatterer,
+    source=source,
+    detector=detector
+)
+
+# %%
+# Measuring the properties
+data = experiment.get(measure.coupling)
+
+# %%
+# Plotting the results
+figure = data.plot(
+    x=experiment.polarization_filter,
+    std=experiment.diameter
+)
+
+_ = figure.show()
```

## docs/examples/experiment/plot_sphere_coupling_vs_phioffset.py

 * *Ordering differences only*

```diff
@@ -1,66 +1,66 @@
-"""
-Sphere: Goniometer
-==================
-
-"""
-
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy
-from PyMieSim.experiment.detector import Photodiode
-from PyMieSim.experiment.scatterer import Sphere
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-from PyOptik import UsualMaterial
-from PyMieSim import measure
-
-# %%
-# Defining the source to be employed.
-source = Gaussian(
-    wavelength=1200e-9,
-    polarization_value=90,
-    polarization_type='linear',
-    optical_power=1e-3,
-    NA=0.2
-)
-# %%
-# Defining the ranging parameters for the scatterer distribution
-scatterer = Sphere(
-    diameter=2000e-9,
-    material=UsualMaterial.BK7,
-    medium_index=1,
-    source=source
-)
-
-# %%
-# Defining the detector to be employed.
-detector = Photodiode(
-    NA=[0.5, 0.3, 0.1, 0.05],
-    phi_offset=numpy.linspace(-180, 180, 400),
-    gamma_offset=0,
-    sampling=400,
-    polarization_filter=None
-)
-
-# %%
-# Defining the experiment setup
-experiment = Setup(
-    scatterer=scatterer,
-    source=source,
-    detector=detector
-)
-
-# %%
-# Measuring the properties
-data = experiment.get(measure.coupling)
-
-# %%
-# Plotting the results
-figure = data.plot(
-    x=experiment.phi_offset,
-    y_scale='log',
-    normalize=True
-)
-
-_ = figure.show()
+"""
+Sphere: Goniometer
+==================
+
+"""
+
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy
+from PyMieSim.experiment.detector import Photodiode
+from PyMieSim.experiment.scatterer import Sphere
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+from PyOptik import UsualMaterial
+from PyMieSim import measure
+
+# %%
+# Defining the source to be employed.
+source = Gaussian(
+    wavelength=1200e-9,
+    polarization_value=90,
+    polarization_type='linear',
+    optical_power=1e-3,
+    NA=0.2
+)
+# %%
+# Defining the ranging parameters for the scatterer distribution
+scatterer = Sphere(
+    diameter=2000e-9,
+    material=UsualMaterial.BK7,
+    medium_index=1,
+    source=source
+)
+
+# %%
+# Defining the detector to be employed.
+detector = Photodiode(
+    NA=[0.5, 0.3, 0.1, 0.05],
+    phi_offset=numpy.linspace(-180, 180, 400),
+    gamma_offset=0,
+    sampling=400,
+    polarization_filter=None
+)
+
+# %%
+# Defining the experiment setup
+experiment = Setup(
+    scatterer=scatterer,
+    source=source,
+    detector=detector
+)
+
+# %%
+# Measuring the properties
+data = experiment.get(measure.coupling)
+
+# %%
+# Plotting the results
+figure = data.plot(
+    x=experiment.phi_offset,
+    y_scale='log',
+    normalize=True
+)
+
+_ = figure.show()
```

## docs/examples/experiment/plot_sphere_coupling_vs_wavelength.py

 * *Ordering differences only*

```diff
@@ -1,68 +1,68 @@
-"""
-Sphere: Coupling vs wavelength
-==============================
-"""
-
-
-# %%
-# Importing the package dependencies: numpy, PyMieSim
-import numpy as np
-
-from PyMieSim.experiment.detector import CoherentMode
-from PyMieSim.experiment.scatterer import Sphere
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-from PyMieSim import measure
-from PyOptik import UsualMaterial
-
-# %%
-# Defining the source to be employed.
-source = Gaussian(
-    wavelength=np.linspace(950e-9, 1050e-9, 200),
-    polarization_value=0,
-    polarization_type='linear',
-    optical_power=1e-3,
-    NA=0.2
-)
-
-# %%
-# Defining the ranging parameters for the scatterer distribution
-scatterer = Sphere(
-    diameter=np.linspace(100e-9, 8000e-9, 5),
-    material=UsualMaterial.BK7,
-    medium_index=1,
-    source=source
-)
-
-# %%
-# Defining the detector to be employed.
-detector = CoherentMode(
-    mode_number="LP11",
-    NA=[0.05, 0.01],
-    phi_offset=-180,
-    gamma_offset=0,
-    polarization_filter=[0, None],
-    rotation=0,
-    sampling=300
-)
-
-# %%
-# Defining the experiment setup
-experiment = Setup(
-    scatterer=scatterer,
-    source=source,
-    detector=detector
-)
-
-# %%
-# Measuring the properties
-data = experiment.get(measure.coupling)
-
-# %%
-# Plotting the results
-figure = data.plot(
-    x=experiment.wavelength,
-    std=experiment.diameter
-)
-
-_ = figure.show()
+"""
+Sphere: Coupling vs wavelength
+==============================
+"""
+
+
+# %%
+# Importing the package dependencies: numpy, PyMieSim
+import numpy as np
+
+from PyMieSim.experiment.detector import CoherentMode
+from PyMieSim.experiment.scatterer import Sphere
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+from PyMieSim import measure
+from PyOptik import UsualMaterial
+
+# %%
+# Defining the source to be employed.
+source = Gaussian(
+    wavelength=np.linspace(950e-9, 1050e-9, 200),
+    polarization_value=0,
+    polarization_type='linear',
+    optical_power=1e-3,
+    NA=0.2
+)
+
+# %%
+# Defining the ranging parameters for the scatterer distribution
+scatterer = Sphere(
+    diameter=np.linspace(100e-9, 8000e-9, 5),
+    material=UsualMaterial.BK7,
+    medium_index=1,
+    source=source
+)
+
+# %%
+# Defining the detector to be employed.
+detector = CoherentMode(
+    mode_number="LP11",
+    NA=[0.05, 0.01],
+    phi_offset=-180,
+    gamma_offset=0,
+    polarization_filter=[0, None],
+    rotation=0,
+    sampling=300
+)
+
+# %%
+# Defining the experiment setup
+experiment = Setup(
+    scatterer=scatterer,
+    source=source,
+    detector=detector
+)
+
+# %%
+# Measuring the properties
+data = experiment.get(measure.coupling)
+
+# %%
+# Plotting the results
+figure = data.plot(
+    x=experiment.wavelength,
+    std=experiment.diameter
+)
+
+_ = figure.show()
```

## docs/examples/extras/SphereProperties.py

 * *Ordering differences only*

```diff
@@ -1,50 +1,50 @@
-"""
-Samples Properties
-==================
-"""
-
-from PyMieSim.single.scatterer import Sphere
-from PyMieSim.single.source import Gaussian
-
-source = Gaussian(
-    wavelength=1000e-9,
-    polarization_value=0,
-    polarization_type='linear',
-    optical_power=1,
-    NA=0.3
-)
-
-source.plot().show()
-
-scatterer = Sphere(
-    diameter=800e-9,
-    source=source,
-    index=1.4,
-    medium_index=1.0
-)
-
-
-farfield = scatterer.get_far_field(sampling=300)
-
-farfield.plot().show()
-
-scatterer.print_properties()
-
-# Property              value
-# --------------  -----------
-# size_parameter  2.51327
-# area            5.02655e-13
-# index           1.4
-# Qsca            1.73765
-# Qext            1.73765
-# Qabs            0
-# Qback           0.35502
-# Qratio          0.204311
-# Qpr             0.528234
-# Csca            8.73437e-13
-# Cext            8.73437e-13
-# Cabs            0
-# Cback           1.78453e-13
-# Cratio          0.204311
-# Cpr             2.65519e-13
-# g               0.696006
+"""
+Samples Properties
+==================
+"""
+
+from PyMieSim.single.scatterer import Sphere
+from PyMieSim.single.source import Gaussian
+
+source = Gaussian(
+    wavelength=1000e-9,
+    polarization_value=0,
+    polarization_type='linear',
+    optical_power=1,
+    NA=0.3
+)
+
+source.plot().show()
+
+scatterer = Sphere(
+    diameter=800e-9,
+    source=source,
+    index=1.4,
+    medium_index=1.0
+)
+
+
+farfield = scatterer.get_far_field(sampling=300)
+
+farfield.plot().show()
+
+scatterer.print_properties()
+
+# Property              value
+# --------------  -----------
+# size_parameter  2.51327
+# area            5.02655e-13
+# index           1.4
+# Qsca            1.73765
+# Qext            1.73765
+# Qabs            0
+# Qback           0.35502
+# Qratio          0.204311
+# Qpr             0.528234
+# Csca            8.73437e-13
+# Cext            8.73437e-13
+# Cabs            0
+# Cback           1.78453e-13
+# Cratio          0.204311
+# Cpr             2.65519e-13
+# g               0.696006
```

## docs/examples/extras/plot_Qsca_vs_permittivity_vs_size_parameter.py

 * *Ordering differences only*

```diff
@@ -1,72 +1,72 @@
-"""
-Scattering efficiency of a sphere
-=================================
-
-PyMieSim makes it easy to create a source and a scatterer. With these objects
-defined, it is possible to use PyMieSim to find the scattering efficiency of the
-scatterer. This feature can be used to plot a graph of the scattering efficiency
-of a sphere as a function of the permittivity and the size parameter.
-"""
-
-# %%
-# Importing the package: PyMieSim
-import numpy
-
-from PyMieSim.experiment.scatterer import Sphere
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-
-from PyMieSim import measure
-
-from MPSPlots.render2D import SceneList
-
-
-permitivity = numpy.linspace(-10, 50, 400)
-
-index = numpy.sqrt(permitivity.astype(complex))
-
-diameter = numpy.linspace(1e-9, 200e-9, 400)
-
-source = Gaussian(
-    wavelength=400e-9,
-    polarization_value=90,
-    polarization_type='linear',
-    optical_power=1e-3,
-    NA=0.2
-)
-
-
-scatterer = Sphere(
-    diameter=diameter,
-    index=index,
-    medium_index=1,
-    source=source
-)
-
-experiment = Setup(
-    scatterer=scatterer,
-    source=source
-)
-
-data = experiment.get(measure.Qsca)
-
-data = abs(data.y.values.squeeze())
-
-figure = SceneList(unit_size=(6, 6))
-
-ax = figure.append_ax(
-    x_label="Permittivity",
-    y_label=r'Diameter [$\mu$ m]',
-    title="Scattering efficiency of a sphere"
-)
-
-artist = ax.add_mesh(
-    x=permitivity,
-    y=diameter,
-    scalar=numpy.log(data),
-    y_scale_factor=1e6,
-)
-
-_ = ax.add_colorbar(artist=artist, colormap='viridis')
-
-_ = figure.show()
+"""
+Scattering efficiency of a sphere
+=================================
+
+PyMieSim makes it easy to create a source and a scatterer. With these objects
+defined, it is possible to use PyMieSim to find the scattering efficiency of the
+scatterer. This feature can be used to plot a graph of the scattering efficiency
+of a sphere as a function of the permittivity and the size parameter.
+"""
+
+# %%
+# Importing the package: PyMieSim
+import numpy
+
+from PyMieSim.experiment.scatterer import Sphere
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+
+from PyMieSim import measure
+
+from MPSPlots.render2D import SceneList
+
+
+permitivity = numpy.linspace(-10, 50, 400)
+
+index = numpy.sqrt(permitivity.astype(complex))
+
+diameter = numpy.linspace(1e-9, 200e-9, 400)
+
+source = Gaussian(
+    wavelength=400e-9,
+    polarization_value=90,
+    polarization_type='linear',
+    optical_power=1e-3,
+    NA=0.2
+)
+
+
+scatterer = Sphere(
+    diameter=diameter,
+    index=index,
+    medium_index=1,
+    source=source
+)
+
+experiment = Setup(
+    scatterer=scatterer,
+    source=source
+)
+
+data = experiment.get(measure.Qsca)
+
+data = abs(data.y.values.squeeze())
+
+figure = SceneList(unit_size=(6, 6))
+
+ax = figure.append_ax(
+    x_label="Permittivity",
+    y_label=r'Diameter [$\mu$ m]',
+    title="Scattering efficiency of a sphere"
+)
+
+artist = ax.add_mesh(
+    x=permitivity,
+    y=diameter,
+    scalar=numpy.log(data),
+    y_scale_factor=1e6,
+)
+
+_ = ax.add_colorbar(artist=artist, colormap='viridis')
+
+_ = figure.show()
```

## docs/examples/extras/plot_coupling_heatmap.py

 * *Ordering differences only*

```diff
@@ -1,85 +1,85 @@
-"""
-Coupling heatmap of a sphere
-=================================
-
-PyMieSim makes it easy to create a source and a scatterer. With these objects
-defined, it is possible to use PyMieSim to find the scattering efficiency of the
-scatterer. This feature can be used to plot a graph of the scattering efficiency
-of a sphere as a function of the permittivity and the size parameter.
-"""
-
-import numpy
-
-from PyMieSim.experiment.detector import Photodiode
-from PyMieSim.experiment.scatterer import Sphere
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-
-from PyMieSim import measure
-
-from MPSPlots.render2D import SceneList
-
-
-index = numpy.linspace(1.3, 2.1, 300)
-
-diameter = numpy.linspace(1e-9, 2000e-9, 300)
-
-source = Gaussian(
-    wavelength=400e-9,
-    polarization_value=90,
-    polarization_type='linear',
-    optical_power=1e-3,
-    NA=0.2
-)
-
-
-scatterer = Sphere(
-    diameter=diameter,
-    index=index,
-    medium_index=1,
-    source=source
-)
-
-
-detector = Photodiode(
-    polarization_filter=None,
-    NA=0.3,
-    phi_offset=0,
-    gamma_offset=0,
-    sampling=400
-)
-
-experiment = Setup(
-    scatterer=scatterer,
-    source=source,
-    detector=detector
-)
-
-data = experiment.get(measure.coupling)
-
-data = abs(data.y.values.squeeze())
-
-figure = SceneList(unit_size=(6, 6))
-
-ax = figure.append_ax(
-    x_label="Permittivity",
-    y_label=r'Diameter [$\mu$m]',
-    title="Coupling power [Watt]"
-)
-
-artist = ax.add_mesh(
-    x=index,
-    y=diameter,
-    scalar=data,
-    y_scale_factor=1e6,
-)
-
-_ = ax.add_colorbar(
-    colormap='viridis',
-    artist=artist,
-    symmetric=False,
-    numeric_format='%.3e'
-)
-
-
-_ = figure.show()
+"""
+Coupling heatmap of a sphere
+=================================
+
+PyMieSim makes it easy to create a source and a scatterer. With these objects
+defined, it is possible to use PyMieSim to find the scattering efficiency of the
+scatterer. This feature can be used to plot a graph of the scattering efficiency
+of a sphere as a function of the permittivity and the size parameter.
+"""
+
+import numpy
+
+from PyMieSim.experiment.detector import Photodiode
+from PyMieSim.experiment.scatterer import Sphere
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+
+from PyMieSim import measure
+
+from MPSPlots.render2D import SceneList
+
+
+index = numpy.linspace(1.3, 2.1, 300)
+
+diameter = numpy.linspace(1e-9, 2000e-9, 300)
+
+source = Gaussian(
+    wavelength=400e-9,
+    polarization_value=90,
+    polarization_type='linear',
+    optical_power=1e-3,
+    NA=0.2
+)
+
+
+scatterer = Sphere(
+    diameter=diameter,
+    index=index,
+    medium_index=1,
+    source=source
+)
+
+
+detector = Photodiode(
+    polarization_filter=None,
+    NA=0.3,
+    phi_offset=0,
+    gamma_offset=0,
+    sampling=400
+)
+
+experiment = Setup(
+    scatterer=scatterer,
+    source=source,
+    detector=detector
+)
+
+data = experiment.get(measure.coupling)
+
+data = abs(data.y.values.squeeze())
+
+figure = SceneList(unit_size=(6, 6))
+
+ax = figure.append_ax(
+    x_label="Permittivity",
+    y_label=r'Diameter [$\mu$m]',
+    title="Coupling power [Watt]"
+)
+
+artist = ax.add_mesh(
+    x=index,
+    y=diameter,
+    scalar=data,
+    y_scale_factor=1e6,
+)
+
+_ = ax.add_colorbar(
+    colormap='viridis',
+    artist=artist,
+    symmetric=False,
+    numeric_format='%.3e'
+)
+
+
+_ = figure.show()
```

## docs/examples/scatterer/plot_farfield.py

 * *Ordering differences only*

```diff
@@ -1,42 +1,42 @@
-"""
-Far-Fields Computation and Visualization
-========================================
-
-This example demonstrates the process of computing and visualizing the far-fields of a scatterer using PyMieSim.
-"""
-
-# %%
-# Importing the package: PyMieSim
-from PyMieSim.single.scatterer import Sphere
-from PyMieSim.single.source import Gaussian
-
-# %%
-# Defining the source
-source = Gaussian(
-    wavelength=0.5e-6,  # 1000 nm
-    polarization_value='right',  # Right circular polarization
-    polarization_type='circular',
-    optical_power=1,  # Arbitrary units
-    NA=0.3  # Numerical Aperture
-)
-
-# %%
-# Defining the scatterer
-scatterer = Sphere(
-    diameter=1.5e-6,  # 1500 nm
-    source=source,
-    index=1.4,  # Refractive index of the scatterer
-    medium_index=1.0  # Refractive index of the surrounding medium
-)
-
-# %%
-# Computing the data
-data = scatterer.get_far_field(sampling=100)  # Specify the number of sampling points
-
-# %%
-# Plotting the data
-figure = data.plot()
-
-# %%
-# Display the plot
-_ = figure.show()
+"""
+Far-Fields Computation and Visualization
+========================================
+
+This example demonstrates the process of computing and visualizing the far-fields of a scatterer using PyMieSim.
+"""
+
+# %%
+# Importing the package: PyMieSim
+from PyMieSim.single.scatterer import Sphere
+from PyMieSim.single.source import Gaussian
+
+# %%
+# Defining the source
+source = Gaussian(
+    wavelength=0.5e-6,  # 1000 nm
+    polarization_value='right',  # Right circular polarization
+    polarization_type='circular',
+    optical_power=1,  # Arbitrary units
+    NA=0.3  # Numerical Aperture
+)
+
+# %%
+# Defining the scatterer
+scatterer = Sphere(
+    diameter=1.5e-6,  # 1500 nm
+    source=source,
+    index=1.4,  # Refractive index of the scatterer
+    medium_index=1.0  # Refractive index of the surrounding medium
+)
+
+# %%
+# Computing the data
+data = scatterer.get_far_field(sampling=100)  # Specify the number of sampling points
+
+# %%
+# Plotting the data
+figure = data.plot()
+
+# %%
+# Display the plot
+_ = figure.show()
```

## docs/examples/scatterer/plot_footprint.py

 * *Ordering differences only*

```diff
@@ -1,47 +1,47 @@
-"""
-Scatterer Footprint Calculation and Visualization
-=================================================
-
-This example demonstrates how to compute and visualize the footprint of a scatterer using PyMieSim.
-"""
-
-# Import necessary components from PyMieSim
-from PyMieSim.single.scatterer import Sphere
-from PyMieSim.single.detector import CoherentMode
-from PyMieSim.single.source import Gaussian
-from PyOptik import UsualMaterial
-
-# Define the Gaussian light source with specified properties
-source = Gaussian(
-    wavelength=1e-6,  # 1000 nm
-    polarization_value=0,
-    polarization_type='linear',
-    optical_power=1,  # Arbitrary units
-    NA=0.3  # Numerical Aperture
-)
-
-# Create a spherical scatterer with a specified diameter and material
-scatterer = Sphere(
-    diameter=2e-6,  # 2000 nm
-    source=source,
-    material=UsualMaterial.BK7  # Using BK7 glass material
-)
-
-# Define the LPMode detector with specific parameters
-detector = CoherentMode(
-    mode_number="HG02",
-    NA=0.3,
-    sampling=200,  # Number of sampling points
-    gamma_offset=0,
-    phi_offset=0,
-)
-
-# Compute the footprint data using the defined scatterer and detector
-data = detector.get_footprint(scatterer)
-
-# Plot the computed footprint data
-figure = data.plot()
-
-# %%
-# Display the plot
-_ = figure.show()
+"""
+Scatterer Footprint Calculation and Visualization
+=================================================
+
+This example demonstrates how to compute and visualize the footprint of a scatterer using PyMieSim.
+"""
+
+# Import necessary components from PyMieSim
+from PyMieSim.single.scatterer import Sphere
+from PyMieSim.single.detector import CoherentMode
+from PyMieSim.single.source import Gaussian
+from PyOptik import UsualMaterial
+
+# Define the Gaussian light source with specified properties
+source = Gaussian(
+    wavelength=1e-6,  # 1000 nm
+    polarization_value=0,
+    polarization_type='linear',
+    optical_power=1,  # Arbitrary units
+    NA=0.3  # Numerical Aperture
+)
+
+# Create a spherical scatterer with a specified diameter and material
+scatterer = Sphere(
+    diameter=2e-6,  # 2000 nm
+    source=source,
+    material=UsualMaterial.BK7  # Using BK7 glass material
+)
+
+# Define the LPMode detector with specific parameters
+detector = CoherentMode(
+    mode_number="HG02",
+    NA=0.3,
+    sampling=200,  # Number of sampling points
+    gamma_offset=0,
+    phi_offset=0,
+)
+
+# Compute the footprint data using the defined scatterer and detector
+data = detector.get_footprint(scatterer)
+
+# Plot the computed footprint data
+figure = data.plot()
+
+# %%
+# Display the plot
+_ = figure.show()
```

## docs/examples/scatterer/plot_s1s2.py

 * *Ordering differences only*

```diff
@@ -1,41 +1,41 @@
-"""
-S1 S2 Function Computation
-==========================
-
-This example demonstrates how to compute and visualize the S1 and S2 scattering functions using PyMieSim.
-"""
-
-# %%
-# Importing the package: PyMieSim
-from PyMieSim.single.scatterer import Sphere
-from PyMieSim.single.source import Gaussian
-
-# %%
-# Defining the source
-source = Gaussian(
-    wavelength=450e-9,  # 450 nm
-    polarization_value=0,  # Linear polarization angle in radians
-    polarization_type='linear',
-    optical_power=1,  # Arbitrary units
-    NA=0.3  # Numerical Aperture
-)
-
-# %%
-# Defining the scatterer
-scatterer = Sphere(
-    diameter=6e-9,  # 6 nm
-    source=source,
-    index=1.4  # Refractive index of the scatterer
-)
-
-# %%
-# Computing the data
-data = scatterer.get_s1s2(sampling=200)  # Specify the number of sampling points
-
-# %%
-# Plotting the data
-figure = data.plot()
-
-# %%
-# Display the plot
-_ = figure.show()
+"""
+S1 S2 Function Computation
+==========================
+
+This example demonstrates how to compute and visualize the S1 and S2 scattering functions using PyMieSim.
+"""
+
+# %%
+# Importing the package: PyMieSim
+from PyMieSim.single.scatterer import Sphere
+from PyMieSim.single.source import Gaussian
+
+# %%
+# Defining the source
+source = Gaussian(
+    wavelength=450e-9,  # 450 nm
+    polarization_value=0,  # Linear polarization angle in radians
+    polarization_type='linear',
+    optical_power=1,  # Arbitrary units
+    NA=0.3  # Numerical Aperture
+)
+
+# %%
+# Defining the scatterer
+scatterer = Sphere(
+    diameter=6e-9,  # 6 nm
+    source=source,
+    index=1.4  # Refractive index of the scatterer
+)
+
+# %%
+# Computing the data
+data = scatterer.get_s1s2(sampling=200)  # Specify the number of sampling points
+
+# %%
+# Plotting the data
+figure = data.plot()
+
+# %%
+# Display the plot
+_ = figure.show()
```

## docs/examples/scatterer/plot_source.py

 * *Ordering differences only*

```diff
@@ -1,28 +1,28 @@
-"""
-Source Plottings
-================
-
-This example demonstrates how to visualize the properties of a light source using PyMieSim.
-"""
-
-# %%
-# Importing the package: PyMieSim
-from PyMieSim.single.source import Gaussian
-
-# %%
-# Defining the source
-source = Gaussian(
-    wavelength=1e-6,  # 1000 nm
-    polarization_value=0,  # Linear polarization angle in radians
-    polarization_type='linear',
-    optical_power=1,  # Arbitrary units
-    NA=0.3  # Numerical Aperture
-)
-
-# %%
-# Plotting the source
-figure = source.plot()
-
-# %%
-# Display the plot
-_ = figure.show()
+"""
+Source Plottings
+================
+
+This example demonstrates how to visualize the properties of a light source using PyMieSim.
+"""
+
+# %%
+# Importing the package: PyMieSim
+from PyMieSim.single.source import Gaussian
+
+# %%
+# Defining the source
+source = Gaussian(
+    wavelength=1e-6,  # 1000 nm
+    polarization_value=0,  # Linear polarization angle in radians
+    polarization_type='linear',
+    optical_power=1,  # Arbitrary units
+    NA=0.3  # Numerical Aperture
+)
+
+# %%
+# Plotting the source
+figure = source.plot()
+
+# %%
+# Display the plot
+_ = figure.show()
```

## docs/examples/scatterer/plot_spf.py

 * *Ordering differences only*

```diff
@@ -1,42 +1,42 @@
-"""
-SPF Computation
-===============
-
-This example demonstrates the computation and visualization of the Scattering Phase Function (SPF) using PyMieSim.
-"""
-
-# %%
-# Importing the package: PyMieSim
-from PyMieSim.single.scatterer import Sphere
-from PyMieSim.single.source import Gaussian
-
-# %%
-# Defining the source
-source = Gaussian(
-    wavelength=1000e-9,  # 1000 nm
-    polarization_value=0,  # Linear polarization angle in radians
-    polarization_type='linear',
-    optical_power=1,  # Arbitrary units
-    NA=0.3  # Numerical Aperture
-)
-
-# %%
-# Defining the scatterer
-scatterer = Sphere(
-    diameter=1.2e-6,  # 1200 nm
-    source=source,
-    index=1.4,  # Refractive index of the scatterer
-    medium_index=1.0,  # Refractive index of the surrounding medium
-)
-
-# %%
-# Computing the data
-data = scatterer.get_spf(sampling=300)  # Specify the number of sampling points
-
-# %%
-# Plotting the data
-figure = data.plot()
-
-# %%
-# Display the plot
-_ = figure.show()
+"""
+SPF Computation
+===============
+
+This example demonstrates the computation and visualization of the Scattering Phase Function (SPF) using PyMieSim.
+"""
+
+# %%
+# Importing the package: PyMieSim
+from PyMieSim.single.scatterer import Sphere
+from PyMieSim.single.source import Gaussian
+
+# %%
+# Defining the source
+source = Gaussian(
+    wavelength=1000e-9,  # 1000 nm
+    polarization_value=0,  # Linear polarization angle in radians
+    polarization_type='linear',
+    optical_power=1,  # Arbitrary units
+    NA=0.3  # Numerical Aperture
+)
+
+# %%
+# Defining the scatterer
+scatterer = Sphere(
+    diameter=1.2e-6,  # 1200 nm
+    source=source,
+    index=1.4,  # Refractive index of the scatterer
+    medium_index=1.0,  # Refractive index of the surrounding medium
+)
+
+# %%
+# Computing the data
+data = scatterer.get_spf(sampling=300)  # Specify the number of sampling points
+
+# %%
+# Plotting the data
+figure = data.plot()
+
+# %%
+# Display the plot
+_ = figure.show()
```

## docs/examples/scatterer/plot_stokes.py

 * *Ordering differences only*

```diff
@@ -1,41 +1,41 @@
-"""
-Stokes Parameters Computation
-=============================
-
-This example demonstrates the computation and visualization of the Stokes parameters using PyMieSim.
-"""
-
-# %%
-# Importing the package: PyMieSim
-from PyMieSim.single.scatterer import Sphere
-from PyMieSim.single.source import Gaussian
-
-# %%
-# Defining the source
-source = Gaussian(
-    wavelength=750e-9,  # 750 nm
-    polarization_value='right',  # Right circular polarization
-    polarization_type='circular',
-    optical_power=1,  # Arbitrary units
-    NA=0.3  # Numerical Aperture
-)
-
-# %%
-# Defining the scatterer
-scatterer = Sphere(
-    diameter=300e-9,  # 300 nm
-    source=source,
-    index=1.4  # Refractive index of the scatterer
-)
-
-# %%
-# Computing the data
-data = scatterer.get_stokes(sampling=100)  # Specify the number of sampling points
-
-# %%
-# Plotting the data
-figure = data.plot()
-
-# %%
-# Display the plot
-_ = figure.show()
+"""
+Stokes Parameters Computation
+=============================
+
+This example demonstrates the computation and visualization of the Stokes parameters using PyMieSim.
+"""
+
+# %%
+# Importing the package: PyMieSim
+from PyMieSim.single.scatterer import Sphere
+from PyMieSim.single.source import Gaussian
+
+# %%
+# Defining the source
+source = Gaussian(
+    wavelength=750e-9,  # 750 nm
+    polarization_value='right',  # Right circular polarization
+    polarization_type='circular',
+    optical_power=1,  # Arbitrary units
+    NA=0.3  # Numerical Aperture
+)
+
+# %%
+# Defining the scatterer
+scatterer = Sphere(
+    diameter=300e-9,  # 300 nm
+    source=source,
+    index=1.4  # Refractive index of the scatterer
+)
+
+# %%
+# Computing the data
+data = scatterer.get_stokes(sampling=100)  # Specify the number of sampling points
+
+# %%
+# Plotting the data
+figure = data.plot()
+
+# %%
+# Display the plot
+_ = figure.show()
```

## docs/examples/validation/plot_BH810.py

 * *Ordering differences only*

```diff
@@ -1,53 +1,53 @@
-"""
-Bohren-Huffman (figure~8.10)
-============================
-
-"""
-
-# %%
-# Importing the dependencies: numpy, matplotlib, PyMieSim
-import numpy
-import matplotlib.pyplot as plt
-
-from PyMieSim.tools.directories import validation_data_path
-from PyMieSim.single.source import Gaussian
-from PyMieSim.single.scatterer import Cylinder
-
-theoretical = numpy.genfromtxt(f"{validation_data_path}/Figure810BH.csv", delimiter=',')
-
-x = theoretical[:, 0]
-y = theoretical[:, 1]
-
-source = Gaussian(
-    wavelength=470e-9,
-    polarization_value=90,
-    polarization_type='linear',
-    optical_power=1e-3,
-    NA=0.1,
-)
-
-scatterer = Cylinder(
-    diameter=3000e-9,
-    source=source,
-    index=1.0 + 0.07j,
-    medium_index=1.0
-)
-
-S1S2 = scatterer.get_s1s2(sampling=800)
-Data = (numpy.abs(S1S2.S1)**2 + numpy.abs(S1S2.S2)**2) * (0.5 / (numpy.pi * source.k))**(1 / 4)
-
-plt.figure(figsize=(8, 4))
-plt.plot(S1S2.phi, Data, 'C1-', linewidth=3, label='PyMieSim')
-
-plt.plot(x, y, 'k--', linewidth=1, label='B&H [8.10]')
-
-plt.xlabel('scatterertering angle [degree]')
-plt.ylabel('Phase function')
-plt.yscale('log')
-plt.grid(True)
-plt.legend()
-plt.tight_layout()
-plt.show()
-
-
-# -
+"""
+Bohren-Huffman (figure~8.10)
+============================
+
+"""
+
+# %%
+# Importing the dependencies: numpy, matplotlib, PyMieSim
+import numpy
+import matplotlib.pyplot as plt
+
+from PyMieSim.tools.directories import validation_data_path
+from PyMieSim.single.source import Gaussian
+from PyMieSim.single.scatterer import Cylinder
+
+theoretical = numpy.genfromtxt(f"{validation_data_path}/Figure810BH.csv", delimiter=',')
+
+x = theoretical[:, 0]
+y = theoretical[:, 1]
+
+source = Gaussian(
+    wavelength=470e-9,
+    polarization_value=90,
+    polarization_type='linear',
+    optical_power=1e-3,
+    NA=0.1,
+)
+
+scatterer = Cylinder(
+    diameter=3000e-9,
+    source=source,
+    index=1.0 + 0.07j,
+    medium_index=1.0
+)
+
+S1S2 = scatterer.get_s1s2(sampling=800)
+Data = (numpy.abs(S1S2.S1)**2 + numpy.abs(S1S2.S2)**2) * (0.5 / (numpy.pi * source.k))**(1 / 4)
+
+plt.figure(figsize=(8, 4))
+plt.plot(S1S2.phi, Data, 'C1-', linewidth=3, label='PyMieSim')
+
+plt.plot(x, y, 'k--', linewidth=1, label='B&H [8.10]')
+
+plt.xlabel('scatterertering angle [degree]')
+plt.ylabel('Phase function')
+plt.yscale('log')
+plt.grid(True)
+plt.legend()
+plt.tight_layout()
+plt.show()
+
+
+# -
```

## docs/examples/validation/plot_BH87.py

 * *Ordering differences only*

```diff
@@ -1,65 +1,65 @@
-"""
-Bohren-Huffman (figure~8.7)
-===========================
-
-"""
-
-# %%
-# Importing the dependencies: numpy, matplotlib, PyMieSim
-import numpy
-import matplotlib.pyplot as plt
-
-from PyMieSim.tools.directories import validation_data_path
-
-from PyMieSim.experiment.scatterer import Cylinder
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-
-from PyMieSim import measure
-
-theoretical = numpy.genfromtxt(f"{validation_data_path}/Figure87BH.csv", delimiter=',')
-
-diameter = numpy.geomspace(10e-9, 6e-6, 800)
-volume = numpy.pi * (diameter / 2)**2
-
-source = Gaussian(
-    wavelength=632.8e-9,
-    polarization_value=[0, 90],
-    polarization_type='linear',
-    optical_power=1e-3,
-    NA=0.2
-)
-
-scatterer = Cylinder(
-    diameter=diameter,
-    index=1.55,
-    medium_index=1,
-    source=source
-)
-
-experiment = Setup(
-    scatterer=scatterer,
-    source=source,
-    detector=None
-)
-
-data = experiment.get(measure.Csca, export_as_numpy=True)
-data = data.squeeze() / volume * 1e-4 / 100
-
-plt.figure(figsize=(8, 4))
-plt.plot(diameter, data[0], 'b--', linewidth=3, label='PyMieSim')
-plt.plot(diameter, data[1], 'r-', linewidth=3, label='PyMieSim')
-
-plt.plot(diameter, theoretical[0], 'k--', linewidth=1, label='BH 8.8')
-plt.plot(diameter, theoretical[1], 'k--', linewidth=1, label='BH 8.8')
-
-plt.xlabel(r'Diameter [$\mu$m]')
-plt.ylabel('Scattering cross section [cylinder]')
-plt.grid(True)
-plt.legend()
-plt.tight_layout()
-plt.show()
-
-assert numpy.all(numpy.isclose(data, theoretical, 1e-9)), 'Error: mismatch on BH_8.7 calculation occuring'
-
-# -
+"""
+Bohren-Huffman (figure~8.7)
+===========================
+
+"""
+
+# %%
+# Importing the dependencies: numpy, matplotlib, PyMieSim
+import numpy
+import matplotlib.pyplot as plt
+
+from PyMieSim.tools.directories import validation_data_path
+
+from PyMieSim.experiment.scatterer import Cylinder
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+
+from PyMieSim import measure
+
+theoretical = numpy.genfromtxt(f"{validation_data_path}/Figure87BH.csv", delimiter=',')
+
+diameter = numpy.geomspace(10e-9, 6e-6, 800)
+volume = numpy.pi * (diameter / 2)**2
+
+source = Gaussian(
+    wavelength=632.8e-9,
+    polarization_value=[0, 90],
+    polarization_type='linear',
+    optical_power=1e-3,
+    NA=0.2
+)
+
+scatterer = Cylinder(
+    diameter=diameter,
+    index=1.55,
+    medium_index=1,
+    source=source
+)
+
+experiment = Setup(
+    scatterer=scatterer,
+    source=source,
+    detector=None
+)
+
+data = experiment.get(measure.Csca, export_as_numpy=True)
+data = data.squeeze() / volume * 1e-4 / 100
+
+plt.figure(figsize=(8, 4))
+plt.plot(diameter, data[0], 'b--', linewidth=3, label='PyMieSim')
+plt.plot(diameter, data[1], 'r-', linewidth=3, label='PyMieSim')
+
+plt.plot(diameter, theoretical[0], 'k--', linewidth=1, label='BH 8.8')
+plt.plot(diameter, theoretical[1], 'k--', linewidth=1, label='BH 8.8')
+
+plt.xlabel(r'Diameter [$\mu$m]')
+plt.ylabel('Scattering cross section [cylinder]')
+plt.grid(True)
+plt.legend()
+plt.tight_layout()
+plt.show()
+
+assert numpy.all(numpy.isclose(data, theoretical, 1e-9)), 'Error: mismatch on BH_8.7 calculation occuring'
+
+# -
```

## docs/examples/validation/plot_BH88.py

 * *Ordering differences only*

```diff
@@ -1,77 +1,77 @@
-"""
-Comparison of PyMieSim and Theoretical Bohren-Huffman Data for Cylinder Scattering
-==================================================================================
-
-"""
-
-# Standard library imports
-import numpy as np
-import matplotlib.pyplot as plt
-
-# PyMieSim imports
-from PyMieSim.tools.directories import validation_data_path
-from PyMieSim.experiment.scatterer import Cylinder
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-import PyMieSim.measure as measure
-
-# Load theoretical data
-theoretical_data = np.genfromtxt(f"{validation_data_path}/Figure88BH.csv", delimiter=',')
-
-# Define parameters
-wavelength = 632.8e-9  # Wavelength of the source in meters
-polarization_values = [0, 90]  # Polarization values in degrees
-optical_power = 1e-3  # Optical power in watts
-NA = 0.2  # Numerical aperture
-diameters = np.geomspace(10e-9, 6e-6, 800)  # Diameters from 10 nm to 6 μm
-index = 1.55  # Refractive index of the cylinder
-medium_index = 1.335  # Refractive index of the medium
-
-# Calculate the volume of the cylinders
-volumes = np.pi * (diameters / 2)**2
-
-# Configure the Gaussian source
-source = Gaussian(
-    wavelength=wavelength,
-    polarization_value=polarization_values,
-    polarization_type='linear',
-    optical_power=optical_power,
-    NA=NA
-)
-
-# Setup cylindrical scatterers
-scatterer = Cylinder(
-    diameter=diameters,
-    index=index,
-    medium_index=medium_index,
-    source=source
-)
-
-# Create experimental setup
-experiment = Setup(
-    scatterer=scatterer,
-    source=source,
-    detector=None
-)
-
-# Compute PyMieSim scattering cross section data
-csca_data = experiment.get(measure.Csca, export_as_numpy=True).squeeze()
-normalized_csca = csca_data / volumes * 1e-4 / 100  # Normalize the data as per specific needs
-
-# Plotting the results
-plt.figure(figsize=(8, 4))
-plt.plot(diameters * 1e6, normalized_csca[0], 'C0-', linewidth=3, label='PyMieSim Polarization: 0')
-plt.plot(diameters * 1e6, normalized_csca[1], 'C1-', linewidth=3, label='PyMieSim Polarization: 90')
-plt.plot(diameters * 1e6, theoretical_data[0], 'k--', linewidth=1, label='Theoretical BH 8.8 Polarization: 0')
-plt.plot(diameters * 1e6, theoretical_data[1], 'k--', linewidth=1, label='Theoretical BH 8.8 Polarization: 90')
-
-plt.xlabel('Diameter (μm)')
-plt.ylabel('Normalized Scattering Cross Section')
-plt.title('Comparison of Scattering Cross Sections for Cylinders')
-plt.grid(True)
-plt.legend()
-plt.tight_layout()
-plt.show()
-
-# Verify data accuracy
-assert np.allclose(normalized_csca, theoretical_data, atol=1e-9), 'Error: mismatch on BH 8.8 calculation occurring'
+"""
+Comparison of PyMieSim and Theoretical Bohren-Huffman Data for Cylinder Scattering
+==================================================================================
+
+"""
+
+# Standard library imports
+import numpy as np
+import matplotlib.pyplot as plt
+
+# PyMieSim imports
+from PyMieSim.tools.directories import validation_data_path
+from PyMieSim.experiment.scatterer import Cylinder
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+import PyMieSim.measure as measure
+
+# Load theoretical data
+theoretical_data = np.genfromtxt(f"{validation_data_path}/Figure88BH.csv", delimiter=',')
+
+# Define parameters
+wavelength = 632.8e-9  # Wavelength of the source in meters
+polarization_values = [0, 90]  # Polarization values in degrees
+optical_power = 1e-3  # Optical power in watts
+NA = 0.2  # Numerical aperture
+diameters = np.geomspace(10e-9, 6e-6, 800)  # Diameters from 10 nm to 6 μm
+index = 1.55  # Refractive index of the cylinder
+medium_index = 1.335  # Refractive index of the medium
+
+# Calculate the volume of the cylinders
+volumes = np.pi * (diameters / 2)**2
+
+# Configure the Gaussian source
+source = Gaussian(
+    wavelength=wavelength,
+    polarization_value=polarization_values,
+    polarization_type='linear',
+    optical_power=optical_power,
+    NA=NA
+)
+
+# Setup cylindrical scatterers
+scatterer = Cylinder(
+    diameter=diameters,
+    index=index,
+    medium_index=medium_index,
+    source=source
+)
+
+# Create experimental setup
+experiment = Setup(
+    scatterer=scatterer,
+    source=source,
+    detector=None
+)
+
+# Compute PyMieSim scattering cross section data
+csca_data = experiment.get(measure.Csca, export_as_numpy=True).squeeze()
+normalized_csca = csca_data / volumes * 1e-4 / 100  # Normalize the data as per specific needs
+
+# Plotting the results
+plt.figure(figsize=(8, 4))
+plt.plot(diameters * 1e6, normalized_csca[0], 'C0-', linewidth=3, label='PyMieSim Polarization: 0')
+plt.plot(diameters * 1e6, normalized_csca[1], 'C1-', linewidth=3, label='PyMieSim Polarization: 90')
+plt.plot(diameters * 1e6, theoretical_data[0], 'k--', linewidth=1, label='Theoretical BH 8.8 Polarization: 0')
+plt.plot(diameters * 1e6, theoretical_data[1], 'k--', linewidth=1, label='Theoretical BH 8.8 Polarization: 90')
+
+plt.xlabel('Diameter (μm)')
+plt.ylabel('Normalized Scattering Cross Section')
+plt.title('Comparison of Scattering Cross Sections for Cylinders')
+plt.grid(True)
+plt.legend()
+plt.tight_layout()
+plt.show()
+
+# Verify data accuracy
+assert np.allclose(normalized_csca, theoretical_data, atol=1e-9), 'Error: mismatch on BH 8.8 calculation occurring'
```

## docs/examples/validation/plot_phase_function_detector.py

 * *Ordering differences only*

```diff
@@ -1,94 +1,94 @@
-"""
-Goniometric Coupling vs S1 S2 Comparison
-========================================
-
-"""
-
-# Standard library imports
-import numpy as np
-import matplotlib.pyplot as plt
-
-# PyMieSim imports
-from PyMieSim.experiment.detector import Photodiode
-from PyMieSim.experiment.scatterer import Sphere as ExperimentSphere
-from PyMieSim.experiment.source import Gaussian as ExperimentGaussian
-from PyMieSim.experiment import Setup
-
-from PyMieSim import measure
-from PyMieSim.single.scatterer import Sphere as SingleSphere
-from PyMieSim.single.source import Gaussian as SingleGaussian
-
-# Setup parameters
-scatterer_diameter = 0.3e-6  # Diameter of the scatterer in meters
-scatterer_index = 1.4  # Refractive index of the scatterer
-source_wavelength = 1.2e-6  # Wavelength of the source in meters
-
-# Experiment source and scatterer setup
-source = ExperimentGaussian(
-    wavelength=source_wavelength,
-    polarization_value=[0, 90],
-    polarization_type='linear',
-    optical_power=1,
-    NA=0.2
-)
-
-scatterer = ExperimentSphere(
-    diameter=scatterer_diameter,
-    index=scatterer_index,
-    medium_index=1.0,
-    source=source
-)
-
-# Detector setup
-detector = Photodiode(
-    NA=[0.1],
-    phi_offset=np.linspace(-180, 180, 100),
-    gamma_offset=0.0,
-    sampling=1000,
-    polarization_filter=None
-)
-
-# Configure experiment
-experiment = Setup(
-    scatterer=scatterer,
-    source=source,
-    detector=detector
-)
-
-# Gather data
-coupling_data = experiment.get(measure.coupling, export_as_numpy=True).squeeze()
-coupling_data /= coupling_data.max()  # Normalize data
-
-# Single scatterer simulation for S1 and S2
-single_source = SingleGaussian(
-    wavelength=source_wavelength,
-    polarization_value=90,
-    polarization_type='linear',
-    optical_power=1,
-    NA=0.2
-)
-
-single_scatterer = SingleSphere(
-    diameter=scatterer_diameter,
-    source=single_source,
-    index=scatterer_index,
-    medium_index=1.0
-)
-
-s1s2 = single_scatterer.get_s1s2()
-phi, s1, s2 = s1s2.phi, np.abs(s1s2.S1)**2, np.abs(s1s2.S2)**2
-s1 /= s1.max()  # Normalize S1 data
-s2 /= s2.max()  # Normalize S2 data
-
-# Plotting the results
-fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4), subplot_kw={'projection': 'polar'})
-ax1.plot(np.deg2rad(phi), s1, 'b-', linewidth=3, label='Computed S1')
-ax1.plot(np.deg2rad(detector.phi_offset), coupling_data[0], 'k--', linewidth=1, label='Coupling for polarization: 0')
-
-ax2.plot(np.deg2rad(phi), s2, 'r-', linewidth=3, label='Computed S2')
-ax2.plot(np.deg2rad(detector.phi_offset), coupling_data[1], 'k--', linewidth=1, label='Coupling for polarization: 90')
-
-ax1.legend(loc='upper right')
-ax2.legend(loc='upper right')
-plt.tight_layout()
-plt.show()
+"""
+Goniometric Coupling vs S1 S2 Comparison
+========================================
+
+"""
+
+# Standard library imports
+import numpy as np
+import matplotlib.pyplot as plt
+
+# PyMieSim imports
+from PyMieSim.experiment.detector import Photodiode
+from PyMieSim.experiment.scatterer import Sphere as ExperimentSphere
+from PyMieSim.experiment.source import Gaussian as ExperimentGaussian
+from PyMieSim.experiment import Setup
+
+from PyMieSim import measure
+from PyMieSim.single.scatterer import Sphere as SingleSphere
+from PyMieSim.single.source import Gaussian as SingleGaussian
+
+# Setup parameters
+scatterer_diameter = 0.3e-6  # Diameter of the scatterer in meters
+scatterer_index = 1.4  # Refractive index of the scatterer
+source_wavelength = 1.2e-6  # Wavelength of the source in meters
+
+# Experiment source and scatterer setup
+source = ExperimentGaussian(
+    wavelength=source_wavelength,
+    polarization_value=[0, 90],
+    polarization_type='linear',
+    optical_power=1,
+    NA=0.2
+)
+
+scatterer = ExperimentSphere(
+    diameter=scatterer_diameter,
+    index=scatterer_index,
+    medium_index=1.0,
+    source=source
+)
+
+# Detector setup
+detector = Photodiode(
+    NA=[0.1],
+    phi_offset=np.linspace(-180, 180, 100),
+    gamma_offset=0.0,
+    sampling=1000,
+    polarization_filter=None
+)
+
+# Configure experiment
+experiment = Setup(
+    scatterer=scatterer,
+    source=source,
+    detector=detector
+)
+
+# Gather data
+coupling_data = experiment.get(measure.coupling, export_as_numpy=True).squeeze()
+coupling_data /= coupling_data.max()  # Normalize data
+
+# Single scatterer simulation for S1 and S2
+single_source = SingleGaussian(
+    wavelength=source_wavelength,
+    polarization_value=90,
+    polarization_type='linear',
+    optical_power=1,
+    NA=0.2
+)
+
+single_scatterer = SingleSphere(
+    diameter=scatterer_diameter,
+    source=single_source,
+    index=scatterer_index,
+    medium_index=1.0
+)
+
+s1s2 = single_scatterer.get_s1s2()
+phi, s1, s2 = s1s2.phi, np.abs(s1s2.S1)**2, np.abs(s1s2.S2)**2
+s1 /= s1.max()  # Normalize S1 data
+s2 /= s2.max()  # Normalize S2 data
+
+# Plotting the results
+fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4), subplot_kw={'projection': 'polar'})
+ax1.plot(np.deg2rad(phi), s1, 'b-', linewidth=3, label='Computed S1')
+ax1.plot(np.deg2rad(detector.phi_offset), coupling_data[0], 'k--', linewidth=1, label='Coupling for polarization: 0')
+
+ax2.plot(np.deg2rad(phi), s2, 'r-', linewidth=3, label='Computed S2')
+ax2.plot(np.deg2rad(detector.phi_offset), coupling_data[1], 'k--', linewidth=1, label='Coupling for polarization: 90')
+
+ax1.legend(loc='upper right')
+ax2.legend(loc='upper right')
+plt.tight_layout()
+plt.show()
```

## docs/examples/validation/plot_pymiescatt_0.py

 * *Ordering differences only*

```diff
@@ -1,72 +1,72 @@
-"""
-PyMieSim vs PyMieScatt Comparison
-=================================
-"""
-
-# Standard library imports
-import numpy as np
-import matplotlib.pyplot as plt
-
-# PyMieSim imports
-from PyMieSim.experiment.scatterer import Sphere
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-import PyMieSim.measure as measure
-
-# PyMieScatt import
-import PyMieScatt as pms
-
-# Define parameters
-wavelength = 632.8e-9  # Wavelength of the light source in meters
-polarization_value = 0
-polarization_type = 'linear'
-optical_power = 1e-3  # Power in watts
-NA = 0.2  # Numerical aperture
-medium_index = 1.21
-refractive_index = 1.4
-diameter_range = np.geomspace(10e-9, 1e-6, 50)  # Geometric space for diameters
-
-# Setup source
-source = Gaussian(
-    wavelength=wavelength,
-    polarization_value=polarization_value,
-    polarization_type=polarization_type,
-    optical_power=optical_power,
-    NA=NA
-)
-
-# Setup scatterer
-scatterer = Sphere(
-    diameter=diameter_range,
-    index=refractive_index,
-    medium_index=medium_index,
-    source=source
-)
-
-# Define experiment setup
-experiment = Setup(
-    scatterer=scatterer,
-    source=source,
-    detector=None  # No detector set specified
-)
-
-# Simulate using PyMieSim
-sim_data = experiment.get(measure.Qsca, export_as_numpy=True).squeeze()
-
-# Simulate using PyMieScatt
-scatt_data = np.array([
-    pms.MieQ(m=refractive_index, diameter=d, wavelength=wavelength, nMedium=medium_index)[1]
-    for d in diameter_range
-])
-
-# Plot results
-plt.figure(figsize=(8, 4))
-plt.plot(diameter_range * 1e6, sim_data, 'C1-', linewidth=3, label='PyMieSim')
-plt.plot(diameter_range * 1e6, scatt_data, 'k--', linewidth=1, label='PyMieScatt')
-plt.xlabel('Diameter (μm)')
-plt.ylabel('Scattering Efficiency')
-plt.title('Comparison of Scattering Efficiency: PyMieSim vs PyMieScatt')
-plt.grid(True)
-plt.legend()
-plt.tight_layout()
-plt.show()
+"""
+PyMieSim vs PyMieScatt Comparison
+=================================
+"""
+
+# Standard library imports
+import numpy as np
+import matplotlib.pyplot as plt
+
+# PyMieSim imports
+from PyMieSim.experiment.scatterer import Sphere
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+import PyMieSim.measure as measure
+
+# PyMieScatt import
+import PyMieScatt as pms
+
+# Define parameters
+wavelength = 632.8e-9  # Wavelength of the light source in meters
+polarization_value = 0
+polarization_type = 'linear'
+optical_power = 1e-3  # Power in watts
+NA = 0.2  # Numerical aperture
+medium_index = 1.21
+refractive_index = 1.4
+diameter_range = np.geomspace(10e-9, 1e-6, 50)  # Geometric space for diameters
+
+# Setup source
+source = Gaussian(
+    wavelength=wavelength,
+    polarization_value=polarization_value,
+    polarization_type=polarization_type,
+    optical_power=optical_power,
+    NA=NA
+)
+
+# Setup scatterer
+scatterer = Sphere(
+    diameter=diameter_range,
+    index=refractive_index,
+    medium_index=medium_index,
+    source=source
+)
+
+# Define experiment setup
+experiment = Setup(
+    scatterer=scatterer,
+    source=source,
+    detector=None  # No detector set specified
+)
+
+# Simulate using PyMieSim
+sim_data = experiment.get(measure.Qsca, export_as_numpy=True).squeeze()
+
+# Simulate using PyMieScatt
+scatt_data = np.array([
+    pms.MieQ(m=refractive_index, diameter=d, wavelength=wavelength, nMedium=medium_index)[1]
+    for d in diameter_range
+])
+
+# Plot results
+plt.figure(figsize=(8, 4))
+plt.plot(diameter_range * 1e6, sim_data, 'C1-', linewidth=3, label='PyMieSim')
+plt.plot(diameter_range * 1e6, scatt_data, 'k--', linewidth=1, label='PyMieScatt')
+plt.xlabel('Diameter (μm)')
+plt.ylabel('Scattering Efficiency')
+plt.title('Comparison of Scattering Efficiency: PyMieSim vs PyMieScatt')
+plt.grid(True)
+plt.legend()
+plt.tight_layout()
+plt.show()
```

## docs/examples/validation/plot_pymiescatt_1.py

 * *Ordering differences only*

```diff
@@ -1,74 +1,74 @@
-"""
-Comparison of Scattering Efficiency Using PyMieSim vs PyMieScatt
-================================================================
-
-"""
-
-# Standard library imports
-import numpy as np
-import matplotlib.pyplot as plt
-
-# PyMieSim imports
-from PyMieSim.experiment.scatterer import Sphere
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-import PyMieSim.measure as measure
-
-# PyMieScatt import
-import PyMieScatt as pms
-
-# Define parameters
-wavelength = 632.8e-9  # Wavelength of the source in meters
-index = 1.4  # Refractive index of the sphere
-medium_index = 1.0  # Refractive index of the medium
-optical_power = 1  # Power of the light source in watts
-NA = 0.2  # Numerical aperture
-diameters = np.geomspace(10e-9, 6e-6, 800)  # Diameters from 10 nm to 6 μm
-
-# Configure the Gaussian source
-source = Gaussian(
-    wavelength=wavelength,
-    polarization_value=0,
-    polarization_type='linear',
-    optical_power=optical_power,
-    NA=NA
-)
-
-# Setup spherical scatterer
-scatterer = Sphere(
-    diameter=diameters,
-    index=index,
-    medium_index=medium_index,
-    source=source
-)
-
-# Create experimental setup
-experiment = Setup(
-    scatterer=scatterer,
-    source=source,
-    detector=None  # No detector configuration
-)
-
-# Compute PyMieSim scattering efficiency data
-sim_data = experiment.get(measure.Qsca, export_as_numpy=True).squeeze()
-
-# Compute PyMieScatt scattering efficiency data
-scatt_data = np.array([
-    pms.MieQ(
-        m=index,
-        wavelength=wavelength,
-        diameter=d
-    )[1] for d in diameters
-]).squeeze()
-
-# Plotting the results
-plt.figure(figsize=(8, 4))
-plt.plot(diameters * 1e6, sim_data, 'C1-', linewidth=3, label='PyMieSim')
-plt.plot(diameters * 1e6, scatt_data, 'k--', linewidth=1, label='PyMieScatt')
-plt.xlabel('Diameter (μm)')
-plt.ylabel('Scattering Efficiency')
-plt.title('Scattering Efficiency Comparison: Sphere')
-plt.grid(True)
-plt.legend()
-plt.tight_layout()
-plt.show()
+"""
+Comparison of Scattering Efficiency Using PyMieSim vs PyMieScatt
+================================================================
+
+"""
+
+# Standard library imports
+import numpy as np
+import matplotlib.pyplot as plt
+
+# PyMieSim imports
+from PyMieSim.experiment.scatterer import Sphere
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+import PyMieSim.measure as measure
+
+# PyMieScatt import
+import PyMieScatt as pms
+
+# Define parameters
+wavelength = 632.8e-9  # Wavelength of the source in meters
+index = 1.4  # Refractive index of the sphere
+medium_index = 1.0  # Refractive index of the medium
+optical_power = 1  # Power of the light source in watts
+NA = 0.2  # Numerical aperture
+diameters = np.geomspace(10e-9, 6e-6, 800)  # Diameters from 10 nm to 6 μm
+
+# Configure the Gaussian source
+source = Gaussian(
+    wavelength=wavelength,
+    polarization_value=0,
+    polarization_type='linear',
+    optical_power=optical_power,
+    NA=NA
+)
+
+# Setup spherical scatterer
+scatterer = Sphere(
+    diameter=diameters,
+    index=index,
+    medium_index=medium_index,
+    source=source
+)
+
+# Create experimental setup
+experiment = Setup(
+    scatterer=scatterer,
+    source=source,
+    detector=None  # No detector configuration
+)
+
+# Compute PyMieSim scattering efficiency data
+sim_data = experiment.get(measure.Qsca, export_as_numpy=True).squeeze()
+
+# Compute PyMieScatt scattering efficiency data
+scatt_data = np.array([
+    pms.MieQ(
+        m=index,
+        wavelength=wavelength,
+        diameter=d
+    )[1] for d in diameters
+]).squeeze()
+
+# Plotting the results
+plt.figure(figsize=(8, 4))
+plt.plot(diameters * 1e6, sim_data, 'C1-', linewidth=3, label='PyMieSim')
+plt.plot(diameters * 1e6, scatt_data, 'k--', linewidth=1, label='PyMieScatt')
+plt.xlabel('Diameter (μm)')
+plt.ylabel('Scattering Efficiency')
+plt.title('Scattering Efficiency Comparison: Sphere')
+plt.grid(True)
+plt.legend()
+plt.tight_layout()
+plt.show()
```

## docs/examples/validation/plot_pymiescatt_2.py

 * *Ordering differences only*

```diff
@@ -1,83 +1,83 @@
-"""
-PyMieSim vs PyMieScatt for Core-Shell Particles
-===============================================
-"""
-
-# Standard library imports
-import numpy as np
-import matplotlib.pyplot as plt
-
-# PyMieSim imports
-from PyMieSim.experiment.scatterer import CoreShell
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-import PyMieSim.measure as measure
-
-# PyMieScatt import
-import PyMieScatt as pms
-
-# Define parameters
-wavelength = 600e-9  # Light source wavelength in meters
-polarization_value = 0
-polarization_type = 'linear'
-optical_power = 1  # Power in watts
-NA = 0.2  # Numerical aperture
-medium_index = 1.2
-core_index = 1.5
-shell_index = 1.4
-shell_width = 600e-9  # Shell width in meters
-core_diameters = np.geomspace(10e-9, 500e-9, 400)  # Core diameters in meters
-
-# Setup source
-source = Gaussian(
-    wavelength=wavelength,
-    polarization_value=polarization_value,
-    polarization_type=polarization_type,
-    optical_power=optical_power,
-    NA=NA
-)
-
-# Setup scatterer
-scatterer = CoreShell(
-    core_diameter=core_diameters,
-    shell_width=shell_width,
-    core_index=core_index,
-    shell_index=shell_index,
-    medium_index=medium_index,
-    source=source
-)
-
-# Define experiment setup
-experiment = Setup(
-    scatterer=scatterer,
-    source=source,
-    detector=None  # No detector set specified
-)
-
-# Simulate using PyMieSim
-sim_data = experiment.get(measure.Qsca, export_as_numpy=True).squeeze()
-
-# Simulate using PyMieScatt
-scatt_data = np.array([
-    pms.MieQCoreShell(
-        mCore=core_index,
-        mShell=shell_index,
-        wavelength=wavelength,
-        dCore=diameter,
-        dShell=diameter + shell_width,
-        nMedium=medium_index
-    )[1]
-    for diameter in core_diameters
-])
-
-# Plot results
-plt.figure(figsize=(8, 4))
-plt.plot(core_diameters * 1e6, sim_data, 'C1-', linewidth=3, label='PyMieSim')
-plt.plot(core_diameters * 1e6, scatt_data, 'k--', linewidth=1, label='PyMieScatt')
-plt.xlabel('Core Diameter (μm)')
-plt.ylabel('Scattering Efficiency')
-plt.title('Scattering Efficiency Comparison for Core-Shell Particles')
-plt.grid(True)
-plt.legend()
-plt.tight_layout()
-plt.show()
+"""
+PyMieSim vs PyMieScatt for Core-Shell Particles
+===============================================
+"""
+
+# Standard library imports
+import numpy as np
+import matplotlib.pyplot as plt
+
+# PyMieSim imports
+from PyMieSim.experiment.scatterer import CoreShell
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+import PyMieSim.measure as measure
+
+# PyMieScatt import
+import PyMieScatt as pms
+
+# Define parameters
+wavelength = 600e-9  # Light source wavelength in meters
+polarization_value = 0
+polarization_type = 'linear'
+optical_power = 1  # Power in watts
+NA = 0.2  # Numerical aperture
+medium_index = 1.2
+core_index = 1.5
+shell_index = 1.4
+shell_width = 600e-9  # Shell width in meters
+core_diameters = np.geomspace(10e-9, 500e-9, 400)  # Core diameters in meters
+
+# Setup source
+source = Gaussian(
+    wavelength=wavelength,
+    polarization_value=polarization_value,
+    polarization_type=polarization_type,
+    optical_power=optical_power,
+    NA=NA
+)
+
+# Setup scatterer
+scatterer = CoreShell(
+    core_diameter=core_diameters,
+    shell_width=shell_width,
+    core_index=core_index,
+    shell_index=shell_index,
+    medium_index=medium_index,
+    source=source
+)
+
+# Define experiment setup
+experiment = Setup(
+    scatterer=scatterer,
+    source=source,
+    detector=None  # No detector set specified
+)
+
+# Simulate using PyMieSim
+sim_data = experiment.get(measure.Qsca, export_as_numpy=True).squeeze()
+
+# Simulate using PyMieScatt
+scatt_data = np.array([
+    pms.MieQCoreShell(
+        mCore=core_index,
+        mShell=shell_index,
+        wavelength=wavelength,
+        dCore=diameter,
+        dShell=diameter + shell_width,
+        nMedium=medium_index
+    )[1]
+    for diameter in core_diameters
+])
+
+# Plot results
+plt.figure(figsize=(8, 4))
+plt.plot(core_diameters * 1e6, sim_data, 'C1-', linewidth=3, label='PyMieSim')
+plt.plot(core_diameters * 1e6, scatt_data, 'k--', linewidth=1, label='PyMieScatt')
+plt.xlabel('Core Diameter (μm)')
+plt.ylabel('Scattering Efficiency')
+plt.title('Scattering Efficiency Comparison for Core-Shell Particles')
+plt.grid(True)
+plt.legend()
+plt.tight_layout()
+plt.show()
```

## docs/examples/validation/plot_pymiescatt_3.py

 * *Ordering differences only*

```diff
@@ -1,82 +1,82 @@
-"""
-PyMieSim vs PyMieScatt Scattering Efficiency Comparison for Core-Shell Particles
-================================================================================
-
-"""
-
-# Standard library imports
-import numpy as np
-import matplotlib.pyplot as plt
-
-# PyMieSim imports
-from PyMieSim.experiment.scatterer import CoreShell
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-import PyMieSim.measure as measure
-
-# PyMieScatt import
-import PyMieScatt as pms
-
-# Define parameters
-wavelength = 600e-9  # Light source wavelength in meters
-polarization_value = 0
-polarization_type = 'linear'
-optical_power = 1  # Optical power in watts
-NA = 0.2  # Numerical aperture
-medium_index = 1.0
-core_index = 1.5
-shell_index = 1.4
-shell_width = 600e-9  # Shell width in meters
-core_diameters = np.geomspace(10e-9, 500e-9, 400)  # Core diameters in meters
-
-# Configure the Gaussian source
-source = Gaussian(
-    wavelength=wavelength,
-    polarization_value=polarization_value,
-    polarization_type=polarization_type,
-    optical_power=optical_power,
-    NA=NA
-)
-
-# Setup core-shell scatterer
-scatterer = CoreShell(
-    core_diameter=core_diameters,
-    shell_width=shell_width,
-    core_index=core_index,
-    shell_index=shell_index,
-    medium_index=medium_index,
-    source=source
-)
-
-# Create experimental setup
-experiment = Setup(
-    scatterer=scatterer,
-    source=source,
-    detector=None
-)
-
-# Compute PyMieSim scattering efficiency data
-sim_data = experiment.get(measure.Qsca, export_as_numpy=True).squeeze()
-
-# Compute PyMieScatt scattering efficiency data
-scatt_data = np.array([
-    pms.MieQCoreShell(
-        mCore=core_index,
-        mShell=shell_index,
-        wavelength=wavelength,
-        dCore=diameter,
-        dShell=diameter + shell_width
-    )[1] for diameter in core_diameters
-]).squeeze()
-
-# Plotting the results
-plt.figure(figsize=(8, 4))
-plt.plot(core_diameters * 1e6, sim_data, 'C1-', linewidth=3, label='PyMieSim')
-plt.plot(core_diameters * 1e6, scatt_data, 'k--', linewidth=1, label='PyMieScatt')
-plt.xlabel('Core Diameter (μm)')
-plt.ylabel('Scattering Efficiency')
-plt.title('Comparison of Scattering Efficiency for Core-Shell Particles')
-plt.grid(True)
-plt.legend()
-plt.tight_layout()
-plt.show()
+"""
+PyMieSim vs PyMieScatt Scattering Efficiency Comparison for Core-Shell Particles
+================================================================================
+
+"""
+
+# Standard library imports
+import numpy as np
+import matplotlib.pyplot as plt
+
+# PyMieSim imports
+from PyMieSim.experiment.scatterer import CoreShell
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+import PyMieSim.measure as measure
+
+# PyMieScatt import
+import PyMieScatt as pms
+
+# Define parameters
+wavelength = 600e-9  # Light source wavelength in meters
+polarization_value = 0
+polarization_type = 'linear'
+optical_power = 1  # Optical power in watts
+NA = 0.2  # Numerical aperture
+medium_index = 1.0
+core_index = 1.5
+shell_index = 1.4
+shell_width = 600e-9  # Shell width in meters
+core_diameters = np.geomspace(10e-9, 500e-9, 400)  # Core diameters in meters
+
+# Configure the Gaussian source
+source = Gaussian(
+    wavelength=wavelength,
+    polarization_value=polarization_value,
+    polarization_type=polarization_type,
+    optical_power=optical_power,
+    NA=NA
+)
+
+# Setup core-shell scatterer
+scatterer = CoreShell(
+    core_diameter=core_diameters,
+    shell_width=shell_width,
+    core_index=core_index,
+    shell_index=shell_index,
+    medium_index=medium_index,
+    source=source
+)
+
+# Create experimental setup
+experiment = Setup(
+    scatterer=scatterer,
+    source=source,
+    detector=None
+)
+
+# Compute PyMieSim scattering efficiency data
+sim_data = experiment.get(measure.Qsca, export_as_numpy=True).squeeze()
+
+# Compute PyMieScatt scattering efficiency data
+scatt_data = np.array([
+    pms.MieQCoreShell(
+        mCore=core_index,
+        mShell=shell_index,
+        wavelength=wavelength,
+        dCore=diameter,
+        dShell=diameter + shell_width
+    )[1] for diameter in core_diameters
+]).squeeze()
+
+# Plotting the results
+plt.figure(figsize=(8, 4))
+plt.plot(core_diameters * 1e6, sim_data, 'C1-', linewidth=3, label='PyMieSim')
+plt.plot(core_diameters * 1e6, scatt_data, 'k--', linewidth=1, label='PyMieScatt')
+plt.xlabel('Core Diameter (μm)')
+plt.ylabel('Scattering Efficiency')
+plt.title('Comparison of Scattering Efficiency for Core-Shell Particles')
+plt.grid(True)
+plt.legend()
+plt.tight_layout()
+plt.show()
```

## docs/source/conf.py

 * *Ordering differences only*

```diff
@@ -1,189 +1,189 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-import sys
-from sphinx_gallery.sorting import ExplicitOrder
-from MPSPlots.styles import use_mpsplots_style
-from packaging.version import parse
-
-from PyMieSim.tools.directories import (
-    project_path,
-    doc_css_path,
-    version_path,
-)
-
-sys.path.insert(0, project_path)
-sys.path.insert(0, project_path.joinpath('PyMieSim'))
-
-
-def setup(app):
-    app.add_css_file(str(doc_css_path))
-
-
-autodoc_mock_imports = [
-    'numpy',
-    'matplotlib',
-    'DataVisual',
-    'MPSPlots',
-    'scipy',
-    'PyMieSim.Tools.measure',
-    'PyMieSim.bin'
-]
-
-project = 'PyMieSim'
-copyright = '2021, Martin Poinsinet de Sivry-Houle'
-author = 'Martin Poinsinet de Sivry-Houle'
-today_fmt = '%B %d, %Y'
-
-with open(version_path, "r+") as f:
-    version = release = f.read()
-
-
-extensions = [
-    'sphinx.ext.mathjax',
-    'numpydoc',
-    'pyvista.ext.plot_directive',
-    'sphinx_gallery.gen_gallery',
-]
-
-
-def reset_mpl(gallery_conf, fname):
-    use_mpsplots_style()
-
-
-try:
-    import pyvista
-    if sys.platform in ["linux", "linux2"]:
-        pyvista.start_xvfb()  # Works only on linux system!
-except ImportError:
-    print('Could not load pyvista library for 3D rendering')
-
-sphinx_gallery_conf = {
-    "examples_dirs": '../examples',
-    "gallery_dirs": "gallery",
-    "backreferences_dir": "api",
-    "subsection_order": ExplicitOrder(
-        [
-            "../examples/scatterer",
-            "../examples/detector",
-            "../examples/experiment",
-            "../examples/validation",
-            "../examples/extras",
-        ]
-    ),
-    'image_scrapers': ('matplotlib', 'pyvista'),
-    'ignore_pattern': '/__',
-    'plot_gallery': True,
-    'reset_modules': reset_mpl,
-    'thumbnail_size': [600, 600],
-    'download_all_examples': False,
-    'line_numbers': False,
-    'remove_config_comments': True,
-    'capture_repr': ('_repr_html_', '__repr__'),
-    'nested_sections': True,
-}
-
-autodoc_default_options = {
-    'members': False,
-    'members-order': 'bysource',
-    'undoc-members': False,
-    'show-inheritance': True,
-    'ignore-module-all': True
-}
-
-numpydoc_show_class_members = False
-
-source_suffix = '.rst'
-
-master_doc = 'index'
-
-language = 'en'
-
-highlight_language = 'python3'
-
-html_theme = "pydata_sphinx_theme"
-
-# -- Options for HTML output -------------------------------------------------
-# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output
-
-exclude_trees = []
-default_role = "autolink"
-pygments_style = "sphinx"
-
-# -- Sphinx-gallery configuration --------------------------------------------
-v = parse(release)
-if v.release is None:
-    raise ValueError(f"Ill-formed version: {version!r}. Version should follow PEP440")
-
-if v.is_devrelease:
-    binder_branch = "main"
-else:
-    major, minor = v.release[:2]
-    binder_branch = f"v{major}.{minor}.x"
-
-html_theme_options = {
-    # Navigation bar
-    "logo": {
-        "alt_text": "PyMieSim's logo",
-        "text": "PyMieSim",
-        "link": "https://pymiesim.readthedocs.io/en/latest/",
-    },
-    "icon_links": [
-        {
-            "name": "GitHub",
-            "url": "https://github.com/MartinPdeS/PyMieSim",
-            "icon": "fa-brands fa-github",
-        },
-        {
-            "name": "PyPI",
-            "url": "https://pypi.org/project/pymiesim/",
-            "icon": "fa-solid fa-box",
-        },
-    ],
-    "navbar_align": "left",
-    "navbar_end": ["version-switcher", "navbar-icon-links"],
-    "show_prev_next": False,
-    "show_version_warning_banner": True,
-    # Footer
-    "footer_start": ["copyright"],
-    "footer_end": ["sphinx-version", "theme-version"],
-    # Other
-    "pygment_light_style": "default",
-    "pygment_dark_style": "github-dark",
-}
-
-
-htmlhelp_basename = 'PyMieSimdoc'
-
-latex_elements = {}
-
-
-latex_documents = [
-    (master_doc, 'PyMieSim.tex', 'PyMieSim Documentation',
-     'Martin Poinsinet de Sivry-Houle', 'manual'),
-]
-
-man_pages = [
-    (master_doc, 'pymiesim', 'PyMieSim Documentation',
-     [author], 1)
-]
-
-texinfo_documents = [
-    (master_doc, 'PyMieSim', 'PyMieSim Documentation',
-     author, 'PyMieSim', 'One line description of project.',
-     'Miscellaneous'),
-]
-
-epub_title = project
-
-html_static_path = ['_static']
-templates_path = ['_templates']
-html_css_files = ['default.css']
-epub_exclude_files = ['search.html']
-
-
-# -- MyST --------------------------------------------------------------------
-myst_enable_extensions = [
-    # Enable fieldlist to allow for Field Lists like in rST (e.g., :orphan:)
-    "fieldlist",
-]
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import sys
+from sphinx_gallery.sorting import ExplicitOrder
+from MPSPlots.styles import use_mpsplots_style
+from packaging.version import parse
+
+from PyMieSim.tools.directories import (
+    project_path,
+    doc_css_path,
+    version_path,
+)
+
+sys.path.insert(0, project_path)
+sys.path.insert(0, project_path.joinpath('PyMieSim'))
+
+
+def setup(app):
+    app.add_css_file(str(doc_css_path))
+
+
+autodoc_mock_imports = [
+    'numpy',
+    'matplotlib',
+    'DataVisual',
+    'MPSPlots',
+    'scipy',
+    'PyMieSim.Tools.measure',
+    'PyMieSim.bin'
+]
+
+project = 'PyMieSim'
+copyright = '2021, Martin Poinsinet de Sivry-Houle'
+author = 'Martin Poinsinet de Sivry-Houle'
+today_fmt = '%B %d, %Y'
+
+with open(version_path, "r+") as f:
+    version = release = f.read()
+
+
+extensions = [
+    'sphinx.ext.mathjax',
+    'numpydoc',
+    'pyvista.ext.plot_directive',
+    'sphinx_gallery.gen_gallery',
+]
+
+
+def reset_mpl(gallery_conf, fname):
+    use_mpsplots_style()
+
+
+try:
+    import pyvista
+    if sys.platform in ["linux", "linux2"]:
+        pyvista.start_xvfb()  # Works only on linux system!
+except ImportError:
+    print('Could not load pyvista library for 3D rendering')
+
+sphinx_gallery_conf = {
+    "examples_dirs": '../examples',
+    "gallery_dirs": "gallery",
+    "backreferences_dir": "api",
+    "subsection_order": ExplicitOrder(
+        [
+            "../examples/scatterer",
+            "../examples/detector",
+            "../examples/experiment",
+            "../examples/validation",
+            "../examples/extras",
+        ]
+    ),
+    'image_scrapers': ('matplotlib', 'pyvista'),
+    'ignore_pattern': '/__',
+    'plot_gallery': True,
+    'reset_modules': reset_mpl,
+    'thumbnail_size': [600, 600],
+    'download_all_examples': False,
+    'line_numbers': False,
+    'remove_config_comments': True,
+    'capture_repr': ('_repr_html_', '__repr__'),
+    'nested_sections': True,
+}
+
+autodoc_default_options = {
+    'members': False,
+    'members-order': 'bysource',
+    'undoc-members': False,
+    'show-inheritance': True,
+    'ignore-module-all': True
+}
+
+numpydoc_show_class_members = False
+
+source_suffix = '.rst'
+
+master_doc = 'index'
+
+language = 'en'
+
+highlight_language = 'python3'
+
+html_theme = "pydata_sphinx_theme"
+
+# -- Options for HTML output -------------------------------------------------
+# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output
+
+exclude_trees = []
+default_role = "autolink"
+pygments_style = "sphinx"
+
+# -- Sphinx-gallery configuration --------------------------------------------
+v = parse(release)
+if v.release is None:
+    raise ValueError(f"Ill-formed version: {version!r}. Version should follow PEP440")
+
+if v.is_devrelease:
+    binder_branch = "main"
+else:
+    major, minor = v.release[:2]
+    binder_branch = f"v{major}.{minor}.x"
+
+html_theme_options = {
+    # Navigation bar
+    "logo": {
+        "alt_text": "PyMieSim's logo",
+        "text": "PyMieSim",
+        "link": "https://pymiesim.readthedocs.io/en/latest/",
+    },
+    "icon_links": [
+        {
+            "name": "GitHub",
+            "url": "https://github.com/MartinPdeS/PyMieSim",
+            "icon": "fa-brands fa-github",
+        },
+        {
+            "name": "PyPI",
+            "url": "https://pypi.org/project/pymiesim/",
+            "icon": "fa-solid fa-box",
+        },
+    ],
+    "navbar_align": "left",
+    "navbar_end": ["version-switcher", "navbar-icon-links"],
+    "show_prev_next": False,
+    "show_version_warning_banner": True,
+    # Footer
+    "footer_start": ["copyright"],
+    "footer_end": ["sphinx-version", "theme-version"],
+    # Other
+    "pygment_light_style": "default",
+    "pygment_dark_style": "github-dark",
+}
+
+
+htmlhelp_basename = 'PyMieSimdoc'
+
+latex_elements = {}
+
+
+latex_documents = [
+    (master_doc, 'PyMieSim.tex', 'PyMieSim Documentation',
+     'Martin Poinsinet de Sivry-Houle', 'manual'),
+]
+
+man_pages = [
+    (master_doc, 'pymiesim', 'PyMieSim Documentation',
+     [author], 1)
+]
+
+texinfo_documents = [
+    (master_doc, 'PyMieSim', 'PyMieSim Documentation',
+     author, 'PyMieSim', 'One line description of project.',
+     'Miscellaneous'),
+]
+
+epub_title = project
+
+html_static_path = ['_static']
+templates_path = ['_templates']
+html_css_files = ['default.css']
+epub_exclude_files = ['search.html']
+
+
+# -- MyST --------------------------------------------------------------------
+myst_enable_extensions = [
+    # Enable fieldlist to allow for Field Lists like in rST (e.g., :orphan:)
+    "fieldlist",
+]
```

## extern/pybind11/noxfile.py

 * *Ordering differences only*

```diff
@@ -1,107 +1,107 @@
-import os
-
-import nox
-
-nox.needs_version = ">=2022.1.7"
-nox.options.sessions = ["lint", "tests", "tests_packaging"]
-
-PYTHON_VERSIONS = [
-    "3.6",
-    "3.7",
-    "3.8",
-    "3.9",
-    "3.10",
-    "3.11",
-    "pypy3.7",
-    "pypy3.8",
-    "pypy3.9",
-]
-
-if os.environ.get("CI", None):
-    nox.options.error_on_missing_interpreters = True
-
-
-@nox.session(reuse_venv=True)
-def lint(session: nox.Session) -> None:
-    """
-    Lint the codebase (except for clang-format/tidy).
-    """
-    session.install("pre-commit")
-    session.run("pre-commit", "run", "-a", *session.posargs)
-
-
-@nox.session(python=PYTHON_VERSIONS)
-def tests(session: nox.Session) -> None:
-    """
-    Run the tests (requires a compiler).
-    """
-    tmpdir = session.create_tmp()
-    session.install("cmake")
-    session.install("-r", "tests/requirements.txt")
-    session.run(
-        "cmake",
-        "-S.",
-        f"-B{tmpdir}",
-        "-DPYBIND11_WERROR=ON",
-        "-DDOWNLOAD_CATCH=ON",
-        "-DDOWNLOAD_EIGEN=ON",
-        *session.posargs,
-    )
-    session.run("cmake", "--build", tmpdir)
-    session.run("cmake", "--build", tmpdir, "--config=Release", "--target", "check")
-
-
-@nox.session
-def tests_packaging(session: nox.Session) -> None:
-    """
-    Run the packaging tests.
-    """
-
-    session.install("-r", "tests/requirements.txt", "--prefer-binary")
-    session.run("pytest", "tests/extra_python_package", *session.posargs)
-
-
-@nox.session(reuse_venv=True)
-def docs(session: nox.Session) -> None:
-    """
-    Build the docs. Pass "serve" to serve.
-    """
-
-    session.install("-r", "docs/requirements.txt")
-    session.chdir("docs")
-
-    if "pdf" in session.posargs:
-        session.run("sphinx-build", "-M", "latexpdf", ".", "_build")
-        return
-
-    session.run("sphinx-build", "-M", "html", ".", "_build")
-
-    if "serve" in session.posargs:
-        session.log("Launching docs at http://localhost:8000/ - use Ctrl-C to quit")
-        session.run("python", "-m", "http.server", "8000", "-d", "_build/html")
-    elif session.posargs:
-        session.error("Unsupported argument to docs")
-
-
-@nox.session(reuse_venv=True)
-def make_changelog(session: nox.Session) -> None:
-    """
-    Inspect the closed issues and make entries for a changelog.
-    """
-    session.install("ghapi", "rich")
-    session.run("python", "tools/make_changelog.py")
-
-
-@nox.session(reuse_venv=True)
-def build(session: nox.Session) -> None:
-    """
-    Build SDists and wheels.
-    """
-
-    session.install("build")
-    session.log("Building normal files")
-    session.run("python", "-m", "build", *session.posargs)
-    session.log("Building pybind11-global files (PYBIND11_GLOBAL_SDIST=1)")
-    session.run(
-        "python", "-m", "build", *session.posargs, env={"PYBIND11_GLOBAL_SDIST": "1"}
-    )
+import os
+
+import nox
+
+nox.needs_version = ">=2022.1.7"
+nox.options.sessions = ["lint", "tests", "tests_packaging"]
+
+PYTHON_VERSIONS = [
+    "3.6",
+    "3.7",
+    "3.8",
+    "3.9",
+    "3.10",
+    "3.11",
+    "pypy3.7",
+    "pypy3.8",
+    "pypy3.9",
+]
+
+if os.environ.get("CI", None):
+    nox.options.error_on_missing_interpreters = True
+
+
+@nox.session(reuse_venv=True)
+def lint(session: nox.Session) -> None:
+    """
+    Lint the codebase (except for clang-format/tidy).
+    """
+    session.install("pre-commit")
+    session.run("pre-commit", "run", "-a", *session.posargs)
+
+
+@nox.session(python=PYTHON_VERSIONS)
+def tests(session: nox.Session) -> None:
+    """
+    Run the tests (requires a compiler).
+    """
+    tmpdir = session.create_tmp()
+    session.install("cmake")
+    session.install("-r", "tests/requirements.txt")
+    session.run(
+        "cmake",
+        "-S.",
+        f"-B{tmpdir}",
+        "-DPYBIND11_WERROR=ON",
+        "-DDOWNLOAD_CATCH=ON",
+        "-DDOWNLOAD_EIGEN=ON",
+        *session.posargs,
+    )
+    session.run("cmake", "--build", tmpdir)
+    session.run("cmake", "--build", tmpdir, "--config=Release", "--target", "check")
+
+
+@nox.session
+def tests_packaging(session: nox.Session) -> None:
+    """
+    Run the packaging tests.
+    """
+
+    session.install("-r", "tests/requirements.txt", "--prefer-binary")
+    session.run("pytest", "tests/extra_python_package", *session.posargs)
+
+
+@nox.session(reuse_venv=True)
+def docs(session: nox.Session) -> None:
+    """
+    Build the docs. Pass "serve" to serve.
+    """
+
+    session.install("-r", "docs/requirements.txt")
+    session.chdir("docs")
+
+    if "pdf" in session.posargs:
+        session.run("sphinx-build", "-M", "latexpdf", ".", "_build")
+        return
+
+    session.run("sphinx-build", "-M", "html", ".", "_build")
+
+    if "serve" in session.posargs:
+        session.log("Launching docs at http://localhost:8000/ - use Ctrl-C to quit")
+        session.run("python", "-m", "http.server", "8000", "-d", "_build/html")
+    elif session.posargs:
+        session.error("Unsupported argument to docs")
+
+
+@nox.session(reuse_venv=True)
+def make_changelog(session: nox.Session) -> None:
+    """
+    Inspect the closed issues and make entries for a changelog.
+    """
+    session.install("ghapi", "rich")
+    session.run("python", "tools/make_changelog.py")
+
+
+@nox.session(reuse_venv=True)
+def build(session: nox.Session) -> None:
+    """
+    Build SDists and wheels.
+    """
+
+    session.install("build")
+    session.log("Building normal files")
+    session.run("python", "-m", "build", *session.posargs)
+    session.log("Building pybind11-global files (PYBIND11_GLOBAL_SDIST=1)")
+    session.run(
+        "python", "-m", "build", *session.posargs, env={"PYBIND11_GLOBAL_SDIST": "1"}
+    )
```

## extern/pybind11/setup.py

 * *Ordering differences only*

```diff
@@ -1,150 +1,150 @@
-#!/usr/bin/env python3
-
-# Setup script for PyPI; use CMakeFile.txt to build extension modules
-
-import contextlib
-import os
-import re
-import shutil
-import string
-import subprocess
-import sys
-from pathlib import Path
-from tempfile import TemporaryDirectory
-from typing import Dict, Iterator, List, Union
-
-import setuptools.command.sdist
-
-DIR = Path(__file__).parent.absolute()
-VERSION_REGEX = re.compile(
-    r"^\s*#\s*define\s+PYBIND11_VERSION_([A-Z]+)\s+(.*)$", re.MULTILINE
-)
-VERSION_FILE = Path("pybind11/_version.py")
-COMMON_FILE = Path("include/pybind11/detail/common.h")
-
-
-def build_expected_version_hex(matches: Dict[str, str]) -> str:
-    patch_level_serial = matches["PATCH"]
-    serial = None
-    major = int(matches["MAJOR"])
-    minor = int(matches["MINOR"])
-    flds = patch_level_serial.split(".")
-    if flds:
-        patch = int(flds[0])
-        if len(flds) == 1:
-            level = "0"
-            serial = 0
-        elif len(flds) == 2:
-            level_serial = flds[1]
-            for level in ("a", "b", "c", "dev"):
-                if level_serial.startswith(level):
-                    serial = int(level_serial[len(level) :])
-                    break
-    if serial is None:
-        msg = f'Invalid PYBIND11_VERSION_PATCH: "{patch_level_serial}"'
-        raise RuntimeError(msg)
-    version_hex_str = f"{major:02x}{minor:02x}{patch:02x}{level[:1]}{serial:x}"
-    return f"0x{version_hex_str.upper()}"
-
-
-# PYBIND11_GLOBAL_SDIST will build a different sdist, with the python-headers
-# files, and the sys.prefix files (CMake and headers).
-
-global_sdist = os.environ.get("PYBIND11_GLOBAL_SDIST", False)
-
-setup_py = Path(
-    "tools/setup_global.py.in" if global_sdist else "tools/setup_main.py.in"
-)
-extra_cmd = 'cmdclass["sdist"] = SDist\n'
-
-to_src = (
-    (Path("pyproject.toml"), Path("tools/pyproject.toml")),
-    (Path("setup.py"), setup_py),
-)
-
-
-# Read the listed version
-loc: Dict[str, str] = {}
-code = compile(VERSION_FILE.read_text(encoding="utf-8"), "pybind11/_version.py", "exec")
-exec(code, loc)
-version = loc["__version__"]
-
-# Verify that the version matches the one in C++
-matches = dict(VERSION_REGEX.findall(COMMON_FILE.read_text(encoding="utf8")))
-cpp_version = "{MAJOR}.{MINOR}.{PATCH}".format(**matches)
-if version != cpp_version:
-    msg = f"Python version {version} does not match C++ version {cpp_version}!"
-    raise RuntimeError(msg)
-
-version_hex = matches.get("HEX", "MISSING")
-exp_version_hex = build_expected_version_hex(matches)
-if version_hex != exp_version_hex:
-    msg = f"PYBIND11_VERSION_HEX {version_hex} does not match expected value {exp_version_hex}!"
-    raise RuntimeError(msg)
-
-
-# TODO: use literals & overload (typing extensions or Python 3.8)
-def get_and_replace(
-    filename: Path, binary: bool = False, **opts: str
-) -> Union[bytes, str]:
-    if binary:
-        contents = filename.read_bytes()
-        return string.Template(contents.decode()).substitute(opts).encode()
-
-    return string.Template(filename.read_text()).substitute(opts)
-
-
-# Use our input files instead when making the SDist (and anything that depends
-# on it, like a wheel)
-class SDist(setuptools.command.sdist.sdist):  # type: ignore[misc]
-    def make_release_tree(self, base_dir: str, files: List[str]) -> None:
-        super().make_release_tree(base_dir, files)
-
-        for to, src in to_src:
-            txt = get_and_replace(src, binary=True, version=version, extra_cmd="")
-
-            dest = Path(base_dir) / to
-
-            # This is normally linked, so unlink before writing!
-            dest.unlink()
-            dest.write_bytes(txt)  # type: ignore[arg-type]
-
-
-# Remove the CMake install directory when done
-@contextlib.contextmanager
-def remove_output(*sources: str) -> Iterator[None]:
-    try:
-        yield
-    finally:
-        for src in sources:
-            shutil.rmtree(src)
-
-
-with remove_output("pybind11/include", "pybind11/share"):
-    # Generate the files if they are not present.
-    with TemporaryDirectory() as tmpdir:
-        cmd = ["cmake", "-S", ".", "-B", tmpdir] + [
-            "-DCMAKE_INSTALL_PREFIX=pybind11",
-            "-DBUILD_TESTING=OFF",
-            "-DPYBIND11_NOPYTHON=ON",
-            "-Dprefix_for_pc_file=${pcfiledir}/../../",
-        ]
-        if "CMAKE_ARGS" in os.environ:
-            fcommand = [
-                c
-                for c in os.environ["CMAKE_ARGS"].split()
-                if "DCMAKE_INSTALL_PREFIX" not in c
-            ]
-            cmd += fcommand
-        subprocess.run(cmd, check=True, cwd=DIR, stdout=sys.stdout, stderr=sys.stderr)
-        subprocess.run(
-            ["cmake", "--install", tmpdir],
-            check=True,
-            cwd=DIR,
-            stdout=sys.stdout,
-            stderr=sys.stderr,
-        )
-
-    txt = get_and_replace(setup_py, version=version, extra_cmd=extra_cmd)
-    code = compile(txt, setup_py, "exec")
-    exec(code, {"SDist": SDist})
+#!/usr/bin/env python3
+
+# Setup script for PyPI; use CMakeFile.txt to build extension modules
+
+import contextlib
+import os
+import re
+import shutil
+import string
+import subprocess
+import sys
+from pathlib import Path
+from tempfile import TemporaryDirectory
+from typing import Dict, Iterator, List, Union
+
+import setuptools.command.sdist
+
+DIR = Path(__file__).parent.absolute()
+VERSION_REGEX = re.compile(
+    r"^\s*#\s*define\s+PYBIND11_VERSION_([A-Z]+)\s+(.*)$", re.MULTILINE
+)
+VERSION_FILE = Path("pybind11/_version.py")
+COMMON_FILE = Path("include/pybind11/detail/common.h")
+
+
+def build_expected_version_hex(matches: Dict[str, str]) -> str:
+    patch_level_serial = matches["PATCH"]
+    serial = None
+    major = int(matches["MAJOR"])
+    minor = int(matches["MINOR"])
+    flds = patch_level_serial.split(".")
+    if flds:
+        patch = int(flds[0])
+        if len(flds) == 1:
+            level = "0"
+            serial = 0
+        elif len(flds) == 2:
+            level_serial = flds[1]
+            for level in ("a", "b", "c", "dev"):
+                if level_serial.startswith(level):
+                    serial = int(level_serial[len(level) :])
+                    break
+    if serial is None:
+        msg = f'Invalid PYBIND11_VERSION_PATCH: "{patch_level_serial}"'
+        raise RuntimeError(msg)
+    version_hex_str = f"{major:02x}{minor:02x}{patch:02x}{level[:1]}{serial:x}"
+    return f"0x{version_hex_str.upper()}"
+
+
+# PYBIND11_GLOBAL_SDIST will build a different sdist, with the python-headers
+# files, and the sys.prefix files (CMake and headers).
+
+global_sdist = os.environ.get("PYBIND11_GLOBAL_SDIST", False)
+
+setup_py = Path(
+    "tools/setup_global.py.in" if global_sdist else "tools/setup_main.py.in"
+)
+extra_cmd = 'cmdclass["sdist"] = SDist\n'
+
+to_src = (
+    (Path("pyproject.toml"), Path("tools/pyproject.toml")),
+    (Path("setup.py"), setup_py),
+)
+
+
+# Read the listed version
+loc: Dict[str, str] = {}
+code = compile(VERSION_FILE.read_text(encoding="utf-8"), "pybind11/_version.py", "exec")
+exec(code, loc)
+version = loc["__version__"]
+
+# Verify that the version matches the one in C++
+matches = dict(VERSION_REGEX.findall(COMMON_FILE.read_text(encoding="utf8")))
+cpp_version = "{MAJOR}.{MINOR}.{PATCH}".format(**matches)
+if version != cpp_version:
+    msg = f"Python version {version} does not match C++ version {cpp_version}!"
+    raise RuntimeError(msg)
+
+version_hex = matches.get("HEX", "MISSING")
+exp_version_hex = build_expected_version_hex(matches)
+if version_hex != exp_version_hex:
+    msg = f"PYBIND11_VERSION_HEX {version_hex} does not match expected value {exp_version_hex}!"
+    raise RuntimeError(msg)
+
+
+# TODO: use literals & overload (typing extensions or Python 3.8)
+def get_and_replace(
+    filename: Path, binary: bool = False, **opts: str
+) -> Union[bytes, str]:
+    if binary:
+        contents = filename.read_bytes()
+        return string.Template(contents.decode()).substitute(opts).encode()
+
+    return string.Template(filename.read_text()).substitute(opts)
+
+
+# Use our input files instead when making the SDist (and anything that depends
+# on it, like a wheel)
+class SDist(setuptools.command.sdist.sdist):  # type: ignore[misc]
+    def make_release_tree(self, base_dir: str, files: List[str]) -> None:
+        super().make_release_tree(base_dir, files)
+
+        for to, src in to_src:
+            txt = get_and_replace(src, binary=True, version=version, extra_cmd="")
+
+            dest = Path(base_dir) / to
+
+            # This is normally linked, so unlink before writing!
+            dest.unlink()
+            dest.write_bytes(txt)  # type: ignore[arg-type]
+
+
+# Remove the CMake install directory when done
+@contextlib.contextmanager
+def remove_output(*sources: str) -> Iterator[None]:
+    try:
+        yield
+    finally:
+        for src in sources:
+            shutil.rmtree(src)
+
+
+with remove_output("pybind11/include", "pybind11/share"):
+    # Generate the files if they are not present.
+    with TemporaryDirectory() as tmpdir:
+        cmd = ["cmake", "-S", ".", "-B", tmpdir] + [
+            "-DCMAKE_INSTALL_PREFIX=pybind11",
+            "-DBUILD_TESTING=OFF",
+            "-DPYBIND11_NOPYTHON=ON",
+            "-Dprefix_for_pc_file=${pcfiledir}/../../",
+        ]
+        if "CMAKE_ARGS" in os.environ:
+            fcommand = [
+                c
+                for c in os.environ["CMAKE_ARGS"].split()
+                if "DCMAKE_INSTALL_PREFIX" not in c
+            ]
+            cmd += fcommand
+        subprocess.run(cmd, check=True, cwd=DIR, stdout=sys.stdout, stderr=sys.stderr)
+        subprocess.run(
+            ["cmake", "--install", tmpdir],
+            check=True,
+            cwd=DIR,
+            stdout=sys.stdout,
+            stderr=sys.stderr,
+        )
+
+    txt = get_and_replace(setup_py, version=version, extra_cmd=extra_cmd)
+    code = compile(txt, setup_py, "exec")
+    exec(code, {"SDist": SDist})
```

## extern/pybind11/docs/benchmark.py

 * *Ordering differences only*

```diff
@@ -1,87 +1,87 @@
-import datetime as dt
-import os
-import random
-
-nfns = 4  # Functions per class
-nargs = 4  # Arguments per function
-
-
-def generate_dummy_code_pybind11(nclasses=10):
-    decl = ""
-    bindings = ""
-
-    for cl in range(nclasses):
-        decl += f"class cl{cl:03};\n"
-    decl += "\n"
-
-    for cl in range(nclasses):
-        decl += f"class {cl:03} {{\n"
-        decl += "public:\n"
-        bindings += f'    py::class_<cl{cl:03}>(m, "cl{cl:03}")\n'
-        for fn in range(nfns):
-            ret = random.randint(0, nclasses - 1)
-            params = [random.randint(0, nclasses - 1) for i in range(nargs)]
-            decl += f"    cl{ret:03} *fn_{fn:03}("
-            decl += ", ".join(f"cl{p:03} *" for p in params)
-            decl += ");\n"
-            bindings += f'        .def("fn_{fn:03}", &cl{cl:03}::fn_{fn:03})\n'
-        decl += "};\n\n"
-        bindings += "        ;\n"
-
-    result = "#include <pybind11/pybind11.h>\n\n"
-    result += "namespace py = pybind11;\n\n"
-    result += decl + "\n"
-    result += "PYBIND11_MODULE(example, m) {\n"
-    result += bindings
-    result += "}"
-    return result
-
-
-def generate_dummy_code_boost(nclasses=10):
-    decl = ""
-    bindings = ""
-
-    for cl in range(nclasses):
-        decl += f"class cl{cl:03};\n"
-    decl += "\n"
-
-    for cl in range(nclasses):
-        decl += "class cl%03i {\n" % cl
-        decl += "public:\n"
-        bindings += f'    py::class_<cl{cl:03}>("cl{cl:03}")\n'
-        for fn in range(nfns):
-            ret = random.randint(0, nclasses - 1)
-            params = [random.randint(0, nclasses - 1) for i in range(nargs)]
-            decl += f"    cl{ret:03} *fn_{fn:03}("
-            decl += ", ".join(f"cl{p:03} *" for p in params)
-            decl += ");\n"
-            bindings += f'        .def("fn_{fn:03}", &cl{cl:03}::fn_{fn:03}, py::return_value_policy<py::manage_new_object>())\n'
-        decl += "};\n\n"
-        bindings += "        ;\n"
-
-    result = "#include <boost/python.hpp>\n\n"
-    result += "namespace py = boost::python;\n\n"
-    result += decl + "\n"
-    result += "BOOST_PYTHON_MODULE(example) {\n"
-    result += bindings
-    result += "}"
-    return result
-
-
-for codegen in [generate_dummy_code_pybind11, generate_dummy_code_boost]:
-    print("{")
-    for i in range(0, 10):
-        nclasses = 2**i
-        with open("test.cpp", "w") as f:
-            f.write(codegen(nclasses))
-        n1 = dt.datetime.now()
-        os.system(
-            "g++ -Os -shared -rdynamic -undefined dynamic_lookup "
-            "-fvisibility=hidden -std=c++14 test.cpp -I include "
-            "-I /System/Library/Frameworks/Python.framework/Headers -o test.so"
-        )
-        n2 = dt.datetime.now()
-        elapsed = (n2 - n1).total_seconds()
-        size = os.stat("test.so").st_size
-        print("   {%i, %f, %i}," % (nclasses * nfns, elapsed, size))
-    print("}")
+import datetime as dt
+import os
+import random
+
+nfns = 4  # Functions per class
+nargs = 4  # Arguments per function
+
+
+def generate_dummy_code_pybind11(nclasses=10):
+    decl = ""
+    bindings = ""
+
+    for cl in range(nclasses):
+        decl += f"class cl{cl:03};\n"
+    decl += "\n"
+
+    for cl in range(nclasses):
+        decl += f"class {cl:03} {{\n"
+        decl += "public:\n"
+        bindings += f'    py::class_<cl{cl:03}>(m, "cl{cl:03}")\n'
+        for fn in range(nfns):
+            ret = random.randint(0, nclasses - 1)
+            params = [random.randint(0, nclasses - 1) for i in range(nargs)]
+            decl += f"    cl{ret:03} *fn_{fn:03}("
+            decl += ", ".join(f"cl{p:03} *" for p in params)
+            decl += ");\n"
+            bindings += f'        .def("fn_{fn:03}", &cl{cl:03}::fn_{fn:03})\n'
+        decl += "};\n\n"
+        bindings += "        ;\n"
+
+    result = "#include <pybind11/pybind11.h>\n\n"
+    result += "namespace py = pybind11;\n\n"
+    result += decl + "\n"
+    result += "PYBIND11_MODULE(example, m) {\n"
+    result += bindings
+    result += "}"
+    return result
+
+
+def generate_dummy_code_boost(nclasses=10):
+    decl = ""
+    bindings = ""
+
+    for cl in range(nclasses):
+        decl += f"class cl{cl:03};\n"
+    decl += "\n"
+
+    for cl in range(nclasses):
+        decl += "class cl%03i {\n" % cl
+        decl += "public:\n"
+        bindings += f'    py::class_<cl{cl:03}>("cl{cl:03}")\n'
+        for fn in range(nfns):
+            ret = random.randint(0, nclasses - 1)
+            params = [random.randint(0, nclasses - 1) for i in range(nargs)]
+            decl += f"    cl{ret:03} *fn_{fn:03}("
+            decl += ", ".join(f"cl{p:03} *" for p in params)
+            decl += ");\n"
+            bindings += f'        .def("fn_{fn:03}", &cl{cl:03}::fn_{fn:03}, py::return_value_policy<py::manage_new_object>())\n'
+        decl += "};\n\n"
+        bindings += "        ;\n"
+
+    result = "#include <boost/python.hpp>\n\n"
+    result += "namespace py = boost::python;\n\n"
+    result += decl + "\n"
+    result += "BOOST_PYTHON_MODULE(example) {\n"
+    result += bindings
+    result += "}"
+    return result
+
+
+for codegen in [generate_dummy_code_pybind11, generate_dummy_code_boost]:
+    print("{")
+    for i in range(0, 10):
+        nclasses = 2**i
+        with open("test.cpp", "w") as f:
+            f.write(codegen(nclasses))
+        n1 = dt.datetime.now()
+        os.system(
+            "g++ -Os -shared -rdynamic -undefined dynamic_lookup "
+            "-fvisibility=hidden -std=c++14 test.cpp -I include "
+            "-I /System/Library/Frameworks/Python.framework/Headers -o test.so"
+        )
+        n2 = dt.datetime.now()
+        elapsed = (n2 - n1).total_seconds()
+        size = os.stat("test.so").st_size
+        print("   {%i, %f, %i}," % (nclasses * nfns, elapsed, size))
+    print("}")
```

## extern/pybind11/docs/conf.py

 * *Ordering differences only*

```diff
@@ -1,368 +1,368 @@
-#!/usr/bin/env python3
-#
-# pybind11 documentation build configuration file, created by
-# sphinx-quickstart on Sun Oct 11 19:23:48 2015.
-#
-# This file is execfile()d with the current directory set to its
-# containing dir.
-#
-# Note that not all possible configuration values are present in this
-# autogenerated file.
-#
-# All configuration values have a default; values that are commented out
-# serve to show the default.
-
-import os
-import re
-import subprocess
-import sys
-from pathlib import Path
-
-DIR = Path(__file__).parent.resolve()
-
-# If extensions (or modules to document with autodoc) are in another directory,
-# add these directories to sys.path here. If the directory is relative to the
-# documentation root, use os.path.abspath to make it absolute, like shown here.
-# sys.path.insert(0, os.path.abspath('.'))
-
-# -- General configuration ------------------------------------------------
-
-# If your documentation needs a minimal Sphinx version, state it here.
-# needs_sphinx = '1.0'
-
-# Add any Sphinx extension module names here, as strings. They can be
-# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
-# ones.
-extensions = [
-    "breathe",
-    "sphinx_copybutton",
-    "sphinxcontrib.rsvgconverter",
-    "sphinxcontrib.moderncmakedomain",
-]
-
-breathe_projects = {"pybind11": ".build/doxygenxml/"}
-breathe_default_project = "pybind11"
-breathe_domain_by_extension = {"h": "cpp"}
-
-# Add any paths that contain templates here, relative to this directory.
-templates_path = [".templates"]
-
-# The suffix(es) of source filenames.
-# You can specify multiple suffix as a list of string:
-# source_suffix = ['.rst', '.md']
-source_suffix = ".rst"
-
-# The encoding of source files.
-# source_encoding = 'utf-8-sig'
-
-# The master toctree document.
-master_doc = "index"
-
-# General information about the project.
-project = "pybind11"
-copyright = "2017, Wenzel Jakob"
-author = "Wenzel Jakob"
-
-# The version info for the project you're documenting, acts as replacement for
-# |version| and |release|, also used in various other places throughout the
-# built documents.
-
-# Read the listed version
-with open("../pybind11/_version.py") as f:
-    code = compile(f.read(), "../pybind11/_version.py", "exec")
-loc = {}
-exec(code, loc)
-
-# The full version, including alpha/beta/rc tags.
-version = loc["__version__"]
-
-# The language for content autogenerated by Sphinx. Refer to documentation
-# for a list of supported languages.
-#
-# This is also used if you do content translation via gettext catalogs.
-# Usually you set "language" from the command line for these cases.
-language = None
-
-# There are two options for replacing |today|: either, you set today to some
-# non-false value, then it is used:
-# today = ''
-# Else, today_fmt is used as the format for a strftime call.
-# today_fmt = '%B %d, %Y'
-
-# List of patterns, relative to source directory, that match files and
-# directories to ignore when looking for source files.
-exclude_patterns = [".build", "release.rst"]
-
-# The reST default role (used for this markup: `text`) to use for all
-# documents.
-default_role = "any"
-
-# If true, '()' will be appended to :func: etc. cross-reference text.
-# add_function_parentheses = True
-
-# If true, the current module name will be prepended to all description
-# unit titles (such as .. function::).
-# add_module_names = True
-
-# If true, sectionauthor and moduleauthor directives will be shown in the
-# output. They are ignored by default.
-# show_authors = False
-
-# The name of the Pygments (syntax highlighting) style to use.
-# pygments_style = 'monokai'
-
-# A list of ignored prefixes for module index sorting.
-# modindex_common_prefix = []
-
-# If true, keep warnings as "system message" paragraphs in the built documents.
-# keep_warnings = False
-
-# If true, `todo` and `todoList` produce output, else they produce nothing.
-todo_include_todos = False
-
-
-# -- Options for HTML output ----------------------------------------------
-
-# The theme to use for HTML and HTML Help pages.  See the documentation for
-# a list of builtin themes.
-
-html_theme = "furo"
-
-# Theme options are theme-specific and customize the look and feel of a theme
-# further.  For a list of options available for each theme, see the
-# documentation.
-# html_theme_options = {}
-
-# Add any paths that contain custom themes here, relative to this directory.
-# html_theme_path = []
-
-# The name for this set of Sphinx documents.  If None, it defaults to
-# "<project> v<version> documentation".
-# html_title = None
-
-# A shorter title for the navigation bar.  Default is the same as html_title.
-# html_short_title = None
-
-# The name of an image file (relative to this directory) to place at the top
-# of the sidebar.
-# html_logo = None
-
-# The name of an image file (within the static path) to use as favicon of the
-# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
-# pixels large.
-# html_favicon = None
-
-# Add any paths that contain custom static files (such as style sheets) here,
-# relative to this directory. They are copied after the builtin static files,
-# so a file named "default.css" will overwrite the builtin "default.css".
-html_static_path = ["_static"]
-
-html_css_files = [
-    "css/custom.css",
-]
-
-# Add any extra paths that contain custom files (such as robots.txt or
-# .htaccess) here, relative to this directory. These files are copied
-# directly to the root of the documentation.
-# html_extra_path = []
-
-# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
-# using the given strftime format.
-# html_last_updated_fmt = '%b %d, %Y'
-
-# If true, SmartyPants will be used to convert quotes and dashes to
-# typographically correct entities.
-# html_use_smartypants = True
-
-# Custom sidebar templates, maps document names to template names.
-# html_sidebars = {}
-
-# Additional templates that should be rendered to pages, maps page names to
-# template names.
-# html_additional_pages = {}
-
-# If false, no module index is generated.
-# html_domain_indices = True
-
-# If false, no index is generated.
-# html_use_index = True
-
-# If true, the index is split into individual pages for each letter.
-# html_split_index = False
-
-# If true, links to the reST sources are added to the pages.
-# html_show_sourcelink = True
-
-# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
-# html_show_sphinx = True
-
-# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
-# html_show_copyright = True
-
-# If true, an OpenSearch description file will be output, and all pages will
-# contain a <link> tag referring to it.  The value of this option must be the
-# base URL from which the finished HTML is served.
-# html_use_opensearch = ''
-
-# This is the file name suffix for HTML files (e.g. ".xhtml").
-# html_file_suffix = None
-
-# Language to be used for generating the HTML full-text search index.
-# Sphinx supports the following languages:
-#   'da', 'de', 'en', 'es', 'fi', 'fr', 'h', 'it', 'ja'
-#   'nl', 'no', 'pt', 'ro', 'r', 'sv', 'tr'
-# html_search_language = 'en'
-
-# A dictionary with options for the search language support, empty by default.
-# Now only 'ja' uses this config value
-# html_search_options = {'type': 'default'}
-
-# The name of a javascript file (relative to the configuration directory) that
-# implements a search results scorer. If empty, the default will be used.
-# html_search_scorer = 'scorer.js'
-
-# Output file base name for HTML help builder.
-htmlhelp_basename = "pybind11doc"
-
-# -- Options for LaTeX output ---------------------------------------------
-
-latex_engine = "pdflatex"
-
-latex_elements = {
-    # The paper size ('letterpaper' or 'a4paper').
-    # 'papersize': 'letterpaper',
-    #
-    # The font size ('10pt', '11pt' or '12pt').
-    # 'pointsize': '10pt',
-    #
-    # Additional stuff for the LaTeX preamble.
-    # remove blank pages (between the title page and the TOC, etc.)
-    "classoptions": ",openany,oneside",
-    "preamble": r"""
-\usepackage{fontawesome}
-\usepackage{textgreek}
-\DeclareUnicodeCharacter{00A0}{}
-\DeclareUnicodeCharacter{2194}{\faArrowsH}
-\DeclareUnicodeCharacter{1F382}{\faBirthdayCake}
-\DeclareUnicodeCharacter{1F355}{\faAdjust}
-\DeclareUnicodeCharacter{0301}{'}
-\DeclareUnicodeCharacter{03C0}{\textpi}
-
-""",
-    # Latex figure (float) alignment
-    # 'figure_align': 'htbp',
-}
-
-# Grouping the document tree into LaTeX files. List of tuples
-# (source start file, target name, title,
-#  author, documentclass [howto, manual, or own class]).
-latex_documents = [
-    (master_doc, "pybind11.tex", "pybind11 Documentation", "Wenzel Jakob", "manual"),
-]
-
-# The name of an image file (relative to this directory) to place at the top of
-# the title page.
-# latex_logo = 'pybind11-logo.png'
-
-# For "manual" documents, if this is true, then toplevel headings are parts,
-# not chapters.
-# latex_use_parts = False
-
-# If true, show page references after internal links.
-# latex_show_pagerefs = False
-
-# If true, show URL addresses after external links.
-# latex_show_urls = False
-
-# Documents to append as an appendix to all manuals.
-# latex_appendices = []
-
-# If false, no module index is generated.
-# latex_domain_indices = True
-
-
-# -- Options for manual page output ---------------------------------------
-
-# One entry per manual page. List of tuples
-# (source start file, name, description, authors, manual section).
-man_pages = [(master_doc, "pybind11", "pybind11 Documentation", [author], 1)]
-
-# If true, show URL addresses after external links.
-# man_show_urls = False
-
-
-# -- Options for Texinfo output -------------------------------------------
-
-# Grouping the document tree into Texinfo files. List of tuples
-# (source start file, target name, title, author,
-#  dir menu entry, description, category)
-texinfo_documents = [
-    (
-        master_doc,
-        "pybind11",
-        "pybind11 Documentation",
-        author,
-        "pybind11",
-        "One line description of project.",
-        "Miscellaneous",
-    ),
-]
-
-# Documents to append as an appendix to all manuals.
-# texinfo_appendices = []
-
-# If false, no module index is generated.
-# texinfo_domain_indices = True
-
-# How to display URL addresses: 'footnote', 'no', or 'inline'.
-# texinfo_show_urls = 'footnote'
-
-# If true, do not generate a @detailmenu in the "Top" node's menu.
-# texinfo_no_detailmenu = False
-
-primary_domain = "cpp"
-highlight_language = "cpp"
-
-
-def generate_doxygen_xml(app):
-    build_dir = os.path.join(app.confdir, ".build")
-    if not os.path.exists(build_dir):
-        os.mkdir(build_dir)
-
-    try:
-        subprocess.call(["doxygen", "--version"])
-        retcode = subprocess.call(["doxygen"], cwd=app.confdir)
-        if retcode < 0:
-            sys.stderr.write(f"doxygen error code: {-retcode}\n")
-    except OSError as e:
-        sys.stderr.write(f"doxygen execution failed: {e}\n")
-
-
-def prepare(app):
-    with open(DIR.parent / "README.rst") as f:
-        contents = f.read()
-
-    if app.builder.name == "latex":
-        # Remove badges and stuff from start
-        contents = contents[contents.find(r".. start") :]
-
-        # Filter out section titles for index.rst for LaTeX
-        contents = re.sub(r"^(.*)\n[-~]{3,}$", r"**\1**", contents, flags=re.MULTILINE)
-
-    with open(DIR / "readme.rst", "w") as f:
-        f.write(contents)
-
-
-def clean_up(app, exception):
-    (DIR / "readme.rst").unlink()
-
-
-def setup(app):
-    # Add hook for building doxygen xml when needed
-    app.connect("builder-inited", generate_doxygen_xml)
-
-    # Copy the readme in
-    app.connect("builder-inited", prepare)
-
-    # Clean up the generated readme
-    app.connect("build-finished", clean_up)
+#!/usr/bin/env python3
+#
+# pybind11 documentation build configuration file, created by
+# sphinx-quickstart on Sun Oct 11 19:23:48 2015.
+#
+# This file is execfile()d with the current directory set to its
+# containing dir.
+#
+# Note that not all possible configuration values are present in this
+# autogenerated file.
+#
+# All configuration values have a default; values that are commented out
+# serve to show the default.
+
+import os
+import re
+import subprocess
+import sys
+from pathlib import Path
+
+DIR = Path(__file__).parent.resolve()
+
+# If extensions (or modules to document with autodoc) are in another directory,
+# add these directories to sys.path here. If the directory is relative to the
+# documentation root, use os.path.abspath to make it absolute, like shown here.
+# sys.path.insert(0, os.path.abspath('.'))
+
+# -- General configuration ------------------------------------------------
+
+# If your documentation needs a minimal Sphinx version, state it here.
+# needs_sphinx = '1.0'
+
+# Add any Sphinx extension module names here, as strings. They can be
+# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
+# ones.
+extensions = [
+    "breathe",
+    "sphinx_copybutton",
+    "sphinxcontrib.rsvgconverter",
+    "sphinxcontrib.moderncmakedomain",
+]
+
+breathe_projects = {"pybind11": ".build/doxygenxml/"}
+breathe_default_project = "pybind11"
+breathe_domain_by_extension = {"h": "cpp"}
+
+# Add any paths that contain templates here, relative to this directory.
+templates_path = [".templates"]
+
+# The suffix(es) of source filenames.
+# You can specify multiple suffix as a list of string:
+# source_suffix = ['.rst', '.md']
+source_suffix = ".rst"
+
+# The encoding of source files.
+# source_encoding = 'utf-8-sig'
+
+# The master toctree document.
+master_doc = "index"
+
+# General information about the project.
+project = "pybind11"
+copyright = "2017, Wenzel Jakob"
+author = "Wenzel Jakob"
+
+# The version info for the project you're documenting, acts as replacement for
+# |version| and |release|, also used in various other places throughout the
+# built documents.
+
+# Read the listed version
+with open("../pybind11/_version.py") as f:
+    code = compile(f.read(), "../pybind11/_version.py", "exec")
+loc = {}
+exec(code, loc)
+
+# The full version, including alpha/beta/rc tags.
+version = loc["__version__"]
+
+# The language for content autogenerated by Sphinx. Refer to documentation
+# for a list of supported languages.
+#
+# This is also used if you do content translation via gettext catalogs.
+# Usually you set "language" from the command line for these cases.
+language = None
+
+# There are two options for replacing |today|: either, you set today to some
+# non-false value, then it is used:
+# today = ''
+# Else, today_fmt is used as the format for a strftime call.
+# today_fmt = '%B %d, %Y'
+
+# List of patterns, relative to source directory, that match files and
+# directories to ignore when looking for source files.
+exclude_patterns = [".build", "release.rst"]
+
+# The reST default role (used for this markup: `text`) to use for all
+# documents.
+default_role = "any"
+
+# If true, '()' will be appended to :func: etc. cross-reference text.
+# add_function_parentheses = True
+
+# If true, the current module name will be prepended to all description
+# unit titles (such as .. function::).
+# add_module_names = True
+
+# If true, sectionauthor and moduleauthor directives will be shown in the
+# output. They are ignored by default.
+# show_authors = False
+
+# The name of the Pygments (syntax highlighting) style to use.
+# pygments_style = 'monokai'
+
+# A list of ignored prefixes for module index sorting.
+# modindex_common_prefix = []
+
+# If true, keep warnings as "system message" paragraphs in the built documents.
+# keep_warnings = False
+
+# If true, `todo` and `todoList` produce output, else they produce nothing.
+todo_include_todos = False
+
+
+# -- Options for HTML output ----------------------------------------------
+
+# The theme to use for HTML and HTML Help pages.  See the documentation for
+# a list of builtin themes.
+
+html_theme = "furo"
+
+# Theme options are theme-specific and customize the look and feel of a theme
+# further.  For a list of options available for each theme, see the
+# documentation.
+# html_theme_options = {}
+
+# Add any paths that contain custom themes here, relative to this directory.
+# html_theme_path = []
+
+# The name for this set of Sphinx documents.  If None, it defaults to
+# "<project> v<version> documentation".
+# html_title = None
+
+# A shorter title for the navigation bar.  Default is the same as html_title.
+# html_short_title = None
+
+# The name of an image file (relative to this directory) to place at the top
+# of the sidebar.
+# html_logo = None
+
+# The name of an image file (within the static path) to use as favicon of the
+# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
+# pixels large.
+# html_favicon = None
+
+# Add any paths that contain custom static files (such as style sheets) here,
+# relative to this directory. They are copied after the builtin static files,
+# so a file named "default.css" will overwrite the builtin "default.css".
+html_static_path = ["_static"]
+
+html_css_files = [
+    "css/custom.css",
+]
+
+# Add any extra paths that contain custom files (such as robots.txt or
+# .htaccess) here, relative to this directory. These files are copied
+# directly to the root of the documentation.
+# html_extra_path = []
+
+# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
+# using the given strftime format.
+# html_last_updated_fmt = '%b %d, %Y'
+
+# If true, SmartyPants will be used to convert quotes and dashes to
+# typographically correct entities.
+# html_use_smartypants = True
+
+# Custom sidebar templates, maps document names to template names.
+# html_sidebars = {}
+
+# Additional templates that should be rendered to pages, maps page names to
+# template names.
+# html_additional_pages = {}
+
+# If false, no module index is generated.
+# html_domain_indices = True
+
+# If false, no index is generated.
+# html_use_index = True
+
+# If true, the index is split into individual pages for each letter.
+# html_split_index = False
+
+# If true, links to the reST sources are added to the pages.
+# html_show_sourcelink = True
+
+# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
+# html_show_sphinx = True
+
+# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
+# html_show_copyright = True
+
+# If true, an OpenSearch description file will be output, and all pages will
+# contain a <link> tag referring to it.  The value of this option must be the
+# base URL from which the finished HTML is served.
+# html_use_opensearch = ''
+
+# This is the file name suffix for HTML files (e.g. ".xhtml").
+# html_file_suffix = None
+
+# Language to be used for generating the HTML full-text search index.
+# Sphinx supports the following languages:
+#   'da', 'de', 'en', 'es', 'fi', 'fr', 'h', 'it', 'ja'
+#   'nl', 'no', 'pt', 'ro', 'r', 'sv', 'tr'
+# html_search_language = 'en'
+
+# A dictionary with options for the search language support, empty by default.
+# Now only 'ja' uses this config value
+# html_search_options = {'type': 'default'}
+
+# The name of a javascript file (relative to the configuration directory) that
+# implements a search results scorer. If empty, the default will be used.
+# html_search_scorer = 'scorer.js'
+
+# Output file base name for HTML help builder.
+htmlhelp_basename = "pybind11doc"
+
+# -- Options for LaTeX output ---------------------------------------------
+
+latex_engine = "pdflatex"
+
+latex_elements = {
+    # The paper size ('letterpaper' or 'a4paper').
+    # 'papersize': 'letterpaper',
+    #
+    # The font size ('10pt', '11pt' or '12pt').
+    # 'pointsize': '10pt',
+    #
+    # Additional stuff for the LaTeX preamble.
+    # remove blank pages (between the title page and the TOC, etc.)
+    "classoptions": ",openany,oneside",
+    "preamble": r"""
+\usepackage{fontawesome}
+\usepackage{textgreek}
+\DeclareUnicodeCharacter{00A0}{}
+\DeclareUnicodeCharacter{2194}{\faArrowsH}
+\DeclareUnicodeCharacter{1F382}{\faBirthdayCake}
+\DeclareUnicodeCharacter{1F355}{\faAdjust}
+\DeclareUnicodeCharacter{0301}{'}
+\DeclareUnicodeCharacter{03C0}{\textpi}
+
+""",
+    # Latex figure (float) alignment
+    # 'figure_align': 'htbp',
+}
+
+# Grouping the document tree into LaTeX files. List of tuples
+# (source start file, target name, title,
+#  author, documentclass [howto, manual, or own class]).
+latex_documents = [
+    (master_doc, "pybind11.tex", "pybind11 Documentation", "Wenzel Jakob", "manual"),
+]
+
+# The name of an image file (relative to this directory) to place at the top of
+# the title page.
+# latex_logo = 'pybind11-logo.png'
+
+# For "manual" documents, if this is true, then toplevel headings are parts,
+# not chapters.
+# latex_use_parts = False
+
+# If true, show page references after internal links.
+# latex_show_pagerefs = False
+
+# If true, show URL addresses after external links.
+# latex_show_urls = False
+
+# Documents to append as an appendix to all manuals.
+# latex_appendices = []
+
+# If false, no module index is generated.
+# latex_domain_indices = True
+
+
+# -- Options for manual page output ---------------------------------------
+
+# One entry per manual page. List of tuples
+# (source start file, name, description, authors, manual section).
+man_pages = [(master_doc, "pybind11", "pybind11 Documentation", [author], 1)]
+
+# If true, show URL addresses after external links.
+# man_show_urls = False
+
+
+# -- Options for Texinfo output -------------------------------------------
+
+# Grouping the document tree into Texinfo files. List of tuples
+# (source start file, target name, title, author,
+#  dir menu entry, description, category)
+texinfo_documents = [
+    (
+        master_doc,
+        "pybind11",
+        "pybind11 Documentation",
+        author,
+        "pybind11",
+        "One line description of project.",
+        "Miscellaneous",
+    ),
+]
+
+# Documents to append as an appendix to all manuals.
+# texinfo_appendices = []
+
+# If false, no module index is generated.
+# texinfo_domain_indices = True
+
+# How to display URL addresses: 'footnote', 'no', or 'inline'.
+# texinfo_show_urls = 'footnote'
+
+# If true, do not generate a @detailmenu in the "Top" node's menu.
+# texinfo_no_detailmenu = False
+
+primary_domain = "cpp"
+highlight_language = "cpp"
+
+
+def generate_doxygen_xml(app):
+    build_dir = os.path.join(app.confdir, ".build")
+    if not os.path.exists(build_dir):
+        os.mkdir(build_dir)
+
+    try:
+        subprocess.call(["doxygen", "--version"])
+        retcode = subprocess.call(["doxygen"], cwd=app.confdir)
+        if retcode < 0:
+            sys.stderr.write(f"doxygen error code: {-retcode}\n")
+    except OSError as e:
+        sys.stderr.write(f"doxygen execution failed: {e}\n")
+
+
+def prepare(app):
+    with open(DIR.parent / "README.rst") as f:
+        contents = f.read()
+
+    if app.builder.name == "latex":
+        # Remove badges and stuff from start
+        contents = contents[contents.find(r".. start") :]
+
+        # Filter out section titles for index.rst for LaTeX
+        contents = re.sub(r"^(.*)\n[-~]{3,}$", r"**\1**", contents, flags=re.MULTILINE)
+
+    with open(DIR / "readme.rst", "w") as f:
+        f.write(contents)
+
+
+def clean_up(app, exception):
+    (DIR / "readme.rst").unlink()
+
+
+def setup(app):
+    # Add hook for building doxygen xml when needed
+    app.connect("builder-inited", generate_doxygen_xml)
+
+    # Copy the readme in
+    app.connect("builder-inited", prepare)
+
+    # Clean up the generated readme
+    app.connect("build-finished", clean_up)
```

## extern/pybind11/pybind11/__init__.py

 * *Ordering differences only*

```diff
@@ -1,17 +1,17 @@
-import sys
-
-if sys.version_info < (3, 6):
-    msg = "pybind11 does not support Python < 3.6. 2.9 was the last release supporting Python 2.7 and 3.5."
-    raise ImportError(msg)
-
-
-from ._version import __version__, version_info
-from .commands import get_cmake_dir, get_include, get_pkgconfig_dir
-
-__all__ = (
-    "version_info",
-    "__version__",
-    "get_include",
-    "get_cmake_dir",
-    "get_pkgconfig_dir",
-)
+import sys
+
+if sys.version_info < (3, 6):
+    msg = "pybind11 does not support Python < 3.6. 2.9 was the last release supporting Python 2.7 and 3.5."
+    raise ImportError(msg)
+
+
+from ._version import __version__, version_info
+from .commands import get_cmake_dir, get_include, get_pkgconfig_dir
+
+__all__ = (
+    "version_info",
+    "__version__",
+    "get_include",
+    "get_cmake_dir",
+    "get_pkgconfig_dir",
+)
```

## extern/pybind11/pybind11/__main__.py

 * *Ordering differences only*

```diff
@@ -1,62 +1,62 @@
-# pylint: disable=missing-function-docstring
-
-import argparse
-import sys
-import sysconfig
-
-from ._version import __version__
-from .commands import get_cmake_dir, get_include, get_pkgconfig_dir
-
-
-def print_includes() -> None:
-    dirs = [
-        sysconfig.get_path("include"),
-        sysconfig.get_path("platinclude"),
-        get_include(),
-    ]
-
-    # Make unique but preserve order
-    unique_dirs = []
-    for d in dirs:
-        if d and d not in unique_dirs:
-            unique_dirs.append(d)
-
-    print(" ".join("-I" + d for d in unique_dirs))
-
-
-def main() -> None:
-    parser = argparse.ArgumentParser()
-    parser.add_argument(
-        "--version",
-        action="version",
-        version=__version__,
-        help="Print the version and exit.",
-    )
-    parser.add_argument(
-        "--includes",
-        action="store_true",
-        help="Include flags for both pybind11 and Python headers.",
-    )
-    parser.add_argument(
-        "--cmakedir",
-        action="store_true",
-        help="Print the CMake module directory, ideal for setting -Dpybind11_ROOT in CMake.",
-    )
-    parser.add_argument(
-        "--pkgconfigdir",
-        action="store_true",
-        help="Print the pkgconfig directory, ideal for setting $PKG_CONFIG_PATH.",
-    )
-    args = parser.parse_args()
-    if not sys.argv[1:]:
-        parser.print_help()
-    if args.includes:
-        print_includes()
-    if args.cmakedir:
-        print(get_cmake_dir())
-    if args.pkgconfigdir:
-        print(get_pkgconfig_dir())
-
-
-if __name__ == "__main__":
-    main()
+# pylint: disable=missing-function-docstring
+
+import argparse
+import sys
+import sysconfig
+
+from ._version import __version__
+from .commands import get_cmake_dir, get_include, get_pkgconfig_dir
+
+
+def print_includes() -> None:
+    dirs = [
+        sysconfig.get_path("include"),
+        sysconfig.get_path("platinclude"),
+        get_include(),
+    ]
+
+    # Make unique but preserve order
+    unique_dirs = []
+    for d in dirs:
+        if d and d not in unique_dirs:
+            unique_dirs.append(d)
+
+    print(" ".join("-I" + d for d in unique_dirs))
+
+
+def main() -> None:
+    parser = argparse.ArgumentParser()
+    parser.add_argument(
+        "--version",
+        action="version",
+        version=__version__,
+        help="Print the version and exit.",
+    )
+    parser.add_argument(
+        "--includes",
+        action="store_true",
+        help="Include flags for both pybind11 and Python headers.",
+    )
+    parser.add_argument(
+        "--cmakedir",
+        action="store_true",
+        help="Print the CMake module directory, ideal for setting -Dpybind11_ROOT in CMake.",
+    )
+    parser.add_argument(
+        "--pkgconfigdir",
+        action="store_true",
+        help="Print the pkgconfig directory, ideal for setting $PKG_CONFIG_PATH.",
+    )
+    args = parser.parse_args()
+    if not sys.argv[1:]:
+        parser.print_help()
+    if args.includes:
+        print_includes()
+    if args.cmakedir:
+        print(get_cmake_dir())
+    if args.pkgconfigdir:
+        print(get_pkgconfig_dir())
+
+
+if __name__ == "__main__":
+    main()
```

## extern/pybind11/pybind11/_version.py

 * *Ordering differences only*

```diff
@@ -1,12 +1,12 @@
-from typing import Union
-
-
-def _to_int(s: str) -> Union[int, str]:
-    try:
-        return int(s)
-    except ValueError:
-        return s
-
-
-__version__ = "2.10.4"
-version_info = tuple(_to_int(s) for s in __version__.split("."))
+from typing import Union
+
+
+def _to_int(s: str) -> Union[int, str]:
+    try:
+        return int(s)
+    except ValueError:
+        return s
+
+
+__version__ = "2.10.4"
+version_info = tuple(_to_int(s) for s in __version__.split("."))
```

## extern/pybind11/pybind11/commands.py

 * *Ordering differences only*

```diff
@@ -1,37 +1,37 @@
-import os
-
-DIR = os.path.abspath(os.path.dirname(__file__))
-
-
-def get_include(user: bool = False) -> str:  # pylint: disable=unused-argument
-    """
-    Return the path to the pybind11 include directory. The historical "user"
-    argument is unused, and may be removed.
-    """
-    installed_path = os.path.join(DIR, "include")
-    source_path = os.path.join(os.path.dirname(DIR), "include")
-    return installed_path if os.path.exists(installed_path) else source_path
-
-
-def get_cmake_dir() -> str:
-    """
-    Return the path to the pybind11 CMake module directory.
-    """
-    cmake_installed_path = os.path.join(DIR, "share", "cmake", "pybind11")
-    if os.path.exists(cmake_installed_path):
-        return cmake_installed_path
-
-    msg = "pybind11 not installed, installation required to access the CMake files"
-    raise ImportError(msg)
-
-
-def get_pkgconfig_dir() -> str:
-    """
-    Return the path to the pybind11 pkgconfig directory.
-    """
-    pkgconfig_installed_path = os.path.join(DIR, "share", "pkgconfig")
-    if os.path.exists(pkgconfig_installed_path):
-        return pkgconfig_installed_path
-
-    msg = "pybind11 not installed, installation required to access the pkgconfig files"
-    raise ImportError(msg)
+import os
+
+DIR = os.path.abspath(os.path.dirname(__file__))
+
+
+def get_include(user: bool = False) -> str:  # pylint: disable=unused-argument
+    """
+    Return the path to the pybind11 include directory. The historical "user"
+    argument is unused, and may be removed.
+    """
+    installed_path = os.path.join(DIR, "include")
+    source_path = os.path.join(os.path.dirname(DIR), "include")
+    return installed_path if os.path.exists(installed_path) else source_path
+
+
+def get_cmake_dir() -> str:
+    """
+    Return the path to the pybind11 CMake module directory.
+    """
+    cmake_installed_path = os.path.join(DIR, "share", "cmake", "pybind11")
+    if os.path.exists(cmake_installed_path):
+        return cmake_installed_path
+
+    msg = "pybind11 not installed, installation required to access the CMake files"
+    raise ImportError(msg)
+
+
+def get_pkgconfig_dir() -> str:
+    """
+    Return the path to the pybind11 pkgconfig directory.
+    """
+    pkgconfig_installed_path = os.path.join(DIR, "share", "pkgconfig")
+    if os.path.exists(pkgconfig_installed_path):
+        return pkgconfig_installed_path
+
+    msg = "pybind11 not installed, installation required to access the pkgconfig files"
+    raise ImportError(msg)
```

## extern/pybind11/pybind11/setup_helpers.py

 * *Ordering differences only*

```diff
@@ -1,503 +1,503 @@
-"""
-This module provides helpers for C++11+ projects using pybind11.
-
-LICENSE:
-
-Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>, All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-1. Redistributions of source code must retain the above copyright notice, this
-   list of conditions and the following disclaimer.
-
-2. Redistributions in binary form must reproduce the above copyright notice,
-   this list of conditions and the following disclaimer in the documentation
-   and/or other materials provided with the distribution.
-
-3. Neither the name of the copyright holder nor the names of its contributors
-   may be used to endorse or promote products derived from this software
-   without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-"""
-
-# IMPORTANT: If you change this file in the pybind11 repo, also review
-# setup_helpers.pyi for matching changes.
-#
-# If you copy this file in, you don't
-# need the .pyi file; it's just an interface file for static type checkers.
-
-import contextlib
-import os
-import platform
-import shlex
-import shutil
-import sys
-import sysconfig
-import tempfile
-import threading
-import warnings
-from functools import lru_cache
-from pathlib import Path
-from typing import (
-    Any,
-    Callable,
-    Dict,
-    Iterable,
-    Iterator,
-    List,
-    Optional,
-    Tuple,
-    TypeVar,
-    Union,
-)
-
-try:
-    from setuptools import Extension as _Extension
-    from setuptools.command.build_ext import build_ext as _build_ext
-except ImportError:
-    from distutils.command.build_ext import build_ext as _build_ext
-    from distutils.extension import Extension as _Extension
-
-import distutils.ccompiler
-import distutils.errors
-
-WIN = sys.platform.startswith("win32") and "mingw" not in sysconfig.get_platform()
-MACOS = sys.platform.startswith("darwin")
-STD_TMPL = "/std:c++{}" if WIN else "-std=c++{}"
-
-
-# It is recommended to use PEP 518 builds if using this module. However, this
-# file explicitly supports being copied into a user's project directory
-# standalone, and pulling pybind11 with the deprecated setup_requires feature.
-# If you copy the file, remember to add it to your MANIFEST.in, and add the current
-# directory into your path if it sits beside your setup.py.
-
-
-class Pybind11Extension(_Extension):  # type: ignore[misc]
-    """
-    Build a C++11+ Extension module with pybind11. This automatically adds the
-    recommended flags when you init the extension and assumes C++ sources - you
-    can further modify the options yourself.
-
-    The customizations are:
-
-    * ``/EHsc`` and ``/bigobj`` on Windows
-    * ``stdlib=libc++`` on macOS
-    * ``visibility=hidden`` and ``-g0`` on Unix
-
-    Finally, you can set ``cxx_std`` via constructor or afterwards to enable
-    flags for C++ std, and a few extra helper flags related to the C++ standard
-    level. It is _highly_ recommended you either set this, or use the provided
-    ``build_ext``, which will search for the highest supported extension for
-    you if the ``cxx_std`` property is not set. Do not set the ``cxx_std``
-    property more than once, as flags are added when you set it. Set the
-    property to None to disable the addition of C++ standard flags.
-
-    If you want to add pybind11 headers manually, for example for an exact
-    git checkout, then set ``include_pybind11=False``.
-    """
-
-    # flags are prepended, so that they can be further overridden, e.g. by
-    # ``extra_compile_args=["-g"]``.
-
-    def _add_cflags(self, flags: List[str]) -> None:
-        self.extra_compile_args[:0] = flags
-
-    def _add_ldflags(self, flags: List[str]) -> None:
-        self.extra_link_args[:0] = flags
-
-    def __init__(self, *args: Any, **kwargs: Any) -> None:
-        self._cxx_level = 0
-        cxx_std = kwargs.pop("cxx_std", 0)
-
-        if "language" not in kwargs:
-            kwargs["language"] = "c++"
-
-        include_pybind11 = kwargs.pop("include_pybind11", True)
-
-        super().__init__(*args, **kwargs)
-
-        # Include the installed package pybind11 headers
-        if include_pybind11:
-            # If using setup_requires, this fails the first time - that's okay
-            try:
-                import pybind11
-
-                pyinc = pybind11.get_include()
-
-                if pyinc not in self.include_dirs:
-                    self.include_dirs.append(pyinc)
-            except ModuleNotFoundError:
-                pass
-
-        self.cxx_std = cxx_std
-
-        cflags = []
-        ldflags = []
-        if WIN:
-            cflags += ["/EHsc", "/bigobj"]
-        else:
-            cflags += ["-fvisibility=hidden"]
-            env_cflags = os.environ.get("CFLAGS", "")
-            env_cppflags = os.environ.get("CPPFLAGS", "")
-            c_cpp_flags = shlex.split(env_cflags) + shlex.split(env_cppflags)
-            if not any(opt.startswith("-g") for opt in c_cpp_flags):
-                cflags += ["-g0"]
-            if MACOS:
-                cflags += ["-stdlib=libc++"]
-                ldflags += ["-stdlib=libc++"]
-        self._add_cflags(cflags)
-        self._add_ldflags(ldflags)
-
-    @property
-    def cxx_std(self) -> int:
-        """
-        The CXX standard level. If set, will add the required flags. If left at
-        0, it will trigger an automatic search when pybind11's build_ext is
-        used. If None, will have no effect.  Besides just the flags, this may
-        add a macos-min 10.9 or 10.14 flag if MACOSX_DEPLOYMENT_TARGET is
-        unset.
-        """
-        return self._cxx_level
-
-    @cxx_std.setter
-    def cxx_std(self, level: int) -> None:
-        if self._cxx_level:
-            warnings.warn(
-                "You cannot safely change the cxx_level after setting it!", stacklevel=2
-            )
-
-        # MSVC 2015 Update 3 and later only have 14 (and later 17) modes, so
-        # force a valid flag here.
-        if WIN and level == 11:
-            level = 14
-
-        self._cxx_level = level
-
-        if not level:
-            return
-
-        cflags = [STD_TMPL.format(level)]
-        ldflags = []
-
-        if MACOS and "MACOSX_DEPLOYMENT_TARGET" not in os.environ:
-            # C++17 requires a higher min version of macOS. An earlier version
-            # (10.12 or 10.13) can be set manually via environment variable if
-            # you are careful in your feature usage, but 10.14 is the safest
-            # setting for general use. However, never set higher than the
-            # current macOS version!
-            current_macos = tuple(int(x) for x in platform.mac_ver()[0].split(".")[:2])
-            desired_macos = (10, 9) if level < 17 else (10, 14)
-            macos_string = ".".join(str(x) for x in min(current_macos, desired_macos))
-            macosx_min = f"-mmacosx-version-min={macos_string}"
-            cflags += [macosx_min]
-            ldflags += [macosx_min]
-
-        self._add_cflags(cflags)
-        self._add_ldflags(ldflags)
-
-
-# Just in case someone clever tries to multithread
-tmp_chdir_lock = threading.Lock()
-
-
-@contextlib.contextmanager
-def tmp_chdir() -> Iterator[str]:
-    "Prepare and enter a temporary directory, cleanup when done"
-
-    # Threadsafe
-    with tmp_chdir_lock:
-        olddir = os.getcwd()
-        try:
-            tmpdir = tempfile.mkdtemp()
-            os.chdir(tmpdir)
-            yield tmpdir
-        finally:
-            os.chdir(olddir)
-            shutil.rmtree(tmpdir)
-
-
-# cf http://bugs.python.org/issue26689
-def has_flag(compiler: Any, flag: str) -> bool:
-    """
-    Return the flag if a flag name is supported on the
-    specified compiler, otherwise None (can be used as a boolean).
-    If multiple flags are passed, return the first that matches.
-    """
-
-    with tmp_chdir():
-        fname = Path("flagcheck.cpp")
-        # Don't trigger -Wunused-parameter.
-        fname.write_text("int main (int, char **) { return 0; }", encoding="utf-8")
-
-        try:
-            compiler.compile([str(fname)], extra_postargs=[flag])
-        except distutils.errors.CompileError:
-            return False
-        return True
-
-
-# Every call will cache the result
-cpp_flag_cache = None
-
-
-@lru_cache()
-def auto_cpp_level(compiler: Any) -> Union[str, int]:
-    """
-    Return the max supported C++ std level (17, 14, or 11). Returns latest on Windows.
-    """
-
-    if WIN:
-        return "latest"
-
-    levels = [17, 14, 11]
-
-    for level in levels:
-        if has_flag(compiler, STD_TMPL.format(level)):
-            return level
-
-    msg = "Unsupported compiler -- at least C++11 support is needed!"
-    raise RuntimeError(msg)
-
-
-class build_ext(_build_ext):  # type: ignore[misc] # noqa: N801
-    """
-    Customized build_ext that allows an auto-search for the highest supported
-    C++ level for Pybind11Extension. This is only needed for the auto-search
-    for now, and is completely optional otherwise.
-    """
-
-    def build_extensions(self) -> None:
-        """
-        Build extensions, injecting C++ std for Pybind11Extension if needed.
-        """
-
-        for ext in self.extensions:
-            if hasattr(ext, "_cxx_level") and ext._cxx_level == 0:
-                ext.cxx_std = auto_cpp_level(self.compiler)
-
-        super().build_extensions()
-
-
-def intree_extensions(
-    paths: Iterable[str], package_dir: Optional[Dict[str, str]] = None
-) -> List[Pybind11Extension]:
-    """
-    Generate Pybind11Extensions from source files directly located in a Python
-    source tree.
-
-    ``package_dir`` behaves as in ``setuptools.setup``.  If unset, the Python
-    package root parent is determined as the first parent directory that does
-    not contain an ``__init__.py`` file.
-    """
-    exts = []
-
-    if package_dir is None:
-        for path in paths:
-            parent, _ = os.path.split(path)
-            while os.path.exists(os.path.join(parent, "__init__.py")):
-                parent, _ = os.path.split(parent)
-            relname, _ = os.path.splitext(os.path.relpath(path, parent))
-            qualified_name = relname.replace(os.path.sep, ".")
-            exts.append(Pybind11Extension(qualified_name, [path]))
-        return exts
-
-    for path in paths:
-        for prefix, parent in package_dir.items():
-            if path.startswith(parent):
-                relname, _ = os.path.splitext(os.path.relpath(path, parent))
-                qualified_name = relname.replace(os.path.sep, ".")
-                if prefix:
-                    qualified_name = prefix + "." + qualified_name
-                exts.append(Pybind11Extension(qualified_name, [path]))
-                break
-        else:
-            msg = (
-                f"path {path} is not a child of any of the directories listed "
-                f"in 'package_dir' ({package_dir})"
-            )
-            raise ValueError(msg)
-
-    return exts
-
-
-def naive_recompile(obj: str, src: str) -> bool:
-    """
-    This will recompile only if the source file changes. It does not check
-    header files, so a more advanced function or Ccache is better if you have
-    editable header files in your package.
-    """
-    return os.stat(obj).st_mtime < os.stat(src).st_mtime
-
-
-def no_recompile(obg: str, src: str) -> bool:  # pylint: disable=unused-argument
-    """
-    This is the safest but slowest choice (and is the default) - will always
-    recompile sources.
-    """
-    return True
-
-
-S = TypeVar("S", bound="ParallelCompile")
-
-CCompilerMethod = Callable[
-    [
-        distutils.ccompiler.CCompiler,
-        List[str],
-        Optional[str],
-        Optional[Union[Tuple[str], Tuple[str, Optional[str]]]],
-        Optional[List[str]],
-        bool,
-        Optional[List[str]],
-        Optional[List[str]],
-        Optional[List[str]],
-    ],
-    List[str],
-]
-
-
-# Optional parallel compile utility
-# inspired by: http://stackoverflow.com/questions/11013851/speeding-up-build-process-with-distutils
-# and: https://github.com/tbenthompson/cppimport/blob/stable/cppimport/build_module.py
-# and NumPy's parallel distutils module:
-#              https://github.com/numpy/numpy/blob/master/numpy/distutils/ccompiler.py
-class ParallelCompile:
-    """
-    Make a parallel compile function. Inspired by
-    numpy.distutils.ccompiler.CCompiler.compile and cppimport.
-
-    This takes several arguments that allow you to customize the compile
-    function created:
-
-    envvar:
-        Set an environment variable to control the compilation threads, like
-        NPY_NUM_BUILD_JOBS
-    default:
-        0 will automatically multithread, or 1 will only multithread if the
-        envvar is set.
-    max:
-        The limit for automatic multithreading if non-zero
-    needs_recompile:
-        A function of (obj, src) that returns True when recompile is needed.  No
-        effect in isolated mode; use ccache instead, see
-        https://github.com/matplotlib/matplotlib/issues/1507/
-
-    To use::
-
-        ParallelCompile("NPY_NUM_BUILD_JOBS").install()
-
-    or::
-
-        with ParallelCompile("NPY_NUM_BUILD_JOBS"):
-            setup(...)
-
-    By default, this assumes all files need to be recompiled. A smarter
-    function can be provided via needs_recompile.  If the output has not yet
-    been generated, the compile will always run, and this function is not
-    called.
-    """
-
-    __slots__ = ("envvar", "default", "max", "_old", "needs_recompile")
-
-    def __init__(
-        self,
-        envvar: Optional[str] = None,
-        default: int = 0,
-        max: int = 0,  # pylint: disable=redefined-builtin
-        needs_recompile: Callable[[str, str], bool] = no_recompile,
-    ) -> None:
-        self.envvar = envvar
-        self.default = default
-        self.max = max
-        self.needs_recompile = needs_recompile
-        self._old: List[CCompilerMethod] = []
-
-    def function(self) -> CCompilerMethod:
-        """
-        Builds a function object usable as distutils.ccompiler.CCompiler.compile.
-        """
-
-        def compile_function(
-            compiler: distutils.ccompiler.CCompiler,
-            sources: List[str],
-            output_dir: Optional[str] = None,
-            macros: Optional[Union[Tuple[str], Tuple[str, Optional[str]]]] = None,
-            include_dirs: Optional[List[str]] = None,
-            debug: bool = False,
-            extra_preargs: Optional[List[str]] = None,
-            extra_postargs: Optional[List[str]] = None,
-            depends: Optional[List[str]] = None,
-        ) -> Any:
-            # These lines are directly from distutils.ccompiler.CCompiler
-            macros, objects, extra_postargs, pp_opts, build = compiler._setup_compile(  # type: ignore[attr-defined]
-                output_dir, macros, include_dirs, sources, depends, extra_postargs
-            )
-            cc_args = compiler._get_cc_args(pp_opts, debug, extra_preargs)  # type: ignore[attr-defined]
-
-            # The number of threads; start with default.
-            threads = self.default
-
-            # Determine the number of compilation threads, unless set by an environment variable.
-            if self.envvar is not None:
-                threads = int(os.environ.get(self.envvar, self.default))
-
-            def _single_compile(obj: Any) -> None:
-                try:
-                    src, ext = build[obj]
-                except KeyError:
-                    return
-
-                if not os.path.exists(obj) or self.needs_recompile(obj, src):
-                    compiler._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)  # type: ignore[attr-defined]
-
-            try:
-                # Importing .synchronize checks for platforms that have some multiprocessing
-                # capabilities but lack semaphores, such as AWS Lambda and Android Termux.
-                import multiprocessing.synchronize
-                from multiprocessing.pool import ThreadPool
-            except ImportError:
-                threads = 1
-
-            if threads == 0:
-                try:
-                    threads = multiprocessing.cpu_count()
-                    threads = self.max if self.max and self.max < threads else threads
-                except NotImplementedError:
-                    threads = 1
-
-            if threads > 1:
-                with ThreadPool(threads) as pool:
-                    for _ in pool.imap_unordered(_single_compile, objects):
-                        pass
-            else:
-                for ob in objects:
-                    _single_compile(ob)
-
-            return objects
-
-        return compile_function
-
-    def install(self: S) -> S:
-        """
-        Installs the compile function into distutils.ccompiler.CCompiler.compile.
-        """
-        distutils.ccompiler.CCompiler.compile = self.function()  # type: ignore[assignment]
-        return self
-
-    def __enter__(self: S) -> S:
-        self._old.append(distutils.ccompiler.CCompiler.compile)
-        return self.install()
-
-    def __exit__(self, *args: Any) -> None:
-        distutils.ccompiler.CCompiler.compile = self._old.pop()  # type: ignore[assignment]
+"""
+This module provides helpers for C++11+ projects using pybind11.
+
+LICENSE:
+
+Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>, All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+1. Redistributions of source code must retain the above copyright notice, this
+   list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright notice,
+   this list of conditions and the following disclaimer in the documentation
+   and/or other materials provided with the distribution.
+
+3. Neither the name of the copyright holder nor the names of its contributors
+   may be used to endorse or promote products derived from this software
+   without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+"""
+
+# IMPORTANT: If you change this file in the pybind11 repo, also review
+# setup_helpers.pyi for matching changes.
+#
+# If you copy this file in, you don't
+# need the .pyi file; it's just an interface file for static type checkers.
+
+import contextlib
+import os
+import platform
+import shlex
+import shutil
+import sys
+import sysconfig
+import tempfile
+import threading
+import warnings
+from functools import lru_cache
+from pathlib import Path
+from typing import (
+    Any,
+    Callable,
+    Dict,
+    Iterable,
+    Iterator,
+    List,
+    Optional,
+    Tuple,
+    TypeVar,
+    Union,
+)
+
+try:
+    from setuptools import Extension as _Extension
+    from setuptools.command.build_ext import build_ext as _build_ext
+except ImportError:
+    from distutils.command.build_ext import build_ext as _build_ext
+    from distutils.extension import Extension as _Extension
+
+import distutils.ccompiler
+import distutils.errors
+
+WIN = sys.platform.startswith("win32") and "mingw" not in sysconfig.get_platform()
+MACOS = sys.platform.startswith("darwin")
+STD_TMPL = "/std:c++{}" if WIN else "-std=c++{}"
+
+
+# It is recommended to use PEP 518 builds if using this module. However, this
+# file explicitly supports being copied into a user's project directory
+# standalone, and pulling pybind11 with the deprecated setup_requires feature.
+# If you copy the file, remember to add it to your MANIFEST.in, and add the current
+# directory into your path if it sits beside your setup.py.
+
+
+class Pybind11Extension(_Extension):  # type: ignore[misc]
+    """
+    Build a C++11+ Extension module with pybind11. This automatically adds the
+    recommended flags when you init the extension and assumes C++ sources - you
+    can further modify the options yourself.
+
+    The customizations are:
+
+    * ``/EHsc`` and ``/bigobj`` on Windows
+    * ``stdlib=libc++`` on macOS
+    * ``visibility=hidden`` and ``-g0`` on Unix
+
+    Finally, you can set ``cxx_std`` via constructor or afterwards to enable
+    flags for C++ std, and a few extra helper flags related to the C++ standard
+    level. It is _highly_ recommended you either set this, or use the provided
+    ``build_ext``, which will search for the highest supported extension for
+    you if the ``cxx_std`` property is not set. Do not set the ``cxx_std``
+    property more than once, as flags are added when you set it. Set the
+    property to None to disable the addition of C++ standard flags.
+
+    If you want to add pybind11 headers manually, for example for an exact
+    git checkout, then set ``include_pybind11=False``.
+    """
+
+    # flags are prepended, so that they can be further overridden, e.g. by
+    # ``extra_compile_args=["-g"]``.
+
+    def _add_cflags(self, flags: List[str]) -> None:
+        self.extra_compile_args[:0] = flags
+
+    def _add_ldflags(self, flags: List[str]) -> None:
+        self.extra_link_args[:0] = flags
+
+    def __init__(self, *args: Any, **kwargs: Any) -> None:
+        self._cxx_level = 0
+        cxx_std = kwargs.pop("cxx_std", 0)
+
+        if "language" not in kwargs:
+            kwargs["language"] = "c++"
+
+        include_pybind11 = kwargs.pop("include_pybind11", True)
+
+        super().__init__(*args, **kwargs)
+
+        # Include the installed package pybind11 headers
+        if include_pybind11:
+            # If using setup_requires, this fails the first time - that's okay
+            try:
+                import pybind11
+
+                pyinc = pybind11.get_include()
+
+                if pyinc not in self.include_dirs:
+                    self.include_dirs.append(pyinc)
+            except ModuleNotFoundError:
+                pass
+
+        self.cxx_std = cxx_std
+
+        cflags = []
+        ldflags = []
+        if WIN:
+            cflags += ["/EHsc", "/bigobj"]
+        else:
+            cflags += ["-fvisibility=hidden"]
+            env_cflags = os.environ.get("CFLAGS", "")
+            env_cppflags = os.environ.get("CPPFLAGS", "")
+            c_cpp_flags = shlex.split(env_cflags) + shlex.split(env_cppflags)
+            if not any(opt.startswith("-g") for opt in c_cpp_flags):
+                cflags += ["-g0"]
+            if MACOS:
+                cflags += ["-stdlib=libc++"]
+                ldflags += ["-stdlib=libc++"]
+        self._add_cflags(cflags)
+        self._add_ldflags(ldflags)
+
+    @property
+    def cxx_std(self) -> int:
+        """
+        The CXX standard level. If set, will add the required flags. If left at
+        0, it will trigger an automatic search when pybind11's build_ext is
+        used. If None, will have no effect.  Besides just the flags, this may
+        add a macos-min 10.9 or 10.14 flag if MACOSX_DEPLOYMENT_TARGET is
+        unset.
+        """
+        return self._cxx_level
+
+    @cxx_std.setter
+    def cxx_std(self, level: int) -> None:
+        if self._cxx_level:
+            warnings.warn(
+                "You cannot safely change the cxx_level after setting it!", stacklevel=2
+            )
+
+        # MSVC 2015 Update 3 and later only have 14 (and later 17) modes, so
+        # force a valid flag here.
+        if WIN and level == 11:
+            level = 14
+
+        self._cxx_level = level
+
+        if not level:
+            return
+
+        cflags = [STD_TMPL.format(level)]
+        ldflags = []
+
+        if MACOS and "MACOSX_DEPLOYMENT_TARGET" not in os.environ:
+            # C++17 requires a higher min version of macOS. An earlier version
+            # (10.12 or 10.13) can be set manually via environment variable if
+            # you are careful in your feature usage, but 10.14 is the safest
+            # setting for general use. However, never set higher than the
+            # current macOS version!
+            current_macos = tuple(int(x) for x in platform.mac_ver()[0].split(".")[:2])
+            desired_macos = (10, 9) if level < 17 else (10, 14)
+            macos_string = ".".join(str(x) for x in min(current_macos, desired_macos))
+            macosx_min = f"-mmacosx-version-min={macos_string}"
+            cflags += [macosx_min]
+            ldflags += [macosx_min]
+
+        self._add_cflags(cflags)
+        self._add_ldflags(ldflags)
+
+
+# Just in case someone clever tries to multithread
+tmp_chdir_lock = threading.Lock()
+
+
+@contextlib.contextmanager
+def tmp_chdir() -> Iterator[str]:
+    "Prepare and enter a temporary directory, cleanup when done"
+
+    # Threadsafe
+    with tmp_chdir_lock:
+        olddir = os.getcwd()
+        try:
+            tmpdir = tempfile.mkdtemp()
+            os.chdir(tmpdir)
+            yield tmpdir
+        finally:
+            os.chdir(olddir)
+            shutil.rmtree(tmpdir)
+
+
+# cf http://bugs.python.org/issue26689
+def has_flag(compiler: Any, flag: str) -> bool:
+    """
+    Return the flag if a flag name is supported on the
+    specified compiler, otherwise None (can be used as a boolean).
+    If multiple flags are passed, return the first that matches.
+    """
+
+    with tmp_chdir():
+        fname = Path("flagcheck.cpp")
+        # Don't trigger -Wunused-parameter.
+        fname.write_text("int main (int, char **) { return 0; }", encoding="utf-8")
+
+        try:
+            compiler.compile([str(fname)], extra_postargs=[flag])
+        except distutils.errors.CompileError:
+            return False
+        return True
+
+
+# Every call will cache the result
+cpp_flag_cache = None
+
+
+@lru_cache()
+def auto_cpp_level(compiler: Any) -> Union[str, int]:
+    """
+    Return the max supported C++ std level (17, 14, or 11). Returns latest on Windows.
+    """
+
+    if WIN:
+        return "latest"
+
+    levels = [17, 14, 11]
+
+    for level in levels:
+        if has_flag(compiler, STD_TMPL.format(level)):
+            return level
+
+    msg = "Unsupported compiler -- at least C++11 support is needed!"
+    raise RuntimeError(msg)
+
+
+class build_ext(_build_ext):  # type: ignore[misc] # noqa: N801
+    """
+    Customized build_ext that allows an auto-search for the highest supported
+    C++ level for Pybind11Extension. This is only needed for the auto-search
+    for now, and is completely optional otherwise.
+    """
+
+    def build_extensions(self) -> None:
+        """
+        Build extensions, injecting C++ std for Pybind11Extension if needed.
+        """
+
+        for ext in self.extensions:
+            if hasattr(ext, "_cxx_level") and ext._cxx_level == 0:
+                ext.cxx_std = auto_cpp_level(self.compiler)
+
+        super().build_extensions()
+
+
+def intree_extensions(
+    paths: Iterable[str], package_dir: Optional[Dict[str, str]] = None
+) -> List[Pybind11Extension]:
+    """
+    Generate Pybind11Extensions from source files directly located in a Python
+    source tree.
+
+    ``package_dir`` behaves as in ``setuptools.setup``.  If unset, the Python
+    package root parent is determined as the first parent directory that does
+    not contain an ``__init__.py`` file.
+    """
+    exts = []
+
+    if package_dir is None:
+        for path in paths:
+            parent, _ = os.path.split(path)
+            while os.path.exists(os.path.join(parent, "__init__.py")):
+                parent, _ = os.path.split(parent)
+            relname, _ = os.path.splitext(os.path.relpath(path, parent))
+            qualified_name = relname.replace(os.path.sep, ".")
+            exts.append(Pybind11Extension(qualified_name, [path]))
+        return exts
+
+    for path in paths:
+        for prefix, parent in package_dir.items():
+            if path.startswith(parent):
+                relname, _ = os.path.splitext(os.path.relpath(path, parent))
+                qualified_name = relname.replace(os.path.sep, ".")
+                if prefix:
+                    qualified_name = prefix + "." + qualified_name
+                exts.append(Pybind11Extension(qualified_name, [path]))
+                break
+        else:
+            msg = (
+                f"path {path} is not a child of any of the directories listed "
+                f"in 'package_dir' ({package_dir})"
+            )
+            raise ValueError(msg)
+
+    return exts
+
+
+def naive_recompile(obj: str, src: str) -> bool:
+    """
+    This will recompile only if the source file changes. It does not check
+    header files, so a more advanced function or Ccache is better if you have
+    editable header files in your package.
+    """
+    return os.stat(obj).st_mtime < os.stat(src).st_mtime
+
+
+def no_recompile(obg: str, src: str) -> bool:  # pylint: disable=unused-argument
+    """
+    This is the safest but slowest choice (and is the default) - will always
+    recompile sources.
+    """
+    return True
+
+
+S = TypeVar("S", bound="ParallelCompile")
+
+CCompilerMethod = Callable[
+    [
+        distutils.ccompiler.CCompiler,
+        List[str],
+        Optional[str],
+        Optional[Union[Tuple[str], Tuple[str, Optional[str]]]],
+        Optional[List[str]],
+        bool,
+        Optional[List[str]],
+        Optional[List[str]],
+        Optional[List[str]],
+    ],
+    List[str],
+]
+
+
+# Optional parallel compile utility
+# inspired by: http://stackoverflow.com/questions/11013851/speeding-up-build-process-with-distutils
+# and: https://github.com/tbenthompson/cppimport/blob/stable/cppimport/build_module.py
+# and NumPy's parallel distutils module:
+#              https://github.com/numpy/numpy/blob/master/numpy/distutils/ccompiler.py
+class ParallelCompile:
+    """
+    Make a parallel compile function. Inspired by
+    numpy.distutils.ccompiler.CCompiler.compile and cppimport.
+
+    This takes several arguments that allow you to customize the compile
+    function created:
+
+    envvar:
+        Set an environment variable to control the compilation threads, like
+        NPY_NUM_BUILD_JOBS
+    default:
+        0 will automatically multithread, or 1 will only multithread if the
+        envvar is set.
+    max:
+        The limit for automatic multithreading if non-zero
+    needs_recompile:
+        A function of (obj, src) that returns True when recompile is needed.  No
+        effect in isolated mode; use ccache instead, see
+        https://github.com/matplotlib/matplotlib/issues/1507/
+
+    To use::
+
+        ParallelCompile("NPY_NUM_BUILD_JOBS").install()
+
+    or::
+
+        with ParallelCompile("NPY_NUM_BUILD_JOBS"):
+            setup(...)
+
+    By default, this assumes all files need to be recompiled. A smarter
+    function can be provided via needs_recompile.  If the output has not yet
+    been generated, the compile will always run, and this function is not
+    called.
+    """
+
+    __slots__ = ("envvar", "default", "max", "_old", "needs_recompile")
+
+    def __init__(
+        self,
+        envvar: Optional[str] = None,
+        default: int = 0,
+        max: int = 0,  # pylint: disable=redefined-builtin
+        needs_recompile: Callable[[str, str], bool] = no_recompile,
+    ) -> None:
+        self.envvar = envvar
+        self.default = default
+        self.max = max
+        self.needs_recompile = needs_recompile
+        self._old: List[CCompilerMethod] = []
+
+    def function(self) -> CCompilerMethod:
+        """
+        Builds a function object usable as distutils.ccompiler.CCompiler.compile.
+        """
+
+        def compile_function(
+            compiler: distutils.ccompiler.CCompiler,
+            sources: List[str],
+            output_dir: Optional[str] = None,
+            macros: Optional[Union[Tuple[str], Tuple[str, Optional[str]]]] = None,
+            include_dirs: Optional[List[str]] = None,
+            debug: bool = False,
+            extra_preargs: Optional[List[str]] = None,
+            extra_postargs: Optional[List[str]] = None,
+            depends: Optional[List[str]] = None,
+        ) -> Any:
+            # These lines are directly from distutils.ccompiler.CCompiler
+            macros, objects, extra_postargs, pp_opts, build = compiler._setup_compile(  # type: ignore[attr-defined]
+                output_dir, macros, include_dirs, sources, depends, extra_postargs
+            )
+            cc_args = compiler._get_cc_args(pp_opts, debug, extra_preargs)  # type: ignore[attr-defined]
+
+            # The number of threads; start with default.
+            threads = self.default
+
+            # Determine the number of compilation threads, unless set by an environment variable.
+            if self.envvar is not None:
+                threads = int(os.environ.get(self.envvar, self.default))
+
+            def _single_compile(obj: Any) -> None:
+                try:
+                    src, ext = build[obj]
+                except KeyError:
+                    return
+
+                if not os.path.exists(obj) or self.needs_recompile(obj, src):
+                    compiler._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)  # type: ignore[attr-defined]
+
+            try:
+                # Importing .synchronize checks for platforms that have some multiprocessing
+                # capabilities but lack semaphores, such as AWS Lambda and Android Termux.
+                import multiprocessing.synchronize
+                from multiprocessing.pool import ThreadPool
+            except ImportError:
+                threads = 1
+
+            if threads == 0:
+                try:
+                    threads = multiprocessing.cpu_count()
+                    threads = self.max if self.max and self.max < threads else threads
+                except NotImplementedError:
+                    threads = 1
+
+            if threads > 1:
+                with ThreadPool(threads) as pool:
+                    for _ in pool.imap_unordered(_single_compile, objects):
+                        pass
+            else:
+                for ob in objects:
+                    _single_compile(ob)
+
+            return objects
+
+        return compile_function
+
+    def install(self: S) -> S:
+        """
+        Installs the compile function into distutils.ccompiler.CCompiler.compile.
+        """
+        distutils.ccompiler.CCompiler.compile = self.function()  # type: ignore[assignment]
+        return self
+
+    def __enter__(self: S) -> S:
+        self._old.append(distutils.ccompiler.CCompiler.compile)
+        return self.install()
+
+    def __exit__(self, *args: Any) -> None:
+        distutils.ccompiler.CCompiler.compile = self._old.pop()  # type: ignore[assignment]
```

## extern/pybind11/tests/conftest.py

 * *Ordering differences only*

```diff
@@ -1,238 +1,238 @@
-"""pytest configuration
-
-Extends output capture as needed by pybind11: ignore constructors, optional unordered lines.
-Adds docstring and exceptions message sanitizers.
-"""
-
-import contextlib
-import difflib
-import gc
-import multiprocessing
-import os
-import re
-import textwrap
-import traceback
-
-import pytest
-
-# Early diagnostic for failed imports
-try:
-    import pybind11_tests
-except Exception:
-    # pytest does not show the traceback without this.
-    traceback.print_exc()
-    raise
-
-
-@pytest.fixture(scope="session", autouse=True)
-def always_forkserver_on_unix():
-    if os.name == "nt":
-        return
-
-    # Full background: https://github.com/pybind/pybind11/issues/4105#issuecomment-1301004592
-    # In a nutshell: fork() after starting threads == flakiness in the form of deadlocks.
-    # It is actually a well-known pitfall, unfortunately without guard rails.
-    # "forkserver" is more performant than "spawn" (~9s vs ~13s for tests/test_gil_scoped.py,
-    # visit the issuecomment link above for details).
-    # Windows does not have fork() and the associated pitfall, therefore it is best left
-    # running with defaults.
-    multiprocessing.set_start_method("forkserver")
-
-
-_long_marker = re.compile(r"([0-9])L")
-_hexadecimal = re.compile(r"0x[0-9a-fA-F]+")
-
-# Avoid collecting Python3 only files
-collect_ignore = []
-
-
-def _strip_and_dedent(s):
-    """For triple-quote strings"""
-    return textwrap.dedent(s.lstrip("\n").rstrip())
-
-
-def _split_and_sort(s):
-    """For output which does not require specific line order"""
-    return sorted(_strip_and_dedent(s).splitlines())
-
-
-def _make_explanation(a, b):
-    """Explanation for a failed assert -- the a and b arguments are List[str]"""
-    return ["--- actual / +++ expected"] + [
-        line.strip("\n") for line in difflib.ndiff(a, b)
-    ]
-
-
-class Output:
-    """Basic output post-processing and comparison"""
-
-    def __init__(self, string):
-        self.string = string
-        self.explanation = []
-
-    def __str__(self):
-        return self.string
-
-    def __eq__(self, other):
-        # Ignore constructor/destructor output which is prefixed with "###"
-        a = [
-            line
-            for line in self.string.strip().splitlines()
-            if not line.startswith("###")
-        ]
-        b = _strip_and_dedent(other).splitlines()
-        if a == b:
-            return True
-        else:
-            self.explanation = _make_explanation(a, b)
-            return False
-
-
-class Unordered(Output):
-    """Custom comparison for output without strict line ordering"""
-
-    def __eq__(self, other):
-        a = _split_and_sort(self.string)
-        b = _split_and_sort(other)
-        if a == b:
-            return True
-        else:
-            self.explanation = _make_explanation(a, b)
-            return False
-
-
-class Capture:
-    def __init__(self, capfd):
-        self.capfd = capfd
-        self.out = ""
-        self.err = ""
-
-    def __enter__(self):
-        self.capfd.readouterr()
-        return self
-
-    def __exit__(self, *args):
-        self.out, self.err = self.capfd.readouterr()
-
-    def __eq__(self, other):
-        a = Output(self.out)
-        b = other
-        if a == b:
-            return True
-        else:
-            self.explanation = a.explanation
-            return False
-
-    def __str__(self):
-        return self.out
-
-    def __contains__(self, item):
-        return item in self.out
-
-    @property
-    def unordered(self):
-        return Unordered(self.out)
-
-    @property
-    def stderr(self):
-        return Output(self.err)
-
-
-@pytest.fixture
-def capture(capsys):
-    """Extended `capsys` with context manager and custom equality operators"""
-    return Capture(capsys)
-
-
-class SanitizedString:
-    def __init__(self, sanitizer):
-        self.sanitizer = sanitizer
-        self.string = ""
-        self.explanation = []
-
-    def __call__(self, thing):
-        self.string = self.sanitizer(thing)
-        return self
-
-    def __eq__(self, other):
-        a = self.string
-        b = _strip_and_dedent(other)
-        if a == b:
-            return True
-        else:
-            self.explanation = _make_explanation(a.splitlines(), b.splitlines())
-            return False
-
-
-def _sanitize_general(s):
-    s = s.strip()
-    s = s.replace("pybind11_tests.", "m.")
-    s = _long_marker.sub(r"\1", s)
-    return s
-
-
-def _sanitize_docstring(thing):
-    s = thing.__doc__
-    s = _sanitize_general(s)
-    return s
-
-
-@pytest.fixture
-def doc():
-    """Sanitize docstrings and add custom failure explanation"""
-    return SanitizedString(_sanitize_docstring)
-
-
-def _sanitize_message(thing):
-    s = str(thing)
-    s = _sanitize_general(s)
-    s = _hexadecimal.sub("0", s)
-    return s
-
-
-@pytest.fixture
-def msg():
-    """Sanitize messages and add custom failure explanation"""
-    return SanitizedString(_sanitize_message)
-
-
-# noinspection PyUnusedLocal
-def pytest_assertrepr_compare(op, left, right):
-    """Hook to insert custom failure explanation"""
-    if hasattr(left, "explanation"):
-        return left.explanation
-
-
-@contextlib.contextmanager
-def suppress(exception):
-    """Suppress the desired exception"""
-    try:
-        yield
-    except exception:
-        pass
-
-
-def gc_collect():
-    """Run the garbage collector twice (needed when running
-    reference counting tests with PyPy)"""
-    gc.collect()
-    gc.collect()
-
-
-def pytest_configure():
-    pytest.suppress = suppress
-    pytest.gc_collect = gc_collect
-
-
-def pytest_report_header(config):
-    del config  # Unused.
-    assert (
-        pybind11_tests.compiler_info is not None
-    ), "Please update pybind11_tests.cpp if this assert fails."
-    return (
-        "C++ Info:"
-        f" {pybind11_tests.compiler_info}"
-        f" {pybind11_tests.cpp_std}"
-        f" {pybind11_tests.PYBIND11_INTERNALS_ID}"
-        f" PYBIND11_SIMPLE_GIL_MANAGEMENT={pybind11_tests.PYBIND11_SIMPLE_GIL_MANAGEMENT}"
-    )
+"""pytest configuration
+
+Extends output capture as needed by pybind11: ignore constructors, optional unordered lines.
+Adds docstring and exceptions message sanitizers.
+"""
+
+import contextlib
+import difflib
+import gc
+import multiprocessing
+import os
+import re
+import textwrap
+import traceback
+
+import pytest
+
+# Early diagnostic for failed imports
+try:
+    import pybind11_tests
+except Exception:
+    # pytest does not show the traceback without this.
+    traceback.print_exc()
+    raise
+
+
+@pytest.fixture(scope="session", autouse=True)
+def always_forkserver_on_unix():
+    if os.name == "nt":
+        return
+
+    # Full background: https://github.com/pybind/pybind11/issues/4105#issuecomment-1301004592
+    # In a nutshell: fork() after starting threads == flakiness in the form of deadlocks.
+    # It is actually a well-known pitfall, unfortunately without guard rails.
+    # "forkserver" is more performant than "spawn" (~9s vs ~13s for tests/test_gil_scoped.py,
+    # visit the issuecomment link above for details).
+    # Windows does not have fork() and the associated pitfall, therefore it is best left
+    # running with defaults.
+    multiprocessing.set_start_method("forkserver")
+
+
+_long_marker = re.compile(r"([0-9])L")
+_hexadecimal = re.compile(r"0x[0-9a-fA-F]+")
+
+# Avoid collecting Python3 only files
+collect_ignore = []
+
+
+def _strip_and_dedent(s):
+    """For triple-quote strings"""
+    return textwrap.dedent(s.lstrip("\n").rstrip())
+
+
+def _split_and_sort(s):
+    """For output which does not require specific line order"""
+    return sorted(_strip_and_dedent(s).splitlines())
+
+
+def _make_explanation(a, b):
+    """Explanation for a failed assert -- the a and b arguments are List[str]"""
+    return ["--- actual / +++ expected"] + [
+        line.strip("\n") for line in difflib.ndiff(a, b)
+    ]
+
+
+class Output:
+    """Basic output post-processing and comparison"""
+
+    def __init__(self, string):
+        self.string = string
+        self.explanation = []
+
+    def __str__(self):
+        return self.string
+
+    def __eq__(self, other):
+        # Ignore constructor/destructor output which is prefixed with "###"
+        a = [
+            line
+            for line in self.string.strip().splitlines()
+            if not line.startswith("###")
+        ]
+        b = _strip_and_dedent(other).splitlines()
+        if a == b:
+            return True
+        else:
+            self.explanation = _make_explanation(a, b)
+            return False
+
+
+class Unordered(Output):
+    """Custom comparison for output without strict line ordering"""
+
+    def __eq__(self, other):
+        a = _split_and_sort(self.string)
+        b = _split_and_sort(other)
+        if a == b:
+            return True
+        else:
+            self.explanation = _make_explanation(a, b)
+            return False
+
+
+class Capture:
+    def __init__(self, capfd):
+        self.capfd = capfd
+        self.out = ""
+        self.err = ""
+
+    def __enter__(self):
+        self.capfd.readouterr()
+        return self
+
+    def __exit__(self, *args):
+        self.out, self.err = self.capfd.readouterr()
+
+    def __eq__(self, other):
+        a = Output(self.out)
+        b = other
+        if a == b:
+            return True
+        else:
+            self.explanation = a.explanation
+            return False
+
+    def __str__(self):
+        return self.out
+
+    def __contains__(self, item):
+        return item in self.out
+
+    @property
+    def unordered(self):
+        return Unordered(self.out)
+
+    @property
+    def stderr(self):
+        return Output(self.err)
+
+
+@pytest.fixture
+def capture(capsys):
+    """Extended `capsys` with context manager and custom equality operators"""
+    return Capture(capsys)
+
+
+class SanitizedString:
+    def __init__(self, sanitizer):
+        self.sanitizer = sanitizer
+        self.string = ""
+        self.explanation = []
+
+    def __call__(self, thing):
+        self.string = self.sanitizer(thing)
+        return self
+
+    def __eq__(self, other):
+        a = self.string
+        b = _strip_and_dedent(other)
+        if a == b:
+            return True
+        else:
+            self.explanation = _make_explanation(a.splitlines(), b.splitlines())
+            return False
+
+
+def _sanitize_general(s):
+    s = s.strip()
+    s = s.replace("pybind11_tests.", "m.")
+    s = _long_marker.sub(r"\1", s)
+    return s
+
+
+def _sanitize_docstring(thing):
+    s = thing.__doc__
+    s = _sanitize_general(s)
+    return s
+
+
+@pytest.fixture
+def doc():
+    """Sanitize docstrings and add custom failure explanation"""
+    return SanitizedString(_sanitize_docstring)
+
+
+def _sanitize_message(thing):
+    s = str(thing)
+    s = _sanitize_general(s)
+    s = _hexadecimal.sub("0", s)
+    return s
+
+
+@pytest.fixture
+def msg():
+    """Sanitize messages and add custom failure explanation"""
+    return SanitizedString(_sanitize_message)
+
+
+# noinspection PyUnusedLocal
+def pytest_assertrepr_compare(op, left, right):
+    """Hook to insert custom failure explanation"""
+    if hasattr(left, "explanation"):
+        return left.explanation
+
+
+@contextlib.contextmanager
+def suppress(exception):
+    """Suppress the desired exception"""
+    try:
+        yield
+    except exception:
+        pass
+
+
+def gc_collect():
+    """Run the garbage collector twice (needed when running
+    reference counting tests with PyPy)"""
+    gc.collect()
+    gc.collect()
+
+
+def pytest_configure():
+    pytest.suppress = suppress
+    pytest.gc_collect = gc_collect
+
+
+def pytest_report_header(config):
+    del config  # Unused.
+    assert (
+        pybind11_tests.compiler_info is not None
+    ), "Please update pybind11_tests.cpp if this assert fails."
+    return (
+        "C++ Info:"
+        f" {pybind11_tests.compiler_info}"
+        f" {pybind11_tests.cpp_std}"
+        f" {pybind11_tests.PYBIND11_INTERNALS_ID}"
+        f" PYBIND11_SIMPLE_GIL_MANAGEMENT={pybind11_tests.PYBIND11_SIMPLE_GIL_MANAGEMENT}"
+    )
```

## extern/pybind11/tests/env.py

 * *Ordering differences only*

```diff
@@ -1,28 +1,28 @@
-import platform
-import sys
-
-import pytest
-
-LINUX = sys.platform.startswith("linux")
-MACOS = sys.platform.startswith("darwin")
-WIN = sys.platform.startswith("win32") or sys.platform.startswith("cygwin")
-
-CPYTHON = platform.python_implementation() == "CPython"
-PYPY = platform.python_implementation() == "PyPy"
-
-
-def deprecated_call():
-    """
-    pytest.deprecated_call() seems broken in pytest<3.9.x; concretely, it
-    doesn't work on CPython 3.8.0 with pytest==3.3.2 on Ubuntu 18.04 (#2922).
-
-    This is a narrowed reimplementation of the following PR :(
-    https://github.com/pytest-dev/pytest/pull/4104
-    """
-    # TODO: Remove this when testing requires pytest>=3.9.
-    pieces = pytest.__version__.split(".")
-    pytest_major_minor = (int(pieces[0]), int(pieces[1]))
-    if pytest_major_minor < (3, 9):
-        return pytest.warns((DeprecationWarning, PendingDeprecationWarning))
-    else:
-        return pytest.deprecated_call()
+import platform
+import sys
+
+import pytest
+
+LINUX = sys.platform.startswith("linux")
+MACOS = sys.platform.startswith("darwin")
+WIN = sys.platform.startswith("win32") or sys.platform.startswith("cygwin")
+
+CPYTHON = platform.python_implementation() == "CPython"
+PYPY = platform.python_implementation() == "PyPy"
+
+
+def deprecated_call():
+    """
+    pytest.deprecated_call() seems broken in pytest<3.9.x; concretely, it
+    doesn't work on CPython 3.8.0 with pytest==3.3.2 on Ubuntu 18.04 (#2922).
+
+    This is a narrowed reimplementation of the following PR :(
+    https://github.com/pytest-dev/pytest/pull/4104
+    """
+    # TODO: Remove this when testing requires pytest>=3.9.
+    pieces = pytest.__version__.split(".")
+    pytest_major_minor = (int(pieces[0]), int(pieces[1]))
+    if pytest_major_minor < (3, 9):
+        return pytest.warns((DeprecationWarning, PendingDeprecationWarning))
+    else:
+        return pytest.deprecated_call()
```

## extern/pybind11/tests/test_async.py

 * *Ordering differences only*

```diff
@@ -1,24 +1,24 @@
-import pytest
-
-asyncio = pytest.importorskip("asyncio")
-m = pytest.importorskip("pybind11_tests.async_module")
-
-
-@pytest.fixture
-def event_loop():
-    loop = asyncio.new_event_loop()
-    yield loop
-    loop.close()
-
-
-async def get_await_result(x):
-    return await x
-
-
-def test_await(event_loop):
-    assert 5 == event_loop.run_until_complete(get_await_result(m.SupportsAsync()))
-
-
-def test_await_missing(event_loop):
-    with pytest.raises(TypeError):
-        event_loop.run_until_complete(get_await_result(m.DoesNotSupportAsync()))
+import pytest
+
+asyncio = pytest.importorskip("asyncio")
+m = pytest.importorskip("pybind11_tests.async_module")
+
+
+@pytest.fixture
+def event_loop():
+    loop = asyncio.new_event_loop()
+    yield loop
+    loop.close()
+
+
+async def get_await_result(x):
+    return await x
+
+
+def test_await(event_loop):
+    assert 5 == event_loop.run_until_complete(get_await_result(m.SupportsAsync()))
+
+
+def test_await_missing(event_loop):
+    with pytest.raises(TypeError):
+        event_loop.run_until_complete(get_await_result(m.DoesNotSupportAsync()))
```

## extern/pybind11/tests/test_buffers.py

 * *Ordering differences only*

```diff
@@ -1,163 +1,163 @@
-import ctypes
-import io
-import struct
-
-import pytest
-
-import env
-from pybind11_tests import ConstructorStats
-from pybind11_tests import buffers as m
-
-np = pytest.importorskip("numpy")
-
-
-def test_from_python():
-    with pytest.raises(RuntimeError) as excinfo:
-        m.Matrix(np.array([1, 2, 3]))  # trying to assign a 1D array
-    assert str(excinfo.value) == "Incompatible buffer format!"
-
-    m3 = np.array([[1, 2, 3], [4, 5, 6]]).astype(np.float32)
-    m4 = m.Matrix(m3)
-
-    for i in range(m4.rows()):
-        for j in range(m4.cols()):
-            assert m3[i, j] == m4[i, j]
-
-    cstats = ConstructorStats.get(m.Matrix)
-    assert cstats.alive() == 1
-    del m3, m4
-    assert cstats.alive() == 0
-    assert cstats.values() == ["2x3 matrix"]
-    assert cstats.copy_constructions == 0
-    # assert cstats.move_constructions >= 0  # Don't invoke any
-    assert cstats.copy_assignments == 0
-    assert cstats.move_assignments == 0
-
-
-# https://foss.heptapod.net/pypy/pypy/-/issues/2444
-# TODO: fix on recent PyPy
-@pytest.mark.xfail(
-    env.PYPY, reason="PyPy 7.3.7 doesn't clear this anymore", strict=False
-)
-def test_to_python():
-    mat = m.Matrix(5, 4)
-    assert memoryview(mat).shape == (5, 4)
-
-    assert mat[2, 3] == 0
-    mat[2, 3] = 4.0
-    mat[3, 2] = 7.0
-    assert mat[2, 3] == 4
-    assert mat[3, 2] == 7
-    assert struct.unpack_from("f", mat, (3 * 4 + 2) * 4) == (7,)
-    assert struct.unpack_from("f", mat, (2 * 4 + 3) * 4) == (4,)
-
-    mat2 = np.array(mat, copy=False)
-    assert mat2.shape == (5, 4)
-    assert abs(mat2).sum() == 11
-    assert mat2[2, 3] == 4 and mat2[3, 2] == 7
-    mat2[2, 3] = 5
-    assert mat2[2, 3] == 5
-
-    cstats = ConstructorStats.get(m.Matrix)
-    assert cstats.alive() == 1
-    del mat
-    pytest.gc_collect()
-    assert cstats.alive() == 1
-    del mat2  # holds a mat reference
-    pytest.gc_collect()
-    assert cstats.alive() == 0
-    assert cstats.values() == ["5x4 matrix"]
-    assert cstats.copy_constructions == 0
-    # assert cstats.move_constructions >= 0  # Don't invoke any
-    assert cstats.copy_assignments == 0
-    assert cstats.move_assignments == 0
-
-
-def test_inherited_protocol():
-    """SquareMatrix is derived from Matrix and inherits the buffer protocol"""
-
-    matrix = m.SquareMatrix(5)
-    assert memoryview(matrix).shape == (5, 5)
-    assert np.asarray(matrix).shape == (5, 5)
-
-
-def test_pointer_to_member_fn():
-    for cls in [m.Buffer, m.ConstBuffer, m.DerivedBuffer]:
-        buf = cls()
-        buf.value = 0x12345678
-        value = struct.unpack("i", bytearray(buf))[0]
-        assert value == 0x12345678
-
-
-def test_readonly_buffer():
-    buf = m.BufferReadOnly(0x64)
-    view = memoryview(buf)
-    assert view[0] == 0x64
-    assert view.readonly
-    with pytest.raises(TypeError):
-        view[0] = 0
-
-
-def test_selective_readonly_buffer():
-    buf = m.BufferReadOnlySelect()
-
-    memoryview(buf)[0] = 0x64
-    assert buf.value == 0x64
-
-    io.BytesIO(b"A").readinto(buf)
-    assert buf.value == ord(b"A")
-
-    buf.readonly = True
-    with pytest.raises(TypeError):
-        memoryview(buf)[0] = 0
-    with pytest.raises(TypeError):
-        io.BytesIO(b"1").readinto(buf)
-
-
-def test_ctypes_array_1d():
-    char1d = (ctypes.c_char * 10)()
-    int1d = (ctypes.c_int * 15)()
-    long1d = (ctypes.c_long * 7)()
-
-    for carray in (char1d, int1d, long1d):
-        info = m.get_buffer_info(carray)
-        assert info.itemsize == ctypes.sizeof(carray._type_)
-        assert info.size == len(carray)
-        assert info.ndim == 1
-        assert info.shape == [info.size]
-        assert info.strides == [info.itemsize]
-        assert not info.readonly
-
-
-def test_ctypes_array_2d():
-    char2d = ((ctypes.c_char * 10) * 4)()
-    int2d = ((ctypes.c_int * 15) * 3)()
-    long2d = ((ctypes.c_long * 7) * 2)()
-
-    for carray in (char2d, int2d, long2d):
-        info = m.get_buffer_info(carray)
-        assert info.itemsize == ctypes.sizeof(carray[0]._type_)
-        assert info.size == len(carray) * len(carray[0])
-        assert info.ndim == 2
-        assert info.shape == [len(carray), len(carray[0])]
-        assert info.strides == [info.itemsize * len(carray[0]), info.itemsize]
-        assert not info.readonly
-
-
-def test_ctypes_from_buffer():
-    test_pystr = b"0123456789"
-    for pyarray in (test_pystr, bytearray(test_pystr)):
-        pyinfo = m.get_buffer_info(pyarray)
-
-        if pyinfo.readonly:
-            cbytes = (ctypes.c_char * len(pyarray)).from_buffer_copy(pyarray)
-            cinfo = m.get_buffer_info(cbytes)
-        else:
-            cbytes = (ctypes.c_char * len(pyarray)).from_buffer(pyarray)
-            cinfo = m.get_buffer_info(cbytes)
-
-        assert cinfo.size == pyinfo.size
-        assert cinfo.ndim == pyinfo.ndim
-        assert cinfo.shape == pyinfo.shape
-        assert cinfo.strides == pyinfo.strides
-        assert not cinfo.readonly
+import ctypes
+import io
+import struct
+
+import pytest
+
+import env
+from pybind11_tests import ConstructorStats
+from pybind11_tests import buffers as m
+
+np = pytest.importorskip("numpy")
+
+
+def test_from_python():
+    with pytest.raises(RuntimeError) as excinfo:
+        m.Matrix(np.array([1, 2, 3]))  # trying to assign a 1D array
+    assert str(excinfo.value) == "Incompatible buffer format!"
+
+    m3 = np.array([[1, 2, 3], [4, 5, 6]]).astype(np.float32)
+    m4 = m.Matrix(m3)
+
+    for i in range(m4.rows()):
+        for j in range(m4.cols()):
+            assert m3[i, j] == m4[i, j]
+
+    cstats = ConstructorStats.get(m.Matrix)
+    assert cstats.alive() == 1
+    del m3, m4
+    assert cstats.alive() == 0
+    assert cstats.values() == ["2x3 matrix"]
+    assert cstats.copy_constructions == 0
+    # assert cstats.move_constructions >= 0  # Don't invoke any
+    assert cstats.copy_assignments == 0
+    assert cstats.move_assignments == 0
+
+
+# https://foss.heptapod.net/pypy/pypy/-/issues/2444
+# TODO: fix on recent PyPy
+@pytest.mark.xfail(
+    env.PYPY, reason="PyPy 7.3.7 doesn't clear this anymore", strict=False
+)
+def test_to_python():
+    mat = m.Matrix(5, 4)
+    assert memoryview(mat).shape == (5, 4)
+
+    assert mat[2, 3] == 0
+    mat[2, 3] = 4.0
+    mat[3, 2] = 7.0
+    assert mat[2, 3] == 4
+    assert mat[3, 2] == 7
+    assert struct.unpack_from("f", mat, (3 * 4 + 2) * 4) == (7,)
+    assert struct.unpack_from("f", mat, (2 * 4 + 3) * 4) == (4,)
+
+    mat2 = np.array(mat, copy=False)
+    assert mat2.shape == (5, 4)
+    assert abs(mat2).sum() == 11
+    assert mat2[2, 3] == 4 and mat2[3, 2] == 7
+    mat2[2, 3] = 5
+    assert mat2[2, 3] == 5
+
+    cstats = ConstructorStats.get(m.Matrix)
+    assert cstats.alive() == 1
+    del mat
+    pytest.gc_collect()
+    assert cstats.alive() == 1
+    del mat2  # holds a mat reference
+    pytest.gc_collect()
+    assert cstats.alive() == 0
+    assert cstats.values() == ["5x4 matrix"]
+    assert cstats.copy_constructions == 0
+    # assert cstats.move_constructions >= 0  # Don't invoke any
+    assert cstats.copy_assignments == 0
+    assert cstats.move_assignments == 0
+
+
+def test_inherited_protocol():
+    """SquareMatrix is derived from Matrix and inherits the buffer protocol"""
+
+    matrix = m.SquareMatrix(5)
+    assert memoryview(matrix).shape == (5, 5)
+    assert np.asarray(matrix).shape == (5, 5)
+
+
+def test_pointer_to_member_fn():
+    for cls in [m.Buffer, m.ConstBuffer, m.DerivedBuffer]:
+        buf = cls()
+        buf.value = 0x12345678
+        value = struct.unpack("i", bytearray(buf))[0]
+        assert value == 0x12345678
+
+
+def test_readonly_buffer():
+    buf = m.BufferReadOnly(0x64)
+    view = memoryview(buf)
+    assert view[0] == 0x64
+    assert view.readonly
+    with pytest.raises(TypeError):
+        view[0] = 0
+
+
+def test_selective_readonly_buffer():
+    buf = m.BufferReadOnlySelect()
+
+    memoryview(buf)[0] = 0x64
+    assert buf.value == 0x64
+
+    io.BytesIO(b"A").readinto(buf)
+    assert buf.value == ord(b"A")
+
+    buf.readonly = True
+    with pytest.raises(TypeError):
+        memoryview(buf)[0] = 0
+    with pytest.raises(TypeError):
+        io.BytesIO(b"1").readinto(buf)
+
+
+def test_ctypes_array_1d():
+    char1d = (ctypes.c_char * 10)()
+    int1d = (ctypes.c_int * 15)()
+    long1d = (ctypes.c_long * 7)()
+
+    for carray in (char1d, int1d, long1d):
+        info = m.get_buffer_info(carray)
+        assert info.itemsize == ctypes.sizeof(carray._type_)
+        assert info.size == len(carray)
+        assert info.ndim == 1
+        assert info.shape == [info.size]
+        assert info.strides == [info.itemsize]
+        assert not info.readonly
+
+
+def test_ctypes_array_2d():
+    char2d = ((ctypes.c_char * 10) * 4)()
+    int2d = ((ctypes.c_int * 15) * 3)()
+    long2d = ((ctypes.c_long * 7) * 2)()
+
+    for carray in (char2d, int2d, long2d):
+        info = m.get_buffer_info(carray)
+        assert info.itemsize == ctypes.sizeof(carray[0]._type_)
+        assert info.size == len(carray) * len(carray[0])
+        assert info.ndim == 2
+        assert info.shape == [len(carray), len(carray[0])]
+        assert info.strides == [info.itemsize * len(carray[0]), info.itemsize]
+        assert not info.readonly
+
+
+def test_ctypes_from_buffer():
+    test_pystr = b"0123456789"
+    for pyarray in (test_pystr, bytearray(test_pystr)):
+        pyinfo = m.get_buffer_info(pyarray)
+
+        if pyinfo.readonly:
+            cbytes = (ctypes.c_char * len(pyarray)).from_buffer_copy(pyarray)
+            cinfo = m.get_buffer_info(cbytes)
+        else:
+            cbytes = (ctypes.c_char * len(pyarray)).from_buffer(pyarray)
+            cinfo = m.get_buffer_info(cbytes)
+
+        assert cinfo.size == pyinfo.size
+        assert cinfo.ndim == pyinfo.ndim
+        assert cinfo.shape == pyinfo.shape
+        assert cinfo.strides == pyinfo.strides
+        assert not cinfo.readonly
```

## extern/pybind11/tests/test_builtin_casters.py

 * *Ordering differences only*

```diff
@@ -1,526 +1,526 @@
-import sys
-
-import pytest
-
-import env
-from pybind11_tests import IncType, UserType
-from pybind11_tests import builtin_casters as m
-
-
-def test_simple_string():
-    assert m.string_roundtrip("const char *") == "const char *"
-
-
-def test_unicode_conversion():
-    """Tests unicode conversion and error reporting."""
-    assert m.good_utf8_string() == "Say utf8‽ 🎂 𝐀"
-    assert m.good_utf16_string() == "b‽🎂𝐀z"
-    assert m.good_utf32_string() == "a𝐀🎂‽z"
-    assert m.good_wchar_string() == "a⸘𝐀z"
-    if hasattr(m, "has_u8string"):
-        assert m.good_utf8_u8string() == "Say utf8‽ 🎂 𝐀"
-
-    with pytest.raises(UnicodeDecodeError):
-        m.bad_utf8_string()
-
-    with pytest.raises(UnicodeDecodeError):
-        m.bad_utf16_string()
-
-    # These are provided only if they actually fail (they don't when 32-bit)
-    if hasattr(m, "bad_utf32_string"):
-        with pytest.raises(UnicodeDecodeError):
-            m.bad_utf32_string()
-    if hasattr(m, "bad_wchar_string"):
-        with pytest.raises(UnicodeDecodeError):
-            m.bad_wchar_string()
-    if hasattr(m, "has_u8string"):
-        with pytest.raises(UnicodeDecodeError):
-            m.bad_utf8_u8string()
-
-    assert m.u8_Z() == "Z"
-    assert m.u8_eacute() == "é"
-    assert m.u16_ibang() == "‽"
-    assert m.u32_mathbfA() == "𝐀"
-    assert m.wchar_heart() == "♥"
-    if hasattr(m, "has_u8string"):
-        assert m.u8_char8_Z() == "Z"
-
-
-def test_single_char_arguments():
-    """Tests failures for passing invalid inputs to char-accepting functions"""
-
-    def toobig_message(r):
-        return f"Character code point not in range({r:#x})"
-
-    toolong_message = "Expected a character, but multi-character string found"
-
-    assert m.ord_char("a") == 0x61  # simple ASCII
-    assert m.ord_char_lv("b") == 0x62
-    assert (
-        m.ord_char("é") == 0xE9
-    )  # requires 2 bytes in utf-8, but can be stuffed in a char
-    with pytest.raises(ValueError) as excinfo:
-        assert m.ord_char("Ā") == 0x100  # requires 2 bytes, doesn't fit in a char
-    assert str(excinfo.value) == toobig_message(0x100)
-    with pytest.raises(ValueError) as excinfo:
-        assert m.ord_char("ab")
-    assert str(excinfo.value) == toolong_message
-
-    assert m.ord_char16("a") == 0x61
-    assert m.ord_char16("é") == 0xE9
-    assert m.ord_char16_lv("ê") == 0xEA
-    assert m.ord_char16("Ā") == 0x100
-    assert m.ord_char16("‽") == 0x203D
-    assert m.ord_char16("♥") == 0x2665
-    assert m.ord_char16_lv("♡") == 0x2661
-    with pytest.raises(ValueError) as excinfo:
-        assert m.ord_char16("🎂") == 0x1F382  # requires surrogate pair
-    assert str(excinfo.value) == toobig_message(0x10000)
-    with pytest.raises(ValueError) as excinfo:
-        assert m.ord_char16("aa")
-    assert str(excinfo.value) == toolong_message
-
-    assert m.ord_char32("a") == 0x61
-    assert m.ord_char32("é") == 0xE9
-    assert m.ord_char32("Ā") == 0x100
-    assert m.ord_char32("‽") == 0x203D
-    assert m.ord_char32("♥") == 0x2665
-    assert m.ord_char32("🎂") == 0x1F382
-    with pytest.raises(ValueError) as excinfo:
-        assert m.ord_char32("aa")
-    assert str(excinfo.value) == toolong_message
-
-    assert m.ord_wchar("a") == 0x61
-    assert m.ord_wchar("é") == 0xE9
-    assert m.ord_wchar("Ā") == 0x100
-    assert m.ord_wchar("‽") == 0x203D
-    assert m.ord_wchar("♥") == 0x2665
-    if m.wchar_size == 2:
-        with pytest.raises(ValueError) as excinfo:
-            assert m.ord_wchar("🎂") == 0x1F382  # requires surrogate pair
-        assert str(excinfo.value) == toobig_message(0x10000)
-    else:
-        assert m.ord_wchar("🎂") == 0x1F382
-    with pytest.raises(ValueError) as excinfo:
-        assert m.ord_wchar("aa")
-    assert str(excinfo.value) == toolong_message
-
-    if hasattr(m, "has_u8string"):
-        assert m.ord_char8("a") == 0x61  # simple ASCII
-        assert m.ord_char8_lv("b") == 0x62
-        assert (
-            m.ord_char8("é") == 0xE9
-        )  # requires 2 bytes in utf-8, but can be stuffed in a char
-        with pytest.raises(ValueError) as excinfo:
-            assert m.ord_char8("Ā") == 0x100  # requires 2 bytes, doesn't fit in a char
-        assert str(excinfo.value) == toobig_message(0x100)
-        with pytest.raises(ValueError) as excinfo:
-            assert m.ord_char8("ab")
-        assert str(excinfo.value) == toolong_message
-
-
-def test_bytes_to_string():
-    """Tests the ability to pass bytes to C++ string-accepting functions.  Note that this is
-    one-way: the only way to return bytes to Python is via the pybind11::bytes class."""
-    # Issue #816
-
-    assert m.strlen(b"hi") == 2
-    assert m.string_length(b"world") == 5
-    assert m.string_length("a\x00b".encode()) == 3
-    assert m.strlen("a\x00b".encode()) == 1  # C-string limitation
-
-    # passing in a utf8 encoded string should work
-    assert m.string_length("💩".encode()) == 4
-
-
-def test_bytearray_to_string():
-    """Tests the ability to pass bytearray to C++ string-accepting functions"""
-    assert m.string_length(bytearray(b"Hi")) == 2
-    assert m.strlen(bytearray(b"bytearray")) == 9
-    assert m.string_length(bytearray()) == 0
-    assert m.string_length(bytearray("🦜", "utf-8", "strict")) == 4
-    assert m.string_length(bytearray(b"\x80")) == 1
-
-
-@pytest.mark.skipif(not hasattr(m, "has_string_view"), reason="no <string_view>")
-def test_string_view(capture):
-    """Tests support for C++17 string_view arguments and return values"""
-    assert m.string_view_chars("Hi") == [72, 105]
-    assert m.string_view_chars("Hi 🎂") == [72, 105, 32, 0xF0, 0x9F, 0x8E, 0x82]
-    assert m.string_view16_chars("Hi 🎂") == [72, 105, 32, 0xD83C, 0xDF82]
-    assert m.string_view32_chars("Hi 🎂") == [72, 105, 32, 127874]
-    if hasattr(m, "has_u8string"):
-        assert m.string_view8_chars("Hi") == [72, 105]
-        assert m.string_view8_chars("Hi 🎂") == [72, 105, 32, 0xF0, 0x9F, 0x8E, 0x82]
-
-    assert m.string_view_return() == "utf8 secret 🎂"
-    assert m.string_view16_return() == "utf16 secret 🎂"
-    assert m.string_view32_return() == "utf32 secret 🎂"
-    if hasattr(m, "has_u8string"):
-        assert m.string_view8_return() == "utf8 secret 🎂"
-
-    with capture:
-        m.string_view_print("Hi")
-        m.string_view_print("utf8 🎂")
-        m.string_view16_print("utf16 🎂")
-        m.string_view32_print("utf32 🎂")
-    assert (
-        capture
-        == """
-        Hi 2
-        utf8 🎂 9
-        utf16 🎂 8
-        utf32 🎂 7
-    """
-    )
-    if hasattr(m, "has_u8string"):
-        with capture:
-            m.string_view8_print("Hi")
-            m.string_view8_print("utf8 🎂")
-        assert (
-            capture
-            == """
-            Hi 2
-            utf8 🎂 9
-        """
-        )
-
-    with capture:
-        m.string_view_print("Hi, ascii")
-        m.string_view_print("Hi, utf8 🎂")
-        m.string_view16_print("Hi, utf16 🎂")
-        m.string_view32_print("Hi, utf32 🎂")
-    assert (
-        capture
-        == """
-        Hi, ascii 9
-        Hi, utf8 🎂 13
-        Hi, utf16 🎂 12
-        Hi, utf32 🎂 11
-    """
-    )
-    if hasattr(m, "has_u8string"):
-        with capture:
-            m.string_view8_print("Hi, ascii")
-            m.string_view8_print("Hi, utf8 🎂")
-        assert (
-            capture
-            == """
-            Hi, ascii 9
-            Hi, utf8 🎂 13
-        """
-        )
-
-    assert m.string_view_bytes() == b"abc \x80\x80 def"
-    assert m.string_view_str() == "abc ‽ def"
-    assert m.string_view_from_bytes("abc ‽ def".encode()) == "abc ‽ def"
-    if hasattr(m, "has_u8string"):
-        assert m.string_view8_str() == "abc ‽ def"
-    assert m.string_view_memoryview() == "Have some 🎂".encode()
-
-    assert m.bytes_from_type_with_both_operator_string_and_string_view() == b"success"
-    assert m.str_from_type_with_both_operator_string_and_string_view() == "success"
-
-
-def test_integer_casting():
-    """Issue #929 - out-of-range integer values shouldn't be accepted"""
-    assert m.i32_str(-1) == "-1"
-    assert m.i64_str(-1) == "-1"
-    assert m.i32_str(2000000000) == "2000000000"
-    assert m.u32_str(2000000000) == "2000000000"
-    assert m.i64_str(-999999999999) == "-999999999999"
-    assert m.u64_str(999999999999) == "999999999999"
-
-    with pytest.raises(TypeError) as excinfo:
-        m.u32_str(-1)
-    assert "incompatible function arguments" in str(excinfo.value)
-    with pytest.raises(TypeError) as excinfo:
-        m.u64_str(-1)
-    assert "incompatible function arguments" in str(excinfo.value)
-    with pytest.raises(TypeError) as excinfo:
-        m.i32_str(-3000000000)
-    assert "incompatible function arguments" in str(excinfo.value)
-    with pytest.raises(TypeError) as excinfo:
-        m.i32_str(3000000000)
-    assert "incompatible function arguments" in str(excinfo.value)
-
-
-def test_int_convert():
-    class Int:
-        def __int__(self):
-            return 42
-
-    class NotInt:
-        pass
-
-    class Float:
-        def __float__(self):
-            return 41.99999
-
-    class Index:
-        def __index__(self):
-            return 42
-
-    class IntAndIndex:
-        def __int__(self):
-            return 42
-
-        def __index__(self):
-            return 0
-
-    class RaisingTypeErrorOnIndex:
-        def __index__(self):
-            raise TypeError
-
-        def __int__(self):
-            return 42
-
-    class RaisingValueErrorOnIndex:
-        def __index__(self):
-            raise ValueError
-
-        def __int__(self):
-            return 42
-
-    convert, noconvert = m.int_passthrough, m.int_passthrough_noconvert
-
-    def requires_conversion(v):
-        pytest.raises(TypeError, noconvert, v)
-
-    def cant_convert(v):
-        pytest.raises(TypeError, convert, v)
-
-    assert convert(7) == 7
-    assert noconvert(7) == 7
-    cant_convert(3.14159)
-    # TODO: Avoid DeprecationWarning in `PyLong_AsLong` (and similar)
-    # TODO: PyPy 3.8 does not behave like CPython 3.8 here yet (7.3.7)
-    if (3, 8) <= sys.version_info < (3, 10) and env.CPYTHON:
-        with env.deprecated_call():
-            assert convert(Int()) == 42
-    else:
-        assert convert(Int()) == 42
-    requires_conversion(Int())
-    cant_convert(NotInt())
-    cant_convert(Float())
-
-    # Before Python 3.8, `PyLong_AsLong` does not pick up on `obj.__index__`,
-    # but pybind11 "backports" this behavior.
-    assert convert(Index()) == 42
-    assert noconvert(Index()) == 42
-    assert convert(IntAndIndex()) == 0  # Fishy; `int(DoubleThought)` == 42
-    assert noconvert(IntAndIndex()) == 0
-    assert convert(RaisingTypeErrorOnIndex()) == 42
-    requires_conversion(RaisingTypeErrorOnIndex())
-    assert convert(RaisingValueErrorOnIndex()) == 42
-    requires_conversion(RaisingValueErrorOnIndex())
-
-
-def test_numpy_int_convert():
-    np = pytest.importorskip("numpy")
-
-    convert, noconvert = m.int_passthrough, m.int_passthrough_noconvert
-
-    def require_implicit(v):
-        pytest.raises(TypeError, noconvert, v)
-
-    # `np.intc` is an alias that corresponds to a C++ `int`
-    assert convert(np.intc(42)) == 42
-    assert noconvert(np.intc(42)) == 42
-
-    # The implicit conversion from np.float32 is undesirable but currently accepted.
-    # TODO: Avoid DeprecationWarning in `PyLong_AsLong` (and similar)
-    # TODO: PyPy 3.8 does not behave like CPython 3.8 here yet (7.3.7)
-    # https://github.com/pybind/pybind11/issues/3408
-    if (3, 8) <= sys.version_info < (3, 10) and env.CPYTHON:
-        with env.deprecated_call():
-            assert convert(np.float32(3.14159)) == 3
-    else:
-        assert convert(np.float32(3.14159)) == 3
-    require_implicit(np.float32(3.14159))
-
-
-def test_tuple(doc):
-    """std::pair <-> tuple & std::tuple <-> tuple"""
-    assert m.pair_passthrough((True, "test")) == ("test", True)
-    assert m.tuple_passthrough((True, "test", 5)) == (5, "test", True)
-    # Any sequence can be cast to a std::pair or std::tuple
-    assert m.pair_passthrough([True, "test"]) == ("test", True)
-    assert m.tuple_passthrough([True, "test", 5]) == (5, "test", True)
-    assert m.empty_tuple() == ()
-
-    assert (
-        doc(m.pair_passthrough)
-        == """
-        pair_passthrough(arg0: Tuple[bool, str]) -> Tuple[str, bool]
-
-        Return a pair in reversed order
-    """
-    )
-    assert (
-        doc(m.tuple_passthrough)
-        == """
-        tuple_passthrough(arg0: Tuple[bool, str, int]) -> Tuple[int, str, bool]
-
-        Return a triple in reversed order
-    """
-    )
-
-    assert m.rvalue_pair() == ("rvalue", "rvalue")
-    assert m.lvalue_pair() == ("lvalue", "lvalue")
-    assert m.rvalue_tuple() == ("rvalue", "rvalue", "rvalue")
-    assert m.lvalue_tuple() == ("lvalue", "lvalue", "lvalue")
-    assert m.rvalue_nested() == ("rvalue", ("rvalue", ("rvalue", "rvalue")))
-    assert m.lvalue_nested() == ("lvalue", ("lvalue", ("lvalue", "lvalue")))
-
-    assert m.int_string_pair() == (2, "items")
-
-
-def test_builtins_cast_return_none():
-    """Casters produced with PYBIND11_TYPE_CASTER() should convert nullptr to None"""
-    assert m.return_none_string() is None
-    assert m.return_none_char() is None
-    assert m.return_none_bool() is None
-    assert m.return_none_int() is None
-    assert m.return_none_float() is None
-    assert m.return_none_pair() is None
-
-
-def test_none_deferred():
-    """None passed as various argument types should defer to other overloads"""
-    assert not m.defer_none_cstring("abc")
-    assert m.defer_none_cstring(None)
-    assert not m.defer_none_custom(UserType())
-    assert m.defer_none_custom(None)
-    assert m.nodefer_none_void(None)
-
-
-def test_void_caster():
-    assert m.load_nullptr_t(None) is None
-    assert m.cast_nullptr_t() is None
-
-
-def test_reference_wrapper():
-    """std::reference_wrapper for builtin and user types"""
-    assert m.refwrap_builtin(42) == 420
-    assert m.refwrap_usertype(UserType(42)) == 42
-    assert m.refwrap_usertype_const(UserType(42)) == 42
-
-    with pytest.raises(TypeError) as excinfo:
-        m.refwrap_builtin(None)
-    assert "incompatible function arguments" in str(excinfo.value)
-
-    with pytest.raises(TypeError) as excinfo:
-        m.refwrap_usertype(None)
-    assert "incompatible function arguments" in str(excinfo.value)
-
-    assert m.refwrap_lvalue().value == 1
-    assert m.refwrap_lvalue_const().value == 1
-
-    a1 = m.refwrap_list(copy=True)
-    a2 = m.refwrap_list(copy=True)
-    assert [x.value for x in a1] == [2, 3]
-    assert [x.value for x in a2] == [2, 3]
-    assert not a1[0] is a2[0] and not a1[1] is a2[1]
-
-    b1 = m.refwrap_list(copy=False)
-    b2 = m.refwrap_list(copy=False)
-    assert [x.value for x in b1] == [1, 2]
-    assert [x.value for x in b2] == [1, 2]
-    assert b1[0] is b2[0] and b1[1] is b2[1]
-
-    assert m.refwrap_iiw(IncType(5)) == 5
-    assert m.refwrap_call_iiw(IncType(10), m.refwrap_iiw) == [10, 10, 10, 10]
-
-
-def test_complex_cast():
-    """std::complex casts"""
-    assert m.complex_cast(1) == "1.0"
-    assert m.complex_cast(2j) == "(0.0, 2.0)"
-
-
-def test_bool_caster():
-    """Test bool caster implicit conversions."""
-    convert, noconvert = m.bool_passthrough, m.bool_passthrough_noconvert
-
-    def require_implicit(v):
-        pytest.raises(TypeError, noconvert, v)
-
-    def cant_convert(v):
-        pytest.raises(TypeError, convert, v)
-
-    # straight up bool
-    assert convert(True) is True
-    assert convert(False) is False
-    assert noconvert(True) is True
-    assert noconvert(False) is False
-
-    # None requires implicit conversion
-    require_implicit(None)
-    assert convert(None) is False
-
-    class A:
-        def __init__(self, x):
-            self.x = x
-
-        def __nonzero__(self):
-            return self.x
-
-        def __bool__(self):
-            return self.x
-
-    class B:
-        pass
-
-    # Arbitrary objects are not accepted
-    cant_convert(object())
-    cant_convert(B())
-
-    # Objects with __nonzero__ / __bool__ defined can be converted
-    require_implicit(A(True))
-    assert convert(A(True)) is True
-    assert convert(A(False)) is False
-
-
-def test_numpy_bool():
-    np = pytest.importorskip("numpy")
-
-    convert, noconvert = m.bool_passthrough, m.bool_passthrough_noconvert
-
-    def cant_convert(v):
-        pytest.raises(TypeError, convert, v)
-
-    # np.bool_ is not considered implicit
-    assert convert(np.bool_(True)) is True
-    assert convert(np.bool_(False)) is False
-    assert noconvert(np.bool_(True)) is True
-    assert noconvert(np.bool_(False)) is False
-    cant_convert(np.zeros(2, dtype="int"))
-
-
-def test_int_long():
-    assert isinstance(m.int_cast(), int)
-    assert isinstance(m.long_cast(), int)
-    assert isinstance(m.longlong_cast(), int)
-
-
-def test_void_caster_2():
-    assert m.test_void_caster()
-
-
-def test_const_ref_caster():
-    """Verifies that const-ref is propagated through type_caster cast_op.
-    The returned ConstRefCasted type is a minimal type that is constructed to
-    reference the casting mode used.
-    """
-    x = False
-    assert m.takes(x) == 1
-    assert m.takes_move(x) == 1
-
-    assert m.takes_ptr(x) == 3
-    assert m.takes_ref(x) == 2
-    assert m.takes_ref_wrap(x) == 2
-
-    assert m.takes_const_ptr(x) == 5
-    assert m.takes_const_ref(x) == 4
-    assert m.takes_const_ref_wrap(x) == 4
+import sys
+
+import pytest
+
+import env
+from pybind11_tests import IncType, UserType
+from pybind11_tests import builtin_casters as m
+
+
+def test_simple_string():
+    assert m.string_roundtrip("const char *") == "const char *"
+
+
+def test_unicode_conversion():
+    """Tests unicode conversion and error reporting."""
+    assert m.good_utf8_string() == "Say utf8‽ 🎂 𝐀"
+    assert m.good_utf16_string() == "b‽🎂𝐀z"
+    assert m.good_utf32_string() == "a𝐀🎂‽z"
+    assert m.good_wchar_string() == "a⸘𝐀z"
+    if hasattr(m, "has_u8string"):
+        assert m.good_utf8_u8string() == "Say utf8‽ 🎂 𝐀"
+
+    with pytest.raises(UnicodeDecodeError):
+        m.bad_utf8_string()
+
+    with pytest.raises(UnicodeDecodeError):
+        m.bad_utf16_string()
+
+    # These are provided only if they actually fail (they don't when 32-bit)
+    if hasattr(m, "bad_utf32_string"):
+        with pytest.raises(UnicodeDecodeError):
+            m.bad_utf32_string()
+    if hasattr(m, "bad_wchar_string"):
+        with pytest.raises(UnicodeDecodeError):
+            m.bad_wchar_string()
+    if hasattr(m, "has_u8string"):
+        with pytest.raises(UnicodeDecodeError):
+            m.bad_utf8_u8string()
+
+    assert m.u8_Z() == "Z"
+    assert m.u8_eacute() == "é"
+    assert m.u16_ibang() == "‽"
+    assert m.u32_mathbfA() == "𝐀"
+    assert m.wchar_heart() == "♥"
+    if hasattr(m, "has_u8string"):
+        assert m.u8_char8_Z() == "Z"
+
+
+def test_single_char_arguments():
+    """Tests failures for passing invalid inputs to char-accepting functions"""
+
+    def toobig_message(r):
+        return f"Character code point not in range({r:#x})"
+
+    toolong_message = "Expected a character, but multi-character string found"
+
+    assert m.ord_char("a") == 0x61  # simple ASCII
+    assert m.ord_char_lv("b") == 0x62
+    assert (
+        m.ord_char("é") == 0xE9
+    )  # requires 2 bytes in utf-8, but can be stuffed in a char
+    with pytest.raises(ValueError) as excinfo:
+        assert m.ord_char("Ā") == 0x100  # requires 2 bytes, doesn't fit in a char
+    assert str(excinfo.value) == toobig_message(0x100)
+    with pytest.raises(ValueError) as excinfo:
+        assert m.ord_char("ab")
+    assert str(excinfo.value) == toolong_message
+
+    assert m.ord_char16("a") == 0x61
+    assert m.ord_char16("é") == 0xE9
+    assert m.ord_char16_lv("ê") == 0xEA
+    assert m.ord_char16("Ā") == 0x100
+    assert m.ord_char16("‽") == 0x203D
+    assert m.ord_char16("♥") == 0x2665
+    assert m.ord_char16_lv("♡") == 0x2661
+    with pytest.raises(ValueError) as excinfo:
+        assert m.ord_char16("🎂") == 0x1F382  # requires surrogate pair
+    assert str(excinfo.value) == toobig_message(0x10000)
+    with pytest.raises(ValueError) as excinfo:
+        assert m.ord_char16("aa")
+    assert str(excinfo.value) == toolong_message
+
+    assert m.ord_char32("a") == 0x61
+    assert m.ord_char32("é") == 0xE9
+    assert m.ord_char32("Ā") == 0x100
+    assert m.ord_char32("‽") == 0x203D
+    assert m.ord_char32("♥") == 0x2665
+    assert m.ord_char32("🎂") == 0x1F382
+    with pytest.raises(ValueError) as excinfo:
+        assert m.ord_char32("aa")
+    assert str(excinfo.value) == toolong_message
+
+    assert m.ord_wchar("a") == 0x61
+    assert m.ord_wchar("é") == 0xE9
+    assert m.ord_wchar("Ā") == 0x100
+    assert m.ord_wchar("‽") == 0x203D
+    assert m.ord_wchar("♥") == 0x2665
+    if m.wchar_size == 2:
+        with pytest.raises(ValueError) as excinfo:
+            assert m.ord_wchar("🎂") == 0x1F382  # requires surrogate pair
+        assert str(excinfo.value) == toobig_message(0x10000)
+    else:
+        assert m.ord_wchar("🎂") == 0x1F382
+    with pytest.raises(ValueError) as excinfo:
+        assert m.ord_wchar("aa")
+    assert str(excinfo.value) == toolong_message
+
+    if hasattr(m, "has_u8string"):
+        assert m.ord_char8("a") == 0x61  # simple ASCII
+        assert m.ord_char8_lv("b") == 0x62
+        assert (
+            m.ord_char8("é") == 0xE9
+        )  # requires 2 bytes in utf-8, but can be stuffed in a char
+        with pytest.raises(ValueError) as excinfo:
+            assert m.ord_char8("Ā") == 0x100  # requires 2 bytes, doesn't fit in a char
+        assert str(excinfo.value) == toobig_message(0x100)
+        with pytest.raises(ValueError) as excinfo:
+            assert m.ord_char8("ab")
+        assert str(excinfo.value) == toolong_message
+
+
+def test_bytes_to_string():
+    """Tests the ability to pass bytes to C++ string-accepting functions.  Note that this is
+    one-way: the only way to return bytes to Python is via the pybind11::bytes class."""
+    # Issue #816
+
+    assert m.strlen(b"hi") == 2
+    assert m.string_length(b"world") == 5
+    assert m.string_length("a\x00b".encode()) == 3
+    assert m.strlen("a\x00b".encode()) == 1  # C-string limitation
+
+    # passing in a utf8 encoded string should work
+    assert m.string_length("💩".encode()) == 4
+
+
+def test_bytearray_to_string():
+    """Tests the ability to pass bytearray to C++ string-accepting functions"""
+    assert m.string_length(bytearray(b"Hi")) == 2
+    assert m.strlen(bytearray(b"bytearray")) == 9
+    assert m.string_length(bytearray()) == 0
+    assert m.string_length(bytearray("🦜", "utf-8", "strict")) == 4
+    assert m.string_length(bytearray(b"\x80")) == 1
+
+
+@pytest.mark.skipif(not hasattr(m, "has_string_view"), reason="no <string_view>")
+def test_string_view(capture):
+    """Tests support for C++17 string_view arguments and return values"""
+    assert m.string_view_chars("Hi") == [72, 105]
+    assert m.string_view_chars("Hi 🎂") == [72, 105, 32, 0xF0, 0x9F, 0x8E, 0x82]
+    assert m.string_view16_chars("Hi 🎂") == [72, 105, 32, 0xD83C, 0xDF82]
+    assert m.string_view32_chars("Hi 🎂") == [72, 105, 32, 127874]
+    if hasattr(m, "has_u8string"):
+        assert m.string_view8_chars("Hi") == [72, 105]
+        assert m.string_view8_chars("Hi 🎂") == [72, 105, 32, 0xF0, 0x9F, 0x8E, 0x82]
+
+    assert m.string_view_return() == "utf8 secret 🎂"
+    assert m.string_view16_return() == "utf16 secret 🎂"
+    assert m.string_view32_return() == "utf32 secret 🎂"
+    if hasattr(m, "has_u8string"):
+        assert m.string_view8_return() == "utf8 secret 🎂"
+
+    with capture:
+        m.string_view_print("Hi")
+        m.string_view_print("utf8 🎂")
+        m.string_view16_print("utf16 🎂")
+        m.string_view32_print("utf32 🎂")
+    assert (
+        capture
+        == """
+        Hi 2
+        utf8 🎂 9
+        utf16 🎂 8
+        utf32 🎂 7
+    """
+    )
+    if hasattr(m, "has_u8string"):
+        with capture:
+            m.string_view8_print("Hi")
+            m.string_view8_print("utf8 🎂")
+        assert (
+            capture
+            == """
+            Hi 2
+            utf8 🎂 9
+        """
+        )
+
+    with capture:
+        m.string_view_print("Hi, ascii")
+        m.string_view_print("Hi, utf8 🎂")
+        m.string_view16_print("Hi, utf16 🎂")
+        m.string_view32_print("Hi, utf32 🎂")
+    assert (
+        capture
+        == """
+        Hi, ascii 9
+        Hi, utf8 🎂 13
+        Hi, utf16 🎂 12
+        Hi, utf32 🎂 11
+    """
+    )
+    if hasattr(m, "has_u8string"):
+        with capture:
+            m.string_view8_print("Hi, ascii")
+            m.string_view8_print("Hi, utf8 🎂")
+        assert (
+            capture
+            == """
+            Hi, ascii 9
+            Hi, utf8 🎂 13
+        """
+        )
+
+    assert m.string_view_bytes() == b"abc \x80\x80 def"
+    assert m.string_view_str() == "abc ‽ def"
+    assert m.string_view_from_bytes("abc ‽ def".encode()) == "abc ‽ def"
+    if hasattr(m, "has_u8string"):
+        assert m.string_view8_str() == "abc ‽ def"
+    assert m.string_view_memoryview() == "Have some 🎂".encode()
+
+    assert m.bytes_from_type_with_both_operator_string_and_string_view() == b"success"
+    assert m.str_from_type_with_both_operator_string_and_string_view() == "success"
+
+
+def test_integer_casting():
+    """Issue #929 - out-of-range integer values shouldn't be accepted"""
+    assert m.i32_str(-1) == "-1"
+    assert m.i64_str(-1) == "-1"
+    assert m.i32_str(2000000000) == "2000000000"
+    assert m.u32_str(2000000000) == "2000000000"
+    assert m.i64_str(-999999999999) == "-999999999999"
+    assert m.u64_str(999999999999) == "999999999999"
+
+    with pytest.raises(TypeError) as excinfo:
+        m.u32_str(-1)
+    assert "incompatible function arguments" in str(excinfo.value)
+    with pytest.raises(TypeError) as excinfo:
+        m.u64_str(-1)
+    assert "incompatible function arguments" in str(excinfo.value)
+    with pytest.raises(TypeError) as excinfo:
+        m.i32_str(-3000000000)
+    assert "incompatible function arguments" in str(excinfo.value)
+    with pytest.raises(TypeError) as excinfo:
+        m.i32_str(3000000000)
+    assert "incompatible function arguments" in str(excinfo.value)
+
+
+def test_int_convert():
+    class Int:
+        def __int__(self):
+            return 42
+
+    class NotInt:
+        pass
+
+    class Float:
+        def __float__(self):
+            return 41.99999
+
+    class Index:
+        def __index__(self):
+            return 42
+
+    class IntAndIndex:
+        def __int__(self):
+            return 42
+
+        def __index__(self):
+            return 0
+
+    class RaisingTypeErrorOnIndex:
+        def __index__(self):
+            raise TypeError
+
+        def __int__(self):
+            return 42
+
+    class RaisingValueErrorOnIndex:
+        def __index__(self):
+            raise ValueError
+
+        def __int__(self):
+            return 42
+
+    convert, noconvert = m.int_passthrough, m.int_passthrough_noconvert
+
+    def requires_conversion(v):
+        pytest.raises(TypeError, noconvert, v)
+
+    def cant_convert(v):
+        pytest.raises(TypeError, convert, v)
+
+    assert convert(7) == 7
+    assert noconvert(7) == 7
+    cant_convert(3.14159)
+    # TODO: Avoid DeprecationWarning in `PyLong_AsLong` (and similar)
+    # TODO: PyPy 3.8 does not behave like CPython 3.8 here yet (7.3.7)
+    if (3, 8) <= sys.version_info < (3, 10) and env.CPYTHON:
+        with env.deprecated_call():
+            assert convert(Int()) == 42
+    else:
+        assert convert(Int()) == 42
+    requires_conversion(Int())
+    cant_convert(NotInt())
+    cant_convert(Float())
+
+    # Before Python 3.8, `PyLong_AsLong` does not pick up on `obj.__index__`,
+    # but pybind11 "backports" this behavior.
+    assert convert(Index()) == 42
+    assert noconvert(Index()) == 42
+    assert convert(IntAndIndex()) == 0  # Fishy; `int(DoubleThought)` == 42
+    assert noconvert(IntAndIndex()) == 0
+    assert convert(RaisingTypeErrorOnIndex()) == 42
+    requires_conversion(RaisingTypeErrorOnIndex())
+    assert convert(RaisingValueErrorOnIndex()) == 42
+    requires_conversion(RaisingValueErrorOnIndex())
+
+
+def test_numpy_int_convert():
+    np = pytest.importorskip("numpy")
+
+    convert, noconvert = m.int_passthrough, m.int_passthrough_noconvert
+
+    def require_implicit(v):
+        pytest.raises(TypeError, noconvert, v)
+
+    # `np.intc` is an alias that corresponds to a C++ `int`
+    assert convert(np.intc(42)) == 42
+    assert noconvert(np.intc(42)) == 42
+
+    # The implicit conversion from np.float32 is undesirable but currently accepted.
+    # TODO: Avoid DeprecationWarning in `PyLong_AsLong` (and similar)
+    # TODO: PyPy 3.8 does not behave like CPython 3.8 here yet (7.3.7)
+    # https://github.com/pybind/pybind11/issues/3408
+    if (3, 8) <= sys.version_info < (3, 10) and env.CPYTHON:
+        with env.deprecated_call():
+            assert convert(np.float32(3.14159)) == 3
+    else:
+        assert convert(np.float32(3.14159)) == 3
+    require_implicit(np.float32(3.14159))
+
+
+def test_tuple(doc):
+    """std::pair <-> tuple & std::tuple <-> tuple"""
+    assert m.pair_passthrough((True, "test")) == ("test", True)
+    assert m.tuple_passthrough((True, "test", 5)) == (5, "test", True)
+    # Any sequence can be cast to a std::pair or std::tuple
+    assert m.pair_passthrough([True, "test"]) == ("test", True)
+    assert m.tuple_passthrough([True, "test", 5]) == (5, "test", True)
+    assert m.empty_tuple() == ()
+
+    assert (
+        doc(m.pair_passthrough)
+        == """
+        pair_passthrough(arg0: Tuple[bool, str]) -> Tuple[str, bool]
+
+        Return a pair in reversed order
+    """
+    )
+    assert (
+        doc(m.tuple_passthrough)
+        == """
+        tuple_passthrough(arg0: Tuple[bool, str, int]) -> Tuple[int, str, bool]
+
+        Return a triple in reversed order
+    """
+    )
+
+    assert m.rvalue_pair() == ("rvalue", "rvalue")
+    assert m.lvalue_pair() == ("lvalue", "lvalue")
+    assert m.rvalue_tuple() == ("rvalue", "rvalue", "rvalue")
+    assert m.lvalue_tuple() == ("lvalue", "lvalue", "lvalue")
+    assert m.rvalue_nested() == ("rvalue", ("rvalue", ("rvalue", "rvalue")))
+    assert m.lvalue_nested() == ("lvalue", ("lvalue", ("lvalue", "lvalue")))
+
+    assert m.int_string_pair() == (2, "items")
+
+
+def test_builtins_cast_return_none():
+    """Casters produced with PYBIND11_TYPE_CASTER() should convert nullptr to None"""
+    assert m.return_none_string() is None
+    assert m.return_none_char() is None
+    assert m.return_none_bool() is None
+    assert m.return_none_int() is None
+    assert m.return_none_float() is None
+    assert m.return_none_pair() is None
+
+
+def test_none_deferred():
+    """None passed as various argument types should defer to other overloads"""
+    assert not m.defer_none_cstring("abc")
+    assert m.defer_none_cstring(None)
+    assert not m.defer_none_custom(UserType())
+    assert m.defer_none_custom(None)
+    assert m.nodefer_none_void(None)
+
+
+def test_void_caster():
+    assert m.load_nullptr_t(None) is None
+    assert m.cast_nullptr_t() is None
+
+
+def test_reference_wrapper():
+    """std::reference_wrapper for builtin and user types"""
+    assert m.refwrap_builtin(42) == 420
+    assert m.refwrap_usertype(UserType(42)) == 42
+    assert m.refwrap_usertype_const(UserType(42)) == 42
+
+    with pytest.raises(TypeError) as excinfo:
+        m.refwrap_builtin(None)
+    assert "incompatible function arguments" in str(excinfo.value)
+
+    with pytest.raises(TypeError) as excinfo:
+        m.refwrap_usertype(None)
+    assert "incompatible function arguments" in str(excinfo.value)
+
+    assert m.refwrap_lvalue().value == 1
+    assert m.refwrap_lvalue_const().value == 1
+
+    a1 = m.refwrap_list(copy=True)
+    a2 = m.refwrap_list(copy=True)
+    assert [x.value for x in a1] == [2, 3]
+    assert [x.value for x in a2] == [2, 3]
+    assert not a1[0] is a2[0] and not a1[1] is a2[1]
+
+    b1 = m.refwrap_list(copy=False)
+    b2 = m.refwrap_list(copy=False)
+    assert [x.value for x in b1] == [1, 2]
+    assert [x.value for x in b2] == [1, 2]
+    assert b1[0] is b2[0] and b1[1] is b2[1]
+
+    assert m.refwrap_iiw(IncType(5)) == 5
+    assert m.refwrap_call_iiw(IncType(10), m.refwrap_iiw) == [10, 10, 10, 10]
+
+
+def test_complex_cast():
+    """std::complex casts"""
+    assert m.complex_cast(1) == "1.0"
+    assert m.complex_cast(2j) == "(0.0, 2.0)"
+
+
+def test_bool_caster():
+    """Test bool caster implicit conversions."""
+    convert, noconvert = m.bool_passthrough, m.bool_passthrough_noconvert
+
+    def require_implicit(v):
+        pytest.raises(TypeError, noconvert, v)
+
+    def cant_convert(v):
+        pytest.raises(TypeError, convert, v)
+
+    # straight up bool
+    assert convert(True) is True
+    assert convert(False) is False
+    assert noconvert(True) is True
+    assert noconvert(False) is False
+
+    # None requires implicit conversion
+    require_implicit(None)
+    assert convert(None) is False
+
+    class A:
+        def __init__(self, x):
+            self.x = x
+
+        def __nonzero__(self):
+            return self.x
+
+        def __bool__(self):
+            return self.x
+
+    class B:
+        pass
+
+    # Arbitrary objects are not accepted
+    cant_convert(object())
+    cant_convert(B())
+
+    # Objects with __nonzero__ / __bool__ defined can be converted
+    require_implicit(A(True))
+    assert convert(A(True)) is True
+    assert convert(A(False)) is False
+
+
+def test_numpy_bool():
+    np = pytest.importorskip("numpy")
+
+    convert, noconvert = m.bool_passthrough, m.bool_passthrough_noconvert
+
+    def cant_convert(v):
+        pytest.raises(TypeError, convert, v)
+
+    # np.bool_ is not considered implicit
+    assert convert(np.bool_(True)) is True
+    assert convert(np.bool_(False)) is False
+    assert noconvert(np.bool_(True)) is True
+    assert noconvert(np.bool_(False)) is False
+    cant_convert(np.zeros(2, dtype="int"))
+
+
+def test_int_long():
+    assert isinstance(m.int_cast(), int)
+    assert isinstance(m.long_cast(), int)
+    assert isinstance(m.longlong_cast(), int)
+
+
+def test_void_caster_2():
+    assert m.test_void_caster()
+
+
+def test_const_ref_caster():
+    """Verifies that const-ref is propagated through type_caster cast_op.
+    The returned ConstRefCasted type is a minimal type that is constructed to
+    reference the casting mode used.
+    """
+    x = False
+    assert m.takes(x) == 1
+    assert m.takes_move(x) == 1
+
+    assert m.takes_ptr(x) == 3
+    assert m.takes_ref(x) == 2
+    assert m.takes_ref_wrap(x) == 2
+
+    assert m.takes_const_ptr(x) == 5
+    assert m.takes_const_ref(x) == 4
+    assert m.takes_const_ref_wrap(x) == 4
```

## extern/pybind11/tests/test_call_policies.py

 * *Ordering differences only*

```diff
@@ -1,247 +1,247 @@
-import pytest
-
-import env  # noqa: F401
-from pybind11_tests import ConstructorStats
-from pybind11_tests import call_policies as m
-
-
-@pytest.mark.xfail("env.PYPY", reason="sometimes comes out 1 off on PyPy", strict=False)
-def test_keep_alive_argument(capture):
-    n_inst = ConstructorStats.detail_reg_inst()
-    with capture:
-        p = m.Parent()
-    assert capture == "Allocating parent."
-    with capture:
-        p.addChild(m.Child())
-        assert ConstructorStats.detail_reg_inst() == n_inst + 1
-    assert (
-        capture
-        == """
-        Allocating child.
-        Releasing child.
-    """
-    )
-    with capture:
-        del p
-        assert ConstructorStats.detail_reg_inst() == n_inst
-    assert capture == "Releasing parent."
-
-    with capture:
-        p = m.Parent()
-    assert capture == "Allocating parent."
-    with capture:
-        p.addChildKeepAlive(m.Child())
-        assert ConstructorStats.detail_reg_inst() == n_inst + 2
-    assert capture == "Allocating child."
-    with capture:
-        del p
-        assert ConstructorStats.detail_reg_inst() == n_inst
-    assert (
-        capture
-        == """
-        Releasing parent.
-        Releasing child.
-    """
-    )
-
-    p = m.Parent()
-    c = m.Child()
-    assert ConstructorStats.detail_reg_inst() == n_inst + 2
-    m.free_function(p, c)
-    del c
-    assert ConstructorStats.detail_reg_inst() == n_inst + 2
-    del p
-    assert ConstructorStats.detail_reg_inst() == n_inst
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.invalid_arg_index()
-    assert str(excinfo.value) == "Could not activate keep_alive!"
-
-
-def test_keep_alive_return_value(capture):
-    n_inst = ConstructorStats.detail_reg_inst()
-    with capture:
-        p = m.Parent()
-    assert capture == "Allocating parent."
-    with capture:
-        p.returnChild()
-        assert ConstructorStats.detail_reg_inst() == n_inst + 1
-    assert (
-        capture
-        == """
-        Allocating child.
-        Releasing child.
-    """
-    )
-    with capture:
-        del p
-        assert ConstructorStats.detail_reg_inst() == n_inst
-    assert capture == "Releasing parent."
-
-    with capture:
-        p = m.Parent()
-    assert capture == "Allocating parent."
-    with capture:
-        p.returnChildKeepAlive()
-        assert ConstructorStats.detail_reg_inst() == n_inst + 2
-    assert capture == "Allocating child."
-    with capture:
-        del p
-        assert ConstructorStats.detail_reg_inst() == n_inst
-    assert (
-        capture
-        == """
-        Releasing parent.
-        Releasing child.
-    """
-    )
-
-    p = m.Parent()
-    assert ConstructorStats.detail_reg_inst() == n_inst + 1
-    with capture:
-        m.Parent.staticFunction(p)
-        assert ConstructorStats.detail_reg_inst() == n_inst + 2
-    assert capture == "Allocating child."
-    with capture:
-        del p
-        assert ConstructorStats.detail_reg_inst() == n_inst
-    assert (
-        capture
-        == """
-        Releasing parent.
-        Releasing child.
-    """
-    )
-
-
-# https://foss.heptapod.net/pypy/pypy/-/issues/2447
-@pytest.mark.xfail("env.PYPY", reason="_PyObject_GetDictPtr is unimplemented")
-def test_alive_gc(capture):
-    n_inst = ConstructorStats.detail_reg_inst()
-    p = m.ParentGC()
-    p.addChildKeepAlive(m.Child())
-    assert ConstructorStats.detail_reg_inst() == n_inst + 2
-    lst = [p]
-    lst.append(lst)  # creates a circular reference
-    with capture:
-        del p, lst
-        assert ConstructorStats.detail_reg_inst() == n_inst
-    assert (
-        capture
-        == """
-        Releasing parent.
-        Releasing child.
-    """
-    )
-
-
-def test_alive_gc_derived(capture):
-    class Derived(m.Parent):
-        pass
-
-    n_inst = ConstructorStats.detail_reg_inst()
-    p = Derived()
-    p.addChildKeepAlive(m.Child())
-    assert ConstructorStats.detail_reg_inst() == n_inst + 2
-    lst = [p]
-    lst.append(lst)  # creates a circular reference
-    with capture:
-        del p, lst
-        assert ConstructorStats.detail_reg_inst() == n_inst
-    assert (
-        capture
-        == """
-        Releasing parent.
-        Releasing child.
-    """
-    )
-
-
-def test_alive_gc_multi_derived(capture):
-    class Derived(m.Parent, m.Child):
-        def __init__(self):
-            m.Parent.__init__(self)
-            m.Child.__init__(self)
-
-    n_inst = ConstructorStats.detail_reg_inst()
-    p = Derived()
-    p.addChildKeepAlive(m.Child())
-    # +3 rather than +2 because Derived corresponds to two registered instances
-    assert ConstructorStats.detail_reg_inst() == n_inst + 3
-    lst = [p]
-    lst.append(lst)  # creates a circular reference
-    with capture:
-        del p, lst
-        assert ConstructorStats.detail_reg_inst() == n_inst
-    assert (
-        capture
-        == """
-        Releasing parent.
-        Releasing child.
-        Releasing child.
-    """
-    )
-
-
-def test_return_none(capture):
-    n_inst = ConstructorStats.detail_reg_inst()
-    with capture:
-        p = m.Parent()
-    assert capture == "Allocating parent."
-    with capture:
-        p.returnNullChildKeepAliveChild()
-        assert ConstructorStats.detail_reg_inst() == n_inst + 1
-    assert capture == ""
-    with capture:
-        del p
-        assert ConstructorStats.detail_reg_inst() == n_inst
-    assert capture == "Releasing parent."
-
-    with capture:
-        p = m.Parent()
-    assert capture == "Allocating parent."
-    with capture:
-        p.returnNullChildKeepAliveParent()
-        assert ConstructorStats.detail_reg_inst() == n_inst + 1
-    assert capture == ""
-    with capture:
-        del p
-        assert ConstructorStats.detail_reg_inst() == n_inst
-    assert capture == "Releasing parent."
-
-
-def test_keep_alive_constructor(capture):
-    n_inst = ConstructorStats.detail_reg_inst()
-
-    with capture:
-        p = m.Parent(m.Child())
-        assert ConstructorStats.detail_reg_inst() == n_inst + 2
-    assert (
-        capture
-        == """
-        Allocating child.
-        Allocating parent.
-    """
-    )
-    with capture:
-        del p
-        assert ConstructorStats.detail_reg_inst() == n_inst
-    assert (
-        capture
-        == """
-        Releasing parent.
-        Releasing child.
-    """
-    )
-
-
-def test_call_guard():
-    assert m.unguarded_call() == "unguarded"
-    assert m.guarded_call() == "guarded"
-
-    assert m.multiple_guards_correct_order() == "guarded & guarded"
-    assert m.multiple_guards_wrong_order() == "unguarded & guarded"
-
-    if hasattr(m, "with_gil"):
-        assert m.with_gil() == "GIL held"
-        assert m.without_gil() == "GIL released"
+import pytest
+
+import env  # noqa: F401
+from pybind11_tests import ConstructorStats
+from pybind11_tests import call_policies as m
+
+
+@pytest.mark.xfail("env.PYPY", reason="sometimes comes out 1 off on PyPy", strict=False)
+def test_keep_alive_argument(capture):
+    n_inst = ConstructorStats.detail_reg_inst()
+    with capture:
+        p = m.Parent()
+    assert capture == "Allocating parent."
+    with capture:
+        p.addChild(m.Child())
+        assert ConstructorStats.detail_reg_inst() == n_inst + 1
+    assert (
+        capture
+        == """
+        Allocating child.
+        Releasing child.
+    """
+    )
+    with capture:
+        del p
+        assert ConstructorStats.detail_reg_inst() == n_inst
+    assert capture == "Releasing parent."
+
+    with capture:
+        p = m.Parent()
+    assert capture == "Allocating parent."
+    with capture:
+        p.addChildKeepAlive(m.Child())
+        assert ConstructorStats.detail_reg_inst() == n_inst + 2
+    assert capture == "Allocating child."
+    with capture:
+        del p
+        assert ConstructorStats.detail_reg_inst() == n_inst
+    assert (
+        capture
+        == """
+        Releasing parent.
+        Releasing child.
+    """
+    )
+
+    p = m.Parent()
+    c = m.Child()
+    assert ConstructorStats.detail_reg_inst() == n_inst + 2
+    m.free_function(p, c)
+    del c
+    assert ConstructorStats.detail_reg_inst() == n_inst + 2
+    del p
+    assert ConstructorStats.detail_reg_inst() == n_inst
+
+    with pytest.raises(RuntimeError) as excinfo:
+        m.invalid_arg_index()
+    assert str(excinfo.value) == "Could not activate keep_alive!"
+
+
+def test_keep_alive_return_value(capture):
+    n_inst = ConstructorStats.detail_reg_inst()
+    with capture:
+        p = m.Parent()
+    assert capture == "Allocating parent."
+    with capture:
+        p.returnChild()
+        assert ConstructorStats.detail_reg_inst() == n_inst + 1
+    assert (
+        capture
+        == """
+        Allocating child.
+        Releasing child.
+    """
+    )
+    with capture:
+        del p
+        assert ConstructorStats.detail_reg_inst() == n_inst
+    assert capture == "Releasing parent."
+
+    with capture:
+        p = m.Parent()
+    assert capture == "Allocating parent."
+    with capture:
+        p.returnChildKeepAlive()
+        assert ConstructorStats.detail_reg_inst() == n_inst + 2
+    assert capture == "Allocating child."
+    with capture:
+        del p
+        assert ConstructorStats.detail_reg_inst() == n_inst
+    assert (
+        capture
+        == """
+        Releasing parent.
+        Releasing child.
+    """
+    )
+
+    p = m.Parent()
+    assert ConstructorStats.detail_reg_inst() == n_inst + 1
+    with capture:
+        m.Parent.staticFunction(p)
+        assert ConstructorStats.detail_reg_inst() == n_inst + 2
+    assert capture == "Allocating child."
+    with capture:
+        del p
+        assert ConstructorStats.detail_reg_inst() == n_inst
+    assert (
+        capture
+        == """
+        Releasing parent.
+        Releasing child.
+    """
+    )
+
+
+# https://foss.heptapod.net/pypy/pypy/-/issues/2447
+@pytest.mark.xfail("env.PYPY", reason="_PyObject_GetDictPtr is unimplemented")
+def test_alive_gc(capture):
+    n_inst = ConstructorStats.detail_reg_inst()
+    p = m.ParentGC()
+    p.addChildKeepAlive(m.Child())
+    assert ConstructorStats.detail_reg_inst() == n_inst + 2
+    lst = [p]
+    lst.append(lst)  # creates a circular reference
+    with capture:
+        del p, lst
+        assert ConstructorStats.detail_reg_inst() == n_inst
+    assert (
+        capture
+        == """
+        Releasing parent.
+        Releasing child.
+    """
+    )
+
+
+def test_alive_gc_derived(capture):
+    class Derived(m.Parent):
+        pass
+
+    n_inst = ConstructorStats.detail_reg_inst()
+    p = Derived()
+    p.addChildKeepAlive(m.Child())
+    assert ConstructorStats.detail_reg_inst() == n_inst + 2
+    lst = [p]
+    lst.append(lst)  # creates a circular reference
+    with capture:
+        del p, lst
+        assert ConstructorStats.detail_reg_inst() == n_inst
+    assert (
+        capture
+        == """
+        Releasing parent.
+        Releasing child.
+    """
+    )
+
+
+def test_alive_gc_multi_derived(capture):
+    class Derived(m.Parent, m.Child):
+        def __init__(self):
+            m.Parent.__init__(self)
+            m.Child.__init__(self)
+
+    n_inst = ConstructorStats.detail_reg_inst()
+    p = Derived()
+    p.addChildKeepAlive(m.Child())
+    # +3 rather than +2 because Derived corresponds to two registered instances
+    assert ConstructorStats.detail_reg_inst() == n_inst + 3
+    lst = [p]
+    lst.append(lst)  # creates a circular reference
+    with capture:
+        del p, lst
+        assert ConstructorStats.detail_reg_inst() == n_inst
+    assert (
+        capture
+        == """
+        Releasing parent.
+        Releasing child.
+        Releasing child.
+    """
+    )
+
+
+def test_return_none(capture):
+    n_inst = ConstructorStats.detail_reg_inst()
+    with capture:
+        p = m.Parent()
+    assert capture == "Allocating parent."
+    with capture:
+        p.returnNullChildKeepAliveChild()
+        assert ConstructorStats.detail_reg_inst() == n_inst + 1
+    assert capture == ""
+    with capture:
+        del p
+        assert ConstructorStats.detail_reg_inst() == n_inst
+    assert capture == "Releasing parent."
+
+    with capture:
+        p = m.Parent()
+    assert capture == "Allocating parent."
+    with capture:
+        p.returnNullChildKeepAliveParent()
+        assert ConstructorStats.detail_reg_inst() == n_inst + 1
+    assert capture == ""
+    with capture:
+        del p
+        assert ConstructorStats.detail_reg_inst() == n_inst
+    assert capture == "Releasing parent."
+
+
+def test_keep_alive_constructor(capture):
+    n_inst = ConstructorStats.detail_reg_inst()
+
+    with capture:
+        p = m.Parent(m.Child())
+        assert ConstructorStats.detail_reg_inst() == n_inst + 2
+    assert (
+        capture
+        == """
+        Allocating child.
+        Allocating parent.
+    """
+    )
+    with capture:
+        del p
+        assert ConstructorStats.detail_reg_inst() == n_inst
+    assert (
+        capture
+        == """
+        Releasing parent.
+        Releasing child.
+    """
+    )
+
+
+def test_call_guard():
+    assert m.unguarded_call() == "unguarded"
+    assert m.guarded_call() == "guarded"
+
+    assert m.multiple_guards_correct_order() == "guarded & guarded"
+    assert m.multiple_guards_wrong_order() == "unguarded & guarded"
+
+    if hasattr(m, "with_gil"):
+        assert m.with_gil() == "GIL held"
+        assert m.without_gil() == "GIL released"
```

## extern/pybind11/tests/test_callbacks.py

 * *Ordering differences only*

```diff
@@ -1,208 +1,208 @@
-import time
-from threading import Thread
-
-import pytest
-
-import env  # noqa: F401
-from pybind11_tests import callbacks as m
-
-
-def test_callbacks():
-    from functools import partial
-
-    def func1():
-        return "func1"
-
-    def func2(a, b, c, d):
-        return "func2", a, b, c, d
-
-    def func3(a):
-        return f"func3({a})"
-
-    assert m.test_callback1(func1) == "func1"
-    assert m.test_callback2(func2) == ("func2", "Hello", "x", True, 5)
-    assert m.test_callback1(partial(func2, 1, 2, 3, 4)) == ("func2", 1, 2, 3, 4)
-    assert m.test_callback1(partial(func3, "partial")) == "func3(partial)"
-    assert m.test_callback3(lambda i: i + 1) == "func(43) = 44"
-
-    f = m.test_callback4()
-    assert f(43) == 44
-    f = m.test_callback5()
-    assert f(number=43) == 44
-
-
-def test_bound_method_callback():
-    # Bound Python method:
-    class MyClass:
-        def double(self, val):
-            return 2 * val
-
-    z = MyClass()
-    assert m.test_callback3(z.double) == "func(43) = 86"
-
-    z = m.CppBoundMethodTest()
-    assert m.test_callback3(z.triple) == "func(43) = 129"
-
-
-def test_keyword_args_and_generalized_unpacking():
-    def f(*args, **kwargs):
-        return args, kwargs
-
-    assert m.test_tuple_unpacking(f) == (("positional", 1, 2, 3, 4, 5, 6), {})
-    assert m.test_dict_unpacking(f) == (
-        ("positional", 1),
-        {"key": "value", "a": 1, "b": 2},
-    )
-    assert m.test_keyword_args(f) == ((), {"x": 10, "y": 20})
-    assert m.test_unpacking_and_keywords1(f) == ((1, 2), {"c": 3, "d": 4})
-    assert m.test_unpacking_and_keywords2(f) == (
-        ("positional", 1, 2, 3, 4, 5),
-        {"key": "value", "a": 1, "b": 2, "c": 3, "d": 4, "e": 5},
-    )
-
-    with pytest.raises(TypeError) as excinfo:
-        m.test_unpacking_error1(f)
-    assert "Got multiple values for keyword argument" in str(excinfo.value)
-
-    with pytest.raises(TypeError) as excinfo:
-        m.test_unpacking_error2(f)
-    assert "Got multiple values for keyword argument" in str(excinfo.value)
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.test_arg_conversion_error1(f)
-    assert "Unable to convert call argument" in str(excinfo.value)
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.test_arg_conversion_error2(f)
-    assert "Unable to convert call argument" in str(excinfo.value)
-
-
-def test_lambda_closure_cleanup():
-    m.test_lambda_closure_cleanup()
-    cstats = m.payload_cstats()
-    assert cstats.alive() == 0
-    assert cstats.copy_constructions == 1
-    assert cstats.move_constructions >= 1
-
-
-def test_cpp_callable_cleanup():
-    alive_counts = m.test_cpp_callable_cleanup()
-    assert alive_counts == [0, 1, 2, 1, 2, 1, 0]
-
-
-def test_cpp_function_roundtrip():
-    """Test if passing a function pointer from C++ -> Python -> C++ yields the original pointer"""
-
-    assert (
-        m.test_dummy_function(m.dummy_function) == "matches dummy_function: eval(1) = 2"
-    )
-    assert (
-        m.test_dummy_function(m.roundtrip(m.dummy_function))
-        == "matches dummy_function: eval(1) = 2"
-    )
-    assert (
-        m.test_dummy_function(m.dummy_function_overloaded)
-        == "matches dummy_function: eval(1) = 2"
-    )
-    assert m.roundtrip(None, expect_none=True) is None
-    assert (
-        m.test_dummy_function(lambda x: x + 2)
-        == "can't convert to function pointer: eval(1) = 3"
-    )
-
-    with pytest.raises(TypeError) as excinfo:
-        m.test_dummy_function(m.dummy_function2)
-    assert "incompatible function arguments" in str(excinfo.value)
-
-    with pytest.raises(TypeError) as excinfo:
-        m.test_dummy_function(lambda x, y: x + y)
-    assert any(
-        s in str(excinfo.value)
-        for s in ("missing 1 required positional argument", "takes exactly 2 arguments")
-    )
-
-
-def test_function_signatures(doc):
-    assert doc(m.test_callback3) == "test_callback3(arg0: Callable[[int], int]) -> str"
-    assert doc(m.test_callback4) == "test_callback4() -> Callable[[int], int]"
-
-
-def test_movable_object():
-    assert m.callback_with_movable(lambda _: None) is True
-
-
-@pytest.mark.skipif(
-    "env.PYPY",
-    reason="PyPy segfaults on here. See discussion on #1413.",
-)
-def test_python_builtins():
-    """Test if python builtins like sum() can be used as callbacks"""
-    assert m.test_sum_builtin(sum, [1, 2, 3]) == 6
-    assert m.test_sum_builtin(sum, []) == 0
-
-
-def test_async_callbacks():
-    # serves as state for async callback
-    class Item:
-        def __init__(self, value):
-            self.value = value
-
-    res = []
-
-    # generate stateful lambda that will store result in `res`
-    def gen_f():
-        s = Item(3)
-        return lambda j: res.append(s.value + j)
-
-    # do some work async
-    work = [1, 2, 3, 4]
-    m.test_async_callback(gen_f(), work)
-    # wait until work is done
-    from time import sleep
-
-    sleep(0.5)
-    assert sum(res) == sum(x + 3 for x in work)
-
-
-def test_async_async_callbacks():
-    t = Thread(target=test_async_callbacks)
-    t.start()
-    t.join()
-
-
-def test_callback_num_times():
-    # Super-simple micro-benchmarking related to PR #2919.
-    # Example runtimes (Intel Xeon 2.2GHz, fully optimized):
-    #   num_millions  1, repeats  2:  0.1 secs
-    #   num_millions 20, repeats 10: 11.5 secs
-    one_million = 1000000
-    num_millions = 1  # Try 20 for actual micro-benchmarking.
-    repeats = 2  # Try 10.
-    rates = []
-    for rep in range(repeats):
-        t0 = time.time()
-        m.callback_num_times(lambda: None, num_millions * one_million)
-        td = time.time() - t0
-        rate = num_millions / td if td else 0
-        rates.append(rate)
-        if not rep:
-            print()
-        print(
-            f"callback_num_times: {num_millions:d} million / {td:.3f} seconds = {rate:.3f} million / second"
-        )
-    if len(rates) > 1:
-        print("Min    Mean   Max")
-        print(f"{min(rates):6.3f} {sum(rates) / len(rates):6.3f} {max(rates):6.3f}")
-
-
-def test_custom_func():
-    assert m.custom_function(4) == 36
-    assert m.roundtrip(m.custom_function)(4) == 36
-
-
-@pytest.mark.skipif(
-    m.custom_function2 is None, reason="Current PYBIND11_INTERNALS_VERSION too low"
-)
-def test_custom_func2():
-    assert m.custom_function2(3) == 27
-    assert m.roundtrip(m.custom_function2)(3) == 27
+import time
+from threading import Thread
+
+import pytest
+
+import env  # noqa: F401
+from pybind11_tests import callbacks as m
+
+
+def test_callbacks():
+    from functools import partial
+
+    def func1():
+        return "func1"
+
+    def func2(a, b, c, d):
+        return "func2", a, b, c, d
+
+    def func3(a):
+        return f"func3({a})"
+
+    assert m.test_callback1(func1) == "func1"
+    assert m.test_callback2(func2) == ("func2", "Hello", "x", True, 5)
+    assert m.test_callback1(partial(func2, 1, 2, 3, 4)) == ("func2", 1, 2, 3, 4)
+    assert m.test_callback1(partial(func3, "partial")) == "func3(partial)"
+    assert m.test_callback3(lambda i: i + 1) == "func(43) = 44"
+
+    f = m.test_callback4()
+    assert f(43) == 44
+    f = m.test_callback5()
+    assert f(number=43) == 44
+
+
+def test_bound_method_callback():
+    # Bound Python method:
+    class MyClass:
+        def double(self, val):
+            return 2 * val
+
+    z = MyClass()
+    assert m.test_callback3(z.double) == "func(43) = 86"
+
+    z = m.CppBoundMethodTest()
+    assert m.test_callback3(z.triple) == "func(43) = 129"
+
+
+def test_keyword_args_and_generalized_unpacking():
+    def f(*args, **kwargs):
+        return args, kwargs
+
+    assert m.test_tuple_unpacking(f) == (("positional", 1, 2, 3, 4, 5, 6), {})
+    assert m.test_dict_unpacking(f) == (
+        ("positional", 1),
+        {"key": "value", "a": 1, "b": 2},
+    )
+    assert m.test_keyword_args(f) == ((), {"x": 10, "y": 20})
+    assert m.test_unpacking_and_keywords1(f) == ((1, 2), {"c": 3, "d": 4})
+    assert m.test_unpacking_and_keywords2(f) == (
+        ("positional", 1, 2, 3, 4, 5),
+        {"key": "value", "a": 1, "b": 2, "c": 3, "d": 4, "e": 5},
+    )
+
+    with pytest.raises(TypeError) as excinfo:
+        m.test_unpacking_error1(f)
+    assert "Got multiple values for keyword argument" in str(excinfo.value)
+
+    with pytest.raises(TypeError) as excinfo:
+        m.test_unpacking_error2(f)
+    assert "Got multiple values for keyword argument" in str(excinfo.value)
+
+    with pytest.raises(RuntimeError) as excinfo:
+        m.test_arg_conversion_error1(f)
+    assert "Unable to convert call argument" in str(excinfo.value)
+
+    with pytest.raises(RuntimeError) as excinfo:
+        m.test_arg_conversion_error2(f)
+    assert "Unable to convert call argument" in str(excinfo.value)
+
+
+def test_lambda_closure_cleanup():
+    m.test_lambda_closure_cleanup()
+    cstats = m.payload_cstats()
+    assert cstats.alive() == 0
+    assert cstats.copy_constructions == 1
+    assert cstats.move_constructions >= 1
+
+
+def test_cpp_callable_cleanup():
+    alive_counts = m.test_cpp_callable_cleanup()
+    assert alive_counts == [0, 1, 2, 1, 2, 1, 0]
+
+
+def test_cpp_function_roundtrip():
+    """Test if passing a function pointer from C++ -> Python -> C++ yields the original pointer"""
+
+    assert (
+        m.test_dummy_function(m.dummy_function) == "matches dummy_function: eval(1) = 2"
+    )
+    assert (
+        m.test_dummy_function(m.roundtrip(m.dummy_function))
+        == "matches dummy_function: eval(1) = 2"
+    )
+    assert (
+        m.test_dummy_function(m.dummy_function_overloaded)
+        == "matches dummy_function: eval(1) = 2"
+    )
+    assert m.roundtrip(None, expect_none=True) is None
+    assert (
+        m.test_dummy_function(lambda x: x + 2)
+        == "can't convert to function pointer: eval(1) = 3"
+    )
+
+    with pytest.raises(TypeError) as excinfo:
+        m.test_dummy_function(m.dummy_function2)
+    assert "incompatible function arguments" in str(excinfo.value)
+
+    with pytest.raises(TypeError) as excinfo:
+        m.test_dummy_function(lambda x, y: x + y)
+    assert any(
+        s in str(excinfo.value)
+        for s in ("missing 1 required positional argument", "takes exactly 2 arguments")
+    )
+
+
+def test_function_signatures(doc):
+    assert doc(m.test_callback3) == "test_callback3(arg0: Callable[[int], int]) -> str"
+    assert doc(m.test_callback4) == "test_callback4() -> Callable[[int], int]"
+
+
+def test_movable_object():
+    assert m.callback_with_movable(lambda _: None) is True
+
+
+@pytest.mark.skipif(
+    "env.PYPY",
+    reason="PyPy segfaults on here. See discussion on #1413.",
+)
+def test_python_builtins():
+    """Test if python builtins like sum() can be used as callbacks"""
+    assert m.test_sum_builtin(sum, [1, 2, 3]) == 6
+    assert m.test_sum_builtin(sum, []) == 0
+
+
+def test_async_callbacks():
+    # serves as state for async callback
+    class Item:
+        def __init__(self, value):
+            self.value = value
+
+    res = []
+
+    # generate stateful lambda that will store result in `res`
+    def gen_f():
+        s = Item(3)
+        return lambda j: res.append(s.value + j)
+
+    # do some work async
+    work = [1, 2, 3, 4]
+    m.test_async_callback(gen_f(), work)
+    # wait until work is done
+    from time import sleep
+
+    sleep(0.5)
+    assert sum(res) == sum(x + 3 for x in work)
+
+
+def test_async_async_callbacks():
+    t = Thread(target=test_async_callbacks)
+    t.start()
+    t.join()
+
+
+def test_callback_num_times():
+    # Super-simple micro-benchmarking related to PR #2919.
+    # Example runtimes (Intel Xeon 2.2GHz, fully optimized):
+    #   num_millions  1, repeats  2:  0.1 secs
+    #   num_millions 20, repeats 10: 11.5 secs
+    one_million = 1000000
+    num_millions = 1  # Try 20 for actual micro-benchmarking.
+    repeats = 2  # Try 10.
+    rates = []
+    for rep in range(repeats):
+        t0 = time.time()
+        m.callback_num_times(lambda: None, num_millions * one_million)
+        td = time.time() - t0
+        rate = num_millions / td if td else 0
+        rates.append(rate)
+        if not rep:
+            print()
+        print(
+            f"callback_num_times: {num_millions:d} million / {td:.3f} seconds = {rate:.3f} million / second"
+        )
+    if len(rates) > 1:
+        print("Min    Mean   Max")
+        print(f"{min(rates):6.3f} {sum(rates) / len(rates):6.3f} {max(rates):6.3f}")
+
+
+def test_custom_func():
+    assert m.custom_function(4) == 36
+    assert m.roundtrip(m.custom_function)(4) == 36
+
+
+@pytest.mark.skipif(
+    m.custom_function2 is None, reason="Current PYBIND11_INTERNALS_VERSION too low"
+)
+def test_custom_func2():
+    assert m.custom_function2(3) == 27
+    assert m.roundtrip(m.custom_function2)(3) == 27
```

## extern/pybind11/tests/test_chrono.py

 * *Ordering differences only*

```diff
@@ -1,205 +1,205 @@
-import datetime
-
-import pytest
-
-import env  # noqa: F401
-from pybind11_tests import chrono as m
-
-
-def test_chrono_system_clock():
-    # Get the time from both c++ and datetime
-    date0 = datetime.datetime.today()
-    date1 = m.test_chrono1()
-    date2 = datetime.datetime.today()
-
-    # The returned value should be a datetime
-    assert isinstance(date1, datetime.datetime)
-
-    # The numbers should vary by a very small amount (time it took to execute)
-    diff_python = abs(date2 - date0)
-    diff = abs(date1 - date2)
-
-    # There should never be a days difference
-    assert diff.days == 0
-
-    # Since datetime.datetime.today() calls time.time(), and on some platforms
-    # that has 1 second accuracy, we compare this way
-    assert diff.seconds <= diff_python.seconds
-
-
-def test_chrono_system_clock_roundtrip():
-    date1 = datetime.datetime.today()
-
-    # Roundtrip the time
-    date2 = m.test_chrono2(date1)
-
-    # The returned value should be a datetime
-    assert isinstance(date2, datetime.datetime)
-
-    # They should be identical (no information lost on roundtrip)
-    diff = abs(date1 - date2)
-    assert diff == datetime.timedelta(0)
-
-
-def test_chrono_system_clock_roundtrip_date():
-    date1 = datetime.date.today()
-
-    # Roundtrip the time
-    datetime2 = m.test_chrono2(date1)
-    date2 = datetime2.date()
-    time2 = datetime2.time()
-
-    # The returned value should be a datetime
-    assert isinstance(datetime2, datetime.datetime)
-    assert isinstance(date2, datetime.date)
-    assert isinstance(time2, datetime.time)
-
-    # They should be identical (no information lost on roundtrip)
-    diff = abs(date1 - date2)
-    assert diff.days == 0
-    assert diff.seconds == 0
-    assert diff.microseconds == 0
-
-    # Year, Month & Day should be the same after the round trip
-    assert date1 == date2
-
-    # There should be no time information
-    assert time2.hour == 0
-    assert time2.minute == 0
-    assert time2.second == 0
-    assert time2.microsecond == 0
-
-
-SKIP_TZ_ENV_ON_WIN = pytest.mark.skipif(
-    "env.WIN", reason="TZ environment variable only supported on POSIX"
-)
-
-
-@pytest.mark.parametrize(
-    "time1",
-    [
-        datetime.datetime.today().time(),
-        datetime.time(0, 0, 0),
-        datetime.time(0, 0, 0, 1),
-        datetime.time(0, 28, 45, 109827),
-        datetime.time(0, 59, 59, 999999),
-        datetime.time(1, 0, 0),
-        datetime.time(5, 59, 59, 0),
-        datetime.time(5, 59, 59, 1),
-    ],
-)
-@pytest.mark.parametrize(
-    "tz",
-    [
-        None,
-        pytest.param("Europe/Brussels", marks=SKIP_TZ_ENV_ON_WIN),
-        pytest.param("Asia/Pyongyang", marks=SKIP_TZ_ENV_ON_WIN),
-        pytest.param("America/New_York", marks=SKIP_TZ_ENV_ON_WIN),
-    ],
-)
-def test_chrono_system_clock_roundtrip_time(time1, tz, monkeypatch):
-    if tz is not None:
-        monkeypatch.setenv("TZ", f"/usr/share/zoneinfo/{tz}")
-
-    # Roundtrip the time
-    datetime2 = m.test_chrono2(time1)
-    date2 = datetime2.date()
-    time2 = datetime2.time()
-
-    # The returned value should be a datetime
-    assert isinstance(datetime2, datetime.datetime)
-    assert isinstance(date2, datetime.date)
-    assert isinstance(time2, datetime.time)
-
-    # Hour, Minute, Second & Microsecond should be the same after the round trip
-    assert time1 == time2
-
-    # There should be no date information (i.e. date = python base date)
-    assert date2.year == 1970
-    assert date2.month == 1
-    assert date2.day == 1
-
-
-def test_chrono_duration_roundtrip():
-    # Get the difference between two times (a timedelta)
-    date1 = datetime.datetime.today()
-    date2 = datetime.datetime.today()
-    diff = date2 - date1
-
-    # Make sure this is a timedelta
-    assert isinstance(diff, datetime.timedelta)
-
-    cpp_diff = m.test_chrono3(diff)
-
-    assert cpp_diff == diff
-
-    # Negative timedelta roundtrip
-    diff = datetime.timedelta(microseconds=-1)
-    cpp_diff = m.test_chrono3(diff)
-
-    assert cpp_diff == diff
-
-
-def test_chrono_duration_subtraction_equivalence():
-    date1 = datetime.datetime.today()
-    date2 = datetime.datetime.today()
-
-    diff = date2 - date1
-    cpp_diff = m.test_chrono4(date2, date1)
-
-    assert cpp_diff == diff
-
-
-def test_chrono_duration_subtraction_equivalence_date():
-    date1 = datetime.date.today()
-    date2 = datetime.date.today()
-
-    diff = date2 - date1
-    cpp_diff = m.test_chrono4(date2, date1)
-
-    assert cpp_diff == diff
-
-
-def test_chrono_steady_clock():
-    time1 = m.test_chrono5()
-    assert isinstance(time1, datetime.timedelta)
-
-
-def test_chrono_steady_clock_roundtrip():
-    time1 = datetime.timedelta(days=10, seconds=10, microseconds=100)
-    time2 = m.test_chrono6(time1)
-
-    assert isinstance(time2, datetime.timedelta)
-
-    # They should be identical (no information lost on roundtrip)
-    assert time1 == time2
-
-
-def test_floating_point_duration():
-    # Test using a floating point number in seconds
-    time = m.test_chrono7(35.525123)
-
-    assert isinstance(time, datetime.timedelta)
-
-    assert time.seconds == 35
-    assert 525122 <= time.microseconds <= 525123
-
-    diff = m.test_chrono_float_diff(43.789012, 1.123456)
-    assert diff.seconds == 42
-    assert 665556 <= diff.microseconds <= 665557
-
-
-def test_nano_timepoint():
-    time = datetime.datetime.now()
-    time1 = m.test_nano_timepoint(time, datetime.timedelta(seconds=60))
-    assert time1 == time + datetime.timedelta(seconds=60)
-
-
-def test_chrono_different_resolutions():
-    resolutions = m.different_resolutions()
-    time = datetime.datetime.now()
-    resolutions.timestamp_h = time
-    resolutions.timestamp_m = time
-    resolutions.timestamp_s = time
-    resolutions.timestamp_ms = time
-    resolutions.timestamp_us = time
+import datetime
+
+import pytest
+
+import env  # noqa: F401
+from pybind11_tests import chrono as m
+
+
+def test_chrono_system_clock():
+    # Get the time from both c++ and datetime
+    date0 = datetime.datetime.today()
+    date1 = m.test_chrono1()
+    date2 = datetime.datetime.today()
+
+    # The returned value should be a datetime
+    assert isinstance(date1, datetime.datetime)
+
+    # The numbers should vary by a very small amount (time it took to execute)
+    diff_python = abs(date2 - date0)
+    diff = abs(date1 - date2)
+
+    # There should never be a days difference
+    assert diff.days == 0
+
+    # Since datetime.datetime.today() calls time.time(), and on some platforms
+    # that has 1 second accuracy, we compare this way
+    assert diff.seconds <= diff_python.seconds
+
+
+def test_chrono_system_clock_roundtrip():
+    date1 = datetime.datetime.today()
+
+    # Roundtrip the time
+    date2 = m.test_chrono2(date1)
+
+    # The returned value should be a datetime
+    assert isinstance(date2, datetime.datetime)
+
+    # They should be identical (no information lost on roundtrip)
+    diff = abs(date1 - date2)
+    assert diff == datetime.timedelta(0)
+
+
+def test_chrono_system_clock_roundtrip_date():
+    date1 = datetime.date.today()
+
+    # Roundtrip the time
+    datetime2 = m.test_chrono2(date1)
+    date2 = datetime2.date()
+    time2 = datetime2.time()
+
+    # The returned value should be a datetime
+    assert isinstance(datetime2, datetime.datetime)
+    assert isinstance(date2, datetime.date)
+    assert isinstance(time2, datetime.time)
+
+    # They should be identical (no information lost on roundtrip)
+    diff = abs(date1 - date2)
+    assert diff.days == 0
+    assert diff.seconds == 0
+    assert diff.microseconds == 0
+
+    # Year, Month & Day should be the same after the round trip
+    assert date1 == date2
+
+    # There should be no time information
+    assert time2.hour == 0
+    assert time2.minute == 0
+    assert time2.second == 0
+    assert time2.microsecond == 0
+
+
+SKIP_TZ_ENV_ON_WIN = pytest.mark.skipif(
+    "env.WIN", reason="TZ environment variable only supported on POSIX"
+)
+
+
+@pytest.mark.parametrize(
+    "time1",
+    [
+        datetime.datetime.today().time(),
+        datetime.time(0, 0, 0),
+        datetime.time(0, 0, 0, 1),
+        datetime.time(0, 28, 45, 109827),
+        datetime.time(0, 59, 59, 999999),
+        datetime.time(1, 0, 0),
+        datetime.time(5, 59, 59, 0),
+        datetime.time(5, 59, 59, 1),
+    ],
+)
+@pytest.mark.parametrize(
+    "tz",
+    [
+        None,
+        pytest.param("Europe/Brussels", marks=SKIP_TZ_ENV_ON_WIN),
+        pytest.param("Asia/Pyongyang", marks=SKIP_TZ_ENV_ON_WIN),
+        pytest.param("America/New_York", marks=SKIP_TZ_ENV_ON_WIN),
+    ],
+)
+def test_chrono_system_clock_roundtrip_time(time1, tz, monkeypatch):
+    if tz is not None:
+        monkeypatch.setenv("TZ", f"/usr/share/zoneinfo/{tz}")
+
+    # Roundtrip the time
+    datetime2 = m.test_chrono2(time1)
+    date2 = datetime2.date()
+    time2 = datetime2.time()
+
+    # The returned value should be a datetime
+    assert isinstance(datetime2, datetime.datetime)
+    assert isinstance(date2, datetime.date)
+    assert isinstance(time2, datetime.time)
+
+    # Hour, Minute, Second & Microsecond should be the same after the round trip
+    assert time1 == time2
+
+    # There should be no date information (i.e. date = python base date)
+    assert date2.year == 1970
+    assert date2.month == 1
+    assert date2.day == 1
+
+
+def test_chrono_duration_roundtrip():
+    # Get the difference between two times (a timedelta)
+    date1 = datetime.datetime.today()
+    date2 = datetime.datetime.today()
+    diff = date2 - date1
+
+    # Make sure this is a timedelta
+    assert isinstance(diff, datetime.timedelta)
+
+    cpp_diff = m.test_chrono3(diff)
+
+    assert cpp_diff == diff
+
+    # Negative timedelta roundtrip
+    diff = datetime.timedelta(microseconds=-1)
+    cpp_diff = m.test_chrono3(diff)
+
+    assert cpp_diff == diff
+
+
+def test_chrono_duration_subtraction_equivalence():
+    date1 = datetime.datetime.today()
+    date2 = datetime.datetime.today()
+
+    diff = date2 - date1
+    cpp_diff = m.test_chrono4(date2, date1)
+
+    assert cpp_diff == diff
+
+
+def test_chrono_duration_subtraction_equivalence_date():
+    date1 = datetime.date.today()
+    date2 = datetime.date.today()
+
+    diff = date2 - date1
+    cpp_diff = m.test_chrono4(date2, date1)
+
+    assert cpp_diff == diff
+
+
+def test_chrono_steady_clock():
+    time1 = m.test_chrono5()
+    assert isinstance(time1, datetime.timedelta)
+
+
+def test_chrono_steady_clock_roundtrip():
+    time1 = datetime.timedelta(days=10, seconds=10, microseconds=100)
+    time2 = m.test_chrono6(time1)
+
+    assert isinstance(time2, datetime.timedelta)
+
+    # They should be identical (no information lost on roundtrip)
+    assert time1 == time2
+
+
+def test_floating_point_duration():
+    # Test using a floating point number in seconds
+    time = m.test_chrono7(35.525123)
+
+    assert isinstance(time, datetime.timedelta)
+
+    assert time.seconds == 35
+    assert 525122 <= time.microseconds <= 525123
+
+    diff = m.test_chrono_float_diff(43.789012, 1.123456)
+    assert diff.seconds == 42
+    assert 665556 <= diff.microseconds <= 665557
+
+
+def test_nano_timepoint():
+    time = datetime.datetime.now()
+    time1 = m.test_nano_timepoint(time, datetime.timedelta(seconds=60))
+    assert time1 == time + datetime.timedelta(seconds=60)
+
+
+def test_chrono_different_resolutions():
+    resolutions = m.different_resolutions()
+    time = datetime.datetime.now()
+    resolutions.timestamp_h = time
+    resolutions.timestamp_m = time
+    resolutions.timestamp_s = time
+    resolutions.timestamp_ms = time
+    resolutions.timestamp_us = time
```

## extern/pybind11/tests/test_class.py

 * *Ordering differences only*

```diff
@@ -1,488 +1,488 @@
-import pytest
-
-import env
-from pybind11_tests import ConstructorStats, UserType
-from pybind11_tests import class_ as m
-
-
-def test_obj_class_name():
-    if env.PYPY:
-        expected_name = "UserType"
-    else:
-        expected_name = "pybind11_tests.UserType"
-    assert m.obj_class_name(UserType(1)) == expected_name
-    assert m.obj_class_name(UserType) == expected_name
-
-
-def test_repr():
-    assert "pybind11_type" in repr(type(UserType))
-    assert "UserType" in repr(UserType)
-
-
-def test_instance(msg):
-    with pytest.raises(TypeError) as excinfo:
-        m.NoConstructor()
-    assert msg(excinfo.value) == "m.class_.NoConstructor: No constructor defined!"
-
-    instance = m.NoConstructor.new_instance()
-
-    cstats = ConstructorStats.get(m.NoConstructor)
-    assert cstats.alive() == 1
-    del instance
-    assert cstats.alive() == 0
-
-
-def test_instance_new(msg):
-    instance = m.NoConstructorNew()  # .__new__(m.NoConstructor.__class__)
-    cstats = ConstructorStats.get(m.NoConstructorNew)
-    assert cstats.alive() == 1
-    del instance
-    assert cstats.alive() == 0
-
-
-def test_type():
-    assert m.check_type(1) == m.DerivedClass1
-    with pytest.raises(RuntimeError) as execinfo:
-        m.check_type(0)
-
-    assert "pybind11::detail::get_type_info: unable to find type info" in str(
-        execinfo.value
-    )
-    assert "Invalid" in str(execinfo.value)
-
-    # Currently not supported
-    # See https://github.com/pybind/pybind11/issues/2486
-    # assert m.check_type(2) == int
-
-
-def test_type_of_py():
-    assert m.get_type_of(1) == int
-    assert m.get_type_of(m.DerivedClass1()) == m.DerivedClass1
-    assert m.get_type_of(int) == type
-
-
-def test_type_of_classic():
-    assert m.get_type_classic(1) == int
-    assert m.get_type_classic(m.DerivedClass1()) == m.DerivedClass1
-    assert m.get_type_classic(int) == type
-
-
-def test_type_of_py_nodelete():
-    # If the above test deleted the class, this will segfault
-    assert m.get_type_of(m.DerivedClass1()) == m.DerivedClass1
-
-
-def test_as_type_py():
-    assert m.as_type(int) == int
-
-    with pytest.raises(TypeError):
-        assert m.as_type(1) == int
-
-    with pytest.raises(TypeError):
-        assert m.as_type(m.DerivedClass1()) == m.DerivedClass1
-
-
-def test_docstrings(doc):
-    assert doc(UserType) == "A `py::class_` type for testing"
-    assert UserType.__name__ == "UserType"
-    assert UserType.__module__ == "pybind11_tests"
-    assert UserType.get_value.__name__ == "get_value"
-    assert UserType.get_value.__module__ == "pybind11_tests"
-
-    assert (
-        doc(UserType.get_value)
-        == """
-        get_value(self: m.UserType) -> int
-
-        Get value using a method
-    """
-    )
-    assert doc(UserType.value) == "Get/set value using a property"
-
-    assert (
-        doc(m.NoConstructor.new_instance)
-        == """
-        new_instance() -> m.class_.NoConstructor
-
-        Return an instance
-    """
-    )
-
-
-def test_qualname(doc):
-    """Tests that a properly qualified name is set in __qualname__ and that
-    generated docstrings properly use it and the module name"""
-    assert m.NestBase.__qualname__ == "NestBase"
-    assert m.NestBase.Nested.__qualname__ == "NestBase.Nested"
-
-    assert (
-        doc(m.NestBase.__init__)
-        == """
-        __init__(self: m.class_.NestBase) -> None
-    """
-    )
-    assert (
-        doc(m.NestBase.g)
-        == """
-        g(self: m.class_.NestBase, arg0: m.class_.NestBase.Nested) -> None
-    """
-    )
-    assert (
-        doc(m.NestBase.Nested.__init__)
-        == """
-        __init__(self: m.class_.NestBase.Nested) -> None
-    """
-    )
-    assert (
-        doc(m.NestBase.Nested.fn)
-        == """
-        fn(self: m.class_.NestBase.Nested, arg0: int, arg1: m.class_.NestBase, arg2: m.class_.NestBase.Nested) -> None
-    """
-    )
-    assert (
-        doc(m.NestBase.Nested.fa)
-        == """
-        fa(self: m.class_.NestBase.Nested, a: int, b: m.class_.NestBase, c: m.class_.NestBase.Nested) -> None
-    """
-    )
-    assert m.NestBase.__module__ == "pybind11_tests.class_"
-    assert m.NestBase.Nested.__module__ == "pybind11_tests.class_"
-
-
-def test_inheritance(msg):
-    roger = m.Rabbit("Rabbit")
-    assert roger.name() + " is a " + roger.species() == "Rabbit is a parrot"
-    assert m.pet_name_species(roger) == "Rabbit is a parrot"
-
-    polly = m.Pet("Polly", "parrot")
-    assert polly.name() + " is a " + polly.species() == "Polly is a parrot"
-    assert m.pet_name_species(polly) == "Polly is a parrot"
-
-    molly = m.Dog("Molly")
-    assert molly.name() + " is a " + molly.species() == "Molly is a dog"
-    assert m.pet_name_species(molly) == "Molly is a dog"
-
-    fred = m.Hamster("Fred")
-    assert fred.name() + " is a " + fred.species() == "Fred is a rodent"
-
-    assert m.dog_bark(molly) == "Woof!"
-
-    with pytest.raises(TypeError) as excinfo:
-        m.dog_bark(polly)
-    assert (
-        msg(excinfo.value)
-        == """
-        dog_bark(): incompatible function arguments. The following argument types are supported:
-            1. (arg0: m.class_.Dog) -> str
-
-        Invoked with: <m.class_.Pet object at 0>
-    """
-    )
-
-    with pytest.raises(TypeError) as excinfo:
-        m.Chimera("lion", "goat")
-    assert "No constructor defined!" in str(excinfo.value)
-
-
-def test_inheritance_init(msg):
-    # Single base
-    class Python(m.Pet):
-        def __init__(self):
-            pass
-
-    with pytest.raises(TypeError) as exc_info:
-        Python()
-    expected = "m.class_.Pet.__init__() must be called when overriding __init__"
-    assert msg(exc_info.value) == expected
-
-    # Multiple bases
-    class RabbitHamster(m.Rabbit, m.Hamster):
-        def __init__(self):
-            m.Rabbit.__init__(self, "RabbitHamster")
-
-    with pytest.raises(TypeError) as exc_info:
-        RabbitHamster()
-    expected = "m.class_.Hamster.__init__() must be called when overriding __init__"
-    assert msg(exc_info.value) == expected
-
-
-def test_automatic_upcasting():
-    assert type(m.return_class_1()).__name__ == "DerivedClass1"
-    assert type(m.return_class_2()).__name__ == "DerivedClass2"
-    assert type(m.return_none()).__name__ == "NoneType"
-    # Repeat these a few times in a random order to ensure no invalid caching is applied
-    assert type(m.return_class_n(1)).__name__ == "DerivedClass1"
-    assert type(m.return_class_n(2)).__name__ == "DerivedClass2"
-    assert type(m.return_class_n(0)).__name__ == "BaseClass"
-    assert type(m.return_class_n(2)).__name__ == "DerivedClass2"
-    assert type(m.return_class_n(2)).__name__ == "DerivedClass2"
-    assert type(m.return_class_n(0)).__name__ == "BaseClass"
-    assert type(m.return_class_n(1)).__name__ == "DerivedClass1"
-
-
-def test_isinstance():
-    objects = [tuple(), dict(), m.Pet("Polly", "parrot")] + [m.Dog("Molly")] * 4
-    expected = (True, True, True, True, True, False, False)
-    assert m.check_instances(objects) == expected
-
-
-def test_mismatched_holder():
-    import re
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.mismatched_holder_1()
-    assert re.match(
-        'generic_type: type ".*MismatchDerived1" does not have a non-default '
-        'holder type while its base ".*MismatchBase1" does',
-        str(excinfo.value),
-    )
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.mismatched_holder_2()
-    assert re.match(
-        'generic_type: type ".*MismatchDerived2" has a non-default holder type '
-        'while its base ".*MismatchBase2" does not',
-        str(excinfo.value),
-    )
-
-
-def test_override_static():
-    """#511: problem with inheritance + overwritten def_static"""
-    b = m.MyBase.make()
-    d1 = m.MyDerived.make2()
-    d2 = m.MyDerived.make()
-
-    assert isinstance(b, m.MyBase)
-    assert isinstance(d1, m.MyDerived)
-    assert isinstance(d2, m.MyDerived)
-
-
-def test_implicit_conversion_life_support():
-    """Ensure the lifetime of temporary objects created for implicit conversions"""
-    assert m.implicitly_convert_argument(UserType(5)) == 5
-    assert m.implicitly_convert_variable(UserType(5)) == 5
-
-    assert "outside a bound function" in m.implicitly_convert_variable_fail(UserType(5))
-
-
-def test_operator_new_delete(capture):
-    """Tests that class-specific operator new/delete functions are invoked"""
-
-    class SubAliased(m.AliasedHasOpNewDelSize):
-        pass
-
-    with capture:
-        a = m.HasOpNewDel()
-        b = m.HasOpNewDelSize()
-        d = m.HasOpNewDelBoth()
-    assert (
-        capture
-        == """
-        A new 8
-        B new 4
-        D new 32
-    """
-    )
-    sz_alias = str(m.AliasedHasOpNewDelSize.size_alias)
-    sz_noalias = str(m.AliasedHasOpNewDelSize.size_noalias)
-    with capture:
-        c = m.AliasedHasOpNewDelSize()
-        c2 = SubAliased()
-    assert capture == ("C new " + sz_noalias + "\n" + "C new " + sz_alias + "\n")
-
-    with capture:
-        del a
-        pytest.gc_collect()
-        del b
-        pytest.gc_collect()
-        del d
-        pytest.gc_collect()
-    assert (
-        capture
-        == """
-        A delete
-        B delete 4
-        D delete
-    """
-    )
-
-    with capture:
-        del c
-        pytest.gc_collect()
-        del c2
-        pytest.gc_collect()
-    assert capture == ("C delete " + sz_noalias + "\n" + "C delete " + sz_alias + "\n")
-
-
-def test_bind_protected_functions():
-    """Expose protected member functions to Python using a helper class"""
-    a = m.ProtectedA()
-    assert a.foo() == 42
-
-    b = m.ProtectedB()
-    assert b.foo() == 42
-    assert m.read_foo(b.void_foo()) == 42
-    assert m.pointers_equal(b.get_self(), b)
-
-    class C(m.ProtectedB):
-        def __init__(self):
-            m.ProtectedB.__init__(self)
-
-        def foo(self):
-            return 0
-
-    c = C()
-    assert c.foo() == 0
-
-
-def test_brace_initialization():
-    """Tests that simple POD classes can be constructed using C++11 brace initialization"""
-    a = m.BraceInitialization(123, "test")
-    assert a.field1 == 123
-    assert a.field2 == "test"
-
-    # Tests that a non-simple class doesn't get brace initialization (if the
-    # class defines an initializer_list constructor, in particular, it would
-    # win over the expected constructor).
-    b = m.NoBraceInitialization([123, 456])
-    assert b.vec == [123, 456]
-
-
-@pytest.mark.xfail("env.PYPY")
-def test_class_refcount():
-    """Instances must correctly increase/decrease the reference count of their types (#1029)"""
-    from sys import getrefcount
-
-    class PyDog(m.Dog):
-        pass
-
-    for cls in m.Dog, PyDog:
-        refcount_1 = getrefcount(cls)
-        molly = [cls("Molly") for _ in range(10)]
-        refcount_2 = getrefcount(cls)
-
-        del molly
-        pytest.gc_collect()
-        refcount_3 = getrefcount(cls)
-
-        assert refcount_1 == refcount_3
-        assert refcount_2 > refcount_1
-
-
-def test_reentrant_implicit_conversion_failure(msg):
-    # ensure that there is no runaway reentrant implicit conversion (#1035)
-    with pytest.raises(TypeError) as excinfo:
-        m.BogusImplicitConversion(0)
-    assert (
-        msg(excinfo.value)
-        == """
-        __init__(): incompatible constructor arguments. The following argument types are supported:
-            1. m.class_.BogusImplicitConversion(arg0: m.class_.BogusImplicitConversion)
-
-        Invoked with: 0
-    """
-    )
-
-
-def test_error_after_conversions():
-    with pytest.raises(TypeError) as exc_info:
-        m.test_error_after_conversions("hello")
-    assert str(exc_info.value).startswith(
-        "Unable to convert function return value to a Python type!"
-    )
-
-
-def test_aligned():
-    if hasattr(m, "Aligned"):
-        p = m.Aligned().ptr()
-        assert p % 1024 == 0
-
-
-# https://foss.heptapod.net/pypy/pypy/-/issues/2742
-@pytest.mark.xfail("env.PYPY")
-def test_final():
-    with pytest.raises(TypeError) as exc_info:
-
-        class PyFinalChild(m.IsFinal):
-            pass
-
-    assert str(exc_info.value).endswith("is not an acceptable base type")
-
-
-# https://foss.heptapod.net/pypy/pypy/-/issues/2742
-@pytest.mark.xfail("env.PYPY")
-def test_non_final_final():
-    with pytest.raises(TypeError) as exc_info:
-
-        class PyNonFinalFinalChild(m.IsNonFinalFinal):
-            pass
-
-    assert str(exc_info.value).endswith("is not an acceptable base type")
-
-
-# https://github.com/pybind/pybind11/issues/1878
-def test_exception_rvalue_abort():
-    with pytest.raises(RuntimeError):
-        m.PyPrintDestructor().throw_something()
-
-
-# https://github.com/pybind/pybind11/issues/1568
-def test_multiple_instances_with_same_pointer(capture):
-    n = 100
-    instances = [m.SamePointer() for _ in range(n)]
-    for i in range(n):
-        # We need to reuse the same allocated memory for with a different type,
-        # to ensure the bug in `deregister_instance_impl` is detected. Otherwise
-        # `Py_TYPE(self) == Py_TYPE(it->second)` will still succeed, even though
-        # the `instance` is already deleted.
-        instances[i] = m.Empty()
-    # No assert: if this does not trigger the error
-    #   pybind11_fail("pybind11_object_dealloc(): Tried to deallocate unregistered instance!");
-    # and just completes without crashing, we're good.
-
-
-# https://github.com/pybind/pybind11/issues/1624
-def test_base_and_derived_nested_scope():
-    assert issubclass(m.DerivedWithNested, m.BaseWithNested)
-    assert m.BaseWithNested.Nested != m.DerivedWithNested.Nested
-    assert m.BaseWithNested.Nested.get_name() == "BaseWithNested::Nested"
-    assert m.DerivedWithNested.Nested.get_name() == "DerivedWithNested::Nested"
-
-
-def test_register_duplicate_class():
-    import types
-
-    module_scope = types.ModuleType("module_scope")
-    with pytest.raises(RuntimeError) as exc_info:
-        m.register_duplicate_class_name(module_scope)
-    expected = (
-        'generic_type: cannot initialize type "Duplicate": '
-        "an object with that name is already defined"
-    )
-    assert str(exc_info.value) == expected
-    with pytest.raises(RuntimeError) as exc_info:
-        m.register_duplicate_class_type(module_scope)
-    expected = 'generic_type: type "YetAnotherDuplicate" is already registered!'
-    assert str(exc_info.value) == expected
-
-    class ClassScope:
-        pass
-
-    with pytest.raises(RuntimeError) as exc_info:
-        m.register_duplicate_nested_class_name(ClassScope)
-    expected = (
-        'generic_type: cannot initialize type "DuplicateNested": '
-        "an object with that name is already defined"
-    )
-    assert str(exc_info.value) == expected
-    with pytest.raises(RuntimeError) as exc_info:
-        m.register_duplicate_nested_class_type(ClassScope)
-    expected = 'generic_type: type "YetAnotherDuplicateNested" is already registered!'
-    assert str(exc_info.value) == expected
-
-
-def test_pr4220_tripped_over_this():
-    assert (
-        m.Empty0().get_msg()
-        == "This is really only meant to exercise successful compilation."
-    )
+import pytest
+
+import env
+from pybind11_tests import ConstructorStats, UserType
+from pybind11_tests import class_ as m
+
+
+def test_obj_class_name():
+    if env.PYPY:
+        expected_name = "UserType"
+    else:
+        expected_name = "pybind11_tests.UserType"
+    assert m.obj_class_name(UserType(1)) == expected_name
+    assert m.obj_class_name(UserType) == expected_name
+
+
+def test_repr():
+    assert "pybind11_type" in repr(type(UserType))
+    assert "UserType" in repr(UserType)
+
+
+def test_instance(msg):
+    with pytest.raises(TypeError) as excinfo:
+        m.NoConstructor()
+    assert msg(excinfo.value) == "m.class_.NoConstructor: No constructor defined!"
+
+    instance = m.NoConstructor.new_instance()
+
+    cstats = ConstructorStats.get(m.NoConstructor)
+    assert cstats.alive() == 1
+    del instance
+    assert cstats.alive() == 0
+
+
+def test_instance_new(msg):
+    instance = m.NoConstructorNew()  # .__new__(m.NoConstructor.__class__)
+    cstats = ConstructorStats.get(m.NoConstructorNew)
+    assert cstats.alive() == 1
+    del instance
+    assert cstats.alive() == 0
+
+
+def test_type():
+    assert m.check_type(1) == m.DerivedClass1
+    with pytest.raises(RuntimeError) as execinfo:
+        m.check_type(0)
+
+    assert "pybind11::detail::get_type_info: unable to find type info" in str(
+        execinfo.value
+    )
+    assert "Invalid" in str(execinfo.value)
+
+    # Currently not supported
+    # See https://github.com/pybind/pybind11/issues/2486
+    # assert m.check_type(2) == int
+
+
+def test_type_of_py():
+    assert m.get_type_of(1) == int
+    assert m.get_type_of(m.DerivedClass1()) == m.DerivedClass1
+    assert m.get_type_of(int) == type
+
+
+def test_type_of_classic():
+    assert m.get_type_classic(1) == int
+    assert m.get_type_classic(m.DerivedClass1()) == m.DerivedClass1
+    assert m.get_type_classic(int) == type
+
+
+def test_type_of_py_nodelete():
+    # If the above test deleted the class, this will segfault
+    assert m.get_type_of(m.DerivedClass1()) == m.DerivedClass1
+
+
+def test_as_type_py():
+    assert m.as_type(int) == int
+
+    with pytest.raises(TypeError):
+        assert m.as_type(1) == int
+
+    with pytest.raises(TypeError):
+        assert m.as_type(m.DerivedClass1()) == m.DerivedClass1
+
+
+def test_docstrings(doc):
+    assert doc(UserType) == "A `py::class_` type for testing"
+    assert UserType.__name__ == "UserType"
+    assert UserType.__module__ == "pybind11_tests"
+    assert UserType.get_value.__name__ == "get_value"
+    assert UserType.get_value.__module__ == "pybind11_tests"
+
+    assert (
+        doc(UserType.get_value)
+        == """
+        get_value(self: m.UserType) -> int
+
+        Get value using a method
+    """
+    )
+    assert doc(UserType.value) == "Get/set value using a property"
+
+    assert (
+        doc(m.NoConstructor.new_instance)
+        == """
+        new_instance() -> m.class_.NoConstructor
+
+        Return an instance
+    """
+    )
+
+
+def test_qualname(doc):
+    """Tests that a properly qualified name is set in __qualname__ and that
+    generated docstrings properly use it and the module name"""
+    assert m.NestBase.__qualname__ == "NestBase"
+    assert m.NestBase.Nested.__qualname__ == "NestBase.Nested"
+
+    assert (
+        doc(m.NestBase.__init__)
+        == """
+        __init__(self: m.class_.NestBase) -> None
+    """
+    )
+    assert (
+        doc(m.NestBase.g)
+        == """
+        g(self: m.class_.NestBase, arg0: m.class_.NestBase.Nested) -> None
+    """
+    )
+    assert (
+        doc(m.NestBase.Nested.__init__)
+        == """
+        __init__(self: m.class_.NestBase.Nested) -> None
+    """
+    )
+    assert (
+        doc(m.NestBase.Nested.fn)
+        == """
+        fn(self: m.class_.NestBase.Nested, arg0: int, arg1: m.class_.NestBase, arg2: m.class_.NestBase.Nested) -> None
+    """
+    )
+    assert (
+        doc(m.NestBase.Nested.fa)
+        == """
+        fa(self: m.class_.NestBase.Nested, a: int, b: m.class_.NestBase, c: m.class_.NestBase.Nested) -> None
+    """
+    )
+    assert m.NestBase.__module__ == "pybind11_tests.class_"
+    assert m.NestBase.Nested.__module__ == "pybind11_tests.class_"
+
+
+def test_inheritance(msg):
+    roger = m.Rabbit("Rabbit")
+    assert roger.name() + " is a " + roger.species() == "Rabbit is a parrot"
+    assert m.pet_name_species(roger) == "Rabbit is a parrot"
+
+    polly = m.Pet("Polly", "parrot")
+    assert polly.name() + " is a " + polly.species() == "Polly is a parrot"
+    assert m.pet_name_species(polly) == "Polly is a parrot"
+
+    molly = m.Dog("Molly")
+    assert molly.name() + " is a " + molly.species() == "Molly is a dog"
+    assert m.pet_name_species(molly) == "Molly is a dog"
+
+    fred = m.Hamster("Fred")
+    assert fred.name() + " is a " + fred.species() == "Fred is a rodent"
+
+    assert m.dog_bark(molly) == "Woof!"
+
+    with pytest.raises(TypeError) as excinfo:
+        m.dog_bark(polly)
+    assert (
+        msg(excinfo.value)
+        == """
+        dog_bark(): incompatible function arguments. The following argument types are supported:
+            1. (arg0: m.class_.Dog) -> str
+
+        Invoked with: <m.class_.Pet object at 0>
+    """
+    )
+
+    with pytest.raises(TypeError) as excinfo:
+        m.Chimera("lion", "goat")
+    assert "No constructor defined!" in str(excinfo.value)
+
+
+def test_inheritance_init(msg):
+    # Single base
+    class Python(m.Pet):
+        def __init__(self):
+            pass
+
+    with pytest.raises(TypeError) as exc_info:
+        Python()
+    expected = "m.class_.Pet.__init__() must be called when overriding __init__"
+    assert msg(exc_info.value) == expected
+
+    # Multiple bases
+    class RabbitHamster(m.Rabbit, m.Hamster):
+        def __init__(self):
+            m.Rabbit.__init__(self, "RabbitHamster")
+
+    with pytest.raises(TypeError) as exc_info:
+        RabbitHamster()
+    expected = "m.class_.Hamster.__init__() must be called when overriding __init__"
+    assert msg(exc_info.value) == expected
+
+
+def test_automatic_upcasting():
+    assert type(m.return_class_1()).__name__ == "DerivedClass1"
+    assert type(m.return_class_2()).__name__ == "DerivedClass2"
+    assert type(m.return_none()).__name__ == "NoneType"
+    # Repeat these a few times in a random order to ensure no invalid caching is applied
+    assert type(m.return_class_n(1)).__name__ == "DerivedClass1"
+    assert type(m.return_class_n(2)).__name__ == "DerivedClass2"
+    assert type(m.return_class_n(0)).__name__ == "BaseClass"
+    assert type(m.return_class_n(2)).__name__ == "DerivedClass2"
+    assert type(m.return_class_n(2)).__name__ == "DerivedClass2"
+    assert type(m.return_class_n(0)).__name__ == "BaseClass"
+    assert type(m.return_class_n(1)).__name__ == "DerivedClass1"
+
+
+def test_isinstance():
+    objects = [tuple(), dict(), m.Pet("Polly", "parrot")] + [m.Dog("Molly")] * 4
+    expected = (True, True, True, True, True, False, False)
+    assert m.check_instances(objects) == expected
+
+
+def test_mismatched_holder():
+    import re
+
+    with pytest.raises(RuntimeError) as excinfo:
+        m.mismatched_holder_1()
+    assert re.match(
+        'generic_type: type ".*MismatchDerived1" does not have a non-default '
+        'holder type while its base ".*MismatchBase1" does',
+        str(excinfo.value),
+    )
+
+    with pytest.raises(RuntimeError) as excinfo:
+        m.mismatched_holder_2()
+    assert re.match(
+        'generic_type: type ".*MismatchDerived2" has a non-default holder type '
+        'while its base ".*MismatchBase2" does not',
+        str(excinfo.value),
+    )
+
+
+def test_override_static():
+    """#511: problem with inheritance + overwritten def_static"""
+    b = m.MyBase.make()
+    d1 = m.MyDerived.make2()
+    d2 = m.MyDerived.make()
+
+    assert isinstance(b, m.MyBase)
+    assert isinstance(d1, m.MyDerived)
+    assert isinstance(d2, m.MyDerived)
+
+
+def test_implicit_conversion_life_support():
+    """Ensure the lifetime of temporary objects created for implicit conversions"""
+    assert m.implicitly_convert_argument(UserType(5)) == 5
+    assert m.implicitly_convert_variable(UserType(5)) == 5
+
+    assert "outside a bound function" in m.implicitly_convert_variable_fail(UserType(5))
+
+
+def test_operator_new_delete(capture):
+    """Tests that class-specific operator new/delete functions are invoked"""
+
+    class SubAliased(m.AliasedHasOpNewDelSize):
+        pass
+
+    with capture:
+        a = m.HasOpNewDel()
+        b = m.HasOpNewDelSize()
+        d = m.HasOpNewDelBoth()
+    assert (
+        capture
+        == """
+        A new 8
+        B new 4
+        D new 32
+    """
+    )
+    sz_alias = str(m.AliasedHasOpNewDelSize.size_alias)
+    sz_noalias = str(m.AliasedHasOpNewDelSize.size_noalias)
+    with capture:
+        c = m.AliasedHasOpNewDelSize()
+        c2 = SubAliased()
+    assert capture == ("C new " + sz_noalias + "\n" + "C new " + sz_alias + "\n")
+
+    with capture:
+        del a
+        pytest.gc_collect()
+        del b
+        pytest.gc_collect()
+        del d
+        pytest.gc_collect()
+    assert (
+        capture
+        == """
+        A delete
+        B delete 4
+        D delete
+    """
+    )
+
+    with capture:
+        del c
+        pytest.gc_collect()
+        del c2
+        pytest.gc_collect()
+    assert capture == ("C delete " + sz_noalias + "\n" + "C delete " + sz_alias + "\n")
+
+
+def test_bind_protected_functions():
+    """Expose protected member functions to Python using a helper class"""
+    a = m.ProtectedA()
+    assert a.foo() == 42
+
+    b = m.ProtectedB()
+    assert b.foo() == 42
+    assert m.read_foo(b.void_foo()) == 42
+    assert m.pointers_equal(b.get_self(), b)
+
+    class C(m.ProtectedB):
+        def __init__(self):
+            m.ProtectedB.__init__(self)
+
+        def foo(self):
+            return 0
+
+    c = C()
+    assert c.foo() == 0
+
+
+def test_brace_initialization():
+    """Tests that simple POD classes can be constructed using C++11 brace initialization"""
+    a = m.BraceInitialization(123, "test")
+    assert a.field1 == 123
+    assert a.field2 == "test"
+
+    # Tests that a non-simple class doesn't get brace initialization (if the
+    # class defines an initializer_list constructor, in particular, it would
+    # win over the expected constructor).
+    b = m.NoBraceInitialization([123, 456])
+    assert b.vec == [123, 456]
+
+
+@pytest.mark.xfail("env.PYPY")
+def test_class_refcount():
+    """Instances must correctly increase/decrease the reference count of their types (#1029)"""
+    from sys import getrefcount
+
+    class PyDog(m.Dog):
+        pass
+
+    for cls in m.Dog, PyDog:
+        refcount_1 = getrefcount(cls)
+        molly = [cls("Molly") for _ in range(10)]
+        refcount_2 = getrefcount(cls)
+
+        del molly
+        pytest.gc_collect()
+        refcount_3 = getrefcount(cls)
+
+        assert refcount_1 == refcount_3
+        assert refcount_2 > refcount_1
+
+
+def test_reentrant_implicit_conversion_failure(msg):
+    # ensure that there is no runaway reentrant implicit conversion (#1035)
+    with pytest.raises(TypeError) as excinfo:
+        m.BogusImplicitConversion(0)
+    assert (
+        msg(excinfo.value)
+        == """
+        __init__(): incompatible constructor arguments. The following argument types are supported:
+            1. m.class_.BogusImplicitConversion(arg0: m.class_.BogusImplicitConversion)
+
+        Invoked with: 0
+    """
+    )
+
+
+def test_error_after_conversions():
+    with pytest.raises(TypeError) as exc_info:
+        m.test_error_after_conversions("hello")
+    assert str(exc_info.value).startswith(
+        "Unable to convert function return value to a Python type!"
+    )
+
+
+def test_aligned():
+    if hasattr(m, "Aligned"):
+        p = m.Aligned().ptr()
+        assert p % 1024 == 0
+
+
+# https://foss.heptapod.net/pypy/pypy/-/issues/2742
+@pytest.mark.xfail("env.PYPY")
+def test_final():
+    with pytest.raises(TypeError) as exc_info:
+
+        class PyFinalChild(m.IsFinal):
+            pass
+
+    assert str(exc_info.value).endswith("is not an acceptable base type")
+
+
+# https://foss.heptapod.net/pypy/pypy/-/issues/2742
+@pytest.mark.xfail("env.PYPY")
+def test_non_final_final():
+    with pytest.raises(TypeError) as exc_info:
+
+        class PyNonFinalFinalChild(m.IsNonFinalFinal):
+            pass
+
+    assert str(exc_info.value).endswith("is not an acceptable base type")
+
+
+# https://github.com/pybind/pybind11/issues/1878
+def test_exception_rvalue_abort():
+    with pytest.raises(RuntimeError):
+        m.PyPrintDestructor().throw_something()
+
+
+# https://github.com/pybind/pybind11/issues/1568
+def test_multiple_instances_with_same_pointer(capture):
+    n = 100
+    instances = [m.SamePointer() for _ in range(n)]
+    for i in range(n):
+        # We need to reuse the same allocated memory for with a different type,
+        # to ensure the bug in `deregister_instance_impl` is detected. Otherwise
+        # `Py_TYPE(self) == Py_TYPE(it->second)` will still succeed, even though
+        # the `instance` is already deleted.
+        instances[i] = m.Empty()
+    # No assert: if this does not trigger the error
+    #   pybind11_fail("pybind11_object_dealloc(): Tried to deallocate unregistered instance!");
+    # and just completes without crashing, we're good.
+
+
+# https://github.com/pybind/pybind11/issues/1624
+def test_base_and_derived_nested_scope():
+    assert issubclass(m.DerivedWithNested, m.BaseWithNested)
+    assert m.BaseWithNested.Nested != m.DerivedWithNested.Nested
+    assert m.BaseWithNested.Nested.get_name() == "BaseWithNested::Nested"
+    assert m.DerivedWithNested.Nested.get_name() == "DerivedWithNested::Nested"
+
+
+def test_register_duplicate_class():
+    import types
+
+    module_scope = types.ModuleType("module_scope")
+    with pytest.raises(RuntimeError) as exc_info:
+        m.register_duplicate_class_name(module_scope)
+    expected = (
+        'generic_type: cannot initialize type "Duplicate": '
+        "an object with that name is already defined"
+    )
+    assert str(exc_info.value) == expected
+    with pytest.raises(RuntimeError) as exc_info:
+        m.register_duplicate_class_type(module_scope)
+    expected = 'generic_type: type "YetAnotherDuplicate" is already registered!'
+    assert str(exc_info.value) == expected
+
+    class ClassScope:
+        pass
+
+    with pytest.raises(RuntimeError) as exc_info:
+        m.register_duplicate_nested_class_name(ClassScope)
+    expected = (
+        'generic_type: cannot initialize type "DuplicateNested": '
+        "an object with that name is already defined"
+    )
+    assert str(exc_info.value) == expected
+    with pytest.raises(RuntimeError) as exc_info:
+        m.register_duplicate_nested_class_type(ClassScope)
+    expected = 'generic_type: type "YetAnotherDuplicateNested" is already registered!'
+    assert str(exc_info.value) == expected
+
+
+def test_pr4220_tripped_over_this():
+    assert (
+        m.Empty0().get_msg()
+        == "This is really only meant to exercise successful compilation."
+    )
```

## extern/pybind11/tests/test_const_name.py

 * *Ordering differences only*

```diff
@@ -1,29 +1,29 @@
-import pytest
-
-from pybind11_tests import const_name as m
-
-
-@pytest.mark.parametrize("func", (m.const_name_tests, m.underscore_tests))
-@pytest.mark.parametrize(
-    "selector, expected",
-    enumerate(
-        (
-            "",
-            "A",
-            "Bd",
-            "Cef",
-            "%",
-            "%",
-            "T1",
-            "U2",
-            "D1",
-            "E2",
-            "KeepAtEnd",
-        )
-    ),
-)
-def test_const_name(func, selector, expected):
-    if isinstance(func, str):
-        pytest.skip(func)
-    text = func(selector)
-    assert text == expected
+import pytest
+
+from pybind11_tests import const_name as m
+
+
+@pytest.mark.parametrize("func", (m.const_name_tests, m.underscore_tests))
+@pytest.mark.parametrize(
+    "selector, expected",
+    enumerate(
+        (
+            "",
+            "A",
+            "Bd",
+            "Cef",
+            "%",
+            "%",
+            "T1",
+            "U2",
+            "D1",
+            "E2",
+            "KeepAtEnd",
+        )
+    ),
+)
+def test_const_name(func, selector, expected):
+    if isinstance(func, str):
+        pytest.skip(func)
+    text = func(selector)
+    assert text == expected
```

## extern/pybind11/tests/test_constants_and_functions.py

 * *Ordering differences only*

```diff
@@ -1,52 +1,52 @@
-import pytest
-
-m = pytest.importorskip("pybind11_tests.constants_and_functions")
-
-
-def test_constants():
-    assert m.some_constant == 14
-
-
-def test_function_overloading():
-    assert m.test_function() == "test_function()"
-    assert m.test_function(7) == "test_function(7)"
-    assert m.test_function(m.MyEnum.EFirstEntry) == "test_function(enum=1)"
-    assert m.test_function(m.MyEnum.ESecondEntry) == "test_function(enum=2)"
-
-    assert m.test_function() == "test_function()"
-    assert m.test_function("abcd") == "test_function(char *)"
-    assert m.test_function(1, 1.0) == "test_function(int, float)"
-    assert m.test_function(1, 1.0) == "test_function(int, float)"
-    assert m.test_function(2.0, 2) == "test_function(float, int)"
-
-
-def test_bytes():
-    assert m.print_bytes(m.return_bytes()) == "bytes[1 0 2 0]"
-
-
-def test_exception_specifiers():
-    c = m.C()
-    assert c.m1(2) == 1
-    assert c.m2(3) == 1
-    assert c.m3(5) == 2
-    assert c.m4(7) == 3
-    assert c.m5(10) == 5
-    assert c.m6(14) == 8
-    assert c.m7(20) == 13
-    assert c.m8(29) == 21
-
-    assert m.f1(33) == 34
-    assert m.f2(53) == 55
-    assert m.f3(86) == 89
-    assert m.f4(140) == 144
-
-
-def test_function_record_leaks():
-    class RaisingRepr:
-        def __repr__(self):
-            raise RuntimeError("Surprise!")
-
-    with pytest.raises(RuntimeError):
-        m.register_large_capture_with_invalid_arguments(m)
-    with pytest.raises(RuntimeError):
-        m.register_with_raising_repr(m, RaisingRepr())
+import pytest
+
+m = pytest.importorskip("pybind11_tests.constants_and_functions")
+
+
+def test_constants():
+    assert m.some_constant == 14
+
+
+def test_function_overloading():
+    assert m.test_function() == "test_function()"
+    assert m.test_function(7) == "test_function(7)"
+    assert m.test_function(m.MyEnum.EFirstEntry) == "test_function(enum=1)"
+    assert m.test_function(m.MyEnum.ESecondEntry) == "test_function(enum=2)"
+
+    assert m.test_function() == "test_function()"
+    assert m.test_function("abcd") == "test_function(char *)"
+    assert m.test_function(1, 1.0) == "test_function(int, float)"
+    assert m.test_function(1, 1.0) == "test_function(int, float)"
+    assert m.test_function(2.0, 2) == "test_function(float, int)"
+
+
+def test_bytes():
+    assert m.print_bytes(m.return_bytes()) == "bytes[1 0 2 0]"
+
+
+def test_exception_specifiers():
+    c = m.C()
+    assert c.m1(2) == 1
+    assert c.m2(3) == 1
+    assert c.m3(5) == 2
+    assert c.m4(7) == 3
+    assert c.m5(10) == 5
+    assert c.m6(14) == 8
+    assert c.m7(20) == 13
+    assert c.m8(29) == 21
+
+    assert m.f1(33) == 34
+    assert m.f2(53) == 55
+    assert m.f3(86) == 89
+    assert m.f4(140) == 144
+
+
+def test_function_record_leaks():
+    class RaisingRepr:
+        def __repr__(self):
+            raise RuntimeError("Surprise!")
+
+    with pytest.raises(RuntimeError):
+        m.register_large_capture_with_invalid_arguments(m)
+    with pytest.raises(RuntimeError):
+        m.register_with_raising_repr(m, RaisingRepr())
```

## extern/pybind11/tests/test_copy_move.py

 * *Ordering differences only*

```diff
@@ -1,132 +1,132 @@
-import pytest
-
-from pybind11_tests import copy_move_policies as m
-
-
-def test_lacking_copy_ctor():
-    with pytest.raises(RuntimeError) as excinfo:
-        m.lacking_copy_ctor.get_one()
-    assert "is non-copyable!" in str(excinfo.value)
-
-
-def test_lacking_move_ctor():
-    with pytest.raises(RuntimeError) as excinfo:
-        m.lacking_move_ctor.get_one()
-    assert "is neither movable nor copyable!" in str(excinfo.value)
-
-
-def test_move_and_copy_casts():
-    """Cast some values in C++ via custom type casters and count the number of moves/copies."""
-
-    cstats = m.move_and_copy_cstats()
-    c_m, c_mc, c_c = (
-        cstats["MoveOnlyInt"],
-        cstats["MoveOrCopyInt"],
-        cstats["CopyOnlyInt"],
-    )
-
-    # The type move constructions/assignments below each get incremented: the move assignment comes
-    # from the type_caster load; the move construction happens when extracting that via a cast or
-    # loading into an argument.
-    assert m.move_and_copy_casts(3) == 18
-    assert c_m.copy_assignments + c_m.copy_constructions == 0
-    assert c_m.move_assignments == 2
-    assert c_m.move_constructions >= 2
-    assert c_mc.alive() == 0
-    assert c_mc.copy_assignments + c_mc.copy_constructions == 0
-    assert c_mc.move_assignments == 2
-    assert c_mc.move_constructions >= 2
-    assert c_c.alive() == 0
-    assert c_c.copy_assignments == 2
-    assert c_c.copy_constructions >= 2
-    assert c_m.alive() + c_mc.alive() + c_c.alive() == 0
-
-
-def test_move_and_copy_loads():
-    """Call some functions that load arguments via custom type casters and count the number of
-    moves/copies."""
-
-    cstats = m.move_and_copy_cstats()
-    c_m, c_mc, c_c = (
-        cstats["MoveOnlyInt"],
-        cstats["MoveOrCopyInt"],
-        cstats["CopyOnlyInt"],
-    )
-
-    assert m.move_only(10) == 10  # 1 move, c_m
-    assert m.move_or_copy(11) == 11  # 1 move, c_mc
-    assert m.copy_only(12) == 12  # 1 copy, c_c
-    assert m.move_pair((13, 14)) == 27  # 1 c_m move, 1 c_mc move
-    assert m.move_tuple((15, 16, 17)) == 48  # 2 c_m moves, 1 c_mc move
-    assert m.copy_tuple((18, 19)) == 37  # 2 c_c copies
-    # Direct constructions: 2 c_m moves, 2 c_mc moves, 1 c_c copy
-    # Extra moves/copies when moving pairs/tuples: 3 c_m, 3 c_mc, 2 c_c
-    assert m.move_copy_nested((1, ((2, 3, (4,)), 5))) == 15
-
-    assert c_m.copy_assignments + c_m.copy_constructions == 0
-    assert c_m.move_assignments == 6
-    assert c_m.move_constructions == 9
-    assert c_mc.copy_assignments + c_mc.copy_constructions == 0
-    assert c_mc.move_assignments == 5
-    assert c_mc.move_constructions == 8
-    assert c_c.copy_assignments == 4
-    assert c_c.copy_constructions == 6
-    assert c_m.alive() + c_mc.alive() + c_c.alive() == 0
-
-
-@pytest.mark.skipif(not m.has_optional, reason="no <optional>")
-def test_move_and_copy_load_optional():
-    """Tests move/copy loads of std::optional arguments"""
-
-    cstats = m.move_and_copy_cstats()
-    c_m, c_mc, c_c = (
-        cstats["MoveOnlyInt"],
-        cstats["MoveOrCopyInt"],
-        cstats["CopyOnlyInt"],
-    )
-
-    # The extra move/copy constructions below come from the std::optional move (which has to move
-    # its arguments):
-    assert m.move_optional(10) == 10  # c_m: 1 move assign, 2 move construct
-    assert m.move_or_copy_optional(11) == 11  # c_mc: 1 move assign, 2 move construct
-    assert m.copy_optional(12) == 12  # c_c: 1 copy assign, 2 copy construct
-    # 1 move assign + move construct moves each of c_m, c_mc, 1 c_c copy
-    # +1 move/copy construct each from moving the tuple
-    # +1 move/copy construct each from moving the optional (which moves the tuple again)
-    assert m.move_optional_tuple((3, 4, 5)) == 12
-
-    assert c_m.copy_assignments + c_m.copy_constructions == 0
-    assert c_m.move_assignments == 2
-    assert c_m.move_constructions == 5
-    assert c_mc.copy_assignments + c_mc.copy_constructions == 0
-    assert c_mc.move_assignments == 2
-    assert c_mc.move_constructions == 5
-    assert c_c.copy_assignments == 2
-    assert c_c.copy_constructions == 5
-    assert c_m.alive() + c_mc.alive() + c_c.alive() == 0
-
-
-def test_private_op_new():
-    """An object with a private `operator new` cannot be returned by value"""
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.private_op_new_value()
-    assert "is neither movable nor copyable" in str(excinfo.value)
-
-    assert m.private_op_new_reference().value == 1
-
-
-def test_move_fallback():
-    """#389: rvp::move should fall-through to copy on non-movable objects"""
-
-    m1 = m.get_moveissue1(1)
-    assert m1.value == 1
-    m2 = m.get_moveissue2(2)
-    assert m2.value == 2
-
-
-def test_pytype_rvalue_cast():
-    """Make sure that cast from pytype rvalue to other pytype works"""
-
-    value = m.get_pytype_rvalue_castissue(1.0)
-    assert value == 1
+import pytest
+
+from pybind11_tests import copy_move_policies as m
+
+
+def test_lacking_copy_ctor():
+    with pytest.raises(RuntimeError) as excinfo:
+        m.lacking_copy_ctor.get_one()
+    assert "is non-copyable!" in str(excinfo.value)
+
+
+def test_lacking_move_ctor():
+    with pytest.raises(RuntimeError) as excinfo:
+        m.lacking_move_ctor.get_one()
+    assert "is neither movable nor copyable!" in str(excinfo.value)
+
+
+def test_move_and_copy_casts():
+    """Cast some values in C++ via custom type casters and count the number of moves/copies."""
+
+    cstats = m.move_and_copy_cstats()
+    c_m, c_mc, c_c = (
+        cstats["MoveOnlyInt"],
+        cstats["MoveOrCopyInt"],
+        cstats["CopyOnlyInt"],
+    )
+
+    # The type move constructions/assignments below each get incremented: the move assignment comes
+    # from the type_caster load; the move construction happens when extracting that via a cast or
+    # loading into an argument.
+    assert m.move_and_copy_casts(3) == 18
+    assert c_m.copy_assignments + c_m.copy_constructions == 0
+    assert c_m.move_assignments == 2
+    assert c_m.move_constructions >= 2
+    assert c_mc.alive() == 0
+    assert c_mc.copy_assignments + c_mc.copy_constructions == 0
+    assert c_mc.move_assignments == 2
+    assert c_mc.move_constructions >= 2
+    assert c_c.alive() == 0
+    assert c_c.copy_assignments == 2
+    assert c_c.copy_constructions >= 2
+    assert c_m.alive() + c_mc.alive() + c_c.alive() == 0
+
+
+def test_move_and_copy_loads():
+    """Call some functions that load arguments via custom type casters and count the number of
+    moves/copies."""
+
+    cstats = m.move_and_copy_cstats()
+    c_m, c_mc, c_c = (
+        cstats["MoveOnlyInt"],
+        cstats["MoveOrCopyInt"],
+        cstats["CopyOnlyInt"],
+    )
+
+    assert m.move_only(10) == 10  # 1 move, c_m
+    assert m.move_or_copy(11) == 11  # 1 move, c_mc
+    assert m.copy_only(12) == 12  # 1 copy, c_c
+    assert m.move_pair((13, 14)) == 27  # 1 c_m move, 1 c_mc move
+    assert m.move_tuple((15, 16, 17)) == 48  # 2 c_m moves, 1 c_mc move
+    assert m.copy_tuple((18, 19)) == 37  # 2 c_c copies
+    # Direct constructions: 2 c_m moves, 2 c_mc moves, 1 c_c copy
+    # Extra moves/copies when moving pairs/tuples: 3 c_m, 3 c_mc, 2 c_c
+    assert m.move_copy_nested((1, ((2, 3, (4,)), 5))) == 15
+
+    assert c_m.copy_assignments + c_m.copy_constructions == 0
+    assert c_m.move_assignments == 6
+    assert c_m.move_constructions == 9
+    assert c_mc.copy_assignments + c_mc.copy_constructions == 0
+    assert c_mc.move_assignments == 5
+    assert c_mc.move_constructions == 8
+    assert c_c.copy_assignments == 4
+    assert c_c.copy_constructions == 6
+    assert c_m.alive() + c_mc.alive() + c_c.alive() == 0
+
+
+@pytest.mark.skipif(not m.has_optional, reason="no <optional>")
+def test_move_and_copy_load_optional():
+    """Tests move/copy loads of std::optional arguments"""
+
+    cstats = m.move_and_copy_cstats()
+    c_m, c_mc, c_c = (
+        cstats["MoveOnlyInt"],
+        cstats["MoveOrCopyInt"],
+        cstats["CopyOnlyInt"],
+    )
+
+    # The extra move/copy constructions below come from the std::optional move (which has to move
+    # its arguments):
+    assert m.move_optional(10) == 10  # c_m: 1 move assign, 2 move construct
+    assert m.move_or_copy_optional(11) == 11  # c_mc: 1 move assign, 2 move construct
+    assert m.copy_optional(12) == 12  # c_c: 1 copy assign, 2 copy construct
+    # 1 move assign + move construct moves each of c_m, c_mc, 1 c_c copy
+    # +1 move/copy construct each from moving the tuple
+    # +1 move/copy construct each from moving the optional (which moves the tuple again)
+    assert m.move_optional_tuple((3, 4, 5)) == 12
+
+    assert c_m.copy_assignments + c_m.copy_constructions == 0
+    assert c_m.move_assignments == 2
+    assert c_m.move_constructions == 5
+    assert c_mc.copy_assignments + c_mc.copy_constructions == 0
+    assert c_mc.move_assignments == 2
+    assert c_mc.move_constructions == 5
+    assert c_c.copy_assignments == 2
+    assert c_c.copy_constructions == 5
+    assert c_m.alive() + c_mc.alive() + c_c.alive() == 0
+
+
+def test_private_op_new():
+    """An object with a private `operator new` cannot be returned by value"""
+
+    with pytest.raises(RuntimeError) as excinfo:
+        m.private_op_new_value()
+    assert "is neither movable nor copyable" in str(excinfo.value)
+
+    assert m.private_op_new_reference().value == 1
+
+
+def test_move_fallback():
+    """#389: rvp::move should fall-through to copy on non-movable objects"""
+
+    m1 = m.get_moveissue1(1)
+    assert m1.value == 1
+    m2 = m.get_moveissue2(2)
+    assert m2.value == 2
+
+
+def test_pytype_rvalue_cast():
+    """Make sure that cast from pytype rvalue to other pytype works"""
+
+    value = m.get_pytype_rvalue_castissue(1.0)
+    assert value == 1
```

## extern/pybind11/tests/test_custom_type_casters.py

 * *Ordering differences only*

```diff
@@ -1,121 +1,121 @@
-import pytest
-
-from pybind11_tests import custom_type_casters as m
-
-
-def test_noconvert_args(msg):
-    a = m.ArgInspector()
-    assert (
-        msg(a.f("hi"))
-        == """
-        loading ArgInspector1 argument WITH conversion allowed.  Argument value = hi
-    """
-    )
-    assert (
-        msg(a.g("this is a", "this is b"))
-        == """
-        loading ArgInspector1 argument WITHOUT conversion allowed.  Argument value = this is a
-        loading ArgInspector1 argument WITH conversion allowed.  Argument value = this is b
-        13
-        loading ArgInspector2 argument WITH conversion allowed.  Argument value = (default arg inspector 2)
-    """
-    )
-    assert (
-        msg(a.g("this is a", "this is b", 42))
-        == """
-        loading ArgInspector1 argument WITHOUT conversion allowed.  Argument value = this is a
-        loading ArgInspector1 argument WITH conversion allowed.  Argument value = this is b
-        42
-        loading ArgInspector2 argument WITH conversion allowed.  Argument value = (default arg inspector 2)
-    """
-    )
-    assert (
-        msg(a.g("this is a", "this is b", 42, "this is d"))
-        == """
-        loading ArgInspector1 argument WITHOUT conversion allowed.  Argument value = this is a
-        loading ArgInspector1 argument WITH conversion allowed.  Argument value = this is b
-        42
-        loading ArgInspector2 argument WITH conversion allowed.  Argument value = this is d
-    """
-    )
-    assert (
-        a.h("arg 1")
-        == "loading ArgInspector2 argument WITHOUT conversion allowed.  Argument value = arg 1"
-    )
-    assert (
-        msg(m.arg_inspect_func("A1", "A2"))
-        == """
-        loading ArgInspector2 argument WITH conversion allowed.  Argument value = A1
-        loading ArgInspector1 argument WITHOUT conversion allowed.  Argument value = A2
-    """
-    )
-
-    assert m.floats_preferred(4) == 2.0
-    assert m.floats_only(4.0) == 2.0
-    with pytest.raises(TypeError) as excinfo:
-        m.floats_only(4)
-    assert (
-        msg(excinfo.value)
-        == """
-        floats_only(): incompatible function arguments. The following argument types are supported:
-            1. (f: float) -> float
-
-        Invoked with: 4
-    """
-    )
-
-    assert m.ints_preferred(4) == 2
-    assert m.ints_preferred(True) == 0
-    with pytest.raises(TypeError) as excinfo:
-        m.ints_preferred(4.0)
-    assert (
-        msg(excinfo.value)
-        == """
-        ints_preferred(): incompatible function arguments. The following argument types are supported:
-            1. (i: int) -> int
-
-        Invoked with: 4.0
-    """
-    )
-
-    assert m.ints_only(4) == 2
-    with pytest.raises(TypeError) as excinfo:
-        m.ints_only(4.0)
-    assert (
-        msg(excinfo.value)
-        == """
-        ints_only(): incompatible function arguments. The following argument types are supported:
-            1. (i: int) -> int
-
-        Invoked with: 4.0
-    """
-    )
-
-
-def test_custom_caster_destruction():
-    """Tests that returning a pointer to a type that gets converted with a custom type caster gets
-    destroyed when the function has py::return_value_policy::take_ownership policy applied.
-    """
-
-    cstats = m.destruction_tester_cstats()
-    # This one *doesn't* have take_ownership: the pointer should be used but not destroyed:
-    z = m.custom_caster_no_destroy()
-    assert cstats.alive() == 1 and cstats.default_constructions == 1
-    assert z
-
-    # take_ownership applied: this constructs a new object, casts it, then destroys it:
-    z = m.custom_caster_destroy()
-    assert z
-    assert cstats.default_constructions == 2
-
-    # Same, but with a const pointer return (which should *not* inhibit destruction):
-    z = m.custom_caster_destroy_const()
-    assert z
-    assert cstats.default_constructions == 3
-
-    # Make sure we still only have the original object (from ..._no_destroy()) alive:
-    assert cstats.alive() == 1
-
-
-def test_custom_caster_other_lib():
-    assert m.other_lib_type(True)
+import pytest
+
+from pybind11_tests import custom_type_casters as m
+
+
+def test_noconvert_args(msg):
+    a = m.ArgInspector()
+    assert (
+        msg(a.f("hi"))
+        == """
+        loading ArgInspector1 argument WITH conversion allowed.  Argument value = hi
+    """
+    )
+    assert (
+        msg(a.g("this is a", "this is b"))
+        == """
+        loading ArgInspector1 argument WITHOUT conversion allowed.  Argument value = this is a
+        loading ArgInspector1 argument WITH conversion allowed.  Argument value = this is b
+        13
+        loading ArgInspector2 argument WITH conversion allowed.  Argument value = (default arg inspector 2)
+    """
+    )
+    assert (
+        msg(a.g("this is a", "this is b", 42))
+        == """
+        loading ArgInspector1 argument WITHOUT conversion allowed.  Argument value = this is a
+        loading ArgInspector1 argument WITH conversion allowed.  Argument value = this is b
+        42
+        loading ArgInspector2 argument WITH conversion allowed.  Argument value = (default arg inspector 2)
+    """
+    )
+    assert (
+        msg(a.g("this is a", "this is b", 42, "this is d"))
+        == """
+        loading ArgInspector1 argument WITHOUT conversion allowed.  Argument value = this is a
+        loading ArgInspector1 argument WITH conversion allowed.  Argument value = this is b
+        42
+        loading ArgInspector2 argument WITH conversion allowed.  Argument value = this is d
+    """
+    )
+    assert (
+        a.h("arg 1")
+        == "loading ArgInspector2 argument WITHOUT conversion allowed.  Argument value = arg 1"
+    )
+    assert (
+        msg(m.arg_inspect_func("A1", "A2"))
+        == """
+        loading ArgInspector2 argument WITH conversion allowed.  Argument value = A1
+        loading ArgInspector1 argument WITHOUT conversion allowed.  Argument value = A2
+    """
+    )
+
+    assert m.floats_preferred(4) == 2.0
+    assert m.floats_only(4.0) == 2.0
+    with pytest.raises(TypeError) as excinfo:
+        m.floats_only(4)
+    assert (
+        msg(excinfo.value)
+        == """
+        floats_only(): incompatible function arguments. The following argument types are supported:
+            1. (f: float) -> float
+
+        Invoked with: 4
+    """
+    )
+
+    assert m.ints_preferred(4) == 2
+    assert m.ints_preferred(True) == 0
+    with pytest.raises(TypeError) as excinfo:
+        m.ints_preferred(4.0)
+    assert (
+        msg(excinfo.value)
+        == """
+        ints_preferred(): incompatible function arguments. The following argument types are supported:
+            1. (i: int) -> int
+
+        Invoked with: 4.0
+    """
+    )
+
+    assert m.ints_only(4) == 2
+    with pytest.raises(TypeError) as excinfo:
+        m.ints_only(4.0)
+    assert (
+        msg(excinfo.value)
+        == """
+        ints_only(): incompatible function arguments. The following argument types are supported:
+            1. (i: int) -> int
+
+        Invoked with: 4.0
+    """
+    )
+
+
+def test_custom_caster_destruction():
+    """Tests that returning a pointer to a type that gets converted with a custom type caster gets
+    destroyed when the function has py::return_value_policy::take_ownership policy applied.
+    """
+
+    cstats = m.destruction_tester_cstats()
+    # This one *doesn't* have take_ownership: the pointer should be used but not destroyed:
+    z = m.custom_caster_no_destroy()
+    assert cstats.alive() == 1 and cstats.default_constructions == 1
+    assert z
+
+    # take_ownership applied: this constructs a new object, casts it, then destroys it:
+    z = m.custom_caster_destroy()
+    assert z
+    assert cstats.default_constructions == 2
+
+    # Same, but with a const pointer return (which should *not* inhibit destruction):
+    z = m.custom_caster_destroy_const()
+    assert z
+    assert cstats.default_constructions == 3
+
+    # Make sure we still only have the original object (from ..._no_destroy()) alive:
+    assert cstats.alive() == 1
+
+
+def test_custom_caster_other_lib():
+    assert m.other_lib_type(True)
```

## extern/pybind11/tests/test_custom_type_setup.py

 * *Ordering differences only*

```diff
@@ -1,48 +1,48 @@
-import gc
-import weakref
-
-import pytest
-
-import env  # noqa: F401
-from pybind11_tests import custom_type_setup as m
-
-
-@pytest.fixture
-def gc_tester():
-    """Tests that an object is garbage collected.
-
-    Assumes that any unreferenced objects are fully collected after calling
-    `gc.collect()`.  That is true on CPython, but does not appear to reliably
-    hold on PyPy.
-    """
-
-    weak_refs = []
-
-    def add_ref(obj):
-        # PyPy does not support `gc.is_tracked`.
-        if hasattr(gc, "is_tracked"):
-            assert gc.is_tracked(obj)
-        weak_refs.append(weakref.ref(obj))
-
-    yield add_ref
-
-    gc.collect()
-    for ref in weak_refs:
-        assert ref() is None
-
-
-# PyPy does not seem to reliably garbage collect.
-@pytest.mark.skipif("env.PYPY")
-def test_self_cycle(gc_tester):
-    obj = m.OwnsPythonObjects()
-    obj.value = obj
-    gc_tester(obj)
-
-
-# PyPy does not seem to reliably garbage collect.
-@pytest.mark.skipif("env.PYPY")
-def test_indirect_cycle(gc_tester):
-    obj = m.OwnsPythonObjects()
-    obj_list = [obj]
-    obj.value = obj_list
-    gc_tester(obj)
+import gc
+import weakref
+
+import pytest
+
+import env  # noqa: F401
+from pybind11_tests import custom_type_setup as m
+
+
+@pytest.fixture
+def gc_tester():
+    """Tests that an object is garbage collected.
+
+    Assumes that any unreferenced objects are fully collected after calling
+    `gc.collect()`.  That is true on CPython, but does not appear to reliably
+    hold on PyPy.
+    """
+
+    weak_refs = []
+
+    def add_ref(obj):
+        # PyPy does not support `gc.is_tracked`.
+        if hasattr(gc, "is_tracked"):
+            assert gc.is_tracked(obj)
+        weak_refs.append(weakref.ref(obj))
+
+    yield add_ref
+
+    gc.collect()
+    for ref in weak_refs:
+        assert ref() is None
+
+
+# PyPy does not seem to reliably garbage collect.
+@pytest.mark.skipif("env.PYPY")
+def test_self_cycle(gc_tester):
+    obj = m.OwnsPythonObjects()
+    obj.value = obj
+    gc_tester(obj)
+
+
+# PyPy does not seem to reliably garbage collect.
+@pytest.mark.skipif("env.PYPY")
+def test_indirect_cycle(gc_tester):
+    obj = m.OwnsPythonObjects()
+    obj_list = [obj]
+    obj.value = obj_list
+    gc_tester(obj)
```

## extern/pybind11/tests/test_docstring_options.py

 * *Ordering differences only*

```diff
@@ -1,64 +1,64 @@
-from pybind11_tests import docstring_options as m
-
-
-def test_docstring_options():
-    # options.disable_function_signatures()
-    assert not m.test_function1.__doc__
-
-    assert m.test_function2.__doc__ == "A custom docstring"
-
-    # docstring specified on just the first overload definition:
-    assert m.test_overloaded1.__doc__ == "Overload docstring"
-
-    # docstring on both overloads:
-    assert m.test_overloaded2.__doc__ == "overload docstring 1\noverload docstring 2"
-
-    # docstring on only second overload:
-    assert m.test_overloaded3.__doc__ == "Overload docstr"
-
-    # options.enable_function_signatures()
-    assert m.test_function3.__doc__.startswith("test_function3(a: int, b: int) -> None")
-
-    assert m.test_function4.__doc__.startswith("test_function4(a: int, b: int) -> None")
-    assert m.test_function4.__doc__.endswith("A custom docstring\n")
-
-    # options.disable_function_signatures()
-    # options.disable_user_defined_docstrings()
-    assert not m.test_function5.__doc__
-
-    # nested options.enable_user_defined_docstrings()
-    assert m.test_function6.__doc__ == "A custom docstring"
-
-    # RAII destructor
-    assert m.test_function7.__doc__.startswith("test_function7(a: int, b: int) -> None")
-    assert m.test_function7.__doc__.endswith("A custom docstring\n")
-
-    # when all options are disabled, no docstring (instead of an empty one) should be generated
-    assert m.test_function8.__doc__ is None
-
-    # Suppression of user-defined docstrings for non-function objects
-    assert not m.DocstringTestFoo.__doc__
-    assert not m.DocstringTestFoo.value_prop.__doc__
-
-    # Check existig behaviour of enum docstings
-    assert (
-        m.DocstringTestEnum1.__doc__
-        == "Enum docstring\n\nMembers:\n\n  Member1\n\n  Member2"
-    )
-
-    # options.enable_enum_members_docstring()
-    assert (
-        m.DocstringTestEnum2.__doc__
-        == "Enum docstring\n\nMembers:\n\n  Member1\n\n  Member2"
-    )
-
-    # options.disable_enum_members_docstring()
-    assert m.DocstringTestEnum3.__doc__ == "Enum docstring"
-
-    # options.disable_user_defined_docstrings()
-    assert m.DocstringTestEnum4.__doc__ == "Members:\n\n  Member1\n\n  Member2"
-
-    # options.disable_user_defined_docstrings()
-    # options.disable_enum_members_docstring()
-    # When all options are disabled, no docstring (instead of an empty one) should be generated
-    assert m.DocstringTestEnum5.__doc__ is None
+from pybind11_tests import docstring_options as m
+
+
+def test_docstring_options():
+    # options.disable_function_signatures()
+    assert not m.test_function1.__doc__
+
+    assert m.test_function2.__doc__ == "A custom docstring"
+
+    # docstring specified on just the first overload definition:
+    assert m.test_overloaded1.__doc__ == "Overload docstring"
+
+    # docstring on both overloads:
+    assert m.test_overloaded2.__doc__ == "overload docstring 1\noverload docstring 2"
+
+    # docstring on only second overload:
+    assert m.test_overloaded3.__doc__ == "Overload docstr"
+
+    # options.enable_function_signatures()
+    assert m.test_function3.__doc__.startswith("test_function3(a: int, b: int) -> None")
+
+    assert m.test_function4.__doc__.startswith("test_function4(a: int, b: int) -> None")
+    assert m.test_function4.__doc__.endswith("A custom docstring\n")
+
+    # options.disable_function_signatures()
+    # options.disable_user_defined_docstrings()
+    assert not m.test_function5.__doc__
+
+    # nested options.enable_user_defined_docstrings()
+    assert m.test_function6.__doc__ == "A custom docstring"
+
+    # RAII destructor
+    assert m.test_function7.__doc__.startswith("test_function7(a: int, b: int) -> None")
+    assert m.test_function7.__doc__.endswith("A custom docstring\n")
+
+    # when all options are disabled, no docstring (instead of an empty one) should be generated
+    assert m.test_function8.__doc__ is None
+
+    # Suppression of user-defined docstrings for non-function objects
+    assert not m.DocstringTestFoo.__doc__
+    assert not m.DocstringTestFoo.value_prop.__doc__
+
+    # Check existig behaviour of enum docstings
+    assert (
+        m.DocstringTestEnum1.__doc__
+        == "Enum docstring\n\nMembers:\n\n  Member1\n\n  Member2"
+    )
+
+    # options.enable_enum_members_docstring()
+    assert (
+        m.DocstringTestEnum2.__doc__
+        == "Enum docstring\n\nMembers:\n\n  Member1\n\n  Member2"
+    )
+
+    # options.disable_enum_members_docstring()
+    assert m.DocstringTestEnum3.__doc__ == "Enum docstring"
+
+    # options.disable_user_defined_docstrings()
+    assert m.DocstringTestEnum4.__doc__ == "Members:\n\n  Member1\n\n  Member2"
+
+    # options.disable_user_defined_docstrings()
+    # options.disable_enum_members_docstring()
+    # When all options are disabled, no docstring (instead of an empty one) should be generated
+    assert m.DocstringTestEnum5.__doc__ is None
```

## extern/pybind11/tests/test_eigen_matrix.py

 * *Ordering differences only*

```diff
@@ -1,784 +1,784 @@
-import pytest
-
-from pybind11_tests import ConstructorStats
-
-np = pytest.importorskip("numpy")
-m = pytest.importorskip("pybind11_tests.eigen_matrix")
-
-
-ref = np.array(
-    [
-        [0.0, 3, 0, 0, 0, 11],
-        [22, 0, 0, 0, 17, 11],
-        [7, 5, 0, 1, 0, 11],
-        [0, 0, 0, 0, 0, 11],
-        [0, 0, 14, 0, 8, 11],
-    ]
-)
-
-
-def assert_equal_ref(mat):
-    np.testing.assert_array_equal(mat, ref)
-
-
-def assert_sparse_equal_ref(sparse_mat):
-    assert_equal_ref(sparse_mat.toarray())
-
-
-def test_fixed():
-    assert_equal_ref(m.fixed_c())
-    assert_equal_ref(m.fixed_r())
-    assert_equal_ref(m.fixed_copy_r(m.fixed_r()))
-    assert_equal_ref(m.fixed_copy_c(m.fixed_c()))
-    assert_equal_ref(m.fixed_copy_r(m.fixed_c()))
-    assert_equal_ref(m.fixed_copy_c(m.fixed_r()))
-
-
-def test_dense():
-    assert_equal_ref(m.dense_r())
-    assert_equal_ref(m.dense_c())
-    assert_equal_ref(m.dense_copy_r(m.dense_r()))
-    assert_equal_ref(m.dense_copy_c(m.dense_c()))
-    assert_equal_ref(m.dense_copy_r(m.dense_c()))
-    assert_equal_ref(m.dense_copy_c(m.dense_r()))
-
-
-def test_partially_fixed():
-    ref2 = np.array([[0.0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]])
-    np.testing.assert_array_equal(m.partial_copy_four_rm_r(ref2), ref2)
-    np.testing.assert_array_equal(m.partial_copy_four_rm_c(ref2), ref2)
-    np.testing.assert_array_equal(m.partial_copy_four_rm_r(ref2[:, 1]), ref2[:, [1]])
-    np.testing.assert_array_equal(m.partial_copy_four_rm_c(ref2[0, :]), ref2[[0], :])
-    np.testing.assert_array_equal(
-        m.partial_copy_four_rm_r(ref2[:, (0, 2)]), ref2[:, (0, 2)]
-    )
-    np.testing.assert_array_equal(
-        m.partial_copy_four_rm_c(ref2[(3, 1, 2), :]), ref2[(3, 1, 2), :]
-    )
-
-    np.testing.assert_array_equal(m.partial_copy_four_cm_r(ref2), ref2)
-    np.testing.assert_array_equal(m.partial_copy_four_cm_c(ref2), ref2)
-    np.testing.assert_array_equal(m.partial_copy_four_cm_r(ref2[:, 1]), ref2[:, [1]])
-    np.testing.assert_array_equal(m.partial_copy_four_cm_c(ref2[0, :]), ref2[[0], :])
-    np.testing.assert_array_equal(
-        m.partial_copy_four_cm_r(ref2[:, (0, 2)]), ref2[:, (0, 2)]
-    )
-    np.testing.assert_array_equal(
-        m.partial_copy_four_cm_c(ref2[(3, 1, 2), :]), ref2[(3, 1, 2), :]
-    )
-
-    # TypeError should be raise for a shape mismatch
-    functions = [
-        m.partial_copy_four_rm_r,
-        m.partial_copy_four_rm_c,
-        m.partial_copy_four_cm_r,
-        m.partial_copy_four_cm_c,
-    ]
-    matrix_with_wrong_shape = [[1, 2], [3, 4]]
-    for f in functions:
-        with pytest.raises(TypeError) as excinfo:
-            f(matrix_with_wrong_shape)
-        assert "incompatible function arguments" in str(excinfo.value)
-
-
-def test_mutator_descriptors():
-    zr = np.arange(30, dtype="float32").reshape(5, 6)  # row-major
-    zc = zr.reshape(6, 5).transpose()  # column-major
-
-    m.fixed_mutator_r(zr)
-    m.fixed_mutator_c(zc)
-    m.fixed_mutator_a(zr)
-    m.fixed_mutator_a(zc)
-    with pytest.raises(TypeError) as excinfo:
-        m.fixed_mutator_r(zc)
-    assert (
-        "(arg0: numpy.ndarray[numpy.float32[5, 6],"
-        " flags.writeable, flags.c_contiguous]) -> None" in str(excinfo.value)
-    )
-    with pytest.raises(TypeError) as excinfo:
-        m.fixed_mutator_c(zr)
-    assert (
-        "(arg0: numpy.ndarray[numpy.float32[5, 6],"
-        " flags.writeable, flags.f_contiguous]) -> None" in str(excinfo.value)
-    )
-    with pytest.raises(TypeError) as excinfo:
-        m.fixed_mutator_a(np.array([[1, 2], [3, 4]], dtype="float32"))
-    assert "(arg0: numpy.ndarray[numpy.float32[5, 6], flags.writeable]) -> None" in str(
-        excinfo.value
-    )
-    zr.flags.writeable = False
-    with pytest.raises(TypeError):
-        m.fixed_mutator_r(zr)
-    with pytest.raises(TypeError):
-        m.fixed_mutator_a(zr)
-
-
-def test_cpp_casting():
-    assert m.cpp_copy(m.fixed_r()) == 22.0
-    assert m.cpp_copy(m.fixed_c()) == 22.0
-    z = np.array([[5.0, 6], [7, 8]])
-    assert m.cpp_copy(z) == 7.0
-    assert m.cpp_copy(m.get_cm_ref()) == 21.0
-    assert m.cpp_copy(m.get_rm_ref()) == 21.0
-    assert m.cpp_ref_c(m.get_cm_ref()) == 21.0
-    assert m.cpp_ref_r(m.get_rm_ref()) == 21.0
-    with pytest.raises(RuntimeError) as excinfo:
-        # Can't reference m.fixed_c: it contains floats, m.cpp_ref_any wants doubles
-        m.cpp_ref_any(m.fixed_c())
-    assert "Unable to cast Python instance" in str(excinfo.value)
-    with pytest.raises(RuntimeError) as excinfo:
-        # Can't reference m.fixed_r: it contains floats, m.cpp_ref_any wants doubles
-        m.cpp_ref_any(m.fixed_r())
-    assert "Unable to cast Python instance" in str(excinfo.value)
-    assert m.cpp_ref_any(m.ReturnTester.create()) == 1.0
-
-    assert m.cpp_ref_any(m.get_cm_ref()) == 21.0
-    assert m.cpp_ref_any(m.get_cm_ref()) == 21.0
-
-
-def test_pass_readonly_array():
-    z = np.full((5, 6), 42.0)
-    z.flags.writeable = False
-    np.testing.assert_array_equal(z, m.fixed_copy_r(z))
-    np.testing.assert_array_equal(m.fixed_r_const(), m.fixed_r())
-    assert not m.fixed_r_const().flags.writeable
-    np.testing.assert_array_equal(m.fixed_copy_r(m.fixed_r_const()), m.fixed_r_const())
-
-
-def test_nonunit_stride_from_python():
-    counting_mat = np.arange(9.0, dtype=np.float32).reshape((3, 3))
-    second_row = counting_mat[1, :]
-    second_col = counting_mat[:, 1]
-    np.testing.assert_array_equal(m.double_row(second_row), 2.0 * second_row)
-    np.testing.assert_array_equal(m.double_col(second_row), 2.0 * second_row)
-    np.testing.assert_array_equal(m.double_complex(second_row), 2.0 * second_row)
-    np.testing.assert_array_equal(m.double_row(second_col), 2.0 * second_col)
-    np.testing.assert_array_equal(m.double_col(second_col), 2.0 * second_col)
-    np.testing.assert_array_equal(m.double_complex(second_col), 2.0 * second_col)
-
-    counting_3d = np.arange(27.0, dtype=np.float32).reshape((3, 3, 3))
-    slices = [counting_3d[0, :, :], counting_3d[:, 0, :], counting_3d[:, :, 0]]
-    for ref_mat in slices:
-        np.testing.assert_array_equal(m.double_mat_cm(ref_mat), 2.0 * ref_mat)
-        np.testing.assert_array_equal(m.double_mat_rm(ref_mat), 2.0 * ref_mat)
-
-    # Mutator:
-    m.double_threer(second_row)
-    m.double_threec(second_col)
-    np.testing.assert_array_equal(counting_mat, [[0.0, 2, 2], [6, 16, 10], [6, 14, 8]])
-
-
-def test_negative_stride_from_python(msg):
-    """Eigen doesn't support (as of yet) negative strides. When a function takes an Eigen matrix by
-    copy or const reference, we can pass a numpy array that has negative strides.  Otherwise, an
-    exception will be thrown as Eigen will not be able to map the numpy array."""
-
-    counting_mat = np.arange(9.0, dtype=np.float32).reshape((3, 3))
-    counting_mat = counting_mat[::-1, ::-1]
-    second_row = counting_mat[1, :]
-    second_col = counting_mat[:, 1]
-    np.testing.assert_array_equal(m.double_row(second_row), 2.0 * second_row)
-    np.testing.assert_array_equal(m.double_col(second_row), 2.0 * second_row)
-    np.testing.assert_array_equal(m.double_complex(second_row), 2.0 * second_row)
-    np.testing.assert_array_equal(m.double_row(second_col), 2.0 * second_col)
-    np.testing.assert_array_equal(m.double_col(second_col), 2.0 * second_col)
-    np.testing.assert_array_equal(m.double_complex(second_col), 2.0 * second_col)
-
-    counting_3d = np.arange(27.0, dtype=np.float32).reshape((3, 3, 3))
-    counting_3d = counting_3d[::-1, ::-1, ::-1]
-    slices = [counting_3d[0, :, :], counting_3d[:, 0, :], counting_3d[:, :, 0]]
-    for ref_mat in slices:
-        np.testing.assert_array_equal(m.double_mat_cm(ref_mat), 2.0 * ref_mat)
-        np.testing.assert_array_equal(m.double_mat_rm(ref_mat), 2.0 * ref_mat)
-
-    # Mutator:
-    with pytest.raises(TypeError) as excinfo:
-        m.double_threer(second_row)
-    assert (
-        msg(excinfo.value)
-        == """
-        double_threer(): incompatible function arguments. The following argument types are supported:
-            1. (arg0: numpy.ndarray[numpy.float32[1, 3], flags.writeable]) -> None
-
-        Invoked with: """
-        + repr(np.array([5.0, 4.0, 3.0], dtype="float32"))
-    )
-
-    with pytest.raises(TypeError) as excinfo:
-        m.double_threec(second_col)
-    assert (
-        msg(excinfo.value)
-        == """
-        double_threec(): incompatible function arguments. The following argument types are supported:
-            1. (arg0: numpy.ndarray[numpy.float32[3, 1], flags.writeable]) -> None
-
-        Invoked with: """
-        + repr(np.array([7.0, 4.0, 1.0], dtype="float32"))
-    )
-
-
-def test_block_runtime_error_type_caster_eigen_ref_made_a_copy():
-    with pytest.raises(RuntimeError) as excinfo:
-        m.block(ref, 0, 0, 0, 0)
-    assert str(excinfo.value) == "type_caster for Eigen::Ref made a copy."
-
-
-def test_nonunit_stride_to_python():
-    assert np.all(m.diagonal(ref) == ref.diagonal())
-    assert np.all(m.diagonal_1(ref) == ref.diagonal(1))
-    for i in range(-5, 7):
-        assert np.all(m.diagonal_n(ref, i) == ref.diagonal(i)), f"m.diagonal_n({i})"
-
-    # Must be order="F", otherwise the type_caster will make a copy and
-    # m.block() will return a dangling reference (heap-use-after-free).
-    rof = np.asarray(ref, order="F")
-    assert np.all(m.block(rof, 2, 1, 3, 3) == rof[2:5, 1:4])
-    assert np.all(m.block(rof, 1, 4, 4, 2) == rof[1:, 4:])
-    assert np.all(m.block(rof, 1, 4, 3, 2) == rof[1:4, 4:])
-
-
-def test_eigen_ref_to_python():
-    chols = [m.cholesky1, m.cholesky2, m.cholesky3, m.cholesky4]
-    for i, chol in enumerate(chols, start=1):
-        mymat = chol(np.array([[1.0, 2, 4], [2, 13, 23], [4, 23, 77]]))
-        assert np.all(
-            mymat == np.array([[1, 0, 0], [2, 3, 0], [4, 5, 6]])
-        ), f"cholesky{i}"
-
-
-def assign_both(a1, a2, r, c, v):
-    a1[r, c] = v
-    a2[r, c] = v
-
-
-def array_copy_but_one(a, r, c, v):
-    z = np.array(a, copy=True)
-    z[r, c] = v
-    return z
-
-
-def test_eigen_return_references():
-    """Tests various ways of returning references and non-referencing copies"""
-
-    primary = np.ones((10, 10))
-    a = m.ReturnTester()
-    a_get1 = a.get()
-    assert not a_get1.flags.owndata and a_get1.flags.writeable
-    assign_both(a_get1, primary, 3, 3, 5)
-    a_get2 = a.get_ptr()
-    assert not a_get2.flags.owndata and a_get2.flags.writeable
-    assign_both(a_get1, primary, 2, 3, 6)
-
-    a_view1 = a.view()
-    assert not a_view1.flags.owndata and not a_view1.flags.writeable
-    with pytest.raises(ValueError):
-        a_view1[2, 3] = 4
-    a_view2 = a.view_ptr()
-    assert not a_view2.flags.owndata and not a_view2.flags.writeable
-    with pytest.raises(ValueError):
-        a_view2[2, 3] = 4
-
-    a_copy1 = a.copy_get()
-    assert a_copy1.flags.owndata and a_copy1.flags.writeable
-    np.testing.assert_array_equal(a_copy1, primary)
-    a_copy1[7, 7] = -44  # Shouldn't affect anything else
-    c1want = array_copy_but_one(primary, 7, 7, -44)
-    a_copy2 = a.copy_view()
-    assert a_copy2.flags.owndata and a_copy2.flags.writeable
-    np.testing.assert_array_equal(a_copy2, primary)
-    a_copy2[4, 4] = -22  # Shouldn't affect anything else
-    c2want = array_copy_but_one(primary, 4, 4, -22)
-
-    a_ref1 = a.ref()
-    assert not a_ref1.flags.owndata and a_ref1.flags.writeable
-    assign_both(a_ref1, primary, 1, 1, 15)
-    a_ref2 = a.ref_const()
-    assert not a_ref2.flags.owndata and not a_ref2.flags.writeable
-    with pytest.raises(ValueError):
-        a_ref2[5, 5] = 33
-    a_ref3 = a.ref_safe()
-    assert not a_ref3.flags.owndata and a_ref3.flags.writeable
-    assign_both(a_ref3, primary, 0, 7, 99)
-    a_ref4 = a.ref_const_safe()
-    assert not a_ref4.flags.owndata and not a_ref4.flags.writeable
-    with pytest.raises(ValueError):
-        a_ref4[7, 0] = 987654321
-
-    a_copy3 = a.copy_ref()
-    assert a_copy3.flags.owndata and a_copy3.flags.writeable
-    np.testing.assert_array_equal(a_copy3, primary)
-    a_copy3[8, 1] = 11
-    c3want = array_copy_but_one(primary, 8, 1, 11)
-    a_copy4 = a.copy_ref_const()
-    assert a_copy4.flags.owndata and a_copy4.flags.writeable
-    np.testing.assert_array_equal(a_copy4, primary)
-    a_copy4[8, 4] = 88
-    c4want = array_copy_but_one(primary, 8, 4, 88)
-
-    a_block1 = a.block(3, 3, 2, 2)
-    assert not a_block1.flags.owndata and a_block1.flags.writeable
-    a_block1[0, 0] = 55
-    primary[3, 3] = 55
-    a_block2 = a.block_safe(2, 2, 3, 2)
-    assert not a_block2.flags.owndata and a_block2.flags.writeable
-    a_block2[2, 1] = -123
-    primary[4, 3] = -123
-    a_block3 = a.block_const(6, 7, 4, 3)
-    assert not a_block3.flags.owndata and not a_block3.flags.writeable
-    with pytest.raises(ValueError):
-        a_block3[2, 2] = -44444
-
-    a_copy5 = a.copy_block(2, 2, 2, 3)
-    assert a_copy5.flags.owndata and a_copy5.flags.writeable
-    np.testing.assert_array_equal(a_copy5, primary[2:4, 2:5])
-    a_copy5[1, 1] = 777
-    c5want = array_copy_but_one(primary[2:4, 2:5], 1, 1, 777)
-
-    a_corn1 = a.corners()
-    assert not a_corn1.flags.owndata and a_corn1.flags.writeable
-    a_corn1 *= 50
-    a_corn1[1, 1] = 999
-    primary[0, 0] = 50
-    primary[0, 9] = 50
-    primary[9, 0] = 50
-    primary[9, 9] = 999
-    a_corn2 = a.corners_const()
-    assert not a_corn2.flags.owndata and not a_corn2.flags.writeable
-    with pytest.raises(ValueError):
-        a_corn2[1, 0] = 51
-
-    # All of the changes made all the way along should be visible everywhere
-    # now (except for the copies, of course)
-    np.testing.assert_array_equal(a_get1, primary)
-    np.testing.assert_array_equal(a_get2, primary)
-    np.testing.assert_array_equal(a_view1, primary)
-    np.testing.assert_array_equal(a_view2, primary)
-    np.testing.assert_array_equal(a_ref1, primary)
-    np.testing.assert_array_equal(a_ref2, primary)
-    np.testing.assert_array_equal(a_ref3, primary)
-    np.testing.assert_array_equal(a_ref4, primary)
-    np.testing.assert_array_equal(a_block1, primary[3:5, 3:5])
-    np.testing.assert_array_equal(a_block2, primary[2:5, 2:4])
-    np.testing.assert_array_equal(a_block3, primary[6:10, 7:10])
-    np.testing.assert_array_equal(
-        a_corn1, primary[0 :: primary.shape[0] - 1, 0 :: primary.shape[1] - 1]
-    )
-    np.testing.assert_array_equal(
-        a_corn2, primary[0 :: primary.shape[0] - 1, 0 :: primary.shape[1] - 1]
-    )
-
-    np.testing.assert_array_equal(a_copy1, c1want)
-    np.testing.assert_array_equal(a_copy2, c2want)
-    np.testing.assert_array_equal(a_copy3, c3want)
-    np.testing.assert_array_equal(a_copy4, c4want)
-    np.testing.assert_array_equal(a_copy5, c5want)
-
-
-def assert_keeps_alive(cl, method, *args):
-    cstats = ConstructorStats.get(cl)
-    start_with = cstats.alive()
-    a = cl()
-    assert cstats.alive() == start_with + 1
-    z = method(a, *args)
-    assert cstats.alive() == start_with + 1
-    del a
-    # Here's the keep alive in action:
-    assert cstats.alive() == start_with + 1
-    del z
-    # Keep alive should have expired:
-    assert cstats.alive() == start_with
-
-
-def test_eigen_keepalive():
-    a = m.ReturnTester()
-    cstats = ConstructorStats.get(m.ReturnTester)
-    assert cstats.alive() == 1
-    unsafe = [a.ref(), a.ref_const(), a.block(1, 2, 3, 4)]
-    copies = [
-        a.copy_get(),
-        a.copy_view(),
-        a.copy_ref(),
-        a.copy_ref_const(),
-        a.copy_block(4, 3, 2, 1),
-    ]
-    del a
-    assert cstats.alive() == 0
-    del unsafe
-    del copies
-
-    for meth in [
-        m.ReturnTester.get,
-        m.ReturnTester.get_ptr,
-        m.ReturnTester.view,
-        m.ReturnTester.view_ptr,
-        m.ReturnTester.ref_safe,
-        m.ReturnTester.ref_const_safe,
-        m.ReturnTester.corners,
-        m.ReturnTester.corners_const,
-    ]:
-        assert_keeps_alive(m.ReturnTester, meth)
-
-    for meth in [m.ReturnTester.block_safe, m.ReturnTester.block_const]:
-        assert_keeps_alive(m.ReturnTester, meth, 4, 3, 2, 1)
-
-
-def test_eigen_ref_mutators():
-    """Tests Eigen's ability to mutate numpy values"""
-
-    orig = np.array([[1.0, 2, 3], [4, 5, 6], [7, 8, 9]])
-    zr = np.array(orig)
-    zc = np.array(orig, order="F")
-    m.add_rm(zr, 1, 0, 100)
-    assert np.all(zr == np.array([[1.0, 2, 3], [104, 5, 6], [7, 8, 9]]))
-    m.add_cm(zc, 1, 0, 200)
-    assert np.all(zc == np.array([[1.0, 2, 3], [204, 5, 6], [7, 8, 9]]))
-
-    m.add_any(zr, 1, 0, 20)
-    assert np.all(zr == np.array([[1.0, 2, 3], [124, 5, 6], [7, 8, 9]]))
-    m.add_any(zc, 1, 0, 10)
-    assert np.all(zc == np.array([[1.0, 2, 3], [214, 5, 6], [7, 8, 9]]))
-
-    # Can't reference a col-major array with a row-major Ref, and vice versa:
-    with pytest.raises(TypeError):
-        m.add_rm(zc, 1, 0, 1)
-    with pytest.raises(TypeError):
-        m.add_cm(zr, 1, 0, 1)
-
-    # Overloads:
-    m.add1(zr, 1, 0, -100)
-    m.add2(zr, 1, 0, -20)
-    assert np.all(zr == orig)
-    m.add1(zc, 1, 0, -200)
-    m.add2(zc, 1, 0, -10)
-    assert np.all(zc == orig)
-
-    # a non-contiguous slice (this won't work on either the row- or
-    # column-contiguous refs, but should work for the any)
-    cornersr = zr[0::2, 0::2]
-    cornersc = zc[0::2, 0::2]
-
-    assert np.all(cornersr == np.array([[1.0, 3], [7, 9]]))
-    assert np.all(cornersc == np.array([[1.0, 3], [7, 9]]))
-
-    with pytest.raises(TypeError):
-        m.add_rm(cornersr, 0, 1, 25)
-    with pytest.raises(TypeError):
-        m.add_cm(cornersr, 0, 1, 25)
-    with pytest.raises(TypeError):
-        m.add_rm(cornersc, 0, 1, 25)
-    with pytest.raises(TypeError):
-        m.add_cm(cornersc, 0, 1, 25)
-    m.add_any(cornersr, 0, 1, 25)
-    m.add_any(cornersc, 0, 1, 44)
-    assert np.all(zr == np.array([[1.0, 2, 28], [4, 5, 6], [7, 8, 9]]))
-    assert np.all(zc == np.array([[1.0, 2, 47], [4, 5, 6], [7, 8, 9]]))
-
-    # You shouldn't be allowed to pass a non-writeable array to a mutating Eigen method:
-    zro = zr[0:4, 0:4]
-    zro.flags.writeable = False
-    with pytest.raises(TypeError):
-        m.add_rm(zro, 0, 0, 0)
-    with pytest.raises(TypeError):
-        m.add_any(zro, 0, 0, 0)
-    with pytest.raises(TypeError):
-        m.add1(zro, 0, 0, 0)
-    with pytest.raises(TypeError):
-        m.add2(zro, 0, 0, 0)
-
-    # integer array shouldn't be passable to a double-matrix-accepting mutating func:
-    zi = np.array([[1, 2], [3, 4]])
-    with pytest.raises(TypeError):
-        m.add_rm(zi)
-
-
-def test_numpy_ref_mutators():
-    """Tests numpy mutating Eigen matrices (for returned Eigen::Ref<...>s)"""
-
-    m.reset_refs()  # In case another test already changed it
-
-    zc = m.get_cm_ref()
-    zcro = m.get_cm_const_ref()
-    zr = m.get_rm_ref()
-    zrro = m.get_rm_const_ref()
-
-    assert [zc[1, 2], zcro[1, 2], zr[1, 2], zrro[1, 2]] == [23] * 4
-
-    assert not zc.flags.owndata and zc.flags.writeable
-    assert not zr.flags.owndata and zr.flags.writeable
-    assert not zcro.flags.owndata and not zcro.flags.writeable
-    assert not zrro.flags.owndata and not zrro.flags.writeable
-
-    zc[1, 2] = 99
-    expect = np.array([[11.0, 12, 13], [21, 22, 99], [31, 32, 33]])
-    # We should have just changed zc, of course, but also zcro and the original eigen matrix
-    assert np.all(zc == expect)
-    assert np.all(zcro == expect)
-    assert np.all(m.get_cm_ref() == expect)
-
-    zr[1, 2] = 99
-    assert np.all(zr == expect)
-    assert np.all(zrro == expect)
-    assert np.all(m.get_rm_ref() == expect)
-
-    # Make sure the readonly ones are numpy-readonly:
-    with pytest.raises(ValueError):
-        zcro[1, 2] = 6
-    with pytest.raises(ValueError):
-        zrro[1, 2] = 6
-
-    # We should be able to explicitly copy like this (and since we're copying,
-    # the const should drop away)
-    y1 = np.array(m.get_cm_const_ref())
-
-    assert y1.flags.owndata and y1.flags.writeable
-    # We should get copies of the eigen data, which was modified above:
-    assert y1[1, 2] == 99
-    y1[1, 2] += 12
-    assert y1[1, 2] == 111
-    assert zc[1, 2] == 99  # Make sure we aren't referencing the original
-
-
-def test_both_ref_mutators():
-    """Tests a complex chain of nested eigen/numpy references"""
-
-    m.reset_refs()  # In case another test already changed it
-
-    z = m.get_cm_ref()  # numpy -> eigen
-    z[0, 2] -= 3
-    z2 = m.incr_matrix(z, 1)  # numpy -> eigen -> numpy -> eigen
-    z2[1, 1] += 6
-    z3 = m.incr_matrix(z, 2)  # (numpy -> eigen)^3
-    z3[2, 2] += -5
-    z4 = m.incr_matrix(z, 3)  # (numpy -> eigen)^4
-    z4[1, 1] -= 1
-    z5 = m.incr_matrix(z, 4)  # (numpy -> eigen)^5
-    z5[0, 0] = 0
-    assert np.all(z == z2)
-    assert np.all(z == z3)
-    assert np.all(z == z4)
-    assert np.all(z == z5)
-    expect = np.array([[0.0, 22, 20], [31, 37, 33], [41, 42, 38]])
-    assert np.all(z == expect)
-
-    y = np.array(range(100), dtype="float64").reshape(10, 10)
-    y2 = m.incr_matrix_any(y, 10)  # np -> eigen -> np
-    y3 = m.incr_matrix_any(
-        y2[0::2, 0::2], -33
-    )  # np -> eigen -> np slice -> np -> eigen -> np
-    y4 = m.even_rows(y3)  # numpy -> eigen slice -> (... y3)
-    y5 = m.even_cols(y4)  # numpy -> eigen slice -> (... y4)
-    y6 = m.incr_matrix_any(y5, 1000)  # numpy -> eigen -> (... y5)
-
-    # Apply same mutations using just numpy:
-    yexpect = np.array(range(100), dtype="float64").reshape(10, 10)
-    yexpect += 10
-    yexpect[0::2, 0::2] -= 33
-    yexpect[0::4, 0::4] += 1000
-    assert np.all(y6 == yexpect[0::4, 0::4])
-    assert np.all(y5 == yexpect[0::4, 0::4])
-    assert np.all(y4 == yexpect[0::4, 0::2])
-    assert np.all(y3 == yexpect[0::2, 0::2])
-    assert np.all(y2 == yexpect)
-    assert np.all(y == yexpect)
-
-
-def test_nocopy_wrapper():
-    # get_elem requires a column-contiguous matrix reference, but should be
-    # callable with other types of matrix (via copying):
-    int_matrix_colmajor = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]], order="F")
-    dbl_matrix_colmajor = np.array(
-        int_matrix_colmajor, dtype="double", order="F", copy=True
-    )
-    int_matrix_rowmajor = np.array(int_matrix_colmajor, order="C", copy=True)
-    dbl_matrix_rowmajor = np.array(
-        int_matrix_rowmajor, dtype="double", order="C", copy=True
-    )
-
-    # All should be callable via get_elem:
-    assert m.get_elem(int_matrix_colmajor) == 8
-    assert m.get_elem(dbl_matrix_colmajor) == 8
-    assert m.get_elem(int_matrix_rowmajor) == 8
-    assert m.get_elem(dbl_matrix_rowmajor) == 8
-
-    # All but the second should fail with m.get_elem_nocopy:
-    with pytest.raises(TypeError) as excinfo:
-        m.get_elem_nocopy(int_matrix_colmajor)
-    assert "get_elem_nocopy(): incompatible function arguments." in str(
-        excinfo.value
-    ) and ", flags.f_contiguous" in str(excinfo.value)
-    assert m.get_elem_nocopy(dbl_matrix_colmajor) == 8
-    with pytest.raises(TypeError) as excinfo:
-        m.get_elem_nocopy(int_matrix_rowmajor)
-    assert "get_elem_nocopy(): incompatible function arguments." in str(
-        excinfo.value
-    ) and ", flags.f_contiguous" in str(excinfo.value)
-    with pytest.raises(TypeError) as excinfo:
-        m.get_elem_nocopy(dbl_matrix_rowmajor)
-    assert "get_elem_nocopy(): incompatible function arguments." in str(
-        excinfo.value
-    ) and ", flags.f_contiguous" in str(excinfo.value)
-
-    # For the row-major test, we take a long matrix in row-major, so only the third is allowed:
-    with pytest.raises(TypeError) as excinfo:
-        m.get_elem_rm_nocopy(int_matrix_colmajor)
-    assert "get_elem_rm_nocopy(): incompatible function arguments." in str(
-        excinfo.value
-    ) and ", flags.c_contiguous" in str(excinfo.value)
-    with pytest.raises(TypeError) as excinfo:
-        m.get_elem_rm_nocopy(dbl_matrix_colmajor)
-    assert "get_elem_rm_nocopy(): incompatible function arguments." in str(
-        excinfo.value
-    ) and ", flags.c_contiguous" in str(excinfo.value)
-    assert m.get_elem_rm_nocopy(int_matrix_rowmajor) == 8
-    with pytest.raises(TypeError) as excinfo:
-        m.get_elem_rm_nocopy(dbl_matrix_rowmajor)
-    assert "get_elem_rm_nocopy(): incompatible function arguments." in str(
-        excinfo.value
-    ) and ", flags.c_contiguous" in str(excinfo.value)
-
-
-def test_eigen_ref_life_support():
-    """Ensure the lifetime of temporary arrays created by the `Ref` caster
-
-    The `Ref` caster sometimes creates a copy which needs to stay alive. This needs to
-    happen both for directs casts (just the array) or indirectly (e.g. list of arrays).
-    """
-
-    a = np.full(shape=10, fill_value=8, dtype=np.int8)
-    assert m.get_elem_direct(a) == 8
-
-    list_of_a = [a]
-    assert m.get_elem_indirect(list_of_a) == 8
-
-
-def test_special_matrix_objects():
-    assert np.all(m.incr_diag(7) == np.diag([1.0, 2, 3, 4, 5, 6, 7]))
-
-    asymm = np.array([[1.0, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])
-    symm_lower = np.array(asymm)
-    symm_upper = np.array(asymm)
-    for i in range(4):
-        for j in range(i + 1, 4):
-            symm_lower[i, j] = symm_lower[j, i]
-            symm_upper[j, i] = symm_upper[i, j]
-
-    assert np.all(m.symmetric_lower(asymm) == symm_lower)
-    assert np.all(m.symmetric_upper(asymm) == symm_upper)
-
-
-def test_dense_signature(doc):
-    assert (
-        doc(m.double_col)
-        == """
-        double_col(arg0: numpy.ndarray[numpy.float32[m, 1]]) -> numpy.ndarray[numpy.float32[m, 1]]
-    """
-    )
-    assert (
-        doc(m.double_row)
-        == """
-        double_row(arg0: numpy.ndarray[numpy.float32[1, n]]) -> numpy.ndarray[numpy.float32[1, n]]
-    """
-    )
-    assert doc(m.double_complex) == (
-        """
-        double_complex(arg0: numpy.ndarray[numpy.complex64[m, 1]])"""
-        """ -> numpy.ndarray[numpy.complex64[m, 1]]
-    """
-    )
-    assert doc(m.double_mat_rm) == (
-        """
-        double_mat_rm(arg0: numpy.ndarray[numpy.float32[m, n]])"""
-        """ -> numpy.ndarray[numpy.float32[m, n]]
-    """
-    )
-
-
-def test_named_arguments():
-    a = np.array([[1.0, 2], [3, 4], [5, 6]])
-    b = np.ones((2, 1))
-
-    assert np.all(m.matrix_multiply(a, b) == np.array([[3.0], [7], [11]]))
-    assert np.all(m.matrix_multiply(A=a, B=b) == np.array([[3.0], [7], [11]]))
-    assert np.all(m.matrix_multiply(B=b, A=a) == np.array([[3.0], [7], [11]]))
-
-    with pytest.raises(ValueError) as excinfo:
-        m.matrix_multiply(b, a)
-    assert str(excinfo.value) == "Nonconformable matrices!"
-
-    with pytest.raises(ValueError) as excinfo:
-        m.matrix_multiply(A=b, B=a)
-    assert str(excinfo.value) == "Nonconformable matrices!"
-
-    with pytest.raises(ValueError) as excinfo:
-        m.matrix_multiply(B=a, A=b)
-    assert str(excinfo.value) == "Nonconformable matrices!"
-
-
-def test_sparse():
-    pytest.importorskip("scipy")
-    assert_sparse_equal_ref(m.sparse_r())
-    assert_sparse_equal_ref(m.sparse_c())
-    assert_sparse_equal_ref(m.sparse_copy_r(m.sparse_r()))
-    assert_sparse_equal_ref(m.sparse_copy_c(m.sparse_c()))
-    assert_sparse_equal_ref(m.sparse_copy_r(m.sparse_c()))
-    assert_sparse_equal_ref(m.sparse_copy_c(m.sparse_r()))
-
-
-def test_sparse_signature(doc):
-    pytest.importorskip("scipy")
-    assert (
-        doc(m.sparse_copy_r)
-        == """
-        sparse_copy_r(arg0: scipy.sparse.csr_matrix[numpy.float32]) -> scipy.sparse.csr_matrix[numpy.float32]
-    """
-    )
-    assert (
-        doc(m.sparse_copy_c)
-        == """
-        sparse_copy_c(arg0: scipy.sparse.csc_matrix[numpy.float32]) -> scipy.sparse.csc_matrix[numpy.float32]
-    """
-    )
-
-
-def test_issue738():
-    """Ignore strides on a length-1 dimension (even if they would be incompatible length > 1)"""
-    assert np.all(m.iss738_f1(np.array([[1.0, 2, 3]])) == np.array([[1.0, 102, 203]]))
-    assert np.all(
-        m.iss738_f1(np.array([[1.0], [2], [3]])) == np.array([[1.0], [12], [23]])
-    )
-
-    assert np.all(m.iss738_f2(np.array([[1.0, 2, 3]])) == np.array([[1.0, 102, 203]]))
-    assert np.all(
-        m.iss738_f2(np.array([[1.0], [2], [3]])) == np.array([[1.0], [12], [23]])
-    )
-
-
-@pytest.mark.parametrize("func", [m.iss738_f1, m.iss738_f2])
-@pytest.mark.parametrize("sizes", [(0, 2), (2, 0)])
-def test_zero_length(func, sizes):
-    """Ignore strides on a length-0 dimension (even if they would be incompatible length > 1)"""
-    assert np.all(func(np.zeros(sizes)) == np.zeros(sizes))
-
-
-def test_issue1105():
-    """Issue 1105: 1xN or Nx1 input arrays weren't accepted for eigen
-    compile-time row vectors or column vector"""
-    assert m.iss1105_row(np.ones((1, 7)))
-    assert m.iss1105_col(np.ones((7, 1)))
-
-    # These should still fail (incompatible dimensions):
-    with pytest.raises(TypeError) as excinfo:
-        m.iss1105_row(np.ones((7, 1)))
-    assert "incompatible function arguments" in str(excinfo.value)
-    with pytest.raises(TypeError) as excinfo:
-        m.iss1105_col(np.ones((1, 7)))
-    assert "incompatible function arguments" in str(excinfo.value)
-
-
-def test_custom_operator_new():
-    """Using Eigen types as member variables requires a class-specific
-    operator new with proper alignment"""
-
-    o = m.CustomOperatorNew()
-    np.testing.assert_allclose(o.a, 0.0)
-    np.testing.assert_allclose(o.b.diagonal(), 1.0)
+import pytest
+
+from pybind11_tests import ConstructorStats
+
+np = pytest.importorskip("numpy")
+m = pytest.importorskip("pybind11_tests.eigen_matrix")
+
+
+ref = np.array(
+    [
+        [0.0, 3, 0, 0, 0, 11],
+        [22, 0, 0, 0, 17, 11],
+        [7, 5, 0, 1, 0, 11],
+        [0, 0, 0, 0, 0, 11],
+        [0, 0, 14, 0, 8, 11],
+    ]
+)
+
+
+def assert_equal_ref(mat):
+    np.testing.assert_array_equal(mat, ref)
+
+
+def assert_sparse_equal_ref(sparse_mat):
+    assert_equal_ref(sparse_mat.toarray())
+
+
+def test_fixed():
+    assert_equal_ref(m.fixed_c())
+    assert_equal_ref(m.fixed_r())
+    assert_equal_ref(m.fixed_copy_r(m.fixed_r()))
+    assert_equal_ref(m.fixed_copy_c(m.fixed_c()))
+    assert_equal_ref(m.fixed_copy_r(m.fixed_c()))
+    assert_equal_ref(m.fixed_copy_c(m.fixed_r()))
+
+
+def test_dense():
+    assert_equal_ref(m.dense_r())
+    assert_equal_ref(m.dense_c())
+    assert_equal_ref(m.dense_copy_r(m.dense_r()))
+    assert_equal_ref(m.dense_copy_c(m.dense_c()))
+    assert_equal_ref(m.dense_copy_r(m.dense_c()))
+    assert_equal_ref(m.dense_copy_c(m.dense_r()))
+
+
+def test_partially_fixed():
+    ref2 = np.array([[0.0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]])
+    np.testing.assert_array_equal(m.partial_copy_four_rm_r(ref2), ref2)
+    np.testing.assert_array_equal(m.partial_copy_four_rm_c(ref2), ref2)
+    np.testing.assert_array_equal(m.partial_copy_four_rm_r(ref2[:, 1]), ref2[:, [1]])
+    np.testing.assert_array_equal(m.partial_copy_four_rm_c(ref2[0, :]), ref2[[0], :])
+    np.testing.assert_array_equal(
+        m.partial_copy_four_rm_r(ref2[:, (0, 2)]), ref2[:, (0, 2)]
+    )
+    np.testing.assert_array_equal(
+        m.partial_copy_four_rm_c(ref2[(3, 1, 2), :]), ref2[(3, 1, 2), :]
+    )
+
+    np.testing.assert_array_equal(m.partial_copy_four_cm_r(ref2), ref2)
+    np.testing.assert_array_equal(m.partial_copy_four_cm_c(ref2), ref2)
+    np.testing.assert_array_equal(m.partial_copy_four_cm_r(ref2[:, 1]), ref2[:, [1]])
+    np.testing.assert_array_equal(m.partial_copy_four_cm_c(ref2[0, :]), ref2[[0], :])
+    np.testing.assert_array_equal(
+        m.partial_copy_four_cm_r(ref2[:, (0, 2)]), ref2[:, (0, 2)]
+    )
+    np.testing.assert_array_equal(
+        m.partial_copy_four_cm_c(ref2[(3, 1, 2), :]), ref2[(3, 1, 2), :]
+    )
+
+    # TypeError should be raise for a shape mismatch
+    functions = [
+        m.partial_copy_four_rm_r,
+        m.partial_copy_four_rm_c,
+        m.partial_copy_four_cm_r,
+        m.partial_copy_four_cm_c,
+    ]
+    matrix_with_wrong_shape = [[1, 2], [3, 4]]
+    for f in functions:
+        with pytest.raises(TypeError) as excinfo:
+            f(matrix_with_wrong_shape)
+        assert "incompatible function arguments" in str(excinfo.value)
+
+
+def test_mutator_descriptors():
+    zr = np.arange(30, dtype="float32").reshape(5, 6)  # row-major
+    zc = zr.reshape(6, 5).transpose()  # column-major
+
+    m.fixed_mutator_r(zr)
+    m.fixed_mutator_c(zc)
+    m.fixed_mutator_a(zr)
+    m.fixed_mutator_a(zc)
+    with pytest.raises(TypeError) as excinfo:
+        m.fixed_mutator_r(zc)
+    assert (
+        "(arg0: numpy.ndarray[numpy.float32[5, 6],"
+        " flags.writeable, flags.c_contiguous]) -> None" in str(excinfo.value)
+    )
+    with pytest.raises(TypeError) as excinfo:
+        m.fixed_mutator_c(zr)
+    assert (
+        "(arg0: numpy.ndarray[numpy.float32[5, 6],"
+        " flags.writeable, flags.f_contiguous]) -> None" in str(excinfo.value)
+    )
+    with pytest.raises(TypeError) as excinfo:
+        m.fixed_mutator_a(np.array([[1, 2], [3, 4]], dtype="float32"))
+    assert "(arg0: numpy.ndarray[numpy.float32[5, 6], flags.writeable]) -> None" in str(
+        excinfo.value
+    )
+    zr.flags.writeable = False
+    with pytest.raises(TypeError):
+        m.fixed_mutator_r(zr)
+    with pytest.raises(TypeError):
+        m.fixed_mutator_a(zr)
+
+
+def test_cpp_casting():
+    assert m.cpp_copy(m.fixed_r()) == 22.0
+    assert m.cpp_copy(m.fixed_c()) == 22.0
+    z = np.array([[5.0, 6], [7, 8]])
+    assert m.cpp_copy(z) == 7.0
+    assert m.cpp_copy(m.get_cm_ref()) == 21.0
+    assert m.cpp_copy(m.get_rm_ref()) == 21.0
+    assert m.cpp_ref_c(m.get_cm_ref()) == 21.0
+    assert m.cpp_ref_r(m.get_rm_ref()) == 21.0
+    with pytest.raises(RuntimeError) as excinfo:
+        # Can't reference m.fixed_c: it contains floats, m.cpp_ref_any wants doubles
+        m.cpp_ref_any(m.fixed_c())
+    assert "Unable to cast Python instance" in str(excinfo.value)
+    with pytest.raises(RuntimeError) as excinfo:
+        # Can't reference m.fixed_r: it contains floats, m.cpp_ref_any wants doubles
+        m.cpp_ref_any(m.fixed_r())
+    assert "Unable to cast Python instance" in str(excinfo.value)
+    assert m.cpp_ref_any(m.ReturnTester.create()) == 1.0
+
+    assert m.cpp_ref_any(m.get_cm_ref()) == 21.0
+    assert m.cpp_ref_any(m.get_cm_ref()) == 21.0
+
+
+def test_pass_readonly_array():
+    z = np.full((5, 6), 42.0)
+    z.flags.writeable = False
+    np.testing.assert_array_equal(z, m.fixed_copy_r(z))
+    np.testing.assert_array_equal(m.fixed_r_const(), m.fixed_r())
+    assert not m.fixed_r_const().flags.writeable
+    np.testing.assert_array_equal(m.fixed_copy_r(m.fixed_r_const()), m.fixed_r_const())
+
+
+def test_nonunit_stride_from_python():
+    counting_mat = np.arange(9.0, dtype=np.float32).reshape((3, 3))
+    second_row = counting_mat[1, :]
+    second_col = counting_mat[:, 1]
+    np.testing.assert_array_equal(m.double_row(second_row), 2.0 * second_row)
+    np.testing.assert_array_equal(m.double_col(second_row), 2.0 * second_row)
+    np.testing.assert_array_equal(m.double_complex(second_row), 2.0 * second_row)
+    np.testing.assert_array_equal(m.double_row(second_col), 2.0 * second_col)
+    np.testing.assert_array_equal(m.double_col(second_col), 2.0 * second_col)
+    np.testing.assert_array_equal(m.double_complex(second_col), 2.0 * second_col)
+
+    counting_3d = np.arange(27.0, dtype=np.float32).reshape((3, 3, 3))
+    slices = [counting_3d[0, :, :], counting_3d[:, 0, :], counting_3d[:, :, 0]]
+    for ref_mat in slices:
+        np.testing.assert_array_equal(m.double_mat_cm(ref_mat), 2.0 * ref_mat)
+        np.testing.assert_array_equal(m.double_mat_rm(ref_mat), 2.0 * ref_mat)
+
+    # Mutator:
+    m.double_threer(second_row)
+    m.double_threec(second_col)
+    np.testing.assert_array_equal(counting_mat, [[0.0, 2, 2], [6, 16, 10], [6, 14, 8]])
+
+
+def test_negative_stride_from_python(msg):
+    """Eigen doesn't support (as of yet) negative strides. When a function takes an Eigen matrix by
+    copy or const reference, we can pass a numpy array that has negative strides.  Otherwise, an
+    exception will be thrown as Eigen will not be able to map the numpy array."""
+
+    counting_mat = np.arange(9.0, dtype=np.float32).reshape((3, 3))
+    counting_mat = counting_mat[::-1, ::-1]
+    second_row = counting_mat[1, :]
+    second_col = counting_mat[:, 1]
+    np.testing.assert_array_equal(m.double_row(second_row), 2.0 * second_row)
+    np.testing.assert_array_equal(m.double_col(second_row), 2.0 * second_row)
+    np.testing.assert_array_equal(m.double_complex(second_row), 2.0 * second_row)
+    np.testing.assert_array_equal(m.double_row(second_col), 2.0 * second_col)
+    np.testing.assert_array_equal(m.double_col(second_col), 2.0 * second_col)
+    np.testing.assert_array_equal(m.double_complex(second_col), 2.0 * second_col)
+
+    counting_3d = np.arange(27.0, dtype=np.float32).reshape((3, 3, 3))
+    counting_3d = counting_3d[::-1, ::-1, ::-1]
+    slices = [counting_3d[0, :, :], counting_3d[:, 0, :], counting_3d[:, :, 0]]
+    for ref_mat in slices:
+        np.testing.assert_array_equal(m.double_mat_cm(ref_mat), 2.0 * ref_mat)
+        np.testing.assert_array_equal(m.double_mat_rm(ref_mat), 2.0 * ref_mat)
+
+    # Mutator:
+    with pytest.raises(TypeError) as excinfo:
+        m.double_threer(second_row)
+    assert (
+        msg(excinfo.value)
+        == """
+        double_threer(): incompatible function arguments. The following argument types are supported:
+            1. (arg0: numpy.ndarray[numpy.float32[1, 3], flags.writeable]) -> None
+
+        Invoked with: """
+        + repr(np.array([5.0, 4.0, 3.0], dtype="float32"))
+    )
+
+    with pytest.raises(TypeError) as excinfo:
+        m.double_threec(second_col)
+    assert (
+        msg(excinfo.value)
+        == """
+        double_threec(): incompatible function arguments. The following argument types are supported:
+            1. (arg0: numpy.ndarray[numpy.float32[3, 1], flags.writeable]) -> None
+
+        Invoked with: """
+        + repr(np.array([7.0, 4.0, 1.0], dtype="float32"))
+    )
+
+
+def test_block_runtime_error_type_caster_eigen_ref_made_a_copy():
+    with pytest.raises(RuntimeError) as excinfo:
+        m.block(ref, 0, 0, 0, 0)
+    assert str(excinfo.value) == "type_caster for Eigen::Ref made a copy."
+
+
+def test_nonunit_stride_to_python():
+    assert np.all(m.diagonal(ref) == ref.diagonal())
+    assert np.all(m.diagonal_1(ref) == ref.diagonal(1))
+    for i in range(-5, 7):
+        assert np.all(m.diagonal_n(ref, i) == ref.diagonal(i)), f"m.diagonal_n({i})"
+
+    # Must be order="F", otherwise the type_caster will make a copy and
+    # m.block() will return a dangling reference (heap-use-after-free).
+    rof = np.asarray(ref, order="F")
+    assert np.all(m.block(rof, 2, 1, 3, 3) == rof[2:5, 1:4])
+    assert np.all(m.block(rof, 1, 4, 4, 2) == rof[1:, 4:])
+    assert np.all(m.block(rof, 1, 4, 3, 2) == rof[1:4, 4:])
+
+
+def test_eigen_ref_to_python():
+    chols = [m.cholesky1, m.cholesky2, m.cholesky3, m.cholesky4]
+    for i, chol in enumerate(chols, start=1):
+        mymat = chol(np.array([[1.0, 2, 4], [2, 13, 23], [4, 23, 77]]))
+        assert np.all(
+            mymat == np.array([[1, 0, 0], [2, 3, 0], [4, 5, 6]])
+        ), f"cholesky{i}"
+
+
+def assign_both(a1, a2, r, c, v):
+    a1[r, c] = v
+    a2[r, c] = v
+
+
+def array_copy_but_one(a, r, c, v):
+    z = np.array(a, copy=True)
+    z[r, c] = v
+    return z
+
+
+def test_eigen_return_references():
+    """Tests various ways of returning references and non-referencing copies"""
+
+    primary = np.ones((10, 10))
+    a = m.ReturnTester()
+    a_get1 = a.get()
+    assert not a_get1.flags.owndata and a_get1.flags.writeable
+    assign_both(a_get1, primary, 3, 3, 5)
+    a_get2 = a.get_ptr()
+    assert not a_get2.flags.owndata and a_get2.flags.writeable
+    assign_both(a_get1, primary, 2, 3, 6)
+
+    a_view1 = a.view()
+    assert not a_view1.flags.owndata and not a_view1.flags.writeable
+    with pytest.raises(ValueError):
+        a_view1[2, 3] = 4
+    a_view2 = a.view_ptr()
+    assert not a_view2.flags.owndata and not a_view2.flags.writeable
+    with pytest.raises(ValueError):
+        a_view2[2, 3] = 4
+
+    a_copy1 = a.copy_get()
+    assert a_copy1.flags.owndata and a_copy1.flags.writeable
+    np.testing.assert_array_equal(a_copy1, primary)
+    a_copy1[7, 7] = -44  # Shouldn't affect anything else
+    c1want = array_copy_but_one(primary, 7, 7, -44)
+    a_copy2 = a.copy_view()
+    assert a_copy2.flags.owndata and a_copy2.flags.writeable
+    np.testing.assert_array_equal(a_copy2, primary)
+    a_copy2[4, 4] = -22  # Shouldn't affect anything else
+    c2want = array_copy_but_one(primary, 4, 4, -22)
+
+    a_ref1 = a.ref()
+    assert not a_ref1.flags.owndata and a_ref1.flags.writeable
+    assign_both(a_ref1, primary, 1, 1, 15)
+    a_ref2 = a.ref_const()
+    assert not a_ref2.flags.owndata and not a_ref2.flags.writeable
+    with pytest.raises(ValueError):
+        a_ref2[5, 5] = 33
+    a_ref3 = a.ref_safe()
+    assert not a_ref3.flags.owndata and a_ref3.flags.writeable
+    assign_both(a_ref3, primary, 0, 7, 99)
+    a_ref4 = a.ref_const_safe()
+    assert not a_ref4.flags.owndata and not a_ref4.flags.writeable
+    with pytest.raises(ValueError):
+        a_ref4[7, 0] = 987654321
+
+    a_copy3 = a.copy_ref()
+    assert a_copy3.flags.owndata and a_copy3.flags.writeable
+    np.testing.assert_array_equal(a_copy3, primary)
+    a_copy3[8, 1] = 11
+    c3want = array_copy_but_one(primary, 8, 1, 11)
+    a_copy4 = a.copy_ref_const()
+    assert a_copy4.flags.owndata and a_copy4.flags.writeable
+    np.testing.assert_array_equal(a_copy4, primary)
+    a_copy4[8, 4] = 88
+    c4want = array_copy_but_one(primary, 8, 4, 88)
+
+    a_block1 = a.block(3, 3, 2, 2)
+    assert not a_block1.flags.owndata and a_block1.flags.writeable
+    a_block1[0, 0] = 55
+    primary[3, 3] = 55
+    a_block2 = a.block_safe(2, 2, 3, 2)
+    assert not a_block2.flags.owndata and a_block2.flags.writeable
+    a_block2[2, 1] = -123
+    primary[4, 3] = -123
+    a_block3 = a.block_const(6, 7, 4, 3)
+    assert not a_block3.flags.owndata and not a_block3.flags.writeable
+    with pytest.raises(ValueError):
+        a_block3[2, 2] = -44444
+
+    a_copy5 = a.copy_block(2, 2, 2, 3)
+    assert a_copy5.flags.owndata and a_copy5.flags.writeable
+    np.testing.assert_array_equal(a_copy5, primary[2:4, 2:5])
+    a_copy5[1, 1] = 777
+    c5want = array_copy_but_one(primary[2:4, 2:5], 1, 1, 777)
+
+    a_corn1 = a.corners()
+    assert not a_corn1.flags.owndata and a_corn1.flags.writeable
+    a_corn1 *= 50
+    a_corn1[1, 1] = 999
+    primary[0, 0] = 50
+    primary[0, 9] = 50
+    primary[9, 0] = 50
+    primary[9, 9] = 999
+    a_corn2 = a.corners_const()
+    assert not a_corn2.flags.owndata and not a_corn2.flags.writeable
+    with pytest.raises(ValueError):
+        a_corn2[1, 0] = 51
+
+    # All of the changes made all the way along should be visible everywhere
+    # now (except for the copies, of course)
+    np.testing.assert_array_equal(a_get1, primary)
+    np.testing.assert_array_equal(a_get2, primary)
+    np.testing.assert_array_equal(a_view1, primary)
+    np.testing.assert_array_equal(a_view2, primary)
+    np.testing.assert_array_equal(a_ref1, primary)
+    np.testing.assert_array_equal(a_ref2, primary)
+    np.testing.assert_array_equal(a_ref3, primary)
+    np.testing.assert_array_equal(a_ref4, primary)
+    np.testing.assert_array_equal(a_block1, primary[3:5, 3:5])
+    np.testing.assert_array_equal(a_block2, primary[2:5, 2:4])
+    np.testing.assert_array_equal(a_block3, primary[6:10, 7:10])
+    np.testing.assert_array_equal(
+        a_corn1, primary[0 :: primary.shape[0] - 1, 0 :: primary.shape[1] - 1]
+    )
+    np.testing.assert_array_equal(
+        a_corn2, primary[0 :: primary.shape[0] - 1, 0 :: primary.shape[1] - 1]
+    )
+
+    np.testing.assert_array_equal(a_copy1, c1want)
+    np.testing.assert_array_equal(a_copy2, c2want)
+    np.testing.assert_array_equal(a_copy3, c3want)
+    np.testing.assert_array_equal(a_copy4, c4want)
+    np.testing.assert_array_equal(a_copy5, c5want)
+
+
+def assert_keeps_alive(cl, method, *args):
+    cstats = ConstructorStats.get(cl)
+    start_with = cstats.alive()
+    a = cl()
+    assert cstats.alive() == start_with + 1
+    z = method(a, *args)
+    assert cstats.alive() == start_with + 1
+    del a
+    # Here's the keep alive in action:
+    assert cstats.alive() == start_with + 1
+    del z
+    # Keep alive should have expired:
+    assert cstats.alive() == start_with
+
+
+def test_eigen_keepalive():
+    a = m.ReturnTester()
+    cstats = ConstructorStats.get(m.ReturnTester)
+    assert cstats.alive() == 1
+    unsafe = [a.ref(), a.ref_const(), a.block(1, 2, 3, 4)]
+    copies = [
+        a.copy_get(),
+        a.copy_view(),
+        a.copy_ref(),
+        a.copy_ref_const(),
+        a.copy_block(4, 3, 2, 1),
+    ]
+    del a
+    assert cstats.alive() == 0
+    del unsafe
+    del copies
+
+    for meth in [
+        m.ReturnTester.get,
+        m.ReturnTester.get_ptr,
+        m.ReturnTester.view,
+        m.ReturnTester.view_ptr,
+        m.ReturnTester.ref_safe,
+        m.ReturnTester.ref_const_safe,
+        m.ReturnTester.corners,
+        m.ReturnTester.corners_const,
+    ]:
+        assert_keeps_alive(m.ReturnTester, meth)
+
+    for meth in [m.ReturnTester.block_safe, m.ReturnTester.block_const]:
+        assert_keeps_alive(m.ReturnTester, meth, 4, 3, 2, 1)
+
+
+def test_eigen_ref_mutators():
+    """Tests Eigen's ability to mutate numpy values"""
+
+    orig = np.array([[1.0, 2, 3], [4, 5, 6], [7, 8, 9]])
+    zr = np.array(orig)
+    zc = np.array(orig, order="F")
+    m.add_rm(zr, 1, 0, 100)
+    assert np.all(zr == np.array([[1.0, 2, 3], [104, 5, 6], [7, 8, 9]]))
+    m.add_cm(zc, 1, 0, 200)
+    assert np.all(zc == np.array([[1.0, 2, 3], [204, 5, 6], [7, 8, 9]]))
+
+    m.add_any(zr, 1, 0, 20)
+    assert np.all(zr == np.array([[1.0, 2, 3], [124, 5, 6], [7, 8, 9]]))
+    m.add_any(zc, 1, 0, 10)
+    assert np.all(zc == np.array([[1.0, 2, 3], [214, 5, 6], [7, 8, 9]]))
+
+    # Can't reference a col-major array with a row-major Ref, and vice versa:
+    with pytest.raises(TypeError):
+        m.add_rm(zc, 1, 0, 1)
+    with pytest.raises(TypeError):
+        m.add_cm(zr, 1, 0, 1)
+
+    # Overloads:
+    m.add1(zr, 1, 0, -100)
+    m.add2(zr, 1, 0, -20)
+    assert np.all(zr == orig)
+    m.add1(zc, 1, 0, -200)
+    m.add2(zc, 1, 0, -10)
+    assert np.all(zc == orig)
+
+    # a non-contiguous slice (this won't work on either the row- or
+    # column-contiguous refs, but should work for the any)
+    cornersr = zr[0::2, 0::2]
+    cornersc = zc[0::2, 0::2]
+
+    assert np.all(cornersr == np.array([[1.0, 3], [7, 9]]))
+    assert np.all(cornersc == np.array([[1.0, 3], [7, 9]]))
+
+    with pytest.raises(TypeError):
+        m.add_rm(cornersr, 0, 1, 25)
+    with pytest.raises(TypeError):
+        m.add_cm(cornersr, 0, 1, 25)
+    with pytest.raises(TypeError):
+        m.add_rm(cornersc, 0, 1, 25)
+    with pytest.raises(TypeError):
+        m.add_cm(cornersc, 0, 1, 25)
+    m.add_any(cornersr, 0, 1, 25)
+    m.add_any(cornersc, 0, 1, 44)
+    assert np.all(zr == np.array([[1.0, 2, 28], [4, 5, 6], [7, 8, 9]]))
+    assert np.all(zc == np.array([[1.0, 2, 47], [4, 5, 6], [7, 8, 9]]))
+
+    # You shouldn't be allowed to pass a non-writeable array to a mutating Eigen method:
+    zro = zr[0:4, 0:4]
+    zro.flags.writeable = False
+    with pytest.raises(TypeError):
+        m.add_rm(zro, 0, 0, 0)
+    with pytest.raises(TypeError):
+        m.add_any(zro, 0, 0, 0)
+    with pytest.raises(TypeError):
+        m.add1(zro, 0, 0, 0)
+    with pytest.raises(TypeError):
+        m.add2(zro, 0, 0, 0)
+
+    # integer array shouldn't be passable to a double-matrix-accepting mutating func:
+    zi = np.array([[1, 2], [3, 4]])
+    with pytest.raises(TypeError):
+        m.add_rm(zi)
+
+
+def test_numpy_ref_mutators():
+    """Tests numpy mutating Eigen matrices (for returned Eigen::Ref<...>s)"""
+
+    m.reset_refs()  # In case another test already changed it
+
+    zc = m.get_cm_ref()
+    zcro = m.get_cm_const_ref()
+    zr = m.get_rm_ref()
+    zrro = m.get_rm_const_ref()
+
+    assert [zc[1, 2], zcro[1, 2], zr[1, 2], zrro[1, 2]] == [23] * 4
+
+    assert not zc.flags.owndata and zc.flags.writeable
+    assert not zr.flags.owndata and zr.flags.writeable
+    assert not zcro.flags.owndata and not zcro.flags.writeable
+    assert not zrro.flags.owndata and not zrro.flags.writeable
+
+    zc[1, 2] = 99
+    expect = np.array([[11.0, 12, 13], [21, 22, 99], [31, 32, 33]])
+    # We should have just changed zc, of course, but also zcro and the original eigen matrix
+    assert np.all(zc == expect)
+    assert np.all(zcro == expect)
+    assert np.all(m.get_cm_ref() == expect)
+
+    zr[1, 2] = 99
+    assert np.all(zr == expect)
+    assert np.all(zrro == expect)
+    assert np.all(m.get_rm_ref() == expect)
+
+    # Make sure the readonly ones are numpy-readonly:
+    with pytest.raises(ValueError):
+        zcro[1, 2] = 6
+    with pytest.raises(ValueError):
+        zrro[1, 2] = 6
+
+    # We should be able to explicitly copy like this (and since we're copying,
+    # the const should drop away)
+    y1 = np.array(m.get_cm_const_ref())
+
+    assert y1.flags.owndata and y1.flags.writeable
+    # We should get copies of the eigen data, which was modified above:
+    assert y1[1, 2] == 99
+    y1[1, 2] += 12
+    assert y1[1, 2] == 111
+    assert zc[1, 2] == 99  # Make sure we aren't referencing the original
+
+
+def test_both_ref_mutators():
+    """Tests a complex chain of nested eigen/numpy references"""
+
+    m.reset_refs()  # In case another test already changed it
+
+    z = m.get_cm_ref()  # numpy -> eigen
+    z[0, 2] -= 3
+    z2 = m.incr_matrix(z, 1)  # numpy -> eigen -> numpy -> eigen
+    z2[1, 1] += 6
+    z3 = m.incr_matrix(z, 2)  # (numpy -> eigen)^3
+    z3[2, 2] += -5
+    z4 = m.incr_matrix(z, 3)  # (numpy -> eigen)^4
+    z4[1, 1] -= 1
+    z5 = m.incr_matrix(z, 4)  # (numpy -> eigen)^5
+    z5[0, 0] = 0
+    assert np.all(z == z2)
+    assert np.all(z == z3)
+    assert np.all(z == z4)
+    assert np.all(z == z5)
+    expect = np.array([[0.0, 22, 20], [31, 37, 33], [41, 42, 38]])
+    assert np.all(z == expect)
+
+    y = np.array(range(100), dtype="float64").reshape(10, 10)
+    y2 = m.incr_matrix_any(y, 10)  # np -> eigen -> np
+    y3 = m.incr_matrix_any(
+        y2[0::2, 0::2], -33
+    )  # np -> eigen -> np slice -> np -> eigen -> np
+    y4 = m.even_rows(y3)  # numpy -> eigen slice -> (... y3)
+    y5 = m.even_cols(y4)  # numpy -> eigen slice -> (... y4)
+    y6 = m.incr_matrix_any(y5, 1000)  # numpy -> eigen -> (... y5)
+
+    # Apply same mutations using just numpy:
+    yexpect = np.array(range(100), dtype="float64").reshape(10, 10)
+    yexpect += 10
+    yexpect[0::2, 0::2] -= 33
+    yexpect[0::4, 0::4] += 1000
+    assert np.all(y6 == yexpect[0::4, 0::4])
+    assert np.all(y5 == yexpect[0::4, 0::4])
+    assert np.all(y4 == yexpect[0::4, 0::2])
+    assert np.all(y3 == yexpect[0::2, 0::2])
+    assert np.all(y2 == yexpect)
+    assert np.all(y == yexpect)
+
+
+def test_nocopy_wrapper():
+    # get_elem requires a column-contiguous matrix reference, but should be
+    # callable with other types of matrix (via copying):
+    int_matrix_colmajor = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]], order="F")
+    dbl_matrix_colmajor = np.array(
+        int_matrix_colmajor, dtype="double", order="F", copy=True
+    )
+    int_matrix_rowmajor = np.array(int_matrix_colmajor, order="C", copy=True)
+    dbl_matrix_rowmajor = np.array(
+        int_matrix_rowmajor, dtype="double", order="C", copy=True
+    )
+
+    # All should be callable via get_elem:
+    assert m.get_elem(int_matrix_colmajor) == 8
+    assert m.get_elem(dbl_matrix_colmajor) == 8
+    assert m.get_elem(int_matrix_rowmajor) == 8
+    assert m.get_elem(dbl_matrix_rowmajor) == 8
+
+    # All but the second should fail with m.get_elem_nocopy:
+    with pytest.raises(TypeError) as excinfo:
+        m.get_elem_nocopy(int_matrix_colmajor)
+    assert "get_elem_nocopy(): incompatible function arguments." in str(
+        excinfo.value
+    ) and ", flags.f_contiguous" in str(excinfo.value)
+    assert m.get_elem_nocopy(dbl_matrix_colmajor) == 8
+    with pytest.raises(TypeError) as excinfo:
+        m.get_elem_nocopy(int_matrix_rowmajor)
+    assert "get_elem_nocopy(): incompatible function arguments." in str(
+        excinfo.value
+    ) and ", flags.f_contiguous" in str(excinfo.value)
+    with pytest.raises(TypeError) as excinfo:
+        m.get_elem_nocopy(dbl_matrix_rowmajor)
+    assert "get_elem_nocopy(): incompatible function arguments." in str(
+        excinfo.value
+    ) and ", flags.f_contiguous" in str(excinfo.value)
+
+    # For the row-major test, we take a long matrix in row-major, so only the third is allowed:
+    with pytest.raises(TypeError) as excinfo:
+        m.get_elem_rm_nocopy(int_matrix_colmajor)
+    assert "get_elem_rm_nocopy(): incompatible function arguments." in str(
+        excinfo.value
+    ) and ", flags.c_contiguous" in str(excinfo.value)
+    with pytest.raises(TypeError) as excinfo:
+        m.get_elem_rm_nocopy(dbl_matrix_colmajor)
+    assert "get_elem_rm_nocopy(): incompatible function arguments." in str(
+        excinfo.value
+    ) and ", flags.c_contiguous" in str(excinfo.value)
+    assert m.get_elem_rm_nocopy(int_matrix_rowmajor) == 8
+    with pytest.raises(TypeError) as excinfo:
+        m.get_elem_rm_nocopy(dbl_matrix_rowmajor)
+    assert "get_elem_rm_nocopy(): incompatible function arguments." in str(
+        excinfo.value
+    ) and ", flags.c_contiguous" in str(excinfo.value)
+
+
+def test_eigen_ref_life_support():
+    """Ensure the lifetime of temporary arrays created by the `Ref` caster
+
+    The `Ref` caster sometimes creates a copy which needs to stay alive. This needs to
+    happen both for directs casts (just the array) or indirectly (e.g. list of arrays).
+    """
+
+    a = np.full(shape=10, fill_value=8, dtype=np.int8)
+    assert m.get_elem_direct(a) == 8
+
+    list_of_a = [a]
+    assert m.get_elem_indirect(list_of_a) == 8
+
+
+def test_special_matrix_objects():
+    assert np.all(m.incr_diag(7) == np.diag([1.0, 2, 3, 4, 5, 6, 7]))
+
+    asymm = np.array([[1.0, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])
+    symm_lower = np.array(asymm)
+    symm_upper = np.array(asymm)
+    for i in range(4):
+        for j in range(i + 1, 4):
+            symm_lower[i, j] = symm_lower[j, i]
+            symm_upper[j, i] = symm_upper[i, j]
+
+    assert np.all(m.symmetric_lower(asymm) == symm_lower)
+    assert np.all(m.symmetric_upper(asymm) == symm_upper)
+
+
+def test_dense_signature(doc):
+    assert (
+        doc(m.double_col)
+        == """
+        double_col(arg0: numpy.ndarray[numpy.float32[m, 1]]) -> numpy.ndarray[numpy.float32[m, 1]]
+    """
+    )
+    assert (
+        doc(m.double_row)
+        == """
+        double_row(arg0: numpy.ndarray[numpy.float32[1, n]]) -> numpy.ndarray[numpy.float32[1, n]]
+    """
+    )
+    assert doc(m.double_complex) == (
+        """
+        double_complex(arg0: numpy.ndarray[numpy.complex64[m, 1]])"""
+        """ -> numpy.ndarray[numpy.complex64[m, 1]]
+    """
+    )
+    assert doc(m.double_mat_rm) == (
+        """
+        double_mat_rm(arg0: numpy.ndarray[numpy.float32[m, n]])"""
+        """ -> numpy.ndarray[numpy.float32[m, n]]
+    """
+    )
+
+
+def test_named_arguments():
+    a = np.array([[1.0, 2], [3, 4], [5, 6]])
+    b = np.ones((2, 1))
+
+    assert np.all(m.matrix_multiply(a, b) == np.array([[3.0], [7], [11]]))
+    assert np.all(m.matrix_multiply(A=a, B=b) == np.array([[3.0], [7], [11]]))
+    assert np.all(m.matrix_multiply(B=b, A=a) == np.array([[3.0], [7], [11]]))
+
+    with pytest.raises(ValueError) as excinfo:
+        m.matrix_multiply(b, a)
+    assert str(excinfo.value) == "Nonconformable matrices!"
+
+    with pytest.raises(ValueError) as excinfo:
+        m.matrix_multiply(A=b, B=a)
+    assert str(excinfo.value) == "Nonconformable matrices!"
+
+    with pytest.raises(ValueError) as excinfo:
+        m.matrix_multiply(B=a, A=b)
+    assert str(excinfo.value) == "Nonconformable matrices!"
+
+
+def test_sparse():
+    pytest.importorskip("scipy")
+    assert_sparse_equal_ref(m.sparse_r())
+    assert_sparse_equal_ref(m.sparse_c())
+    assert_sparse_equal_ref(m.sparse_copy_r(m.sparse_r()))
+    assert_sparse_equal_ref(m.sparse_copy_c(m.sparse_c()))
+    assert_sparse_equal_ref(m.sparse_copy_r(m.sparse_c()))
+    assert_sparse_equal_ref(m.sparse_copy_c(m.sparse_r()))
+
+
+def test_sparse_signature(doc):
+    pytest.importorskip("scipy")
+    assert (
+        doc(m.sparse_copy_r)
+        == """
+        sparse_copy_r(arg0: scipy.sparse.csr_matrix[numpy.float32]) -> scipy.sparse.csr_matrix[numpy.float32]
+    """
+    )
+    assert (
+        doc(m.sparse_copy_c)
+        == """
+        sparse_copy_c(arg0: scipy.sparse.csc_matrix[numpy.float32]) -> scipy.sparse.csc_matrix[numpy.float32]
+    """
+    )
+
+
+def test_issue738():
+    """Ignore strides on a length-1 dimension (even if they would be incompatible length > 1)"""
+    assert np.all(m.iss738_f1(np.array([[1.0, 2, 3]])) == np.array([[1.0, 102, 203]]))
+    assert np.all(
+        m.iss738_f1(np.array([[1.0], [2], [3]])) == np.array([[1.0], [12], [23]])
+    )
+
+    assert np.all(m.iss738_f2(np.array([[1.0, 2, 3]])) == np.array([[1.0, 102, 203]]))
+    assert np.all(
+        m.iss738_f2(np.array([[1.0], [2], [3]])) == np.array([[1.0], [12], [23]])
+    )
+
+
+@pytest.mark.parametrize("func", [m.iss738_f1, m.iss738_f2])
+@pytest.mark.parametrize("sizes", [(0, 2), (2, 0)])
+def test_zero_length(func, sizes):
+    """Ignore strides on a length-0 dimension (even if they would be incompatible length > 1)"""
+    assert np.all(func(np.zeros(sizes)) == np.zeros(sizes))
+
+
+def test_issue1105():
+    """Issue 1105: 1xN or Nx1 input arrays weren't accepted for eigen
+    compile-time row vectors or column vector"""
+    assert m.iss1105_row(np.ones((1, 7)))
+    assert m.iss1105_col(np.ones((7, 1)))
+
+    # These should still fail (incompatible dimensions):
+    with pytest.raises(TypeError) as excinfo:
+        m.iss1105_row(np.ones((7, 1)))
+    assert "incompatible function arguments" in str(excinfo.value)
+    with pytest.raises(TypeError) as excinfo:
+        m.iss1105_col(np.ones((1, 7)))
+    assert "incompatible function arguments" in str(excinfo.value)
+
+
+def test_custom_operator_new():
+    """Using Eigen types as member variables requires a class-specific
+    operator new with proper alignment"""
+
+    o = m.CustomOperatorNew()
+    np.testing.assert_allclose(o.a, 0.0)
+    np.testing.assert_allclose(o.b.diagonal(), 1.0)
```

## extern/pybind11/tests/test_eigen_tensor.py

 * *Ordering differences only*

```diff
@@ -1,290 +1,290 @@
-import sys
-
-import pytest
-
-np = pytest.importorskip("numpy")
-eigen_tensor = pytest.importorskip("pybind11_tests.eigen_tensor")
-submodules = [eigen_tensor.c_style, eigen_tensor.f_style]
-try:
-    import eigen_tensor_avoid_stl_array as avoid
-
-    submodules += [avoid.c_style, avoid.f_style]
-except ImportError as e:
-    # Ensure config, build, toolchain, etc. issues are not masked here:
-    raise RuntimeError(
-        "import eigen_tensor_avoid_stl_array FAILED, while "
-        "import pybind11_tests.eigen_tensor succeeded. "
-        "Please ensure that "
-        "test_eigen_tensor.cpp & "
-        "eigen_tensor_avoid_stl_array.cpp "
-        "are built together (or both are not built if Eigen is not available)."
-    ) from e
-
-tensor_ref = np.empty((3, 5, 2), dtype=np.int64)
-
-for i in range(tensor_ref.shape[0]):
-    for j in range(tensor_ref.shape[1]):
-        for k in range(tensor_ref.shape[2]):
-            tensor_ref[i, j, k] = i * (5 * 2) + j * 2 + k
-
-indices = (2, 3, 1)
-
-
-@pytest.fixture(autouse=True)
-def cleanup():
-    for module in submodules:
-        module.setup()
-
-    yield
-
-    for module in submodules:
-        assert module.is_ok()
-
-
-def test_import_avoid_stl_array():
-    pytest.importorskip("eigen_tensor_avoid_stl_array")
-    assert len(submodules) == 4
-
-
-def assert_equal_tensor_ref(mat, writeable=True, modified=None):
-    assert mat.flags.writeable == writeable
-
-    copy = np.array(tensor_ref)
-    if modified is not None:
-        copy[indices] = modified
-
-    np.testing.assert_array_equal(mat, copy)
-
-
-@pytest.mark.parametrize("m", submodules)
-@pytest.mark.parametrize("member_name", ["member", "member_view"])
-def test_reference_internal(m, member_name):
-    if not hasattr(sys, "getrefcount"):
-        pytest.skip("No reference counting")
-    foo = m.CustomExample()
-    counts = sys.getrefcount(foo)
-    mem = getattr(foo, member_name)
-    assert_equal_tensor_ref(mem, writeable=False)
-    new_counts = sys.getrefcount(foo)
-    assert new_counts == counts + 1
-    assert_equal_tensor_ref(mem, writeable=False)
-    del mem
-    assert sys.getrefcount(foo) == counts
-
-
-assert_equal_funcs = [
-    "copy_tensor",
-    "copy_fixed_tensor",
-    "copy_const_tensor",
-    "move_tensor_copy",
-    "move_fixed_tensor_copy",
-    "take_tensor",
-    "take_fixed_tensor",
-    "reference_tensor",
-    "reference_tensor_v2",
-    "reference_fixed_tensor",
-    "reference_view_of_tensor",
-    "reference_view_of_tensor_v3",
-    "reference_view_of_tensor_v5",
-    "reference_view_of_fixed_tensor",
-]
-
-assert_equal_const_funcs = [
-    "reference_view_of_tensor_v2",
-    "reference_view_of_tensor_v4",
-    "reference_view_of_tensor_v6",
-    "reference_const_tensor",
-    "reference_const_tensor_v2",
-]
-
-
-@pytest.mark.parametrize("m", submodules)
-@pytest.mark.parametrize("func_name", assert_equal_funcs + assert_equal_const_funcs)
-def test_convert_tensor_to_py(m, func_name):
-    writeable = func_name in assert_equal_funcs
-    assert_equal_tensor_ref(getattr(m, func_name)(), writeable=writeable)
-
-
-@pytest.mark.parametrize("m", submodules)
-def test_bad_cpp_to_python_casts(m):
-    with pytest.raises(
-        RuntimeError, match="Cannot use reference internal when there is no parent"
-    ):
-        m.reference_tensor_internal()
-
-    with pytest.raises(RuntimeError, match="Cannot move from a constant reference"):
-        m.move_const_tensor()
-
-    with pytest.raises(
-        RuntimeError, match="Cannot take ownership of a const reference"
-    ):
-        m.take_const_tensor()
-
-    with pytest.raises(
-        RuntimeError,
-        match="Invalid return_value_policy for Eigen Map type, must be either reference or reference_internal",
-    ):
-        m.take_view_tensor()
-
-
-@pytest.mark.parametrize("m", submodules)
-def test_bad_python_to_cpp_casts(m):
-    with pytest.raises(
-        TypeError, match=r"^round_trip_tensor\(\): incompatible function arguments"
-    ):
-        m.round_trip_tensor(np.zeros((2, 3)))
-
-    with pytest.raises(TypeError, match=r"^Cannot cast array data from dtype"):
-        m.round_trip_tensor(np.zeros(dtype=np.str_, shape=(2, 3, 1)))
-
-    with pytest.raises(
-        TypeError,
-        match=r"^round_trip_tensor_noconvert\(\): incompatible function arguments",
-    ):
-        m.round_trip_tensor_noconvert(tensor_ref)
-
-    assert_equal_tensor_ref(
-        m.round_trip_tensor_noconvert(tensor_ref.astype(np.float64))
-    )
-
-    if m.needed_options == "F":
-        bad_options = "C"
-    else:
-        bad_options = "F"
-    # Shape, dtype and the order need to be correct for a TensorMap cast
-    with pytest.raises(
-        TypeError, match=r"^round_trip_view_tensor\(\): incompatible function arguments"
-    ):
-        m.round_trip_view_tensor(
-            np.zeros((3, 5, 2), dtype=np.float64, order=bad_options)
-        )
-
-    with pytest.raises(
-        TypeError, match=r"^round_trip_view_tensor\(\): incompatible function arguments"
-    ):
-        m.round_trip_view_tensor(
-            np.zeros((3, 5, 2), dtype=np.float32, order=m.needed_options)
-        )
-
-    with pytest.raises(
-        TypeError, match=r"^round_trip_view_tensor\(\): incompatible function arguments"
-    ):
-        m.round_trip_view_tensor(
-            np.zeros((3, 5), dtype=np.float64, order=m.needed_options)
-        )
-
-    with pytest.raises(
-        TypeError, match=r"^round_trip_view_tensor\(\): incompatible function arguments"
-    ):
-        temp = np.zeros((3, 5, 2), dtype=np.float64, order=m.needed_options)
-        m.round_trip_view_tensor(
-            temp[:, ::-1, :],
-        )
-
-    with pytest.raises(
-        TypeError, match=r"^round_trip_view_tensor\(\): incompatible function arguments"
-    ):
-        temp = np.zeros((3, 5, 2), dtype=np.float64, order=m.needed_options)
-        temp.setflags(write=False)
-        m.round_trip_view_tensor(temp)
-
-
-@pytest.mark.parametrize("m", submodules)
-def test_references_actually_refer(m):
-    a = m.reference_tensor()
-    temp = a[indices]
-    a[indices] = 100
-    assert_equal_tensor_ref(m.copy_const_tensor(), modified=100)
-    a[indices] = temp
-    assert_equal_tensor_ref(m.copy_const_tensor())
-
-    a = m.reference_view_of_tensor()
-    a[indices] = 100
-    assert_equal_tensor_ref(m.copy_const_tensor(), modified=100)
-    a[indices] = temp
-    assert_equal_tensor_ref(m.copy_const_tensor())
-
-
-@pytest.mark.parametrize("m", submodules)
-def test_round_trip(m):
-    assert_equal_tensor_ref(m.round_trip_tensor(tensor_ref))
-
-    with pytest.raises(TypeError, match="^Cannot cast array data from"):
-        assert_equal_tensor_ref(m.round_trip_tensor2(tensor_ref))
-
-    assert_equal_tensor_ref(m.round_trip_tensor2(np.array(tensor_ref, dtype=np.int32)))
-    assert_equal_tensor_ref(m.round_trip_fixed_tensor(tensor_ref))
-    assert_equal_tensor_ref(m.round_trip_aligned_view_tensor(m.reference_tensor()))
-
-    copy = np.array(tensor_ref, dtype=np.float64, order=m.needed_options)
-    assert_equal_tensor_ref(m.round_trip_view_tensor(copy))
-    assert_equal_tensor_ref(m.round_trip_view_tensor_ref(copy))
-    assert_equal_tensor_ref(m.round_trip_view_tensor_ptr(copy))
-    copy.setflags(write=False)
-    assert_equal_tensor_ref(m.round_trip_const_view_tensor(copy))
-
-    np.testing.assert_array_equal(
-        tensor_ref[:, ::-1, :], m.round_trip_tensor(tensor_ref[:, ::-1, :])
-    )
-
-    assert m.round_trip_rank_0(np.float64(3.5)) == 3.5
-    assert m.round_trip_rank_0(3.5) == 3.5
-
-    with pytest.raises(
-        TypeError,
-        match=r"^round_trip_rank_0_noconvert\(\): incompatible function arguments",
-    ):
-        m.round_trip_rank_0_noconvert(np.float64(3.5))
-
-    with pytest.raises(
-        TypeError,
-        match=r"^round_trip_rank_0_noconvert\(\): incompatible function arguments",
-    ):
-        m.round_trip_rank_0_noconvert(3.5)
-
-    with pytest.raises(
-        TypeError, match=r"^round_trip_rank_0_view\(\): incompatible function arguments"
-    ):
-        m.round_trip_rank_0_view(np.float64(3.5))
-
-    with pytest.raises(
-        TypeError, match=r"^round_trip_rank_0_view\(\): incompatible function arguments"
-    ):
-        m.round_trip_rank_0_view(3.5)
-
-
-@pytest.mark.parametrize("m", submodules)
-def test_round_trip_references_actually_refer(m):
-    # Need to create a copy that matches the type on the C side
-    copy = np.array(tensor_ref, dtype=np.float64, order=m.needed_options)
-    a = m.round_trip_view_tensor(copy)
-    temp = a[indices]
-    a[indices] = 100
-    assert_equal_tensor_ref(copy, modified=100)
-    a[indices] = temp
-    assert_equal_tensor_ref(copy)
-
-
-@pytest.mark.parametrize("m", submodules)
-def test_doc_string(m, doc):
-    assert (
-        doc(m.copy_tensor) == "copy_tensor() -> numpy.ndarray[numpy.float64[?, ?, ?]]"
-    )
-    assert (
-        doc(m.copy_fixed_tensor)
-        == "copy_fixed_tensor() -> numpy.ndarray[numpy.float64[3, 5, 2]]"
-    )
-    assert (
-        doc(m.reference_const_tensor)
-        == "reference_const_tensor() -> numpy.ndarray[numpy.float64[?, ?, ?]]"
-    )
-
-    order_flag = f"flags.{m.needed_options.lower()}_contiguous"
-    assert doc(m.round_trip_view_tensor) == (
-        f"round_trip_view_tensor(arg0: numpy.ndarray[numpy.float64[?, ?, ?], flags.writeable, {order_flag}])"
-        + f" -> numpy.ndarray[numpy.float64[?, ?, ?], flags.writeable, {order_flag}]"
-    )
-    assert doc(m.round_trip_const_view_tensor) == (
-        f"round_trip_const_view_tensor(arg0: numpy.ndarray[numpy.float64[?, ?, ?], {order_flag}])"
-        + " -> numpy.ndarray[numpy.float64[?, ?, ?]]"
-    )
+import sys
+
+import pytest
+
+np = pytest.importorskip("numpy")
+eigen_tensor = pytest.importorskip("pybind11_tests.eigen_tensor")
+submodules = [eigen_tensor.c_style, eigen_tensor.f_style]
+try:
+    import eigen_tensor_avoid_stl_array as avoid
+
+    submodules += [avoid.c_style, avoid.f_style]
+except ImportError as e:
+    # Ensure config, build, toolchain, etc. issues are not masked here:
+    raise RuntimeError(
+        "import eigen_tensor_avoid_stl_array FAILED, while "
+        "import pybind11_tests.eigen_tensor succeeded. "
+        "Please ensure that "
+        "test_eigen_tensor.cpp & "
+        "eigen_tensor_avoid_stl_array.cpp "
+        "are built together (or both are not built if Eigen is not available)."
+    ) from e
+
+tensor_ref = np.empty((3, 5, 2), dtype=np.int64)
+
+for i in range(tensor_ref.shape[0]):
+    for j in range(tensor_ref.shape[1]):
+        for k in range(tensor_ref.shape[2]):
+            tensor_ref[i, j, k] = i * (5 * 2) + j * 2 + k
+
+indices = (2, 3, 1)
+
+
+@pytest.fixture(autouse=True)
+def cleanup():
+    for module in submodules:
+        module.setup()
+
+    yield
+
+    for module in submodules:
+        assert module.is_ok()
+
+
+def test_import_avoid_stl_array():
+    pytest.importorskip("eigen_tensor_avoid_stl_array")
+    assert len(submodules) == 4
+
+
+def assert_equal_tensor_ref(mat, writeable=True, modified=None):
+    assert mat.flags.writeable == writeable
+
+    copy = np.array(tensor_ref)
+    if modified is not None:
+        copy[indices] = modified
+
+    np.testing.assert_array_equal(mat, copy)
+
+
+@pytest.mark.parametrize("m", submodules)
+@pytest.mark.parametrize("member_name", ["member", "member_view"])
+def test_reference_internal(m, member_name):
+    if not hasattr(sys, "getrefcount"):
+        pytest.skip("No reference counting")
+    foo = m.CustomExample()
+    counts = sys.getrefcount(foo)
+    mem = getattr(foo, member_name)
+    assert_equal_tensor_ref(mem, writeable=False)
+    new_counts = sys.getrefcount(foo)
+    assert new_counts == counts + 1
+    assert_equal_tensor_ref(mem, writeable=False)
+    del mem
+    assert sys.getrefcount(foo) == counts
+
+
+assert_equal_funcs = [
+    "copy_tensor",
+    "copy_fixed_tensor",
+    "copy_const_tensor",
+    "move_tensor_copy",
+    "move_fixed_tensor_copy",
+    "take_tensor",
+    "take_fixed_tensor",
+    "reference_tensor",
+    "reference_tensor_v2",
+    "reference_fixed_tensor",
+    "reference_view_of_tensor",
+    "reference_view_of_tensor_v3",
+    "reference_view_of_tensor_v5",
+    "reference_view_of_fixed_tensor",
+]
+
+assert_equal_const_funcs = [
+    "reference_view_of_tensor_v2",
+    "reference_view_of_tensor_v4",
+    "reference_view_of_tensor_v6",
+    "reference_const_tensor",
+    "reference_const_tensor_v2",
+]
+
+
+@pytest.mark.parametrize("m", submodules)
+@pytest.mark.parametrize("func_name", assert_equal_funcs + assert_equal_const_funcs)
+def test_convert_tensor_to_py(m, func_name):
+    writeable = func_name in assert_equal_funcs
+    assert_equal_tensor_ref(getattr(m, func_name)(), writeable=writeable)
+
+
+@pytest.mark.parametrize("m", submodules)
+def test_bad_cpp_to_python_casts(m):
+    with pytest.raises(
+        RuntimeError, match="Cannot use reference internal when there is no parent"
+    ):
+        m.reference_tensor_internal()
+
+    with pytest.raises(RuntimeError, match="Cannot move from a constant reference"):
+        m.move_const_tensor()
+
+    with pytest.raises(
+        RuntimeError, match="Cannot take ownership of a const reference"
+    ):
+        m.take_const_tensor()
+
+    with pytest.raises(
+        RuntimeError,
+        match="Invalid return_value_policy for Eigen Map type, must be either reference or reference_internal",
+    ):
+        m.take_view_tensor()
+
+
+@pytest.mark.parametrize("m", submodules)
+def test_bad_python_to_cpp_casts(m):
+    with pytest.raises(
+        TypeError, match=r"^round_trip_tensor\(\): incompatible function arguments"
+    ):
+        m.round_trip_tensor(np.zeros((2, 3)))
+
+    with pytest.raises(TypeError, match=r"^Cannot cast array data from dtype"):
+        m.round_trip_tensor(np.zeros(dtype=np.str_, shape=(2, 3, 1)))
+
+    with pytest.raises(
+        TypeError,
+        match=r"^round_trip_tensor_noconvert\(\): incompatible function arguments",
+    ):
+        m.round_trip_tensor_noconvert(tensor_ref)
+
+    assert_equal_tensor_ref(
+        m.round_trip_tensor_noconvert(tensor_ref.astype(np.float64))
+    )
+
+    if m.needed_options == "F":
+        bad_options = "C"
+    else:
+        bad_options = "F"
+    # Shape, dtype and the order need to be correct for a TensorMap cast
+    with pytest.raises(
+        TypeError, match=r"^round_trip_view_tensor\(\): incompatible function arguments"
+    ):
+        m.round_trip_view_tensor(
+            np.zeros((3, 5, 2), dtype=np.float64, order=bad_options)
+        )
+
+    with pytest.raises(
+        TypeError, match=r"^round_trip_view_tensor\(\): incompatible function arguments"
+    ):
+        m.round_trip_view_tensor(
+            np.zeros((3, 5, 2), dtype=np.float32, order=m.needed_options)
+        )
+
+    with pytest.raises(
+        TypeError, match=r"^round_trip_view_tensor\(\): incompatible function arguments"
+    ):
+        m.round_trip_view_tensor(
+            np.zeros((3, 5), dtype=np.float64, order=m.needed_options)
+        )
+
+    with pytest.raises(
+        TypeError, match=r"^round_trip_view_tensor\(\): incompatible function arguments"
+    ):
+        temp = np.zeros((3, 5, 2), dtype=np.float64, order=m.needed_options)
+        m.round_trip_view_tensor(
+            temp[:, ::-1, :],
+        )
+
+    with pytest.raises(
+        TypeError, match=r"^round_trip_view_tensor\(\): incompatible function arguments"
+    ):
+        temp = np.zeros((3, 5, 2), dtype=np.float64, order=m.needed_options)
+        temp.setflags(write=False)
+        m.round_trip_view_tensor(temp)
+
+
+@pytest.mark.parametrize("m", submodules)
+def test_references_actually_refer(m):
+    a = m.reference_tensor()
+    temp = a[indices]
+    a[indices] = 100
+    assert_equal_tensor_ref(m.copy_const_tensor(), modified=100)
+    a[indices] = temp
+    assert_equal_tensor_ref(m.copy_const_tensor())
+
+    a = m.reference_view_of_tensor()
+    a[indices] = 100
+    assert_equal_tensor_ref(m.copy_const_tensor(), modified=100)
+    a[indices] = temp
+    assert_equal_tensor_ref(m.copy_const_tensor())
+
+
+@pytest.mark.parametrize("m", submodules)
+def test_round_trip(m):
+    assert_equal_tensor_ref(m.round_trip_tensor(tensor_ref))
+
+    with pytest.raises(TypeError, match="^Cannot cast array data from"):
+        assert_equal_tensor_ref(m.round_trip_tensor2(tensor_ref))
+
+    assert_equal_tensor_ref(m.round_trip_tensor2(np.array(tensor_ref, dtype=np.int32)))
+    assert_equal_tensor_ref(m.round_trip_fixed_tensor(tensor_ref))
+    assert_equal_tensor_ref(m.round_trip_aligned_view_tensor(m.reference_tensor()))
+
+    copy = np.array(tensor_ref, dtype=np.float64, order=m.needed_options)
+    assert_equal_tensor_ref(m.round_trip_view_tensor(copy))
+    assert_equal_tensor_ref(m.round_trip_view_tensor_ref(copy))
+    assert_equal_tensor_ref(m.round_trip_view_tensor_ptr(copy))
+    copy.setflags(write=False)
+    assert_equal_tensor_ref(m.round_trip_const_view_tensor(copy))
+
+    np.testing.assert_array_equal(
+        tensor_ref[:, ::-1, :], m.round_trip_tensor(tensor_ref[:, ::-1, :])
+    )
+
+    assert m.round_trip_rank_0(np.float64(3.5)) == 3.5
+    assert m.round_trip_rank_0(3.5) == 3.5
+
+    with pytest.raises(
+        TypeError,
+        match=r"^round_trip_rank_0_noconvert\(\): incompatible function arguments",
+    ):
+        m.round_trip_rank_0_noconvert(np.float64(3.5))
+
+    with pytest.raises(
+        TypeError,
+        match=r"^round_trip_rank_0_noconvert\(\): incompatible function arguments",
+    ):
+        m.round_trip_rank_0_noconvert(3.5)
+
+    with pytest.raises(
+        TypeError, match=r"^round_trip_rank_0_view\(\): incompatible function arguments"
+    ):
+        m.round_trip_rank_0_view(np.float64(3.5))
+
+    with pytest.raises(
+        TypeError, match=r"^round_trip_rank_0_view\(\): incompatible function arguments"
+    ):
+        m.round_trip_rank_0_view(3.5)
+
+
+@pytest.mark.parametrize("m", submodules)
+def test_round_trip_references_actually_refer(m):
+    # Need to create a copy that matches the type on the C side
+    copy = np.array(tensor_ref, dtype=np.float64, order=m.needed_options)
+    a = m.round_trip_view_tensor(copy)
+    temp = a[indices]
+    a[indices] = 100
+    assert_equal_tensor_ref(copy, modified=100)
+    a[indices] = temp
+    assert_equal_tensor_ref(copy)
+
+
+@pytest.mark.parametrize("m", submodules)
+def test_doc_string(m, doc):
+    assert (
+        doc(m.copy_tensor) == "copy_tensor() -> numpy.ndarray[numpy.float64[?, ?, ?]]"
+    )
+    assert (
+        doc(m.copy_fixed_tensor)
+        == "copy_fixed_tensor() -> numpy.ndarray[numpy.float64[3, 5, 2]]"
+    )
+    assert (
+        doc(m.reference_const_tensor)
+        == "reference_const_tensor() -> numpy.ndarray[numpy.float64[?, ?, ?]]"
+    )
+
+    order_flag = f"flags.{m.needed_options.lower()}_contiguous"
+    assert doc(m.round_trip_view_tensor) == (
+        f"round_trip_view_tensor(arg0: numpy.ndarray[numpy.float64[?, ?, ?], flags.writeable, {order_flag}])"
+        + f" -> numpy.ndarray[numpy.float64[?, ?, ?], flags.writeable, {order_flag}]"
+    )
+    assert doc(m.round_trip_const_view_tensor) == (
+        f"round_trip_const_view_tensor(arg0: numpy.ndarray[numpy.float64[?, ?, ?], {order_flag}])"
+        + " -> numpy.ndarray[numpy.float64[?, ?, ?]]"
+    )
```

## extern/pybind11/tests/test_enum.py

 * *Ordering differences only*

```diff
@@ -1,264 +1,264 @@
-import pytest
-
-from pybind11_tests import enums as m
-
-
-def test_unscoped_enum():
-    assert str(m.UnscopedEnum.EOne) == "UnscopedEnum.EOne"
-    assert str(m.UnscopedEnum.ETwo) == "UnscopedEnum.ETwo"
-    assert str(m.EOne) == "UnscopedEnum.EOne"
-    assert repr(m.UnscopedEnum.EOne) == "<UnscopedEnum.EOne: 1>"
-    assert repr(m.UnscopedEnum.ETwo) == "<UnscopedEnum.ETwo: 2>"
-    assert repr(m.EOne) == "<UnscopedEnum.EOne: 1>"
-
-    # name property
-    assert m.UnscopedEnum.EOne.name == "EOne"
-    assert m.UnscopedEnum.EOne.value == 1
-    assert m.UnscopedEnum.ETwo.name == "ETwo"
-    assert m.UnscopedEnum.ETwo.value == 2
-    assert m.EOne is m.UnscopedEnum.EOne
-    # name, value readonly
-    with pytest.raises(AttributeError):
-        m.UnscopedEnum.EOne.name = ""
-    with pytest.raises(AttributeError):
-        m.UnscopedEnum.EOne.value = 10
-    # name, value returns a copy
-    # TODO: Neither the name nor value tests actually check against aliasing.
-    # Use a mutable type that has reference semantics.
-    nonaliased_name = m.UnscopedEnum.EOne.name
-    nonaliased_name = "bar"  # noqa: F841
-    assert m.UnscopedEnum.EOne.name == "EOne"
-    nonaliased_value = m.UnscopedEnum.EOne.value
-    nonaliased_value = 10  # noqa: F841
-    assert m.UnscopedEnum.EOne.value == 1
-
-    # __members__ property
-    assert m.UnscopedEnum.__members__ == {
-        "EOne": m.UnscopedEnum.EOne,
-        "ETwo": m.UnscopedEnum.ETwo,
-        "EThree": m.UnscopedEnum.EThree,
-    }
-    # __members__ readonly
-    with pytest.raises(AttributeError):
-        m.UnscopedEnum.__members__ = {}
-    # __members__ returns a copy
-    nonaliased_members = m.UnscopedEnum.__members__
-    nonaliased_members["bar"] = "baz"
-    assert m.UnscopedEnum.__members__ == {
-        "EOne": m.UnscopedEnum.EOne,
-        "ETwo": m.UnscopedEnum.ETwo,
-        "EThree": m.UnscopedEnum.EThree,
-    }
-
-    for docstring_line in """An unscoped enumeration
-
-Members:
-
-  EOne : Docstring for EOne
-
-  ETwo : Docstring for ETwo
-
-  EThree : Docstring for EThree""".split(
-        "\n"
-    ):
-        assert docstring_line in m.UnscopedEnum.__doc__
-
-    # Unscoped enums will accept ==/!= int comparisons
-    y = m.UnscopedEnum.ETwo
-    assert y == 2
-    assert 2 == y
-    assert y != 3
-    assert 3 != y
-    # Compare with None
-    assert y != None  # noqa: E711
-    assert not (y == None)  # noqa: E711
-    # Compare with an object
-    assert y != object()
-    assert not (y == object())
-    # Compare with string
-    assert y != "2"
-    assert "2" != y
-    assert not ("2" == y)
-    assert not (y == "2")
-
-    with pytest.raises(TypeError):
-        y < object()  # noqa: B015
-
-    with pytest.raises(TypeError):
-        y <= object()  # noqa: B015
-
-    with pytest.raises(TypeError):
-        y > object()  # noqa: B015
-
-    with pytest.raises(TypeError):
-        y >= object()  # noqa: B015
-
-    with pytest.raises(TypeError):
-        y | object()
-
-    with pytest.raises(TypeError):
-        y & object()
-
-    with pytest.raises(TypeError):
-        y ^ object()
-
-    assert int(m.UnscopedEnum.ETwo) == 2
-    assert str(m.UnscopedEnum(2)) == "UnscopedEnum.ETwo"
-
-    # order
-    assert m.UnscopedEnum.EOne < m.UnscopedEnum.ETwo
-    assert m.UnscopedEnum.EOne < 2
-    assert m.UnscopedEnum.ETwo > m.UnscopedEnum.EOne
-    assert m.UnscopedEnum.ETwo > 1
-    assert m.UnscopedEnum.ETwo <= 2
-    assert m.UnscopedEnum.ETwo >= 2
-    assert m.UnscopedEnum.EOne <= m.UnscopedEnum.ETwo
-    assert m.UnscopedEnum.EOne <= 2
-    assert m.UnscopedEnum.ETwo >= m.UnscopedEnum.EOne
-    assert m.UnscopedEnum.ETwo >= 1
-    assert not (m.UnscopedEnum.ETwo < m.UnscopedEnum.EOne)
-    assert not (2 < m.UnscopedEnum.EOne)
-
-    # arithmetic
-    assert m.UnscopedEnum.EOne & m.UnscopedEnum.EThree == m.UnscopedEnum.EOne
-    assert m.UnscopedEnum.EOne | m.UnscopedEnum.ETwo == m.UnscopedEnum.EThree
-    assert m.UnscopedEnum.EOne ^ m.UnscopedEnum.EThree == m.UnscopedEnum.ETwo
-
-
-def test_scoped_enum():
-    assert m.test_scoped_enum(m.ScopedEnum.Three) == "ScopedEnum::Three"
-    z = m.ScopedEnum.Two
-    assert m.test_scoped_enum(z) == "ScopedEnum::Two"
-
-    # Scoped enums will *NOT* accept ==/!= int comparisons (Will always return False)
-    assert not z == 3
-    assert not 3 == z
-    assert z != 3
-    assert 3 != z
-    # Compare with None
-    assert z != None  # noqa: E711
-    assert not (z == None)  # noqa: E711
-    # Compare with an object
-    assert z != object()
-    assert not (z == object())
-    # Scoped enums will *NOT* accept >, <, >= and <= int comparisons (Will throw exceptions)
-    with pytest.raises(TypeError):
-        z > 3  # noqa: B015
-    with pytest.raises(TypeError):
-        z < 3  # noqa: B015
-    with pytest.raises(TypeError):
-        z >= 3  # noqa: B015
-    with pytest.raises(TypeError):
-        z <= 3  # noqa: B015
-
-    # order
-    assert m.ScopedEnum.Two < m.ScopedEnum.Three
-    assert m.ScopedEnum.Three > m.ScopedEnum.Two
-    assert m.ScopedEnum.Two <= m.ScopedEnum.Three
-    assert m.ScopedEnum.Two <= m.ScopedEnum.Two
-    assert m.ScopedEnum.Two >= m.ScopedEnum.Two
-    assert m.ScopedEnum.Three >= m.ScopedEnum.Two
-
-
-def test_implicit_conversion():
-    assert str(m.ClassWithUnscopedEnum.EMode.EFirstMode) == "EMode.EFirstMode"
-    assert str(m.ClassWithUnscopedEnum.EFirstMode) == "EMode.EFirstMode"
-    assert repr(m.ClassWithUnscopedEnum.EMode.EFirstMode) == "<EMode.EFirstMode: 1>"
-    assert repr(m.ClassWithUnscopedEnum.EFirstMode) == "<EMode.EFirstMode: 1>"
-
-    f = m.ClassWithUnscopedEnum.test_function
-    first = m.ClassWithUnscopedEnum.EFirstMode
-    second = m.ClassWithUnscopedEnum.ESecondMode
-
-    assert f(first) == 1
-
-    assert f(first) == f(first)
-    assert not f(first) != f(first)
-
-    assert f(first) != f(second)
-    assert not f(first) == f(second)
-
-    assert f(first) == int(f(first))
-    assert not f(first) != int(f(first))
-
-    assert f(first) != int(f(second))
-    assert not f(first) == int(f(second))
-
-    # noinspection PyDictCreation
-    x = {f(first): 1, f(second): 2}
-    x[f(first)] = 3
-    x[f(second)] = 4
-    # Hashing test
-    assert repr(x) == "{<EMode.EFirstMode: 1>: 3, <EMode.ESecondMode: 2>: 4}"
-
-
-def test_binary_operators():
-    assert int(m.Flags.Read) == 4
-    assert int(m.Flags.Write) == 2
-    assert int(m.Flags.Execute) == 1
-    assert int(m.Flags.Read | m.Flags.Write | m.Flags.Execute) == 7
-    assert int(m.Flags.Read | m.Flags.Write) == 6
-    assert int(m.Flags.Read | m.Flags.Execute) == 5
-    assert int(m.Flags.Write | m.Flags.Execute) == 3
-    assert int(m.Flags.Write | 1) == 3
-    assert ~m.Flags.Write == -3
-
-    state = m.Flags.Read | m.Flags.Write
-    assert (state & m.Flags.Read) != 0
-    assert (state & m.Flags.Write) != 0
-    assert (state & m.Flags.Execute) == 0
-    assert (state & 1) == 0
-
-    state2 = ~state
-    assert state2 == -7
-    assert int(state ^ state2) == -1
-
-
-def test_enum_to_int():
-    m.test_enum_to_int(m.Flags.Read)
-    m.test_enum_to_int(m.ClassWithUnscopedEnum.EMode.EFirstMode)
-    m.test_enum_to_int(m.ScopedCharEnum.Positive)
-    m.test_enum_to_int(m.ScopedBoolEnum.TRUE)
-    m.test_enum_to_uint(m.Flags.Read)
-    m.test_enum_to_uint(m.ClassWithUnscopedEnum.EMode.EFirstMode)
-    m.test_enum_to_uint(m.ScopedCharEnum.Positive)
-    m.test_enum_to_uint(m.ScopedBoolEnum.TRUE)
-    m.test_enum_to_long_long(m.Flags.Read)
-    m.test_enum_to_long_long(m.ClassWithUnscopedEnum.EMode.EFirstMode)
-    m.test_enum_to_long_long(m.ScopedCharEnum.Positive)
-    m.test_enum_to_long_long(m.ScopedBoolEnum.TRUE)
-
-
-def test_duplicate_enum_name():
-    with pytest.raises(ValueError) as excinfo:
-        m.register_bad_enum()
-    assert str(excinfo.value) == 'SimpleEnum: element "ONE" already exists!'
-
-
-def test_char_underlying_enum():  # Issue #1331/PR #1334:
-    assert type(m.ScopedCharEnum.Positive.__int__()) is int
-    assert int(m.ScopedChar16Enum.Zero) == 0
-    assert hash(m.ScopedChar32Enum.Positive) == 1
-    assert type(m.ScopedCharEnum.Positive.__getstate__()) is int
-    assert m.ScopedWCharEnum(1) == m.ScopedWCharEnum.Positive
-    with pytest.raises(TypeError):
-        # Even if the underlying type is char, only an int can be used to construct the enum:
-        m.ScopedCharEnum("0")
-
-
-def test_bool_underlying_enum():
-    assert type(m.ScopedBoolEnum.TRUE.__int__()) is int
-    assert int(m.ScopedBoolEnum.FALSE) == 0
-    assert hash(m.ScopedBoolEnum.TRUE) == 1
-    assert type(m.ScopedBoolEnum.TRUE.__getstate__()) is int
-    assert m.ScopedBoolEnum(1) == m.ScopedBoolEnum.TRUE
-    # Enum could construct with a bool
-    # (bool is a strict subclass of int, and False will be converted to 0)
-    assert m.ScopedBoolEnum(False) == m.ScopedBoolEnum.FALSE
-
-
-def test_docstring_signatures():
-    for enum_type in [m.ScopedEnum, m.UnscopedEnum]:
-        for attr in enum_type.__dict__.values():
-            # Issue #2623/PR #2637: Add argument names to enum_ methods
-            assert "arg0" not in (attr.__doc__ or "")
+import pytest
+
+from pybind11_tests import enums as m
+
+
+def test_unscoped_enum():
+    assert str(m.UnscopedEnum.EOne) == "UnscopedEnum.EOne"
+    assert str(m.UnscopedEnum.ETwo) == "UnscopedEnum.ETwo"
+    assert str(m.EOne) == "UnscopedEnum.EOne"
+    assert repr(m.UnscopedEnum.EOne) == "<UnscopedEnum.EOne: 1>"
+    assert repr(m.UnscopedEnum.ETwo) == "<UnscopedEnum.ETwo: 2>"
+    assert repr(m.EOne) == "<UnscopedEnum.EOne: 1>"
+
+    # name property
+    assert m.UnscopedEnum.EOne.name == "EOne"
+    assert m.UnscopedEnum.EOne.value == 1
+    assert m.UnscopedEnum.ETwo.name == "ETwo"
+    assert m.UnscopedEnum.ETwo.value == 2
+    assert m.EOne is m.UnscopedEnum.EOne
+    # name, value readonly
+    with pytest.raises(AttributeError):
+        m.UnscopedEnum.EOne.name = ""
+    with pytest.raises(AttributeError):
+        m.UnscopedEnum.EOne.value = 10
+    # name, value returns a copy
+    # TODO: Neither the name nor value tests actually check against aliasing.
+    # Use a mutable type that has reference semantics.
+    nonaliased_name = m.UnscopedEnum.EOne.name
+    nonaliased_name = "bar"  # noqa: F841
+    assert m.UnscopedEnum.EOne.name == "EOne"
+    nonaliased_value = m.UnscopedEnum.EOne.value
+    nonaliased_value = 10  # noqa: F841
+    assert m.UnscopedEnum.EOne.value == 1
+
+    # __members__ property
+    assert m.UnscopedEnum.__members__ == {
+        "EOne": m.UnscopedEnum.EOne,
+        "ETwo": m.UnscopedEnum.ETwo,
+        "EThree": m.UnscopedEnum.EThree,
+    }
+    # __members__ readonly
+    with pytest.raises(AttributeError):
+        m.UnscopedEnum.__members__ = {}
+    # __members__ returns a copy
+    nonaliased_members = m.UnscopedEnum.__members__
+    nonaliased_members["bar"] = "baz"
+    assert m.UnscopedEnum.__members__ == {
+        "EOne": m.UnscopedEnum.EOne,
+        "ETwo": m.UnscopedEnum.ETwo,
+        "EThree": m.UnscopedEnum.EThree,
+    }
+
+    for docstring_line in """An unscoped enumeration
+
+Members:
+
+  EOne : Docstring for EOne
+
+  ETwo : Docstring for ETwo
+
+  EThree : Docstring for EThree""".split(
+        "\n"
+    ):
+        assert docstring_line in m.UnscopedEnum.__doc__
+
+    # Unscoped enums will accept ==/!= int comparisons
+    y = m.UnscopedEnum.ETwo
+    assert y == 2
+    assert 2 == y
+    assert y != 3
+    assert 3 != y
+    # Compare with None
+    assert y != None  # noqa: E711
+    assert not (y == None)  # noqa: E711
+    # Compare with an object
+    assert y != object()
+    assert not (y == object())
+    # Compare with string
+    assert y != "2"
+    assert "2" != y
+    assert not ("2" == y)
+    assert not (y == "2")
+
+    with pytest.raises(TypeError):
+        y < object()  # noqa: B015
+
+    with pytest.raises(TypeError):
+        y <= object()  # noqa: B015
+
+    with pytest.raises(TypeError):
+        y > object()  # noqa: B015
+
+    with pytest.raises(TypeError):
+        y >= object()  # noqa: B015
+
+    with pytest.raises(TypeError):
+        y | object()
+
+    with pytest.raises(TypeError):
+        y & object()
+
+    with pytest.raises(TypeError):
+        y ^ object()
+
+    assert int(m.UnscopedEnum.ETwo) == 2
+    assert str(m.UnscopedEnum(2)) == "UnscopedEnum.ETwo"
+
+    # order
+    assert m.UnscopedEnum.EOne < m.UnscopedEnum.ETwo
+    assert m.UnscopedEnum.EOne < 2
+    assert m.UnscopedEnum.ETwo > m.UnscopedEnum.EOne
+    assert m.UnscopedEnum.ETwo > 1
+    assert m.UnscopedEnum.ETwo <= 2
+    assert m.UnscopedEnum.ETwo >= 2
+    assert m.UnscopedEnum.EOne <= m.UnscopedEnum.ETwo
+    assert m.UnscopedEnum.EOne <= 2
+    assert m.UnscopedEnum.ETwo >= m.UnscopedEnum.EOne
+    assert m.UnscopedEnum.ETwo >= 1
+    assert not (m.UnscopedEnum.ETwo < m.UnscopedEnum.EOne)
+    assert not (2 < m.UnscopedEnum.EOne)
+
+    # arithmetic
+    assert m.UnscopedEnum.EOne & m.UnscopedEnum.EThree == m.UnscopedEnum.EOne
+    assert m.UnscopedEnum.EOne | m.UnscopedEnum.ETwo == m.UnscopedEnum.EThree
+    assert m.UnscopedEnum.EOne ^ m.UnscopedEnum.EThree == m.UnscopedEnum.ETwo
+
+
+def test_scoped_enum():
+    assert m.test_scoped_enum(m.ScopedEnum.Three) == "ScopedEnum::Three"
+    z = m.ScopedEnum.Two
+    assert m.test_scoped_enum(z) == "ScopedEnum::Two"
+
+    # Scoped enums will *NOT* accept ==/!= int comparisons (Will always return False)
+    assert not z == 3
+    assert not 3 == z
+    assert z != 3
+    assert 3 != z
+    # Compare with None
+    assert z != None  # noqa: E711
+    assert not (z == None)  # noqa: E711
+    # Compare with an object
+    assert z != object()
+    assert not (z == object())
+    # Scoped enums will *NOT* accept >, <, >= and <= int comparisons (Will throw exceptions)
+    with pytest.raises(TypeError):
+        z > 3  # noqa: B015
+    with pytest.raises(TypeError):
+        z < 3  # noqa: B015
+    with pytest.raises(TypeError):
+        z >= 3  # noqa: B015
+    with pytest.raises(TypeError):
+        z <= 3  # noqa: B015
+
+    # order
+    assert m.ScopedEnum.Two < m.ScopedEnum.Three
+    assert m.ScopedEnum.Three > m.ScopedEnum.Two
+    assert m.ScopedEnum.Two <= m.ScopedEnum.Three
+    assert m.ScopedEnum.Two <= m.ScopedEnum.Two
+    assert m.ScopedEnum.Two >= m.ScopedEnum.Two
+    assert m.ScopedEnum.Three >= m.ScopedEnum.Two
+
+
+def test_implicit_conversion():
+    assert str(m.ClassWithUnscopedEnum.EMode.EFirstMode) == "EMode.EFirstMode"
+    assert str(m.ClassWithUnscopedEnum.EFirstMode) == "EMode.EFirstMode"
+    assert repr(m.ClassWithUnscopedEnum.EMode.EFirstMode) == "<EMode.EFirstMode: 1>"
+    assert repr(m.ClassWithUnscopedEnum.EFirstMode) == "<EMode.EFirstMode: 1>"
+
+    f = m.ClassWithUnscopedEnum.test_function
+    first = m.ClassWithUnscopedEnum.EFirstMode
+    second = m.ClassWithUnscopedEnum.ESecondMode
+
+    assert f(first) == 1
+
+    assert f(first) == f(first)
+    assert not f(first) != f(first)
+
+    assert f(first) != f(second)
+    assert not f(first) == f(second)
+
+    assert f(first) == int(f(first))
+    assert not f(first) != int(f(first))
+
+    assert f(first) != int(f(second))
+    assert not f(first) == int(f(second))
+
+    # noinspection PyDictCreation
+    x = {f(first): 1, f(second): 2}
+    x[f(first)] = 3
+    x[f(second)] = 4
+    # Hashing test
+    assert repr(x) == "{<EMode.EFirstMode: 1>: 3, <EMode.ESecondMode: 2>: 4}"
+
+
+def test_binary_operators():
+    assert int(m.Flags.Read) == 4
+    assert int(m.Flags.Write) == 2
+    assert int(m.Flags.Execute) == 1
+    assert int(m.Flags.Read | m.Flags.Write | m.Flags.Execute) == 7
+    assert int(m.Flags.Read | m.Flags.Write) == 6
+    assert int(m.Flags.Read | m.Flags.Execute) == 5
+    assert int(m.Flags.Write | m.Flags.Execute) == 3
+    assert int(m.Flags.Write | 1) == 3
+    assert ~m.Flags.Write == -3
+
+    state = m.Flags.Read | m.Flags.Write
+    assert (state & m.Flags.Read) != 0
+    assert (state & m.Flags.Write) != 0
+    assert (state & m.Flags.Execute) == 0
+    assert (state & 1) == 0
+
+    state2 = ~state
+    assert state2 == -7
+    assert int(state ^ state2) == -1
+
+
+def test_enum_to_int():
+    m.test_enum_to_int(m.Flags.Read)
+    m.test_enum_to_int(m.ClassWithUnscopedEnum.EMode.EFirstMode)
+    m.test_enum_to_int(m.ScopedCharEnum.Positive)
+    m.test_enum_to_int(m.ScopedBoolEnum.TRUE)
+    m.test_enum_to_uint(m.Flags.Read)
+    m.test_enum_to_uint(m.ClassWithUnscopedEnum.EMode.EFirstMode)
+    m.test_enum_to_uint(m.ScopedCharEnum.Positive)
+    m.test_enum_to_uint(m.ScopedBoolEnum.TRUE)
+    m.test_enum_to_long_long(m.Flags.Read)
+    m.test_enum_to_long_long(m.ClassWithUnscopedEnum.EMode.EFirstMode)
+    m.test_enum_to_long_long(m.ScopedCharEnum.Positive)
+    m.test_enum_to_long_long(m.ScopedBoolEnum.TRUE)
+
+
+def test_duplicate_enum_name():
+    with pytest.raises(ValueError) as excinfo:
+        m.register_bad_enum()
+    assert str(excinfo.value) == 'SimpleEnum: element "ONE" already exists!'
+
+
+def test_char_underlying_enum():  # Issue #1331/PR #1334:
+    assert type(m.ScopedCharEnum.Positive.__int__()) is int
+    assert int(m.ScopedChar16Enum.Zero) == 0
+    assert hash(m.ScopedChar32Enum.Positive) == 1
+    assert type(m.ScopedCharEnum.Positive.__getstate__()) is int
+    assert m.ScopedWCharEnum(1) == m.ScopedWCharEnum.Positive
+    with pytest.raises(TypeError):
+        # Even if the underlying type is char, only an int can be used to construct the enum:
+        m.ScopedCharEnum("0")
+
+
+def test_bool_underlying_enum():
+    assert type(m.ScopedBoolEnum.TRUE.__int__()) is int
+    assert int(m.ScopedBoolEnum.FALSE) == 0
+    assert hash(m.ScopedBoolEnum.TRUE) == 1
+    assert type(m.ScopedBoolEnum.TRUE.__getstate__()) is int
+    assert m.ScopedBoolEnum(1) == m.ScopedBoolEnum.TRUE
+    # Enum could construct with a bool
+    # (bool is a strict subclass of int, and False will be converted to 0)
+    assert m.ScopedBoolEnum(False) == m.ScopedBoolEnum.FALSE
+
+
+def test_docstring_signatures():
+    for enum_type in [m.ScopedEnum, m.UnscopedEnum]:
+        for attr in enum_type.__dict__.values():
+            # Issue #2623/PR #2637: Add argument names to enum_ methods
+            assert "arg0" not in (attr.__doc__ or "")
```

## extern/pybind11/tests/test_eval.py

 * *Ordering differences only*

```diff
@@ -1,50 +1,50 @@
-import os
-
-import pytest
-
-import env  # noqa: F401
-from pybind11_tests import eval_ as m
-
-
-def test_evals(capture):
-    with capture:
-        assert m.test_eval_statements()
-    assert capture == "Hello World!"
-
-    assert m.test_eval()
-    assert m.test_eval_single_statement()
-
-    assert m.test_eval_failure()
-
-
-@pytest.mark.xfail("env.PYPY", raises=RuntimeError)
-def test_eval_file():
-    filename = os.path.join(os.path.dirname(__file__), "test_eval_call.py")
-    assert m.test_eval_file(filename)
-
-    assert m.test_eval_file_failure()
-
-
-def test_eval_empty_globals():
-    assert "__builtins__" in m.eval_empty_globals(None)
-
-    g = {}
-    assert "__builtins__" in m.eval_empty_globals(g)
-    assert "__builtins__" in g
-
-
-def test_eval_closure():
-    global_, local = m.test_eval_closure()
-
-    assert global_["closure_value"] == 42
-    assert local["closure_value"] == 0
-
-    assert "local_value" not in global_
-    assert local["local_value"] == 0
-
-    assert "func_global" not in global_
-    assert local["func_global"]() == 42
-
-    assert "func_local" not in global_
-    with pytest.raises(NameError):
-        local["func_local"]()
+import os
+
+import pytest
+
+import env  # noqa: F401
+from pybind11_tests import eval_ as m
+
+
+def test_evals(capture):
+    with capture:
+        assert m.test_eval_statements()
+    assert capture == "Hello World!"
+
+    assert m.test_eval()
+    assert m.test_eval_single_statement()
+
+    assert m.test_eval_failure()
+
+
+@pytest.mark.xfail("env.PYPY", raises=RuntimeError)
+def test_eval_file():
+    filename = os.path.join(os.path.dirname(__file__), "test_eval_call.py")
+    assert m.test_eval_file(filename)
+
+    assert m.test_eval_file_failure()
+
+
+def test_eval_empty_globals():
+    assert "__builtins__" in m.eval_empty_globals(None)
+
+    g = {}
+    assert "__builtins__" in m.eval_empty_globals(g)
+    assert "__builtins__" in g
+
+
+def test_eval_closure():
+    global_, local = m.test_eval_closure()
+
+    assert global_["closure_value"] == 42
+    assert local["closure_value"] == 0
+
+    assert "local_value" not in global_
+    assert local["local_value"] == 0
+
+    assert "func_global" not in global_
+    assert local["func_global"]() == 42
+
+    assert "func_local" not in global_
+    with pytest.raises(NameError):
+        local["func_local"]()
```

## extern/pybind11/tests/test_eval_call.py

 * *Ordering differences only*

```diff
@@ -1,4 +1,4 @@
-# This file is called from 'test_eval.py'
-
-if "call_test2" in locals():
-    call_test2(y)  # noqa: F821 undefined name
+# This file is called from 'test_eval.py'
+
+if "call_test2" in locals():
+    call_test2(y)  # noqa: F821 undefined name
```

## extern/pybind11/tests/test_exceptions.py

 * *Ordering differences only*

```diff
@@ -1,383 +1,383 @@
-import sys
-
-import pytest
-
-import env
-import pybind11_cross_module_tests as cm
-import pybind11_tests  # noqa: F401
-from pybind11_tests import exceptions as m
-
-
-def test_std_exception(msg):
-    with pytest.raises(RuntimeError) as excinfo:
-        m.throw_std_exception()
-    assert msg(excinfo.value) == "This exception was intentionally thrown."
-
-
-def test_error_already_set(msg):
-    with pytest.raises(RuntimeError) as excinfo:
-        m.throw_already_set(False)
-    assert (
-        msg(excinfo.value)
-        == "Internal error: pybind11::error_already_set called while Python error indicator not set."
-    )
-
-    with pytest.raises(ValueError) as excinfo:
-        m.throw_already_set(True)
-    assert msg(excinfo.value) == "foo"
-
-
-def test_raise_from(msg):
-    with pytest.raises(ValueError) as excinfo:
-        m.raise_from()
-    assert msg(excinfo.value) == "outer"
-    assert msg(excinfo.value.__cause__) == "inner"
-
-
-def test_raise_from_already_set(msg):
-    with pytest.raises(ValueError) as excinfo:
-        m.raise_from_already_set()
-    assert msg(excinfo.value) == "outer"
-    assert msg(excinfo.value.__cause__) == "inner"
-
-
-def test_cross_module_exceptions(msg):
-    with pytest.raises(RuntimeError) as excinfo:
-        cm.raise_runtime_error()
-    assert str(excinfo.value) == "My runtime error"
-
-    with pytest.raises(ValueError) as excinfo:
-        cm.raise_value_error()
-    assert str(excinfo.value) == "My value error"
-
-    with pytest.raises(ValueError) as excinfo:
-        cm.throw_pybind_value_error()
-    assert str(excinfo.value) == "pybind11 value error"
-
-    with pytest.raises(TypeError) as excinfo:
-        cm.throw_pybind_type_error()
-    assert str(excinfo.value) == "pybind11 type error"
-
-    with pytest.raises(StopIteration) as excinfo:
-        cm.throw_stop_iteration()
-
-    with pytest.raises(cm.LocalSimpleException) as excinfo:
-        cm.throw_local_simple_error()
-    assert msg(excinfo.value) == "external mod"
-
-    with pytest.raises(KeyError) as excinfo:
-        cm.throw_local_error()
-    # KeyError is a repr of the key, so it has an extra set of quotes
-    assert str(excinfo.value) == "'just local'"
-
-
-# TODO: FIXME
-@pytest.mark.xfail(
-    "env.MACOS and (env.PYPY or pybind11_tests.compiler_info.startswith('Homebrew Clang'))",
-    raises=RuntimeError,
-    reason="See Issue #2847, PR #2999, PR #4324",
-)
-def test_cross_module_exception_translator():
-    with pytest.raises(KeyError):
-        # translator registered in cross_module_tests
-        m.throw_should_be_translated_to_key_error()
-
-
-def test_python_call_in_catch():
-    d = {}
-    assert m.python_call_in_destructor(d) is True
-    assert d["good"] is True
-
-
-def ignore_pytest_unraisable_warning(f):
-    unraisable = "PytestUnraisableExceptionWarning"
-    if hasattr(pytest, unraisable):  # Python >= 3.8 and pytest >= 6
-        dec = pytest.mark.filterwarnings(f"ignore::pytest.{unraisable}")
-        return dec(f)
-    else:
-        return f
-
-
-# TODO: find out why this fails on PyPy, https://foss.heptapod.net/pypy/pypy/-/issues/3583
-@pytest.mark.xfail(env.PYPY, reason="Failure on PyPy 3.8 (7.3.7)", strict=False)
-@ignore_pytest_unraisable_warning
-def test_python_alreadyset_in_destructor(monkeypatch, capsys):
-    hooked = False
-    triggered = False
-
-    if hasattr(sys, "unraisablehook"):  # Python 3.8+
-        hooked = True
-        # Don't take `sys.unraisablehook`, as that's overwritten by pytest
-        default_hook = sys.__unraisablehook__
-
-        def hook(unraisable_hook_args):
-            exc_type, exc_value, exc_tb, err_msg, obj = unraisable_hook_args
-            if obj == "already_set demo":
-                nonlocal triggered
-                triggered = True
-            default_hook(unraisable_hook_args)
-            return
-
-        # Use monkeypatch so pytest can apply and remove the patch as appropriate
-        monkeypatch.setattr(sys, "unraisablehook", hook)
-
-    assert m.python_alreadyset_in_destructor("already_set demo") is True
-    if hooked:
-        assert triggered is True
-
-    _, captured_stderr = capsys.readouterr()
-    assert captured_stderr.startswith("Exception ignored in: 'already_set demo'")
-    assert captured_stderr.rstrip().endswith("KeyError: 'bar'")
-
-
-def test_exception_matches():
-    assert m.exception_matches()
-    assert m.exception_matches_base()
-    assert m.modulenotfound_exception_matches_base()
-
-
-def test_custom(msg):
-    # Can we catch a MyException?
-    with pytest.raises(m.MyException) as excinfo:
-        m.throws1()
-    assert msg(excinfo.value) == "this error should go to a custom type"
-
-    # Can we translate to standard Python exceptions?
-    with pytest.raises(RuntimeError) as excinfo:
-        m.throws2()
-    assert msg(excinfo.value) == "this error should go to a standard Python exception"
-
-    # Can we handle unknown exceptions?
-    with pytest.raises(RuntimeError) as excinfo:
-        m.throws3()
-    assert msg(excinfo.value) == "Caught an unknown exception!"
-
-    # Can we delegate to another handler by rethrowing?
-    with pytest.raises(m.MyException) as excinfo:
-        m.throws4()
-    assert msg(excinfo.value) == "this error is rethrown"
-
-    # Can we fall-through to the default handler?
-    with pytest.raises(RuntimeError) as excinfo:
-        m.throws_logic_error()
-    assert (
-        msg(excinfo.value) == "this error should fall through to the standard handler"
-    )
-
-    # OverFlow error translation.
-    with pytest.raises(OverflowError) as excinfo:
-        m.throws_overflow_error()
-
-    # Can we handle a helper-declared exception?
-    with pytest.raises(m.MyException5) as excinfo:
-        m.throws5()
-    assert msg(excinfo.value) == "this is a helper-defined translated exception"
-
-    # Exception subclassing:
-    with pytest.raises(m.MyException5) as excinfo:
-        m.throws5_1()
-    assert msg(excinfo.value) == "MyException5 subclass"
-    assert isinstance(excinfo.value, m.MyException5_1)
-
-    with pytest.raises(m.MyException5_1) as excinfo:
-        m.throws5_1()
-    assert msg(excinfo.value) == "MyException5 subclass"
-
-    with pytest.raises(m.MyException5) as excinfo:
-        try:
-            m.throws5()
-        except m.MyException5_1 as err:
-            raise RuntimeError("Exception error: caught child from parent") from err
-    assert msg(excinfo.value) == "this is a helper-defined translated exception"
-
-
-def test_nested_throws(capture):
-    """Tests nested (e.g. C++ -> Python -> C++) exception handling"""
-
-    def throw_myex():
-        raise m.MyException("nested error")
-
-    def throw_myex5():
-        raise m.MyException5("nested error 5")
-
-    # In the comments below, the exception is caught in the first step, thrown in the last step
-
-    # C++ -> Python
-    with capture:
-        m.try_catch(m.MyException5, throw_myex5)
-    assert str(capture).startswith("MyException5: nested error 5")
-
-    # Python -> C++ -> Python
-    with pytest.raises(m.MyException) as excinfo:
-        m.try_catch(m.MyException5, throw_myex)
-    assert str(excinfo.value) == "nested error"
-
-    def pycatch(exctype, f, *args):
-        try:
-            f(*args)
-        except m.MyException as e:
-            print(e)
-
-    # C++ -> Python -> C++ -> Python
-    with capture:
-        m.try_catch(
-            m.MyException5,
-            pycatch,
-            m.MyException,
-            m.try_catch,
-            m.MyException,
-            throw_myex5,
-        )
-    assert str(capture).startswith("MyException5: nested error 5")
-
-    # C++ -> Python -> C++
-    with capture:
-        m.try_catch(m.MyException, pycatch, m.MyException5, m.throws4)
-    assert capture == "this error is rethrown"
-
-    # Python -> C++ -> Python -> C++
-    with pytest.raises(m.MyException5) as excinfo:
-        m.try_catch(m.MyException, pycatch, m.MyException, m.throws5)
-    assert str(excinfo.value) == "this is a helper-defined translated exception"
-
-
-def test_throw_nested_exception():
-    with pytest.raises(RuntimeError) as excinfo:
-        m.throw_nested_exception()
-    assert str(excinfo.value) == "Outer Exception"
-    assert str(excinfo.value.__cause__) == "Inner Exception"
-
-
-# This can often happen if you wrap a pybind11 class in a Python wrapper
-def test_invalid_repr():
-    class MyRepr:
-        def __repr__(self):
-            raise AttributeError("Example error")
-
-    with pytest.raises(TypeError):
-        m.simple_bool_passthrough(MyRepr())
-
-
-def test_local_translator(msg):
-    """Tests that a local translator works and that the local translator from
-    the cross module is not applied"""
-    with pytest.raises(RuntimeError) as excinfo:
-        m.throws6()
-    assert msg(excinfo.value) == "MyException6 only handled in this module"
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.throws_local_error()
-    assert not isinstance(excinfo.value, KeyError)
-    assert msg(excinfo.value) == "never caught"
-
-    with pytest.raises(Exception) as excinfo:
-        m.throws_local_simple_error()
-    assert not isinstance(excinfo.value, cm.LocalSimpleException)
-    assert msg(excinfo.value) == "this mod"
-
-
-def test_error_already_set_message_with_unicode_surrogate():  # Issue #4288
-    assert m.error_already_set_what(RuntimeError, "\ud927") == (
-        "RuntimeError: \\ud927",
-        False,
-    )
-
-
-def test_error_already_set_message_with_malformed_utf8():
-    assert m.error_already_set_what(RuntimeError, b"\x80") == (
-        "RuntimeError: b'\\x80'",
-        False,
-    )
-
-
-class FlakyException(Exception):
-    def __init__(self, failure_point):
-        if failure_point == "failure_point_init":
-            raise ValueError("triggered_failure_point_init")
-        self.failure_point = failure_point
-
-    def __str__(self):
-        if self.failure_point == "failure_point_str":
-            raise ValueError("triggered_failure_point_str")
-        return "FlakyException.__str__"
-
-
-@pytest.mark.parametrize(
-    "exc_type, exc_value, expected_what",
-    (
-        (ValueError, "plain_str", "ValueError: plain_str"),
-        (ValueError, ("tuple_elem",), "ValueError: tuple_elem"),
-        (FlakyException, ("happy",), "FlakyException: FlakyException.__str__"),
-    ),
-)
-def test_error_already_set_what_with_happy_exceptions(
-    exc_type, exc_value, expected_what
-):
-    what, py_err_set_after_what = m.error_already_set_what(exc_type, exc_value)
-    assert not py_err_set_after_what
-    assert what == expected_what
-
-
-@pytest.mark.skipif("env.PYPY", reason="PyErr_NormalizeException Segmentation fault")
-def test_flaky_exception_failure_point_init():
-    with pytest.raises(RuntimeError) as excinfo:
-        m.error_already_set_what(FlakyException, ("failure_point_init",))
-    lines = str(excinfo.value).splitlines()
-    # PyErr_NormalizeException replaces the original FlakyException with ValueError:
-    assert lines[:3] == [
-        "pybind11::error_already_set: MISMATCH of original and normalized active exception types:"
-        " ORIGINAL FlakyException REPLACED BY ValueError: triggered_failure_point_init",
-        "",
-        "At:",
-    ]
-    # Checking the first two lines of the traceback as formatted in error_string():
-    assert "test_exceptions.py(" in lines[3]
-    assert lines[3].endswith("): __init__")
-    assert lines[4].endswith("): test_flaky_exception_failure_point_init")
-
-
-def test_flaky_exception_failure_point_str():
-    what, py_err_set_after_what = m.error_already_set_what(
-        FlakyException, ("failure_point_str",)
-    )
-    assert not py_err_set_after_what
-    lines = what.splitlines()
-    if env.PYPY and len(lines) == 3:
-        n = 3  # Traceback is missing.
-    else:
-        n = 5
-    assert (
-        lines[:n]
-        == [
-            "FlakyException: <MESSAGE UNAVAILABLE DUE TO ANOTHER EXCEPTION>",
-            "",
-            "MESSAGE UNAVAILABLE DUE TO EXCEPTION: ValueError: triggered_failure_point_str",
-            "",
-            "At:",
-        ][:n]
-    )
-
-
-def test_cross_module_interleaved_error_already_set():
-    with pytest.raises(RuntimeError) as excinfo:
-        m.test_cross_module_interleaved_error_already_set()
-    assert str(excinfo.value) in (
-        "2nd error.",  # Almost all platforms.
-        "RuntimeError: 2nd error.",  # Some PyPy builds (seen under macOS).
-    )
-
-
-def test_error_already_set_double_restore():
-    m.test_error_already_set_double_restore(True)  # dry_run
-    with pytest.raises(RuntimeError) as excinfo:
-        m.test_error_already_set_double_restore(False)
-    assert str(excinfo.value) == (
-        "Internal error: pybind11::detail::error_fetch_and_normalize::restore()"
-        " called a second time. ORIGINAL ERROR: ValueError: Random error."
-    )
-
-
-def test_pypy_oserror_normalization():
-    # https://github.com/pybind/pybind11/issues/4075
-    what = m.test_pypy_oserror_normalization()
-    assert "this_filename_must_not_exist" in what
+import sys
+
+import pytest
+
+import env
+import pybind11_cross_module_tests as cm
+import pybind11_tests  # noqa: F401
+from pybind11_tests import exceptions as m
+
+
+def test_std_exception(msg):
+    with pytest.raises(RuntimeError) as excinfo:
+        m.throw_std_exception()
+    assert msg(excinfo.value) == "This exception was intentionally thrown."
+
+
+def test_error_already_set(msg):
+    with pytest.raises(RuntimeError) as excinfo:
+        m.throw_already_set(False)
+    assert (
+        msg(excinfo.value)
+        == "Internal error: pybind11::error_already_set called while Python error indicator not set."
+    )
+
+    with pytest.raises(ValueError) as excinfo:
+        m.throw_already_set(True)
+    assert msg(excinfo.value) == "foo"
+
+
+def test_raise_from(msg):
+    with pytest.raises(ValueError) as excinfo:
+        m.raise_from()
+    assert msg(excinfo.value) == "outer"
+    assert msg(excinfo.value.__cause__) == "inner"
+
+
+def test_raise_from_already_set(msg):
+    with pytest.raises(ValueError) as excinfo:
+        m.raise_from_already_set()
+    assert msg(excinfo.value) == "outer"
+    assert msg(excinfo.value.__cause__) == "inner"
+
+
+def test_cross_module_exceptions(msg):
+    with pytest.raises(RuntimeError) as excinfo:
+        cm.raise_runtime_error()
+    assert str(excinfo.value) == "My runtime error"
+
+    with pytest.raises(ValueError) as excinfo:
+        cm.raise_value_error()
+    assert str(excinfo.value) == "My value error"
+
+    with pytest.raises(ValueError) as excinfo:
+        cm.throw_pybind_value_error()
+    assert str(excinfo.value) == "pybind11 value error"
+
+    with pytest.raises(TypeError) as excinfo:
+        cm.throw_pybind_type_error()
+    assert str(excinfo.value) == "pybind11 type error"
+
+    with pytest.raises(StopIteration) as excinfo:
+        cm.throw_stop_iteration()
+
+    with pytest.raises(cm.LocalSimpleException) as excinfo:
+        cm.throw_local_simple_error()
+    assert msg(excinfo.value) == "external mod"
+
+    with pytest.raises(KeyError) as excinfo:
+        cm.throw_local_error()
+    # KeyError is a repr of the key, so it has an extra set of quotes
+    assert str(excinfo.value) == "'just local'"
+
+
+# TODO: FIXME
+@pytest.mark.xfail(
+    "env.MACOS and (env.PYPY or pybind11_tests.compiler_info.startswith('Homebrew Clang'))",
+    raises=RuntimeError,
+    reason="See Issue #2847, PR #2999, PR #4324",
+)
+def test_cross_module_exception_translator():
+    with pytest.raises(KeyError):
+        # translator registered in cross_module_tests
+        m.throw_should_be_translated_to_key_error()
+
+
+def test_python_call_in_catch():
+    d = {}
+    assert m.python_call_in_destructor(d) is True
+    assert d["good"] is True
+
+
+def ignore_pytest_unraisable_warning(f):
+    unraisable = "PytestUnraisableExceptionWarning"
+    if hasattr(pytest, unraisable):  # Python >= 3.8 and pytest >= 6
+        dec = pytest.mark.filterwarnings(f"ignore::pytest.{unraisable}")
+        return dec(f)
+    else:
+        return f
+
+
+# TODO: find out why this fails on PyPy, https://foss.heptapod.net/pypy/pypy/-/issues/3583
+@pytest.mark.xfail(env.PYPY, reason="Failure on PyPy 3.8 (7.3.7)", strict=False)
+@ignore_pytest_unraisable_warning
+def test_python_alreadyset_in_destructor(monkeypatch, capsys):
+    hooked = False
+    triggered = False
+
+    if hasattr(sys, "unraisablehook"):  # Python 3.8+
+        hooked = True
+        # Don't take `sys.unraisablehook`, as that's overwritten by pytest
+        default_hook = sys.__unraisablehook__
+
+        def hook(unraisable_hook_args):
+            exc_type, exc_value, exc_tb, err_msg, obj = unraisable_hook_args
+            if obj == "already_set demo":
+                nonlocal triggered
+                triggered = True
+            default_hook(unraisable_hook_args)
+            return
+
+        # Use monkeypatch so pytest can apply and remove the patch as appropriate
+        monkeypatch.setattr(sys, "unraisablehook", hook)
+
+    assert m.python_alreadyset_in_destructor("already_set demo") is True
+    if hooked:
+        assert triggered is True
+
+    _, captured_stderr = capsys.readouterr()
+    assert captured_stderr.startswith("Exception ignored in: 'already_set demo'")
+    assert captured_stderr.rstrip().endswith("KeyError: 'bar'")
+
+
+def test_exception_matches():
+    assert m.exception_matches()
+    assert m.exception_matches_base()
+    assert m.modulenotfound_exception_matches_base()
+
+
+def test_custom(msg):
+    # Can we catch a MyException?
+    with pytest.raises(m.MyException) as excinfo:
+        m.throws1()
+    assert msg(excinfo.value) == "this error should go to a custom type"
+
+    # Can we translate to standard Python exceptions?
+    with pytest.raises(RuntimeError) as excinfo:
+        m.throws2()
+    assert msg(excinfo.value) == "this error should go to a standard Python exception"
+
+    # Can we handle unknown exceptions?
+    with pytest.raises(RuntimeError) as excinfo:
+        m.throws3()
+    assert msg(excinfo.value) == "Caught an unknown exception!"
+
+    # Can we delegate to another handler by rethrowing?
+    with pytest.raises(m.MyException) as excinfo:
+        m.throws4()
+    assert msg(excinfo.value) == "this error is rethrown"
+
+    # Can we fall-through to the default handler?
+    with pytest.raises(RuntimeError) as excinfo:
+        m.throws_logic_error()
+    assert (
+        msg(excinfo.value) == "this error should fall through to the standard handler"
+    )
+
+    # OverFlow error translation.
+    with pytest.raises(OverflowError) as excinfo:
+        m.throws_overflow_error()
+
+    # Can we handle a helper-declared exception?
+    with pytest.raises(m.MyException5) as excinfo:
+        m.throws5()
+    assert msg(excinfo.value) == "this is a helper-defined translated exception"
+
+    # Exception subclassing:
+    with pytest.raises(m.MyException5) as excinfo:
+        m.throws5_1()
+    assert msg(excinfo.value) == "MyException5 subclass"
+    assert isinstance(excinfo.value, m.MyException5_1)
+
+    with pytest.raises(m.MyException5_1) as excinfo:
+        m.throws5_1()
+    assert msg(excinfo.value) == "MyException5 subclass"
+
+    with pytest.raises(m.MyException5) as excinfo:
+        try:
+            m.throws5()
+        except m.MyException5_1 as err:
+            raise RuntimeError("Exception error: caught child from parent") from err
+    assert msg(excinfo.value) == "this is a helper-defined translated exception"
+
+
+def test_nested_throws(capture):
+    """Tests nested (e.g. C++ -> Python -> C++) exception handling"""
+
+    def throw_myex():
+        raise m.MyException("nested error")
+
+    def throw_myex5():
+        raise m.MyException5("nested error 5")
+
+    # In the comments below, the exception is caught in the first step, thrown in the last step
+
+    # C++ -> Python
+    with capture:
+        m.try_catch(m.MyException5, throw_myex5)
+    assert str(capture).startswith("MyException5: nested error 5")
+
+    # Python -> C++ -> Python
+    with pytest.raises(m.MyException) as excinfo:
+        m.try_catch(m.MyException5, throw_myex)
+    assert str(excinfo.value) == "nested error"
+
+    def pycatch(exctype, f, *args):
+        try:
+            f(*args)
+        except m.MyException as e:
+            print(e)
+
+    # C++ -> Python -> C++ -> Python
+    with capture:
+        m.try_catch(
+            m.MyException5,
+            pycatch,
+            m.MyException,
+            m.try_catch,
+            m.MyException,
+            throw_myex5,
+        )
+    assert str(capture).startswith("MyException5: nested error 5")
+
+    # C++ -> Python -> C++
+    with capture:
+        m.try_catch(m.MyException, pycatch, m.MyException5, m.throws4)
+    assert capture == "this error is rethrown"
+
+    # Python -> C++ -> Python -> C++
+    with pytest.raises(m.MyException5) as excinfo:
+        m.try_catch(m.MyException, pycatch, m.MyException, m.throws5)
+    assert str(excinfo.value) == "this is a helper-defined translated exception"
+
+
+def test_throw_nested_exception():
+    with pytest.raises(RuntimeError) as excinfo:
+        m.throw_nested_exception()
+    assert str(excinfo.value) == "Outer Exception"
+    assert str(excinfo.value.__cause__) == "Inner Exception"
+
+
+# This can often happen if you wrap a pybind11 class in a Python wrapper
+def test_invalid_repr():
+    class MyRepr:
+        def __repr__(self):
+            raise AttributeError("Example error")
+
+    with pytest.raises(TypeError):
+        m.simple_bool_passthrough(MyRepr())
+
+
+def test_local_translator(msg):
+    """Tests that a local translator works and that the local translator from
+    the cross module is not applied"""
+    with pytest.raises(RuntimeError) as excinfo:
+        m.throws6()
+    assert msg(excinfo.value) == "MyException6 only handled in this module"
+
+    with pytest.raises(RuntimeError) as excinfo:
+        m.throws_local_error()
+    assert not isinstance(excinfo.value, KeyError)
+    assert msg(excinfo.value) == "never caught"
+
+    with pytest.raises(Exception) as excinfo:
+        m.throws_local_simple_error()
+    assert not isinstance(excinfo.value, cm.LocalSimpleException)
+    assert msg(excinfo.value) == "this mod"
+
+
+def test_error_already_set_message_with_unicode_surrogate():  # Issue #4288
+    assert m.error_already_set_what(RuntimeError, "\ud927") == (
+        "RuntimeError: \\ud927",
+        False,
+    )
+
+
+def test_error_already_set_message_with_malformed_utf8():
+    assert m.error_already_set_what(RuntimeError, b"\x80") == (
+        "RuntimeError: b'\\x80'",
+        False,
+    )
+
+
+class FlakyException(Exception):
+    def __init__(self, failure_point):
+        if failure_point == "failure_point_init":
+            raise ValueError("triggered_failure_point_init")
+        self.failure_point = failure_point
+
+    def __str__(self):
+        if self.failure_point == "failure_point_str":
+            raise ValueError("triggered_failure_point_str")
+        return "FlakyException.__str__"
+
+
+@pytest.mark.parametrize(
+    "exc_type, exc_value, expected_what",
+    (
+        (ValueError, "plain_str", "ValueError: plain_str"),
+        (ValueError, ("tuple_elem",), "ValueError: tuple_elem"),
+        (FlakyException, ("happy",), "FlakyException: FlakyException.__str__"),
+    ),
+)
+def test_error_already_set_what_with_happy_exceptions(
+    exc_type, exc_value, expected_what
+):
+    what, py_err_set_after_what = m.error_already_set_what(exc_type, exc_value)
+    assert not py_err_set_after_what
+    assert what == expected_what
+
+
+@pytest.mark.skipif("env.PYPY", reason="PyErr_NormalizeException Segmentation fault")
+def test_flaky_exception_failure_point_init():
+    with pytest.raises(RuntimeError) as excinfo:
+        m.error_already_set_what(FlakyException, ("failure_point_init",))
+    lines = str(excinfo.value).splitlines()
+    # PyErr_NormalizeException replaces the original FlakyException with ValueError:
+    assert lines[:3] == [
+        "pybind11::error_already_set: MISMATCH of original and normalized active exception types:"
+        " ORIGINAL FlakyException REPLACED BY ValueError: triggered_failure_point_init",
+        "",
+        "At:",
+    ]
+    # Checking the first two lines of the traceback as formatted in error_string():
+    assert "test_exceptions.py(" in lines[3]
+    assert lines[3].endswith("): __init__")
+    assert lines[4].endswith("): test_flaky_exception_failure_point_init")
+
+
+def test_flaky_exception_failure_point_str():
+    what, py_err_set_after_what = m.error_already_set_what(
+        FlakyException, ("failure_point_str",)
+    )
+    assert not py_err_set_after_what
+    lines = what.splitlines()
+    if env.PYPY and len(lines) == 3:
+        n = 3  # Traceback is missing.
+    else:
+        n = 5
+    assert (
+        lines[:n]
+        == [
+            "FlakyException: <MESSAGE UNAVAILABLE DUE TO ANOTHER EXCEPTION>",
+            "",
+            "MESSAGE UNAVAILABLE DUE TO EXCEPTION: ValueError: triggered_failure_point_str",
+            "",
+            "At:",
+        ][:n]
+    )
+
+
+def test_cross_module_interleaved_error_already_set():
+    with pytest.raises(RuntimeError) as excinfo:
+        m.test_cross_module_interleaved_error_already_set()
+    assert str(excinfo.value) in (
+        "2nd error.",  # Almost all platforms.
+        "RuntimeError: 2nd error.",  # Some PyPy builds (seen under macOS).
+    )
+
+
+def test_error_already_set_double_restore():
+    m.test_error_already_set_double_restore(True)  # dry_run
+    with pytest.raises(RuntimeError) as excinfo:
+        m.test_error_already_set_double_restore(False)
+    assert str(excinfo.value) == (
+        "Internal error: pybind11::detail::error_fetch_and_normalize::restore()"
+        " called a second time. ORIGINAL ERROR: ValueError: Random error."
+    )
+
+
+def test_pypy_oserror_normalization():
+    # https://github.com/pybind/pybind11/issues/4075
+    what = m.test_pypy_oserror_normalization()
+    assert "this_filename_must_not_exist" in what
```

## extern/pybind11/tests/test_factory_constructors.py

 * *Ordering differences only*

```diff
@@ -1,516 +1,516 @@
-import re
-
-import pytest
-
-from pybind11_tests import ConstructorStats
-from pybind11_tests import factory_constructors as m
-from pybind11_tests.factory_constructors import tag
-
-
-def test_init_factory_basic():
-    """Tests py::init_factory() wrapper around various ways of returning the object"""
-
-    cstats = [
-        ConstructorStats.get(c)
-        for c in [m.TestFactory1, m.TestFactory2, m.TestFactory3]
-    ]
-    cstats[0].alive()  # force gc
-    n_inst = ConstructorStats.detail_reg_inst()
-
-    x1 = m.TestFactory1(tag.unique_ptr, 3)
-    assert x1.value == "3"
-    y1 = m.TestFactory1(tag.pointer)
-    assert y1.value == "(empty)"
-    z1 = m.TestFactory1("hi!")
-    assert z1.value == "hi!"
-
-    assert ConstructorStats.detail_reg_inst() == n_inst + 3
-
-    x2 = m.TestFactory2(tag.move)
-    assert x2.value == "(empty2)"
-    y2 = m.TestFactory2(tag.pointer, 7)
-    assert y2.value == "7"
-    z2 = m.TestFactory2(tag.unique_ptr, "hi again")
-    assert z2.value == "hi again"
-
-    assert ConstructorStats.detail_reg_inst() == n_inst + 6
-
-    x3 = m.TestFactory3(tag.shared_ptr)
-    assert x3.value == "(empty3)"
-    y3 = m.TestFactory3(tag.pointer, 42)
-    assert y3.value == "42"
-    z3 = m.TestFactory3("bye")
-    assert z3.value == "bye"
-
-    for null_ptr_kind in [tag.null_ptr, tag.null_unique_ptr, tag.null_shared_ptr]:
-        with pytest.raises(TypeError) as excinfo:
-            m.TestFactory3(null_ptr_kind)
-        assert (
-            str(excinfo.value) == "pybind11::init(): factory function returned nullptr"
-        )
-
-    assert [i.alive() for i in cstats] == [3, 3, 3]
-    assert ConstructorStats.detail_reg_inst() == n_inst + 9
-
-    del x1, y2, y3, z3
-    assert [i.alive() for i in cstats] == [2, 2, 1]
-    assert ConstructorStats.detail_reg_inst() == n_inst + 5
-    del x2, x3, y1, z1, z2
-    assert [i.alive() for i in cstats] == [0, 0, 0]
-    assert ConstructorStats.detail_reg_inst() == n_inst
-
-    assert [i.values() for i in cstats] == [
-        ["3", "hi!"],
-        ["7", "hi again"],
-        ["42", "bye"],
-    ]
-    assert [i.default_constructions for i in cstats] == [1, 1, 1]
-
-
-def test_init_factory_signature(msg):
-    with pytest.raises(TypeError) as excinfo:
-        m.TestFactory1("invalid", "constructor", "arguments")
-    assert (
-        msg(excinfo.value)
-        == """
-        __init__(): incompatible constructor arguments. The following argument types are supported:
-            1. m.factory_constructors.TestFactory1(arg0: m.factory_constructors.tag.unique_ptr_tag, arg1: int)
-            2. m.factory_constructors.TestFactory1(arg0: str)
-            3. m.factory_constructors.TestFactory1(arg0: m.factory_constructors.tag.pointer_tag)
-            4. m.factory_constructors.TestFactory1(arg0: handle, arg1: int, arg2: handle)
-
-        Invoked with: 'invalid', 'constructor', 'arguments'
-    """
-    )
-
-    assert (
-        msg(m.TestFactory1.__init__.__doc__)
-        == """
-        __init__(*args, **kwargs)
-        Overloaded function.
-
-        1. __init__(self: m.factory_constructors.TestFactory1, arg0: m.factory_constructors.tag.unique_ptr_tag, arg1: int) -> None
-
-        2. __init__(self: m.factory_constructors.TestFactory1, arg0: str) -> None
-
-        3. __init__(self: m.factory_constructors.TestFactory1, arg0: m.factory_constructors.tag.pointer_tag) -> None
-
-        4. __init__(self: m.factory_constructors.TestFactory1, arg0: handle, arg1: int, arg2: handle) -> None
-    """  # noqa: E501 line too long
-    )
-
-
-def test_init_factory_casting():
-    """Tests py::init_factory() wrapper with various upcasting and downcasting returns"""
-
-    cstats = [
-        ConstructorStats.get(c)
-        for c in [m.TestFactory3, m.TestFactory4, m.TestFactory5]
-    ]
-    cstats[0].alive()  # force gc
-    n_inst = ConstructorStats.detail_reg_inst()
-
-    # Construction from derived references:
-    a = m.TestFactory3(tag.pointer, tag.TF4, 4)
-    assert a.value == "4"
-    b = m.TestFactory3(tag.shared_ptr, tag.TF4, 5)
-    assert b.value == "5"
-    c = m.TestFactory3(tag.pointer, tag.TF5, 6)
-    assert c.value == "6"
-    d = m.TestFactory3(tag.shared_ptr, tag.TF5, 7)
-    assert d.value == "7"
-
-    assert ConstructorStats.detail_reg_inst() == n_inst + 4
-
-    # Shared a lambda with TF3:
-    e = m.TestFactory4(tag.pointer, tag.TF4, 8)
-    assert e.value == "8"
-
-    assert ConstructorStats.detail_reg_inst() == n_inst + 5
-    assert [i.alive() for i in cstats] == [5, 3, 2]
-
-    del a
-    assert [i.alive() for i in cstats] == [4, 2, 2]
-    assert ConstructorStats.detail_reg_inst() == n_inst + 4
-
-    del b, c, e
-    assert [i.alive() for i in cstats] == [1, 0, 1]
-    assert ConstructorStats.detail_reg_inst() == n_inst + 1
-
-    del d
-    assert [i.alive() for i in cstats] == [0, 0, 0]
-    assert ConstructorStats.detail_reg_inst() == n_inst
-
-    assert [i.values() for i in cstats] == [
-        ["4", "5", "6", "7", "8"],
-        ["4", "5", "8"],
-        ["6", "7"],
-    ]
-
-
-def test_init_factory_alias():
-    """Tests py::init_factory() wrapper with value conversions and alias types"""
-
-    cstats = [m.TestFactory6.get_cstats(), m.TestFactory6.get_alias_cstats()]
-    cstats[0].alive()  # force gc
-    n_inst = ConstructorStats.detail_reg_inst()
-
-    a = m.TestFactory6(tag.base, 1)
-    assert a.get() == 1
-    assert not a.has_alias()
-    b = m.TestFactory6(tag.alias, "hi there")
-    assert b.get() == 8
-    assert b.has_alias()
-    c = m.TestFactory6(tag.alias, 3)
-    assert c.get() == 3
-    assert c.has_alias()
-    d = m.TestFactory6(tag.alias, tag.pointer, 4)
-    assert d.get() == 4
-    assert d.has_alias()
-    e = m.TestFactory6(tag.base, tag.pointer, 5)
-    assert e.get() == 5
-    assert not e.has_alias()
-    f = m.TestFactory6(tag.base, tag.alias, tag.pointer, 6)
-    assert f.get() == 6
-    assert f.has_alias()
-
-    assert ConstructorStats.detail_reg_inst() == n_inst + 6
-    assert [i.alive() for i in cstats] == [6, 4]
-
-    del a, b, e
-    assert [i.alive() for i in cstats] == [3, 3]
-    assert ConstructorStats.detail_reg_inst() == n_inst + 3
-    del f, c, d
-    assert [i.alive() for i in cstats] == [0, 0]
-    assert ConstructorStats.detail_reg_inst() == n_inst
-
-    class MyTest(m.TestFactory6):
-        def __init__(self, *args):
-            m.TestFactory6.__init__(self, *args)
-
-        def get(self):
-            return -5 + m.TestFactory6.get(self)
-
-    # Return Class by value, moved into new alias:
-    z = MyTest(tag.base, 123)
-    assert z.get() == 118
-    assert z.has_alias()
-
-    # Return alias by value, moved into new alias:
-    y = MyTest(tag.alias, "why hello!")
-    assert y.get() == 5
-    assert y.has_alias()
-
-    # Return Class by pointer, moved into new alias then original destroyed:
-    x = MyTest(tag.base, tag.pointer, 47)
-    assert x.get() == 42
-    assert x.has_alias()
-
-    assert ConstructorStats.detail_reg_inst() == n_inst + 3
-    assert [i.alive() for i in cstats] == [3, 3]
-    del x, y, z
-    assert [i.alive() for i in cstats] == [0, 0]
-    assert ConstructorStats.detail_reg_inst() == n_inst
-
-    assert [i.values() for i in cstats] == [
-        ["1", "8", "3", "4", "5", "6", "123", "10", "47"],
-        ["hi there", "3", "4", "6", "move", "123", "why hello!", "move", "47"],
-    ]
-
-
-def test_init_factory_dual():
-    """Tests init factory functions with dual main/alias factory functions"""
-    from pybind11_tests.factory_constructors import TestFactory7
-
-    cstats = [TestFactory7.get_cstats(), TestFactory7.get_alias_cstats()]
-    cstats[0].alive()  # force gc
-    n_inst = ConstructorStats.detail_reg_inst()
-
-    class PythFactory7(TestFactory7):
-        def get(self):
-            return 100 + TestFactory7.get(self)
-
-    a1 = TestFactory7(1)
-    a2 = PythFactory7(2)
-    assert a1.get() == 1
-    assert a2.get() == 102
-    assert not a1.has_alias()
-    assert a2.has_alias()
-
-    b1 = TestFactory7(tag.pointer, 3)
-    b2 = PythFactory7(tag.pointer, 4)
-    assert b1.get() == 3
-    assert b2.get() == 104
-    assert not b1.has_alias()
-    assert b2.has_alias()
-
-    c1 = TestFactory7(tag.mixed, 5)
-    c2 = PythFactory7(tag.mixed, 6)
-    assert c1.get() == 5
-    assert c2.get() == 106
-    assert not c1.has_alias()
-    assert c2.has_alias()
-
-    d1 = TestFactory7(tag.base, tag.pointer, 7)
-    d2 = PythFactory7(tag.base, tag.pointer, 8)
-    assert d1.get() == 7
-    assert d2.get() == 108
-    assert not d1.has_alias()
-    assert d2.has_alias()
-
-    # Both return an alias; the second multiplies the value by 10:
-    e1 = TestFactory7(tag.alias, tag.pointer, 9)
-    e2 = PythFactory7(tag.alias, tag.pointer, 10)
-    assert e1.get() == 9
-    assert e2.get() == 200
-    assert e1.has_alias()
-    assert e2.has_alias()
-
-    f1 = TestFactory7(tag.shared_ptr, tag.base, 11)
-    f2 = PythFactory7(tag.shared_ptr, tag.base, 12)
-    assert f1.get() == 11
-    assert f2.get() == 112
-    assert not f1.has_alias()
-    assert f2.has_alias()
-
-    g1 = TestFactory7(tag.shared_ptr, tag.invalid_base, 13)
-    assert g1.get() == 13
-    assert not g1.has_alias()
-    with pytest.raises(TypeError) as excinfo:
-        PythFactory7(tag.shared_ptr, tag.invalid_base, 14)
-    assert (
-        str(excinfo.value)
-        == "pybind11::init(): construction failed: returned holder-wrapped instance is not an "
-        "alias instance"
-    )
-
-    assert [i.alive() for i in cstats] == [13, 7]
-    assert ConstructorStats.detail_reg_inst() == n_inst + 13
-
-    del a1, a2, b1, d1, e1, e2
-    assert [i.alive() for i in cstats] == [7, 4]
-    assert ConstructorStats.detail_reg_inst() == n_inst + 7
-    del b2, c1, c2, d2, f1, f2, g1
-    assert [i.alive() for i in cstats] == [0, 0]
-    assert ConstructorStats.detail_reg_inst() == n_inst
-
-    assert [i.values() for i in cstats] == [
-        ["1", "2", "3", "4", "5", "6", "7", "8", "9", "100", "11", "12", "13", "14"],
-        ["2", "4", "6", "8", "9", "100", "12"],
-    ]
-
-
-def test_no_placement_new(capture):
-    """Prior to 2.2, `py::init<...>` relied on the type supporting placement
-    new; this tests a class without placement new support."""
-    with capture:
-        a = m.NoPlacementNew(123)
-
-    found = re.search(r"^operator new called, returning (\d+)\n$", str(capture))
-    assert found
-    assert a.i == 123
-    with capture:
-        del a
-        pytest.gc_collect()
-    assert capture == "operator delete called on " + found.group(1)
-
-    with capture:
-        b = m.NoPlacementNew()
-
-    found = re.search(r"^operator new called, returning (\d+)\n$", str(capture))
-    assert found
-    assert b.i == 100
-    with capture:
-        del b
-        pytest.gc_collect()
-    assert capture == "operator delete called on " + found.group(1)
-
-
-def test_multiple_inheritance():
-    class MITest(m.TestFactory1, m.TestFactory2):
-        def __init__(self):
-            m.TestFactory1.__init__(self, tag.unique_ptr, 33)
-            m.TestFactory2.__init__(self, tag.move)
-
-    a = MITest()
-    assert m.TestFactory1.value.fget(a) == "33"
-    assert m.TestFactory2.value.fget(a) == "(empty2)"
-
-
-def create_and_destroy(*args):
-    a = m.NoisyAlloc(*args)
-    print("---")
-    del a
-    pytest.gc_collect()
-
-
-def strip_comments(s):
-    return re.sub(r"\s+#.*", "", s)
-
-
-def test_reallocation_a(capture, msg):
-    """When the constructor is overloaded, previous overloads can require a preallocated value.
-    This test makes sure that such preallocated values only happen when they might be necessary,
-    and that they are deallocated properly."""
-
-    pytest.gc_collect()
-
-    with capture:
-        create_and_destroy(1)
-    assert (
-        msg(capture)
-        == """
-        noisy new
-        noisy placement new
-        NoisyAlloc(int 1)
-        ---
-        ~NoisyAlloc()
-        noisy delete
-    """
-    )
-
-
-def test_reallocation_b(capture, msg):
-    with capture:
-        create_and_destroy(1.5)
-    assert msg(capture) == strip_comments(
-        """
-        noisy new               # allocation required to attempt first overload
-        noisy delete            # have to dealloc before considering factory init overload
-        noisy new               # pointer factory calling "new", part 1: allocation
-        NoisyAlloc(double 1.5)  # ... part two, invoking constructor
-        ---
-        ~NoisyAlloc()  # Destructor
-        noisy delete   # operator delete
-    """
-    )
-
-
-def test_reallocation_c(capture, msg):
-    with capture:
-        create_and_destroy(2, 3)
-    assert msg(capture) == strip_comments(
-        """
-        noisy new          # pointer factory calling "new", allocation
-        NoisyAlloc(int 2)  # constructor
-        ---
-        ~NoisyAlloc()  # Destructor
-        noisy delete   # operator delete
-    """
-    )
-
-
-def test_reallocation_d(capture, msg):
-    with capture:
-        create_and_destroy(2.5, 3)
-    assert msg(capture) == strip_comments(
-        """
-        NoisyAlloc(double 2.5)  # construction (local func variable: operator_new not called)
-        noisy new               # return-by-value "new" part 1: allocation
-        ~NoisyAlloc()           # moved-away local func variable destruction
-        ---
-        ~NoisyAlloc()  # Destructor
-        noisy delete   # operator delete
-    """
-    )
-
-
-def test_reallocation_e(capture, msg):
-    with capture:
-        create_and_destroy(3.5, 4.5)
-    assert msg(capture) == strip_comments(
-        """
-        noisy new               # preallocation needed before invoking placement-new overload
-        noisy placement new     # Placement new
-        NoisyAlloc(double 3.5)  # construction
-        ---
-        ~NoisyAlloc()  # Destructor
-        noisy delete   # operator delete
-    """
-    )
-
-
-def test_reallocation_f(capture, msg):
-    with capture:
-        create_and_destroy(4, 0.5)
-    assert msg(capture) == strip_comments(
-        """
-        noisy new          # preallocation needed before invoking placement-new overload
-        noisy delete       # deallocation of preallocated storage
-        noisy new          # Factory pointer allocation
-        NoisyAlloc(int 4)  # factory pointer construction
-        ---
-        ~NoisyAlloc()  # Destructor
-        noisy delete   # operator delete
-    """
-    )
-
-
-def test_reallocation_g(capture, msg):
-    with capture:
-        create_and_destroy(5, "hi")
-    assert msg(capture) == strip_comments(
-        """
-        noisy new            # preallocation needed before invoking first placement new
-        noisy delete         # delete before considering new-style constructor
-        noisy new            # preallocation for second placement new
-        noisy placement new  # Placement new in the second placement new overload
-        NoisyAlloc(int 5)    # construction
-        ---
-        ~NoisyAlloc()  # Destructor
-        noisy delete   # operator delete
-    """
-    )
-
-
-def test_invalid_self():
-    """Tests invocation of the pybind-registered base class with an invalid `self` argument."""
-
-    class NotPybindDerived:
-        pass
-
-    # Attempts to initialize with an invalid type passed as `self`:
-    class BrokenTF1(m.TestFactory1):
-        def __init__(self, bad):
-            if bad == 1:
-                a = m.TestFactory2(tag.pointer, 1)
-                m.TestFactory1.__init__(a, tag.pointer)
-            elif bad == 2:
-                a = NotPybindDerived()
-                m.TestFactory1.__init__(a, tag.pointer)
-
-    # Same as above, but for a class with an alias:
-    class BrokenTF6(m.TestFactory6):
-        def __init__(self, bad):
-            if bad == 0:
-                m.TestFactory6.__init__()
-            elif bad == 1:
-                a = m.TestFactory2(tag.pointer, 1)
-                m.TestFactory6.__init__(a, tag.base, 1)
-            elif bad == 2:
-                a = m.TestFactory2(tag.pointer, 1)
-                m.TestFactory6.__init__(a, tag.alias, 1)
-            elif bad == 3:
-                m.TestFactory6.__init__(
-                    NotPybindDerived.__new__(NotPybindDerived), tag.base, 1
-                )
-            elif bad == 4:
-                m.TestFactory6.__init__(
-                    NotPybindDerived.__new__(NotPybindDerived), tag.alias, 1
-                )
-
-    for arg in (1, 2):
-        with pytest.raises(TypeError) as excinfo:
-            BrokenTF1(arg)
-        assert (
-            str(excinfo.value)
-            == "__init__(self, ...) called with invalid or missing `self` argument"
-        )
-
-    for arg in (0, 1, 2, 3, 4):
-        with pytest.raises(TypeError) as excinfo:
-            BrokenTF6(arg)
-        assert (
-            str(excinfo.value)
-            == "__init__(self, ...) called with invalid or missing `self` argument"
-        )
+import re
+
+import pytest
+
+from pybind11_tests import ConstructorStats
+from pybind11_tests import factory_constructors as m
+from pybind11_tests.factory_constructors import tag
+
+
+def test_init_factory_basic():
+    """Tests py::init_factory() wrapper around various ways of returning the object"""
+
+    cstats = [
+        ConstructorStats.get(c)
+        for c in [m.TestFactory1, m.TestFactory2, m.TestFactory3]
+    ]
+    cstats[0].alive()  # force gc
+    n_inst = ConstructorStats.detail_reg_inst()
+
+    x1 = m.TestFactory1(tag.unique_ptr, 3)
+    assert x1.value == "3"
+    y1 = m.TestFactory1(tag.pointer)
+    assert y1.value == "(empty)"
+    z1 = m.TestFactory1("hi!")
+    assert z1.value == "hi!"
+
+    assert ConstructorStats.detail_reg_inst() == n_inst + 3
+
+    x2 = m.TestFactory2(tag.move)
+    assert x2.value == "(empty2)"
+    y2 = m.TestFactory2(tag.pointer, 7)
+    assert y2.value == "7"
+    z2 = m.TestFactory2(tag.unique_ptr, "hi again")
+    assert z2.value == "hi again"
+
+    assert ConstructorStats.detail_reg_inst() == n_inst + 6
+
+    x3 = m.TestFactory3(tag.shared_ptr)
+    assert x3.value == "(empty3)"
+    y3 = m.TestFactory3(tag.pointer, 42)
+    assert y3.value == "42"
+    z3 = m.TestFactory3("bye")
+    assert z3.value == "bye"
+
+    for null_ptr_kind in [tag.null_ptr, tag.null_unique_ptr, tag.null_shared_ptr]:
+        with pytest.raises(TypeError) as excinfo:
+            m.TestFactory3(null_ptr_kind)
+        assert (
+            str(excinfo.value) == "pybind11::init(): factory function returned nullptr"
+        )
+
+    assert [i.alive() for i in cstats] == [3, 3, 3]
+    assert ConstructorStats.detail_reg_inst() == n_inst + 9
+
+    del x1, y2, y3, z3
+    assert [i.alive() for i in cstats] == [2, 2, 1]
+    assert ConstructorStats.detail_reg_inst() == n_inst + 5
+    del x2, x3, y1, z1, z2
+    assert [i.alive() for i in cstats] == [0, 0, 0]
+    assert ConstructorStats.detail_reg_inst() == n_inst
+
+    assert [i.values() for i in cstats] == [
+        ["3", "hi!"],
+        ["7", "hi again"],
+        ["42", "bye"],
+    ]
+    assert [i.default_constructions for i in cstats] == [1, 1, 1]
+
+
+def test_init_factory_signature(msg):
+    with pytest.raises(TypeError) as excinfo:
+        m.TestFactory1("invalid", "constructor", "arguments")
+    assert (
+        msg(excinfo.value)
+        == """
+        __init__(): incompatible constructor arguments. The following argument types are supported:
+            1. m.factory_constructors.TestFactory1(arg0: m.factory_constructors.tag.unique_ptr_tag, arg1: int)
+            2. m.factory_constructors.TestFactory1(arg0: str)
+            3. m.factory_constructors.TestFactory1(arg0: m.factory_constructors.tag.pointer_tag)
+            4. m.factory_constructors.TestFactory1(arg0: handle, arg1: int, arg2: handle)
+
+        Invoked with: 'invalid', 'constructor', 'arguments'
+    """
+    )
+
+    assert (
+        msg(m.TestFactory1.__init__.__doc__)
+        == """
+        __init__(*args, **kwargs)
+        Overloaded function.
+
+        1. __init__(self: m.factory_constructors.TestFactory1, arg0: m.factory_constructors.tag.unique_ptr_tag, arg1: int) -> None
+
+        2. __init__(self: m.factory_constructors.TestFactory1, arg0: str) -> None
+
+        3. __init__(self: m.factory_constructors.TestFactory1, arg0: m.factory_constructors.tag.pointer_tag) -> None
+
+        4. __init__(self: m.factory_constructors.TestFactory1, arg0: handle, arg1: int, arg2: handle) -> None
+    """  # noqa: E501 line too long
+    )
+
+
+def test_init_factory_casting():
+    """Tests py::init_factory() wrapper with various upcasting and downcasting returns"""
+
+    cstats = [
+        ConstructorStats.get(c)
+        for c in [m.TestFactory3, m.TestFactory4, m.TestFactory5]
+    ]
+    cstats[0].alive()  # force gc
+    n_inst = ConstructorStats.detail_reg_inst()
+
+    # Construction from derived references:
+    a = m.TestFactory3(tag.pointer, tag.TF4, 4)
+    assert a.value == "4"
+    b = m.TestFactory3(tag.shared_ptr, tag.TF4, 5)
+    assert b.value == "5"
+    c = m.TestFactory3(tag.pointer, tag.TF5, 6)
+    assert c.value == "6"
+    d = m.TestFactory3(tag.shared_ptr, tag.TF5, 7)
+    assert d.value == "7"
+
+    assert ConstructorStats.detail_reg_inst() == n_inst + 4
+
+    # Shared a lambda with TF3:
+    e = m.TestFactory4(tag.pointer, tag.TF4, 8)
+    assert e.value == "8"
+
+    assert ConstructorStats.detail_reg_inst() == n_inst + 5
+    assert [i.alive() for i in cstats] == [5, 3, 2]
+
+    del a
+    assert [i.alive() for i in cstats] == [4, 2, 2]
+    assert ConstructorStats.detail_reg_inst() == n_inst + 4
+
+    del b, c, e
+    assert [i.alive() for i in cstats] == [1, 0, 1]
+    assert ConstructorStats.detail_reg_inst() == n_inst + 1
+
+    del d
+    assert [i.alive() for i in cstats] == [0, 0, 0]
+    assert ConstructorStats.detail_reg_inst() == n_inst
+
+    assert [i.values() for i in cstats] == [
+        ["4", "5", "6", "7", "8"],
+        ["4", "5", "8"],
+        ["6", "7"],
+    ]
+
+
+def test_init_factory_alias():
+    """Tests py::init_factory() wrapper with value conversions and alias types"""
+
+    cstats = [m.TestFactory6.get_cstats(), m.TestFactory6.get_alias_cstats()]
+    cstats[0].alive()  # force gc
+    n_inst = ConstructorStats.detail_reg_inst()
+
+    a = m.TestFactory6(tag.base, 1)
+    assert a.get() == 1
+    assert not a.has_alias()
+    b = m.TestFactory6(tag.alias, "hi there")
+    assert b.get() == 8
+    assert b.has_alias()
+    c = m.TestFactory6(tag.alias, 3)
+    assert c.get() == 3
+    assert c.has_alias()
+    d = m.TestFactory6(tag.alias, tag.pointer, 4)
+    assert d.get() == 4
+    assert d.has_alias()
+    e = m.TestFactory6(tag.base, tag.pointer, 5)
+    assert e.get() == 5
+    assert not e.has_alias()
+    f = m.TestFactory6(tag.base, tag.alias, tag.pointer, 6)
+    assert f.get() == 6
+    assert f.has_alias()
+
+    assert ConstructorStats.detail_reg_inst() == n_inst + 6
+    assert [i.alive() for i in cstats] == [6, 4]
+
+    del a, b, e
+    assert [i.alive() for i in cstats] == [3, 3]
+    assert ConstructorStats.detail_reg_inst() == n_inst + 3
+    del f, c, d
+    assert [i.alive() for i in cstats] == [0, 0]
+    assert ConstructorStats.detail_reg_inst() == n_inst
+
+    class MyTest(m.TestFactory6):
+        def __init__(self, *args):
+            m.TestFactory6.__init__(self, *args)
+
+        def get(self):
+            return -5 + m.TestFactory6.get(self)
+
+    # Return Class by value, moved into new alias:
+    z = MyTest(tag.base, 123)
+    assert z.get() == 118
+    assert z.has_alias()
+
+    # Return alias by value, moved into new alias:
+    y = MyTest(tag.alias, "why hello!")
+    assert y.get() == 5
+    assert y.has_alias()
+
+    # Return Class by pointer, moved into new alias then original destroyed:
+    x = MyTest(tag.base, tag.pointer, 47)
+    assert x.get() == 42
+    assert x.has_alias()
+
+    assert ConstructorStats.detail_reg_inst() == n_inst + 3
+    assert [i.alive() for i in cstats] == [3, 3]
+    del x, y, z
+    assert [i.alive() for i in cstats] == [0, 0]
+    assert ConstructorStats.detail_reg_inst() == n_inst
+
+    assert [i.values() for i in cstats] == [
+        ["1", "8", "3", "4", "5", "6", "123", "10", "47"],
+        ["hi there", "3", "4", "6", "move", "123", "why hello!", "move", "47"],
+    ]
+
+
+def test_init_factory_dual():
+    """Tests init factory functions with dual main/alias factory functions"""
+    from pybind11_tests.factory_constructors import TestFactory7
+
+    cstats = [TestFactory7.get_cstats(), TestFactory7.get_alias_cstats()]
+    cstats[0].alive()  # force gc
+    n_inst = ConstructorStats.detail_reg_inst()
+
+    class PythFactory7(TestFactory7):
+        def get(self):
+            return 100 + TestFactory7.get(self)
+
+    a1 = TestFactory7(1)
+    a2 = PythFactory7(2)
+    assert a1.get() == 1
+    assert a2.get() == 102
+    assert not a1.has_alias()
+    assert a2.has_alias()
+
+    b1 = TestFactory7(tag.pointer, 3)
+    b2 = PythFactory7(tag.pointer, 4)
+    assert b1.get() == 3
+    assert b2.get() == 104
+    assert not b1.has_alias()
+    assert b2.has_alias()
+
+    c1 = TestFactory7(tag.mixed, 5)
+    c2 = PythFactory7(tag.mixed, 6)
+    assert c1.get() == 5
+    assert c2.get() == 106
+    assert not c1.has_alias()
+    assert c2.has_alias()
+
+    d1 = TestFactory7(tag.base, tag.pointer, 7)
+    d2 = PythFactory7(tag.base, tag.pointer, 8)
+    assert d1.get() == 7
+    assert d2.get() == 108
+    assert not d1.has_alias()
+    assert d2.has_alias()
+
+    # Both return an alias; the second multiplies the value by 10:
+    e1 = TestFactory7(tag.alias, tag.pointer, 9)
+    e2 = PythFactory7(tag.alias, tag.pointer, 10)
+    assert e1.get() == 9
+    assert e2.get() == 200
+    assert e1.has_alias()
+    assert e2.has_alias()
+
+    f1 = TestFactory7(tag.shared_ptr, tag.base, 11)
+    f2 = PythFactory7(tag.shared_ptr, tag.base, 12)
+    assert f1.get() == 11
+    assert f2.get() == 112
+    assert not f1.has_alias()
+    assert f2.has_alias()
+
+    g1 = TestFactory7(tag.shared_ptr, tag.invalid_base, 13)
+    assert g1.get() == 13
+    assert not g1.has_alias()
+    with pytest.raises(TypeError) as excinfo:
+        PythFactory7(tag.shared_ptr, tag.invalid_base, 14)
+    assert (
+        str(excinfo.value)
+        == "pybind11::init(): construction failed: returned holder-wrapped instance is not an "
+        "alias instance"
+    )
+
+    assert [i.alive() for i in cstats] == [13, 7]
+    assert ConstructorStats.detail_reg_inst() == n_inst + 13
+
+    del a1, a2, b1, d1, e1, e2
+    assert [i.alive() for i in cstats] == [7, 4]
+    assert ConstructorStats.detail_reg_inst() == n_inst + 7
+    del b2, c1, c2, d2, f1, f2, g1
+    assert [i.alive() for i in cstats] == [0, 0]
+    assert ConstructorStats.detail_reg_inst() == n_inst
+
+    assert [i.values() for i in cstats] == [
+        ["1", "2", "3", "4", "5", "6", "7", "8", "9", "100", "11", "12", "13", "14"],
+        ["2", "4", "6", "8", "9", "100", "12"],
+    ]
+
+
+def test_no_placement_new(capture):
+    """Prior to 2.2, `py::init<...>` relied on the type supporting placement
+    new; this tests a class without placement new support."""
+    with capture:
+        a = m.NoPlacementNew(123)
+
+    found = re.search(r"^operator new called, returning (\d+)\n$", str(capture))
+    assert found
+    assert a.i == 123
+    with capture:
+        del a
+        pytest.gc_collect()
+    assert capture == "operator delete called on " + found.group(1)
+
+    with capture:
+        b = m.NoPlacementNew()
+
+    found = re.search(r"^operator new called, returning (\d+)\n$", str(capture))
+    assert found
+    assert b.i == 100
+    with capture:
+        del b
+        pytest.gc_collect()
+    assert capture == "operator delete called on " + found.group(1)
+
+
+def test_multiple_inheritance():
+    class MITest(m.TestFactory1, m.TestFactory2):
+        def __init__(self):
+            m.TestFactory1.__init__(self, tag.unique_ptr, 33)
+            m.TestFactory2.__init__(self, tag.move)
+
+    a = MITest()
+    assert m.TestFactory1.value.fget(a) == "33"
+    assert m.TestFactory2.value.fget(a) == "(empty2)"
+
+
+def create_and_destroy(*args):
+    a = m.NoisyAlloc(*args)
+    print("---")
+    del a
+    pytest.gc_collect()
+
+
+def strip_comments(s):
+    return re.sub(r"\s+#.*", "", s)
+
+
+def test_reallocation_a(capture, msg):
+    """When the constructor is overloaded, previous overloads can require a preallocated value.
+    This test makes sure that such preallocated values only happen when they might be necessary,
+    and that they are deallocated properly."""
+
+    pytest.gc_collect()
+
+    with capture:
+        create_and_destroy(1)
+    assert (
+        msg(capture)
+        == """
+        noisy new
+        noisy placement new
+        NoisyAlloc(int 1)
+        ---
+        ~NoisyAlloc()
+        noisy delete
+    """
+    )
+
+
+def test_reallocation_b(capture, msg):
+    with capture:
+        create_and_destroy(1.5)
+    assert msg(capture) == strip_comments(
+        """
+        noisy new               # allocation required to attempt first overload
+        noisy delete            # have to dealloc before considering factory init overload
+        noisy new               # pointer factory calling "new", part 1: allocation
+        NoisyAlloc(double 1.5)  # ... part two, invoking constructor
+        ---
+        ~NoisyAlloc()  # Destructor
+        noisy delete   # operator delete
+    """
+    )
+
+
+def test_reallocation_c(capture, msg):
+    with capture:
+        create_and_destroy(2, 3)
+    assert msg(capture) == strip_comments(
+        """
+        noisy new          # pointer factory calling "new", allocation
+        NoisyAlloc(int 2)  # constructor
+        ---
+        ~NoisyAlloc()  # Destructor
+        noisy delete   # operator delete
+    """
+    )
+
+
+def test_reallocation_d(capture, msg):
+    with capture:
+        create_and_destroy(2.5, 3)
+    assert msg(capture) == strip_comments(
+        """
+        NoisyAlloc(double 2.5)  # construction (local func variable: operator_new not called)
+        noisy new               # return-by-value "new" part 1: allocation
+        ~NoisyAlloc()           # moved-away local func variable destruction
+        ---
+        ~NoisyAlloc()  # Destructor
+        noisy delete   # operator delete
+    """
+    )
+
+
+def test_reallocation_e(capture, msg):
+    with capture:
+        create_and_destroy(3.5, 4.5)
+    assert msg(capture) == strip_comments(
+        """
+        noisy new               # preallocation needed before invoking placement-new overload
+        noisy placement new     # Placement new
+        NoisyAlloc(double 3.5)  # construction
+        ---
+        ~NoisyAlloc()  # Destructor
+        noisy delete   # operator delete
+    """
+    )
+
+
+def test_reallocation_f(capture, msg):
+    with capture:
+        create_and_destroy(4, 0.5)
+    assert msg(capture) == strip_comments(
+        """
+        noisy new          # preallocation needed before invoking placement-new overload
+        noisy delete       # deallocation of preallocated storage
+        noisy new          # Factory pointer allocation
+        NoisyAlloc(int 4)  # factory pointer construction
+        ---
+        ~NoisyAlloc()  # Destructor
+        noisy delete   # operator delete
+    """
+    )
+
+
+def test_reallocation_g(capture, msg):
+    with capture:
+        create_and_destroy(5, "hi")
+    assert msg(capture) == strip_comments(
+        """
+        noisy new            # preallocation needed before invoking first placement new
+        noisy delete         # delete before considering new-style constructor
+        noisy new            # preallocation for second placement new
+        noisy placement new  # Placement new in the second placement new overload
+        NoisyAlloc(int 5)    # construction
+        ---
+        ~NoisyAlloc()  # Destructor
+        noisy delete   # operator delete
+    """
+    )
+
+
+def test_invalid_self():
+    """Tests invocation of the pybind-registered base class with an invalid `self` argument."""
+
+    class NotPybindDerived:
+        pass
+
+    # Attempts to initialize with an invalid type passed as `self`:
+    class BrokenTF1(m.TestFactory1):
+        def __init__(self, bad):
+            if bad == 1:
+                a = m.TestFactory2(tag.pointer, 1)
+                m.TestFactory1.__init__(a, tag.pointer)
+            elif bad == 2:
+                a = NotPybindDerived()
+                m.TestFactory1.__init__(a, tag.pointer)
+
+    # Same as above, but for a class with an alias:
+    class BrokenTF6(m.TestFactory6):
+        def __init__(self, bad):
+            if bad == 0:
+                m.TestFactory6.__init__()
+            elif bad == 1:
+                a = m.TestFactory2(tag.pointer, 1)
+                m.TestFactory6.__init__(a, tag.base, 1)
+            elif bad == 2:
+                a = m.TestFactory2(tag.pointer, 1)
+                m.TestFactory6.__init__(a, tag.alias, 1)
+            elif bad == 3:
+                m.TestFactory6.__init__(
+                    NotPybindDerived.__new__(NotPybindDerived), tag.base, 1
+                )
+            elif bad == 4:
+                m.TestFactory6.__init__(
+                    NotPybindDerived.__new__(NotPybindDerived), tag.alias, 1
+                )
+
+    for arg in (1, 2):
+        with pytest.raises(TypeError) as excinfo:
+            BrokenTF1(arg)
+        assert (
+            str(excinfo.value)
+            == "__init__(self, ...) called with invalid or missing `self` argument"
+        )
+
+    for arg in (0, 1, 2, 3, 4):
+        with pytest.raises(TypeError) as excinfo:
+            BrokenTF6(arg)
+        assert (
+            str(excinfo.value)
+            == "__init__(self, ...) called with invalid or missing `self` argument"
+        )
```

## extern/pybind11/tests/test_gil_scoped.py

 * *Ordering differences only*

```diff
@@ -1,244 +1,244 @@
-import multiprocessing
-import sys
-import threading
-import time
-
-import pytest
-
-import env
-from pybind11_tests import gil_scoped as m
-
-
-class ExtendedVirtClass(m.VirtClass):
-    def virtual_func(self):
-        pass
-
-    def pure_virtual_func(self):
-        pass
-
-
-def test_callback_py_obj():
-    m.test_callback_py_obj(lambda: None)
-
-
-def test_callback_std_func():
-    m.test_callback_std_func(lambda: None)
-
-
-def test_callback_virtual_func():
-    extended = ExtendedVirtClass()
-    m.test_callback_virtual_func(extended)
-
-
-def test_callback_pure_virtual_func():
-    extended = ExtendedVirtClass()
-    m.test_callback_pure_virtual_func(extended)
-
-
-def test_cross_module_gil_released():
-    """Makes sure that the GIL can be acquired by another module from a GIL-released state."""
-    m.test_cross_module_gil_released()  # Should not raise a SIGSEGV
-
-
-def test_cross_module_gil_acquired():
-    """Makes sure that the GIL can be acquired by another module from a GIL-acquired state."""
-    m.test_cross_module_gil_acquired()  # Should not raise a SIGSEGV
-
-
-def test_cross_module_gil_inner_custom_released():
-    """Makes sure that the GIL can be acquired/released by another module
-    from a GIL-released state using custom locking logic."""
-    m.test_cross_module_gil_inner_custom_released()
-
-
-def test_cross_module_gil_inner_custom_acquired():
-    """Makes sure that the GIL can be acquired/acquired by another module
-    from a GIL-acquired state using custom locking logic."""
-    m.test_cross_module_gil_inner_custom_acquired()
-
-
-def test_cross_module_gil_inner_pybind11_released():
-    """Makes sure that the GIL can be acquired/released by another module
-    from a GIL-released state using pybind11 locking logic."""
-    m.test_cross_module_gil_inner_pybind11_released()
-
-
-def test_cross_module_gil_inner_pybind11_acquired():
-    """Makes sure that the GIL can be acquired/acquired by another module
-    from a GIL-acquired state using pybind11 locking logic."""
-    m.test_cross_module_gil_inner_pybind11_acquired()
-
-
-def test_cross_module_gil_nested_custom_released():
-    """Makes sure that the GIL can be nested acquired/released by another module
-    from a GIL-released state using custom locking logic."""
-    m.test_cross_module_gil_nested_custom_released()
-
-
-def test_cross_module_gil_nested_custom_acquired():
-    """Makes sure that the GIL can be nested acquired/acquired by another module
-    from a GIL-acquired state using custom locking logic."""
-    m.test_cross_module_gil_nested_custom_acquired()
-
-
-def test_cross_module_gil_nested_pybind11_released():
-    """Makes sure that the GIL can be nested acquired/released by another module
-    from a GIL-released state using pybind11 locking logic."""
-    m.test_cross_module_gil_nested_pybind11_released()
-
-
-def test_cross_module_gil_nested_pybind11_acquired():
-    """Makes sure that the GIL can be nested acquired/acquired by another module
-    from a GIL-acquired state using pybind11 locking logic."""
-    m.test_cross_module_gil_nested_pybind11_acquired()
-
-
-def test_release_acquire():
-    assert m.test_release_acquire(0xAB) == "171"
-
-
-def test_nested_acquire():
-    assert m.test_nested_acquire(0xAB) == "171"
-
-
-def test_multi_acquire_release_cross_module():
-    for bits in range(16 * 8):
-        internals_ids = m.test_multi_acquire_release_cross_module(bits)
-        assert len(internals_ids) == 2 if bits % 8 else 1
-
-
-# Intentionally putting human review in the loop here, to guard against accidents.
-VARS_BEFORE_ALL_BASIC_TESTS = dict(vars())  # Make a copy of the dict (critical).
-ALL_BASIC_TESTS = (
-    test_callback_py_obj,
-    test_callback_std_func,
-    test_callback_virtual_func,
-    test_callback_pure_virtual_func,
-    test_cross_module_gil_released,
-    test_cross_module_gil_acquired,
-    test_cross_module_gil_inner_custom_released,
-    test_cross_module_gil_inner_custom_acquired,
-    test_cross_module_gil_inner_pybind11_released,
-    test_cross_module_gil_inner_pybind11_acquired,
-    test_cross_module_gil_nested_custom_released,
-    test_cross_module_gil_nested_custom_acquired,
-    test_cross_module_gil_nested_pybind11_released,
-    test_cross_module_gil_nested_pybind11_acquired,
-    test_release_acquire,
-    test_nested_acquire,
-    test_multi_acquire_release_cross_module,
-)
-
-
-def test_all_basic_tests_completeness():
-    num_found = 0
-    for key, value in VARS_BEFORE_ALL_BASIC_TESTS.items():
-        if not key.startswith("test_"):
-            continue
-        assert value in ALL_BASIC_TESTS
-        num_found += 1
-    assert len(ALL_BASIC_TESTS) == num_found
-
-
-def _intentional_deadlock():
-    m.intentional_deadlock()
-
-
-ALL_BASIC_TESTS_PLUS_INTENTIONAL_DEADLOCK = ALL_BASIC_TESTS + (_intentional_deadlock,)
-
-
-def _run_in_process(target, *args, **kwargs):
-    if len(args) == 0:
-        test_fn = target
-    else:
-        test_fn = args[0]
-    # Do not need to wait much, 10s should be more than enough.
-    timeout = 0.1 if test_fn is _intentional_deadlock else 10
-    process = multiprocessing.Process(target=target, args=args, kwargs=kwargs)
-    process.daemon = True
-    try:
-        t_start = time.time()
-        process.start()
-        if timeout >= 100:  # For debugging.
-            print(
-                "\nprocess.pid STARTED", process.pid, (sys.argv, target, args, kwargs)
-            )
-            print(f"COPY-PASTE-THIS: gdb {sys.argv[0]} -p {process.pid}", flush=True)
-        process.join(timeout=timeout)
-        if timeout >= 100:
-            print("\nprocess.pid JOINED", process.pid, flush=True)
-        t_delta = time.time() - t_start
-        if process.exitcode == 66 and m.defined_THREAD_SANITIZER:  # Issue #2754
-            # WOULD-BE-NICE-TO-HAVE: Check that the message below is actually in the output.
-            # Maybe this could work:
-            # https://gist.github.com/alexeygrigorev/01ce847f2e721b513b42ea4a6c96905e
-            pytest.skip(
-                "ThreadSanitizer: starting new threads after multi-threaded fork is not supported."
-            )
-        elif test_fn is _intentional_deadlock:
-            assert process.exitcode is None
-            return 0
-        elif process.exitcode is None:
-            assert t_delta > 0.9 * timeout
-            msg = "DEADLOCK, most likely, exactly what this test is meant to detect."
-            if env.PYPY and env.WIN:
-                pytest.skip(msg)
-            raise RuntimeError(msg)
-        return process.exitcode
-    finally:
-        if process.is_alive():
-            process.terminate()
-
-
-def _run_in_threads(test_fn, num_threads, parallel):
-    threads = []
-    for _ in range(num_threads):
-        thread = threading.Thread(target=test_fn)
-        thread.daemon = True
-        thread.start()
-        if parallel:
-            threads.append(thread)
-        else:
-            thread.join()
-    for thread in threads:
-        thread.join()
-
-
-# TODO: FIXME, sometimes returns -11 (segfault) instead of 0 on macOS Python 3.9
-@pytest.mark.parametrize("test_fn", ALL_BASIC_TESTS_PLUS_INTENTIONAL_DEADLOCK)
-def test_run_in_process_one_thread(test_fn):
-    """Makes sure there is no GIL deadlock when running in a thread.
-
-    It runs in a separate process to be able to stop and assert if it deadlocks.
-    """
-    assert _run_in_process(_run_in_threads, test_fn, num_threads=1, parallel=False) == 0
-
-
-# TODO: FIXME on macOS Python 3.9
-@pytest.mark.parametrize("test_fn", ALL_BASIC_TESTS_PLUS_INTENTIONAL_DEADLOCK)
-def test_run_in_process_multiple_threads_parallel(test_fn):
-    """Makes sure there is no GIL deadlock when running in a thread multiple times in parallel.
-
-    It runs in a separate process to be able to stop and assert if it deadlocks.
-    """
-    assert _run_in_process(_run_in_threads, test_fn, num_threads=8, parallel=True) == 0
-
-
-# TODO: FIXME on macOS Python 3.9
-@pytest.mark.parametrize("test_fn", ALL_BASIC_TESTS_PLUS_INTENTIONAL_DEADLOCK)
-def test_run_in_process_multiple_threads_sequential(test_fn):
-    """Makes sure there is no GIL deadlock when running in a thread multiple times sequentially.
-
-    It runs in a separate process to be able to stop and assert if it deadlocks.
-    """
-    assert _run_in_process(_run_in_threads, test_fn, num_threads=8, parallel=False) == 0
-
-
-# TODO: FIXME on macOS Python 3.9
-@pytest.mark.parametrize("test_fn", ALL_BASIC_TESTS_PLUS_INTENTIONAL_DEADLOCK)
-def test_run_in_process_direct(test_fn):
-    """Makes sure there is no GIL deadlock when using processes.
-
-    This test is for completion, but it was never an issue.
-    """
-    assert _run_in_process(test_fn) == 0
+import multiprocessing
+import sys
+import threading
+import time
+
+import pytest
+
+import env
+from pybind11_tests import gil_scoped as m
+
+
+class ExtendedVirtClass(m.VirtClass):
+    def virtual_func(self):
+        pass
+
+    def pure_virtual_func(self):
+        pass
+
+
+def test_callback_py_obj():
+    m.test_callback_py_obj(lambda: None)
+
+
+def test_callback_std_func():
+    m.test_callback_std_func(lambda: None)
+
+
+def test_callback_virtual_func():
+    extended = ExtendedVirtClass()
+    m.test_callback_virtual_func(extended)
+
+
+def test_callback_pure_virtual_func():
+    extended = ExtendedVirtClass()
+    m.test_callback_pure_virtual_func(extended)
+
+
+def test_cross_module_gil_released():
+    """Makes sure that the GIL can be acquired by another module from a GIL-released state."""
+    m.test_cross_module_gil_released()  # Should not raise a SIGSEGV
+
+
+def test_cross_module_gil_acquired():
+    """Makes sure that the GIL can be acquired by another module from a GIL-acquired state."""
+    m.test_cross_module_gil_acquired()  # Should not raise a SIGSEGV
+
+
+def test_cross_module_gil_inner_custom_released():
+    """Makes sure that the GIL can be acquired/released by another module
+    from a GIL-released state using custom locking logic."""
+    m.test_cross_module_gil_inner_custom_released()
+
+
+def test_cross_module_gil_inner_custom_acquired():
+    """Makes sure that the GIL can be acquired/acquired by another module
+    from a GIL-acquired state using custom locking logic."""
+    m.test_cross_module_gil_inner_custom_acquired()
+
+
+def test_cross_module_gil_inner_pybind11_released():
+    """Makes sure that the GIL can be acquired/released by another module
+    from a GIL-released state using pybind11 locking logic."""
+    m.test_cross_module_gil_inner_pybind11_released()
+
+
+def test_cross_module_gil_inner_pybind11_acquired():
+    """Makes sure that the GIL can be acquired/acquired by another module
+    from a GIL-acquired state using pybind11 locking logic."""
+    m.test_cross_module_gil_inner_pybind11_acquired()
+
+
+def test_cross_module_gil_nested_custom_released():
+    """Makes sure that the GIL can be nested acquired/released by another module
+    from a GIL-released state using custom locking logic."""
+    m.test_cross_module_gil_nested_custom_released()
+
+
+def test_cross_module_gil_nested_custom_acquired():
+    """Makes sure that the GIL can be nested acquired/acquired by another module
+    from a GIL-acquired state using custom locking logic."""
+    m.test_cross_module_gil_nested_custom_acquired()
+
+
+def test_cross_module_gil_nested_pybind11_released():
+    """Makes sure that the GIL can be nested acquired/released by another module
+    from a GIL-released state using pybind11 locking logic."""
+    m.test_cross_module_gil_nested_pybind11_released()
+
+
+def test_cross_module_gil_nested_pybind11_acquired():
+    """Makes sure that the GIL can be nested acquired/acquired by another module
+    from a GIL-acquired state using pybind11 locking logic."""
+    m.test_cross_module_gil_nested_pybind11_acquired()
+
+
+def test_release_acquire():
+    assert m.test_release_acquire(0xAB) == "171"
+
+
+def test_nested_acquire():
+    assert m.test_nested_acquire(0xAB) == "171"
+
+
+def test_multi_acquire_release_cross_module():
+    for bits in range(16 * 8):
+        internals_ids = m.test_multi_acquire_release_cross_module(bits)
+        assert len(internals_ids) == 2 if bits % 8 else 1
+
+
+# Intentionally putting human review in the loop here, to guard against accidents.
+VARS_BEFORE_ALL_BASIC_TESTS = dict(vars())  # Make a copy of the dict (critical).
+ALL_BASIC_TESTS = (
+    test_callback_py_obj,
+    test_callback_std_func,
+    test_callback_virtual_func,
+    test_callback_pure_virtual_func,
+    test_cross_module_gil_released,
+    test_cross_module_gil_acquired,
+    test_cross_module_gil_inner_custom_released,
+    test_cross_module_gil_inner_custom_acquired,
+    test_cross_module_gil_inner_pybind11_released,
+    test_cross_module_gil_inner_pybind11_acquired,
+    test_cross_module_gil_nested_custom_released,
+    test_cross_module_gil_nested_custom_acquired,
+    test_cross_module_gil_nested_pybind11_released,
+    test_cross_module_gil_nested_pybind11_acquired,
+    test_release_acquire,
+    test_nested_acquire,
+    test_multi_acquire_release_cross_module,
+)
+
+
+def test_all_basic_tests_completeness():
+    num_found = 0
+    for key, value in VARS_BEFORE_ALL_BASIC_TESTS.items():
+        if not key.startswith("test_"):
+            continue
+        assert value in ALL_BASIC_TESTS
+        num_found += 1
+    assert len(ALL_BASIC_TESTS) == num_found
+
+
+def _intentional_deadlock():
+    m.intentional_deadlock()
+
+
+ALL_BASIC_TESTS_PLUS_INTENTIONAL_DEADLOCK = ALL_BASIC_TESTS + (_intentional_deadlock,)
+
+
+def _run_in_process(target, *args, **kwargs):
+    if len(args) == 0:
+        test_fn = target
+    else:
+        test_fn = args[0]
+    # Do not need to wait much, 10s should be more than enough.
+    timeout = 0.1 if test_fn is _intentional_deadlock else 10
+    process = multiprocessing.Process(target=target, args=args, kwargs=kwargs)
+    process.daemon = True
+    try:
+        t_start = time.time()
+        process.start()
+        if timeout >= 100:  # For debugging.
+            print(
+                "\nprocess.pid STARTED", process.pid, (sys.argv, target, args, kwargs)
+            )
+            print(f"COPY-PASTE-THIS: gdb {sys.argv[0]} -p {process.pid}", flush=True)
+        process.join(timeout=timeout)
+        if timeout >= 100:
+            print("\nprocess.pid JOINED", process.pid, flush=True)
+        t_delta = time.time() - t_start
+        if process.exitcode == 66 and m.defined_THREAD_SANITIZER:  # Issue #2754
+            # WOULD-BE-NICE-TO-HAVE: Check that the message below is actually in the output.
+            # Maybe this could work:
+            # https://gist.github.com/alexeygrigorev/01ce847f2e721b513b42ea4a6c96905e
+            pytest.skip(
+                "ThreadSanitizer: starting new threads after multi-threaded fork is not supported."
+            )
+        elif test_fn is _intentional_deadlock:
+            assert process.exitcode is None
+            return 0
+        elif process.exitcode is None:
+            assert t_delta > 0.9 * timeout
+            msg = "DEADLOCK, most likely, exactly what this test is meant to detect."
+            if env.PYPY and env.WIN:
+                pytest.skip(msg)
+            raise RuntimeError(msg)
+        return process.exitcode
+    finally:
+        if process.is_alive():
+            process.terminate()
+
+
+def _run_in_threads(test_fn, num_threads, parallel):
+    threads = []
+    for _ in range(num_threads):
+        thread = threading.Thread(target=test_fn)
+        thread.daemon = True
+        thread.start()
+        if parallel:
+            threads.append(thread)
+        else:
+            thread.join()
+    for thread in threads:
+        thread.join()
+
+
+# TODO: FIXME, sometimes returns -11 (segfault) instead of 0 on macOS Python 3.9
+@pytest.mark.parametrize("test_fn", ALL_BASIC_TESTS_PLUS_INTENTIONAL_DEADLOCK)
+def test_run_in_process_one_thread(test_fn):
+    """Makes sure there is no GIL deadlock when running in a thread.
+
+    It runs in a separate process to be able to stop and assert if it deadlocks.
+    """
+    assert _run_in_process(_run_in_threads, test_fn, num_threads=1, parallel=False) == 0
+
+
+# TODO: FIXME on macOS Python 3.9
+@pytest.mark.parametrize("test_fn", ALL_BASIC_TESTS_PLUS_INTENTIONAL_DEADLOCK)
+def test_run_in_process_multiple_threads_parallel(test_fn):
+    """Makes sure there is no GIL deadlock when running in a thread multiple times in parallel.
+
+    It runs in a separate process to be able to stop and assert if it deadlocks.
+    """
+    assert _run_in_process(_run_in_threads, test_fn, num_threads=8, parallel=True) == 0
+
+
+# TODO: FIXME on macOS Python 3.9
+@pytest.mark.parametrize("test_fn", ALL_BASIC_TESTS_PLUS_INTENTIONAL_DEADLOCK)
+def test_run_in_process_multiple_threads_sequential(test_fn):
+    """Makes sure there is no GIL deadlock when running in a thread multiple times sequentially.
+
+    It runs in a separate process to be able to stop and assert if it deadlocks.
+    """
+    assert _run_in_process(_run_in_threads, test_fn, num_threads=8, parallel=False) == 0
+
+
+# TODO: FIXME on macOS Python 3.9
+@pytest.mark.parametrize("test_fn", ALL_BASIC_TESTS_PLUS_INTENTIONAL_DEADLOCK)
+def test_run_in_process_direct(test_fn):
+    """Makes sure there is no GIL deadlock when using processes.
+
+    This test is for completion, but it was never an issue.
+    """
+    assert _run_in_process(test_fn) == 0
```

## extern/pybind11/tests/test_iostream.py

 * *Ordering differences only*

```diff
@@ -1,295 +1,295 @@
-from contextlib import redirect_stderr, redirect_stdout
-from io import StringIO
-
-from pybind11_tests import iostream as m
-
-
-def test_captured(capsys):
-    msg = "I've been redirected to Python, I hope!"
-    m.captured_output(msg)
-    stdout, stderr = capsys.readouterr()
-    assert stdout == msg
-    assert stderr == ""
-
-    m.captured_output_default(msg)
-    stdout, stderr = capsys.readouterr()
-    assert stdout == msg
-    assert stderr == ""
-
-    m.captured_err(msg)
-    stdout, stderr = capsys.readouterr()
-    assert stdout == ""
-    assert stderr == msg
-
-
-def test_captured_large_string(capsys):
-    # Make this bigger than the buffer used on the C++ side: 1024 chars
-    msg = "I've been redirected to Python, I hope!"
-    msg = msg * (1024 // len(msg) + 1)
-
-    m.captured_output_default(msg)
-    stdout, stderr = capsys.readouterr()
-    assert stdout == msg
-    assert stderr == ""
-
-
-def test_captured_utf8_2byte_offset0(capsys):
-    msg = "\u07FF"
-    msg = "" + msg * (1024 // len(msg) + 1)
-
-    m.captured_output_default(msg)
-    stdout, stderr = capsys.readouterr()
-    assert stdout == msg
-    assert stderr == ""
-
-
-def test_captured_utf8_2byte_offset1(capsys):
-    msg = "\u07FF"
-    msg = "1" + msg * (1024 // len(msg) + 1)
-
-    m.captured_output_default(msg)
-    stdout, stderr = capsys.readouterr()
-    assert stdout == msg
-    assert stderr == ""
-
-
-def test_captured_utf8_3byte_offset0(capsys):
-    msg = "\uFFFF"
-    msg = "" + msg * (1024 // len(msg) + 1)
-
-    m.captured_output_default(msg)
-    stdout, stderr = capsys.readouterr()
-    assert stdout == msg
-    assert stderr == ""
-
-
-def test_captured_utf8_3byte_offset1(capsys):
-    msg = "\uFFFF"
-    msg = "1" + msg * (1024 // len(msg) + 1)
-
-    m.captured_output_default(msg)
-    stdout, stderr = capsys.readouterr()
-    assert stdout == msg
-    assert stderr == ""
-
-
-def test_captured_utf8_3byte_offset2(capsys):
-    msg = "\uFFFF"
-    msg = "12" + msg * (1024 // len(msg) + 1)
-
-    m.captured_output_default(msg)
-    stdout, stderr = capsys.readouterr()
-    assert stdout == msg
-    assert stderr == ""
-
-
-def test_captured_utf8_4byte_offset0(capsys):
-    msg = "\U0010FFFF"
-    msg = "" + msg * (1024 // len(msg) + 1)
-
-    m.captured_output_default(msg)
-    stdout, stderr = capsys.readouterr()
-    assert stdout == msg
-    assert stderr == ""
-
-
-def test_captured_utf8_4byte_offset1(capsys):
-    msg = "\U0010FFFF"
-    msg = "1" + msg * (1024 // len(msg) + 1)
-
-    m.captured_output_default(msg)
-    stdout, stderr = capsys.readouterr()
-    assert stdout == msg
-    assert stderr == ""
-
-
-def test_captured_utf8_4byte_offset2(capsys):
-    msg = "\U0010FFFF"
-    msg = "12" + msg * (1024 // len(msg) + 1)
-
-    m.captured_output_default(msg)
-    stdout, stderr = capsys.readouterr()
-    assert stdout == msg
-    assert stderr == ""
-
-
-def test_captured_utf8_4byte_offset3(capsys):
-    msg = "\U0010FFFF"
-    msg = "123" + msg * (1024 // len(msg) + 1)
-
-    m.captured_output_default(msg)
-    stdout, stderr = capsys.readouterr()
-    assert stdout == msg
-    assert stderr == ""
-
-
-def test_guard_capture(capsys):
-    msg = "I've been redirected to Python, I hope!"
-    m.guard_output(msg)
-    stdout, stderr = capsys.readouterr()
-    assert stdout == msg
-    assert stderr == ""
-
-
-def test_series_captured(capture):
-    with capture:
-        m.captured_output("a")
-        m.captured_output("b")
-    assert capture == "ab"
-
-
-def test_flush(capfd):
-    msg = "(not flushed)"
-    msg2 = "(flushed)"
-
-    with m.ostream_redirect():
-        m.noisy_function(msg, flush=False)
-        stdout, stderr = capfd.readouterr()
-        assert stdout == ""
-
-        m.noisy_function(msg2, flush=True)
-        stdout, stderr = capfd.readouterr()
-        assert stdout == msg + msg2
-
-        m.noisy_function(msg, flush=False)
-
-    stdout, stderr = capfd.readouterr()
-    assert stdout == msg
-
-
-def test_not_captured(capfd):
-    msg = "Something that should not show up in log"
-    stream = StringIO()
-    with redirect_stdout(stream):
-        m.raw_output(msg)
-    stdout, stderr = capfd.readouterr()
-    assert stdout == msg
-    assert stderr == ""
-    assert stream.getvalue() == ""
-
-    stream = StringIO()
-    with redirect_stdout(stream):
-        m.captured_output(msg)
-    stdout, stderr = capfd.readouterr()
-    assert stdout == ""
-    assert stderr == ""
-    assert stream.getvalue() == msg
-
-
-def test_err(capfd):
-    msg = "Something that should not show up in log"
-    stream = StringIO()
-    with redirect_stderr(stream):
-        m.raw_err(msg)
-    stdout, stderr = capfd.readouterr()
-    assert stdout == ""
-    assert stderr == msg
-    assert stream.getvalue() == ""
-
-    stream = StringIO()
-    with redirect_stderr(stream):
-        m.captured_err(msg)
-    stdout, stderr = capfd.readouterr()
-    assert stdout == ""
-    assert stderr == ""
-    assert stream.getvalue() == msg
-
-
-def test_multi_captured(capfd):
-    stream = StringIO()
-    with redirect_stdout(stream):
-        m.captured_output("a")
-        m.raw_output("b")
-        m.captured_output("c")
-        m.raw_output("d")
-    stdout, stderr = capfd.readouterr()
-    assert stdout == "bd"
-    assert stream.getvalue() == "ac"
-
-
-def test_dual(capsys):
-    m.captured_dual("a", "b")
-    stdout, stderr = capsys.readouterr()
-    assert stdout == "a"
-    assert stderr == "b"
-
-
-def test_redirect(capfd):
-    msg = "Should not be in log!"
-    stream = StringIO()
-    with redirect_stdout(stream):
-        m.raw_output(msg)
-    stdout, stderr = capfd.readouterr()
-    assert stdout == msg
-    assert stream.getvalue() == ""
-
-    stream = StringIO()
-    with redirect_stdout(stream):
-        with m.ostream_redirect():
-            m.raw_output(msg)
-    stdout, stderr = capfd.readouterr()
-    assert stdout == ""
-    assert stream.getvalue() == msg
-
-    stream = StringIO()
-    with redirect_stdout(stream):
-        m.raw_output(msg)
-    stdout, stderr = capfd.readouterr()
-    assert stdout == msg
-    assert stream.getvalue() == ""
-
-
-def test_redirect_err(capfd):
-    msg = "StdOut"
-    msg2 = "StdErr"
-
-    stream = StringIO()
-    with redirect_stderr(stream):
-        with m.ostream_redirect(stdout=False):
-            m.raw_output(msg)
-            m.raw_err(msg2)
-    stdout, stderr = capfd.readouterr()
-    assert stdout == msg
-    assert stderr == ""
-    assert stream.getvalue() == msg2
-
-
-def test_redirect_both(capfd):
-    msg = "StdOut"
-    msg2 = "StdErr"
-
-    stream = StringIO()
-    stream2 = StringIO()
-    with redirect_stdout(stream):
-        with redirect_stderr(stream2):
-            with m.ostream_redirect():
-                m.raw_output(msg)
-                m.raw_err(msg2)
-    stdout, stderr = capfd.readouterr()
-    assert stdout == ""
-    assert stderr == ""
-    assert stream.getvalue() == msg
-    assert stream2.getvalue() == msg2
-
-
-def test_threading():
-    with m.ostream_redirect(stdout=True, stderr=False):
-        # start some threads
-        threads = []
-
-        # start some threads
-        for _j in range(20):
-            threads.append(m.TestThread())
-
-        # give the threads some time to fail
-        threads[0].sleep()
-
-        # stop all the threads
-        for t in threads:
-            t.stop()
-
-        for t in threads:
-            t.join()
-
-        # if a thread segfaults, we don't get here
-        assert True
+from contextlib import redirect_stderr, redirect_stdout
+from io import StringIO
+
+from pybind11_tests import iostream as m
+
+
+def test_captured(capsys):
+    msg = "I've been redirected to Python, I hope!"
+    m.captured_output(msg)
+    stdout, stderr = capsys.readouterr()
+    assert stdout == msg
+    assert stderr == ""
+
+    m.captured_output_default(msg)
+    stdout, stderr = capsys.readouterr()
+    assert stdout == msg
+    assert stderr == ""
+
+    m.captured_err(msg)
+    stdout, stderr = capsys.readouterr()
+    assert stdout == ""
+    assert stderr == msg
+
+
+def test_captured_large_string(capsys):
+    # Make this bigger than the buffer used on the C++ side: 1024 chars
+    msg = "I've been redirected to Python, I hope!"
+    msg = msg * (1024 // len(msg) + 1)
+
+    m.captured_output_default(msg)
+    stdout, stderr = capsys.readouterr()
+    assert stdout == msg
+    assert stderr == ""
+
+
+def test_captured_utf8_2byte_offset0(capsys):
+    msg = "\u07FF"
+    msg = "" + msg * (1024 // len(msg) + 1)
+
+    m.captured_output_default(msg)
+    stdout, stderr = capsys.readouterr()
+    assert stdout == msg
+    assert stderr == ""
+
+
+def test_captured_utf8_2byte_offset1(capsys):
+    msg = "\u07FF"
+    msg = "1" + msg * (1024 // len(msg) + 1)
+
+    m.captured_output_default(msg)
+    stdout, stderr = capsys.readouterr()
+    assert stdout == msg
+    assert stderr == ""
+
+
+def test_captured_utf8_3byte_offset0(capsys):
+    msg = "\uFFFF"
+    msg = "" + msg * (1024 // len(msg) + 1)
+
+    m.captured_output_default(msg)
+    stdout, stderr = capsys.readouterr()
+    assert stdout == msg
+    assert stderr == ""
+
+
+def test_captured_utf8_3byte_offset1(capsys):
+    msg = "\uFFFF"
+    msg = "1" + msg * (1024 // len(msg) + 1)
+
+    m.captured_output_default(msg)
+    stdout, stderr = capsys.readouterr()
+    assert stdout == msg
+    assert stderr == ""
+
+
+def test_captured_utf8_3byte_offset2(capsys):
+    msg = "\uFFFF"
+    msg = "12" + msg * (1024 // len(msg) + 1)
+
+    m.captured_output_default(msg)
+    stdout, stderr = capsys.readouterr()
+    assert stdout == msg
+    assert stderr == ""
+
+
+def test_captured_utf8_4byte_offset0(capsys):
+    msg = "\U0010FFFF"
+    msg = "" + msg * (1024 // len(msg) + 1)
+
+    m.captured_output_default(msg)
+    stdout, stderr = capsys.readouterr()
+    assert stdout == msg
+    assert stderr == ""
+
+
+def test_captured_utf8_4byte_offset1(capsys):
+    msg = "\U0010FFFF"
+    msg = "1" + msg * (1024 // len(msg) + 1)
+
+    m.captured_output_default(msg)
+    stdout, stderr = capsys.readouterr()
+    assert stdout == msg
+    assert stderr == ""
+
+
+def test_captured_utf8_4byte_offset2(capsys):
+    msg = "\U0010FFFF"
+    msg = "12" + msg * (1024 // len(msg) + 1)
+
+    m.captured_output_default(msg)
+    stdout, stderr = capsys.readouterr()
+    assert stdout == msg
+    assert stderr == ""
+
+
+def test_captured_utf8_4byte_offset3(capsys):
+    msg = "\U0010FFFF"
+    msg = "123" + msg * (1024 // len(msg) + 1)
+
+    m.captured_output_default(msg)
+    stdout, stderr = capsys.readouterr()
+    assert stdout == msg
+    assert stderr == ""
+
+
+def test_guard_capture(capsys):
+    msg = "I've been redirected to Python, I hope!"
+    m.guard_output(msg)
+    stdout, stderr = capsys.readouterr()
+    assert stdout == msg
+    assert stderr == ""
+
+
+def test_series_captured(capture):
+    with capture:
+        m.captured_output("a")
+        m.captured_output("b")
+    assert capture == "ab"
+
+
+def test_flush(capfd):
+    msg = "(not flushed)"
+    msg2 = "(flushed)"
+
+    with m.ostream_redirect():
+        m.noisy_function(msg, flush=False)
+        stdout, stderr = capfd.readouterr()
+        assert stdout == ""
+
+        m.noisy_function(msg2, flush=True)
+        stdout, stderr = capfd.readouterr()
+        assert stdout == msg + msg2
+
+        m.noisy_function(msg, flush=False)
+
+    stdout, stderr = capfd.readouterr()
+    assert stdout == msg
+
+
+def test_not_captured(capfd):
+    msg = "Something that should not show up in log"
+    stream = StringIO()
+    with redirect_stdout(stream):
+        m.raw_output(msg)
+    stdout, stderr = capfd.readouterr()
+    assert stdout == msg
+    assert stderr == ""
+    assert stream.getvalue() == ""
+
+    stream = StringIO()
+    with redirect_stdout(stream):
+        m.captured_output(msg)
+    stdout, stderr = capfd.readouterr()
+    assert stdout == ""
+    assert stderr == ""
+    assert stream.getvalue() == msg
+
+
+def test_err(capfd):
+    msg = "Something that should not show up in log"
+    stream = StringIO()
+    with redirect_stderr(stream):
+        m.raw_err(msg)
+    stdout, stderr = capfd.readouterr()
+    assert stdout == ""
+    assert stderr == msg
+    assert stream.getvalue() == ""
+
+    stream = StringIO()
+    with redirect_stderr(stream):
+        m.captured_err(msg)
+    stdout, stderr = capfd.readouterr()
+    assert stdout == ""
+    assert stderr == ""
+    assert stream.getvalue() == msg
+
+
+def test_multi_captured(capfd):
+    stream = StringIO()
+    with redirect_stdout(stream):
+        m.captured_output("a")
+        m.raw_output("b")
+        m.captured_output("c")
+        m.raw_output("d")
+    stdout, stderr = capfd.readouterr()
+    assert stdout == "bd"
+    assert stream.getvalue() == "ac"
+
+
+def test_dual(capsys):
+    m.captured_dual("a", "b")
+    stdout, stderr = capsys.readouterr()
+    assert stdout == "a"
+    assert stderr == "b"
+
+
+def test_redirect(capfd):
+    msg = "Should not be in log!"
+    stream = StringIO()
+    with redirect_stdout(stream):
+        m.raw_output(msg)
+    stdout, stderr = capfd.readouterr()
+    assert stdout == msg
+    assert stream.getvalue() == ""
+
+    stream = StringIO()
+    with redirect_stdout(stream):
+        with m.ostream_redirect():
+            m.raw_output(msg)
+    stdout, stderr = capfd.readouterr()
+    assert stdout == ""
+    assert stream.getvalue() == msg
+
+    stream = StringIO()
+    with redirect_stdout(stream):
+        m.raw_output(msg)
+    stdout, stderr = capfd.readouterr()
+    assert stdout == msg
+    assert stream.getvalue() == ""
+
+
+def test_redirect_err(capfd):
+    msg = "StdOut"
+    msg2 = "StdErr"
+
+    stream = StringIO()
+    with redirect_stderr(stream):
+        with m.ostream_redirect(stdout=False):
+            m.raw_output(msg)
+            m.raw_err(msg2)
+    stdout, stderr = capfd.readouterr()
+    assert stdout == msg
+    assert stderr == ""
+    assert stream.getvalue() == msg2
+
+
+def test_redirect_both(capfd):
+    msg = "StdOut"
+    msg2 = "StdErr"
+
+    stream = StringIO()
+    stream2 = StringIO()
+    with redirect_stdout(stream):
+        with redirect_stderr(stream2):
+            with m.ostream_redirect():
+                m.raw_output(msg)
+                m.raw_err(msg2)
+    stdout, stderr = capfd.readouterr()
+    assert stdout == ""
+    assert stderr == ""
+    assert stream.getvalue() == msg
+    assert stream2.getvalue() == msg2
+
+
+def test_threading():
+    with m.ostream_redirect(stdout=True, stderr=False):
+        # start some threads
+        threads = []
+
+        # start some threads
+        for _j in range(20):
+            threads.append(m.TestThread())
+
+        # give the threads some time to fail
+        threads[0].sleep()
+
+        # stop all the threads
+        for t in threads:
+            t.stop()
+
+        for t in threads:
+            t.join()
+
+        # if a thread segfaults, we don't get here
+        assert True
```

## extern/pybind11/tests/test_kwargs_and_defaults.py

 * *Ordering differences only*

```diff
@@ -1,390 +1,390 @@
-import pytest
-
-from pybind11_tests import kwargs_and_defaults as m
-
-
-def test_function_signatures(doc):
-    assert doc(m.kw_func0) == "kw_func0(arg0: int, arg1: int) -> str"
-    assert doc(m.kw_func1) == "kw_func1(x: int, y: int) -> str"
-    assert doc(m.kw_func2) == "kw_func2(x: int = 100, y: int = 200) -> str"
-    assert doc(m.kw_func3) == "kw_func3(data: str = 'Hello world!') -> None"
-    assert doc(m.kw_func4) == "kw_func4(myList: List[int] = [13, 17]) -> str"
-    assert doc(m.kw_func_udl) == "kw_func_udl(x: int, y: int = 300) -> str"
-    assert doc(m.kw_func_udl_z) == "kw_func_udl_z(x: int, y: int = 0) -> str"
-    assert doc(m.args_function) == "args_function(*args) -> tuple"
-    assert (
-        doc(m.args_kwargs_function) == "args_kwargs_function(*args, **kwargs) -> tuple"
-    )
-    assert (
-        doc(m.KWClass.foo0)
-        == "foo0(self: m.kwargs_and_defaults.KWClass, arg0: int, arg1: float) -> None"
-    )
-    assert (
-        doc(m.KWClass.foo1)
-        == "foo1(self: m.kwargs_and_defaults.KWClass, x: int, y: float) -> None"
-    )
-
-
-def test_named_arguments(msg):
-    assert m.kw_func0(5, 10) == "x=5, y=10"
-
-    assert m.kw_func1(5, 10) == "x=5, y=10"
-    assert m.kw_func1(5, y=10) == "x=5, y=10"
-    assert m.kw_func1(y=10, x=5) == "x=5, y=10"
-
-    assert m.kw_func2() == "x=100, y=200"
-    assert m.kw_func2(5) == "x=5, y=200"
-    assert m.kw_func2(x=5) == "x=5, y=200"
-    assert m.kw_func2(y=10) == "x=100, y=10"
-    assert m.kw_func2(5, 10) == "x=5, y=10"
-    assert m.kw_func2(x=5, y=10) == "x=5, y=10"
-
-    with pytest.raises(TypeError) as excinfo:
-        # noinspection PyArgumentList
-        m.kw_func2(x=5, y=10, z=12)
-    assert excinfo.match(
-        r"(?s)^kw_func2\(\): incompatible.*Invoked with: kwargs: ((x=5|y=10|z=12)(, |$))"
-        + "{3}$"
-    )
-
-    assert m.kw_func4() == "{13 17}"
-    assert m.kw_func4(myList=[1, 2, 3]) == "{1 2 3}"
-
-    assert m.kw_func_udl(x=5, y=10) == "x=5, y=10"
-    assert m.kw_func_udl_z(x=5) == "x=5, y=0"
-
-
-def test_arg_and_kwargs():
-    args = "arg1_value", "arg2_value", 3
-    assert m.args_function(*args) == args
-
-    args = "a1", "a2"
-    kwargs = dict(arg3="a3", arg4=4)
-    assert m.args_kwargs_function(*args, **kwargs) == (args, kwargs)
-
-
-def test_mixed_args_and_kwargs(msg):
-    mpa = m.mixed_plus_args
-    mpk = m.mixed_plus_kwargs
-    mpak = m.mixed_plus_args_kwargs
-    mpakd = m.mixed_plus_args_kwargs_defaults
-
-    assert mpa(1, 2.5, 4, 99.5, None) == (1, 2.5, (4, 99.5, None))
-    assert mpa(1, 2.5) == (1, 2.5, ())
-    with pytest.raises(TypeError) as excinfo:
-        assert mpa(1)
-    assert (
-        msg(excinfo.value)
-        == """
-        mixed_plus_args(): incompatible function arguments. The following argument types are supported:
-            1. (arg0: int, arg1: float, *args) -> tuple
-
-        Invoked with: 1
-    """
-    )
-    with pytest.raises(TypeError) as excinfo:
-        assert mpa()
-    assert (
-        msg(excinfo.value)
-        == """
-        mixed_plus_args(): incompatible function arguments. The following argument types are supported:
-            1. (arg0: int, arg1: float, *args) -> tuple
-
-        Invoked with:
-    """
-    )
-
-    assert mpk(-2, 3.5, pi=3.14159, e=2.71828) == (
-        -2,
-        3.5,
-        {"e": 2.71828, "pi": 3.14159},
-    )
-    assert mpak(7, 7.7, 7.77, 7.777, 7.7777, minusseven=-7) == (
-        7,
-        7.7,
-        (7.77, 7.777, 7.7777),
-        {"minusseven": -7},
-    )
-    assert mpakd() == (1, 3.14159, (), {})
-    assert mpakd(3) == (3, 3.14159, (), {})
-    assert mpakd(j=2.71828) == (1, 2.71828, (), {})
-    assert mpakd(k=42) == (1, 3.14159, (), {"k": 42})
-    assert mpakd(1, 1, 2, 3, 5, 8, then=13, followedby=21) == (
-        1,
-        1,
-        (2, 3, 5, 8),
-        {"then": 13, "followedby": 21},
-    )
-    # Arguments specified both positionally and via kwargs should fail:
-    with pytest.raises(TypeError) as excinfo:
-        assert mpakd(1, i=1)
-    assert (
-        msg(excinfo.value)
-        == """
-        mixed_plus_args_kwargs_defaults(): incompatible function arguments. The following argument types are supported:
-            1. (i: int = 1, j: float = 3.14159, *args, **kwargs) -> tuple
-
-        Invoked with: 1; kwargs: i=1
-    """
-    )
-    with pytest.raises(TypeError) as excinfo:
-        assert mpakd(1, 2, j=1)
-    assert (
-        msg(excinfo.value)
-        == """
-        mixed_plus_args_kwargs_defaults(): incompatible function arguments. The following argument types are supported:
-            1. (i: int = 1, j: float = 3.14159, *args, **kwargs) -> tuple
-
-        Invoked with: 1, 2; kwargs: j=1
-    """
-    )
-
-    # Arguments after a py::args are automatically keyword-only (pybind 2.9+)
-    assert m.args_kwonly(2, 2.5, z=22) == (2, 2.5, (), 22)
-    assert m.args_kwonly(2, 2.5, "a", "b", "c", z=22) == (2, 2.5, ("a", "b", "c"), 22)
-    assert m.args_kwonly(z=22, i=4, j=16) == (4, 16, (), 22)
-
-    with pytest.raises(TypeError) as excinfo:
-        assert m.args_kwonly(2, 2.5, 22)  # missing z= keyword
-    assert (
-        msg(excinfo.value)
-        == """
-        args_kwonly(): incompatible function arguments. The following argument types are supported:
-            1. (i: int, j: float, *args, z: int) -> tuple
-
-        Invoked with: 2, 2.5, 22
-    """
-    )
-
-    assert m.args_kwonly_kwargs(i=1, k=4, j=10, z=-1, y=9) == (
-        1,
-        10,
-        (),
-        -1,
-        {"k": 4, "y": 9},
-    )
-    assert m.args_kwonly_kwargs(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, z=11, y=12) == (
-        1,
-        2,
-        (3, 4, 5, 6, 7, 8, 9, 10),
-        11,
-        {"y": 12},
-    )
-    assert (
-        m.args_kwonly_kwargs.__doc__
-        == "args_kwonly_kwargs(i: int, j: float, *args, z: int, **kwargs) -> tuple\n"
-    )
-
-    assert (
-        m.args_kwonly_kwargs_defaults.__doc__
-        == "args_kwonly_kwargs_defaults(i: int = 1, j: float = 3.14159, *args, z: int = 42, **kwargs) -> tuple\n"  # noqa: E501 line too long
-    )
-    assert m.args_kwonly_kwargs_defaults() == (1, 3.14159, (), 42, {})
-    assert m.args_kwonly_kwargs_defaults(2) == (2, 3.14159, (), 42, {})
-    assert m.args_kwonly_kwargs_defaults(z=-99) == (1, 3.14159, (), -99, {})
-    assert m.args_kwonly_kwargs_defaults(5, 6, 7, 8) == (5, 6, (7, 8), 42, {})
-    assert m.args_kwonly_kwargs_defaults(5, 6, 7, m=8) == (5, 6, (7,), 42, {"m": 8})
-    assert m.args_kwonly_kwargs_defaults(5, 6, 7, m=8, z=9) == (5, 6, (7,), 9, {"m": 8})
-
-
-def test_keyword_only_args(msg):
-    assert m.kw_only_all(i=1, j=2) == (1, 2)
-    assert m.kw_only_all(j=1, i=2) == (2, 1)
-
-    with pytest.raises(TypeError) as excinfo:
-        assert m.kw_only_all(i=1) == (1,)
-    assert "incompatible function arguments" in str(excinfo.value)
-
-    with pytest.raises(TypeError) as excinfo:
-        assert m.kw_only_all(1, 2) == (1, 2)
-    assert "incompatible function arguments" in str(excinfo.value)
-
-    assert m.kw_only_some(1, k=3, j=2) == (1, 2, 3)
-
-    assert m.kw_only_with_defaults(z=8) == (3, 4, 5, 8)
-    assert m.kw_only_with_defaults(2, z=8) == (2, 4, 5, 8)
-    assert m.kw_only_with_defaults(2, j=7, k=8, z=9) == (2, 7, 8, 9)
-    assert m.kw_only_with_defaults(2, 7, z=9, k=8) == (2, 7, 8, 9)
-
-    assert m.kw_only_mixed(1, j=2) == (1, 2)
-    assert m.kw_only_mixed(j=2, i=3) == (3, 2)
-    assert m.kw_only_mixed(i=2, j=3) == (2, 3)
-
-    assert m.kw_only_plus_more(4, 5, k=6, extra=7) == (4, 5, 6, {"extra": 7})
-    assert m.kw_only_plus_more(3, k=5, j=4, extra=6) == (3, 4, 5, {"extra": 6})
-    assert m.kw_only_plus_more(2, k=3, extra=4) == (2, -1, 3, {"extra": 4})
-
-    with pytest.raises(TypeError) as excinfo:
-        assert m.kw_only_mixed(i=1) == (1,)
-    assert "incompatible function arguments" in str(excinfo.value)
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.register_invalid_kw_only(m)
-    assert (
-        msg(excinfo.value)
-        == """
-        arg(): cannot specify an unnamed argument after a kw_only() annotation or args() argument
-    """
-    )
-
-    # https://github.com/pybind/pybind11/pull/3402#issuecomment-963341987
-    x = m.first_arg_kw_only(i=1)
-    x.method()
-    x.method(i=1, j=2)
-    assert (
-        m.first_arg_kw_only.__init__.__doc__
-        == "__init__(self: pybind11_tests.kwargs_and_defaults.first_arg_kw_only, *, i: int = 0) -> None\n"  # noqa: E501 line too long
-    )
-    assert (
-        m.first_arg_kw_only.method.__doc__
-        == "method(self: pybind11_tests.kwargs_and_defaults.first_arg_kw_only, *, i: int = 1, j: int = 2) -> None\n"  # noqa: E501 line too long
-    )
-
-
-def test_positional_only_args(msg):
-    assert m.pos_only_all(1, 2) == (1, 2)
-    assert m.pos_only_all(2, 1) == (2, 1)
-
-    with pytest.raises(TypeError) as excinfo:
-        m.pos_only_all(i=1, j=2)
-    assert "incompatible function arguments" in str(excinfo.value)
-
-    assert m.pos_only_mix(1, 2) == (1, 2)
-    assert m.pos_only_mix(2, j=1) == (2, 1)
-
-    with pytest.raises(TypeError) as excinfo:
-        m.pos_only_mix(i=1, j=2)
-    assert "incompatible function arguments" in str(excinfo.value)
-
-    assert m.pos_kw_only_mix(1, 2, k=3) == (1, 2, 3)
-    assert m.pos_kw_only_mix(1, j=2, k=3) == (1, 2, 3)
-
-    with pytest.raises(TypeError) as excinfo:
-        m.pos_kw_only_mix(i=1, j=2, k=3)
-    assert "incompatible function arguments" in str(excinfo.value)
-
-    with pytest.raises(TypeError) as excinfo:
-        m.pos_kw_only_mix(1, 2, 3)
-    assert "incompatible function arguments" in str(excinfo.value)
-
-    with pytest.raises(TypeError) as excinfo:
-        m.pos_only_def_mix()
-    assert "incompatible function arguments" in str(excinfo.value)
-
-    assert m.pos_only_def_mix(1) == (1, 2, 3)
-    assert m.pos_only_def_mix(1, 4) == (1, 4, 3)
-    assert m.pos_only_def_mix(1, 4, 7) == (1, 4, 7)
-    assert m.pos_only_def_mix(1, 4, k=7) == (1, 4, 7)
-
-    with pytest.raises(TypeError) as excinfo:
-        m.pos_only_def_mix(1, j=4)
-    assert "incompatible function arguments" in str(excinfo.value)
-
-    # Mix it with args and kwargs:
-    assert (
-        m.args_kwonly_full_monty.__doc__
-        == "args_kwonly_full_monty(arg0: int = 1, arg1: int = 2, /, j: float = 3.14159, *args, z: int = 42, **kwargs) -> tuple\n"  # noqa: E501 line too long
-    )
-    assert m.args_kwonly_full_monty() == (1, 2, 3.14159, (), 42, {})
-    assert m.args_kwonly_full_monty(8) == (8, 2, 3.14159, (), 42, {})
-    assert m.args_kwonly_full_monty(8, 9) == (8, 9, 3.14159, (), 42, {})
-    assert m.args_kwonly_full_monty(8, 9, 10) == (8, 9, 10.0, (), 42, {})
-    assert m.args_kwonly_full_monty(3, 4, 5, 6, 7, m=8, z=9) == (
-        3,
-        4,
-        5.0,
-        (
-            6,
-            7,
-        ),
-        9,
-        {"m": 8},
-    )
-    assert m.args_kwonly_full_monty(3, 4, 5, 6, 7, m=8, z=9) == (
-        3,
-        4,
-        5.0,
-        (
-            6,
-            7,
-        ),
-        9,
-        {"m": 8},
-    )
-    assert m.args_kwonly_full_monty(5, j=7, m=8, z=9) == (5, 2, 7.0, (), 9, {"m": 8})
-    assert m.args_kwonly_full_monty(i=5, j=7, m=8, z=9) == (
-        1,
-        2,
-        7.0,
-        (),
-        9,
-        {"i": 5, "m": 8},
-    )
-
-    # pos_only at the beginning of the argument list was "broken" in how it was displayed (though
-    # this is fairly useless in practice).  Related to:
-    # https://github.com/pybind/pybind11/pull/3402#issuecomment-963341987
-    assert (
-        m.first_arg_kw_only.pos_only.__doc__
-        == "pos_only(self: pybind11_tests.kwargs_and_defaults.first_arg_kw_only, /, i: int, j: int) -> None\n"  # noqa: E501 line too long
-    )
-
-
-def test_signatures():
-    assert "kw_only_all(*, i: int, j: int) -> tuple\n" == m.kw_only_all.__doc__
-    assert "kw_only_mixed(i: int, *, j: int) -> tuple\n" == m.kw_only_mixed.__doc__
-    assert "pos_only_all(i: int, j: int, /) -> tuple\n" == m.pos_only_all.__doc__
-    assert "pos_only_mix(i: int, /, j: int) -> tuple\n" == m.pos_only_mix.__doc__
-    assert (
-        "pos_kw_only_mix(i: int, /, j: int, *, k: int) -> tuple\n"
-        == m.pos_kw_only_mix.__doc__
-    )
-
-
-def test_args_refcount():
-    """Issue/PR #1216 - py::args elements get double-inc_ref()ed when combined with regular
-    arguments"""
-    refcount = m.arg_refcount_h
-
-    myval = 54321
-    expected = refcount(myval)
-    assert m.arg_refcount_h(myval) == expected
-    assert m.arg_refcount_o(myval) == expected + 1
-    assert m.arg_refcount_h(myval) == expected
-    assert refcount(myval) == expected
-
-    assert m.mixed_plus_args(1, 2.0, "a", myval) == (1, 2.0, ("a", myval))
-    assert refcount(myval) == expected
-
-    assert m.mixed_plus_kwargs(3, 4.0, a=1, b=myval) == (3, 4.0, {"a": 1, "b": myval})
-    assert refcount(myval) == expected
-
-    assert m.args_function(-1, myval) == (-1, myval)
-    assert refcount(myval) == expected
-
-    assert m.mixed_plus_args_kwargs(5, 6.0, myval, a=myval) == (
-        5,
-        6.0,
-        (myval,),
-        {"a": myval},
-    )
-    assert refcount(myval) == expected
-
-    assert m.args_kwargs_function(7, 8, myval, a=1, b=myval) == (
-        (7, 8, myval),
-        {"a": 1, "b": myval},
-    )
-    assert refcount(myval) == expected
-
-    exp3 = refcount(myval, myval, myval)
-    assert m.args_refcount(myval, myval, myval) == (exp3, exp3, exp3)
-    assert refcount(myval) == expected
-
-    # This function takes the first arg as a `py::object` and the rest as a `py::args`.  Unlike the
-    # previous case, when we have both positional and `py::args` we need to construct a new tuple
-    # for the `py::args`; in the previous case, we could simply inc_ref and pass on Python's input
-    # tuple without having to inc_ref the individual elements, but here we can't, hence the extra
-    # refs.
-    assert m.mixed_args_refcount(myval, myval, myval) == (exp3 + 3, exp3 + 3, exp3 + 3)
-
-    assert m.class_default_argument() == "<class 'decimal.Decimal'>"
+import pytest
+
+from pybind11_tests import kwargs_and_defaults as m
+
+
+def test_function_signatures(doc):
+    assert doc(m.kw_func0) == "kw_func0(arg0: int, arg1: int) -> str"
+    assert doc(m.kw_func1) == "kw_func1(x: int, y: int) -> str"
+    assert doc(m.kw_func2) == "kw_func2(x: int = 100, y: int = 200) -> str"
+    assert doc(m.kw_func3) == "kw_func3(data: str = 'Hello world!') -> None"
+    assert doc(m.kw_func4) == "kw_func4(myList: List[int] = [13, 17]) -> str"
+    assert doc(m.kw_func_udl) == "kw_func_udl(x: int, y: int = 300) -> str"
+    assert doc(m.kw_func_udl_z) == "kw_func_udl_z(x: int, y: int = 0) -> str"
+    assert doc(m.args_function) == "args_function(*args) -> tuple"
+    assert (
+        doc(m.args_kwargs_function) == "args_kwargs_function(*args, **kwargs) -> tuple"
+    )
+    assert (
+        doc(m.KWClass.foo0)
+        == "foo0(self: m.kwargs_and_defaults.KWClass, arg0: int, arg1: float) -> None"
+    )
+    assert (
+        doc(m.KWClass.foo1)
+        == "foo1(self: m.kwargs_and_defaults.KWClass, x: int, y: float) -> None"
+    )
+
+
+def test_named_arguments(msg):
+    assert m.kw_func0(5, 10) == "x=5, y=10"
+
+    assert m.kw_func1(5, 10) == "x=5, y=10"
+    assert m.kw_func1(5, y=10) == "x=5, y=10"
+    assert m.kw_func1(y=10, x=5) == "x=5, y=10"
+
+    assert m.kw_func2() == "x=100, y=200"
+    assert m.kw_func2(5) == "x=5, y=200"
+    assert m.kw_func2(x=5) == "x=5, y=200"
+    assert m.kw_func2(y=10) == "x=100, y=10"
+    assert m.kw_func2(5, 10) == "x=5, y=10"
+    assert m.kw_func2(x=5, y=10) == "x=5, y=10"
+
+    with pytest.raises(TypeError) as excinfo:
+        # noinspection PyArgumentList
+        m.kw_func2(x=5, y=10, z=12)
+    assert excinfo.match(
+        r"(?s)^kw_func2\(\): incompatible.*Invoked with: kwargs: ((x=5|y=10|z=12)(, |$))"
+        + "{3}$"
+    )
+
+    assert m.kw_func4() == "{13 17}"
+    assert m.kw_func4(myList=[1, 2, 3]) == "{1 2 3}"
+
+    assert m.kw_func_udl(x=5, y=10) == "x=5, y=10"
+    assert m.kw_func_udl_z(x=5) == "x=5, y=0"
+
+
+def test_arg_and_kwargs():
+    args = "arg1_value", "arg2_value", 3
+    assert m.args_function(*args) == args
+
+    args = "a1", "a2"
+    kwargs = dict(arg3="a3", arg4=4)
+    assert m.args_kwargs_function(*args, **kwargs) == (args, kwargs)
+
+
+def test_mixed_args_and_kwargs(msg):
+    mpa = m.mixed_plus_args
+    mpk = m.mixed_plus_kwargs
+    mpak = m.mixed_plus_args_kwargs
+    mpakd = m.mixed_plus_args_kwargs_defaults
+
+    assert mpa(1, 2.5, 4, 99.5, None) == (1, 2.5, (4, 99.5, None))
+    assert mpa(1, 2.5) == (1, 2.5, ())
+    with pytest.raises(TypeError) as excinfo:
+        assert mpa(1)
+    assert (
+        msg(excinfo.value)
+        == """
+        mixed_plus_args(): incompatible function arguments. The following argument types are supported:
+            1. (arg0: int, arg1: float, *args) -> tuple
+
+        Invoked with: 1
+    """
+    )
+    with pytest.raises(TypeError) as excinfo:
+        assert mpa()
+    assert (
+        msg(excinfo.value)
+        == """
+        mixed_plus_args(): incompatible function arguments. The following argument types are supported:
+            1. (arg0: int, arg1: float, *args) -> tuple
+
+        Invoked with:
+    """
+    )
+
+    assert mpk(-2, 3.5, pi=3.14159, e=2.71828) == (
+        -2,
+        3.5,
+        {"e": 2.71828, "pi": 3.14159},
+    )
+    assert mpak(7, 7.7, 7.77, 7.777, 7.7777, minusseven=-7) == (
+        7,
+        7.7,
+        (7.77, 7.777, 7.7777),
+        {"minusseven": -7},
+    )
+    assert mpakd() == (1, 3.14159, (), {})
+    assert mpakd(3) == (3, 3.14159, (), {})
+    assert mpakd(j=2.71828) == (1, 2.71828, (), {})
+    assert mpakd(k=42) == (1, 3.14159, (), {"k": 42})
+    assert mpakd(1, 1, 2, 3, 5, 8, then=13, followedby=21) == (
+        1,
+        1,
+        (2, 3, 5, 8),
+        {"then": 13, "followedby": 21},
+    )
+    # Arguments specified both positionally and via kwargs should fail:
+    with pytest.raises(TypeError) as excinfo:
+        assert mpakd(1, i=1)
+    assert (
+        msg(excinfo.value)
+        == """
+        mixed_plus_args_kwargs_defaults(): incompatible function arguments. The following argument types are supported:
+            1. (i: int = 1, j: float = 3.14159, *args, **kwargs) -> tuple
+
+        Invoked with: 1; kwargs: i=1
+    """
+    )
+    with pytest.raises(TypeError) as excinfo:
+        assert mpakd(1, 2, j=1)
+    assert (
+        msg(excinfo.value)
+        == """
+        mixed_plus_args_kwargs_defaults(): incompatible function arguments. The following argument types are supported:
+            1. (i: int = 1, j: float = 3.14159, *args, **kwargs) -> tuple
+
+        Invoked with: 1, 2; kwargs: j=1
+    """
+    )
+
+    # Arguments after a py::args are automatically keyword-only (pybind 2.9+)
+    assert m.args_kwonly(2, 2.5, z=22) == (2, 2.5, (), 22)
+    assert m.args_kwonly(2, 2.5, "a", "b", "c", z=22) == (2, 2.5, ("a", "b", "c"), 22)
+    assert m.args_kwonly(z=22, i=4, j=16) == (4, 16, (), 22)
+
+    with pytest.raises(TypeError) as excinfo:
+        assert m.args_kwonly(2, 2.5, 22)  # missing z= keyword
+    assert (
+        msg(excinfo.value)
+        == """
+        args_kwonly(): incompatible function arguments. The following argument types are supported:
+            1. (i: int, j: float, *args, z: int) -> tuple
+
+        Invoked with: 2, 2.5, 22
+    """
+    )
+
+    assert m.args_kwonly_kwargs(i=1, k=4, j=10, z=-1, y=9) == (
+        1,
+        10,
+        (),
+        -1,
+        {"k": 4, "y": 9},
+    )
+    assert m.args_kwonly_kwargs(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, z=11, y=12) == (
+        1,
+        2,
+        (3, 4, 5, 6, 7, 8, 9, 10),
+        11,
+        {"y": 12},
+    )
+    assert (
+        m.args_kwonly_kwargs.__doc__
+        == "args_kwonly_kwargs(i: int, j: float, *args, z: int, **kwargs) -> tuple\n"
+    )
+
+    assert (
+        m.args_kwonly_kwargs_defaults.__doc__
+        == "args_kwonly_kwargs_defaults(i: int = 1, j: float = 3.14159, *args, z: int = 42, **kwargs) -> tuple\n"  # noqa: E501 line too long
+    )
+    assert m.args_kwonly_kwargs_defaults() == (1, 3.14159, (), 42, {})
+    assert m.args_kwonly_kwargs_defaults(2) == (2, 3.14159, (), 42, {})
+    assert m.args_kwonly_kwargs_defaults(z=-99) == (1, 3.14159, (), -99, {})
+    assert m.args_kwonly_kwargs_defaults(5, 6, 7, 8) == (5, 6, (7, 8), 42, {})
+    assert m.args_kwonly_kwargs_defaults(5, 6, 7, m=8) == (5, 6, (7,), 42, {"m": 8})
+    assert m.args_kwonly_kwargs_defaults(5, 6, 7, m=8, z=9) == (5, 6, (7,), 9, {"m": 8})
+
+
+def test_keyword_only_args(msg):
+    assert m.kw_only_all(i=1, j=2) == (1, 2)
+    assert m.kw_only_all(j=1, i=2) == (2, 1)
+
+    with pytest.raises(TypeError) as excinfo:
+        assert m.kw_only_all(i=1) == (1,)
+    assert "incompatible function arguments" in str(excinfo.value)
+
+    with pytest.raises(TypeError) as excinfo:
+        assert m.kw_only_all(1, 2) == (1, 2)
+    assert "incompatible function arguments" in str(excinfo.value)
+
+    assert m.kw_only_some(1, k=3, j=2) == (1, 2, 3)
+
+    assert m.kw_only_with_defaults(z=8) == (3, 4, 5, 8)
+    assert m.kw_only_with_defaults(2, z=8) == (2, 4, 5, 8)
+    assert m.kw_only_with_defaults(2, j=7, k=8, z=9) == (2, 7, 8, 9)
+    assert m.kw_only_with_defaults(2, 7, z=9, k=8) == (2, 7, 8, 9)
+
+    assert m.kw_only_mixed(1, j=2) == (1, 2)
+    assert m.kw_only_mixed(j=2, i=3) == (3, 2)
+    assert m.kw_only_mixed(i=2, j=3) == (2, 3)
+
+    assert m.kw_only_plus_more(4, 5, k=6, extra=7) == (4, 5, 6, {"extra": 7})
+    assert m.kw_only_plus_more(3, k=5, j=4, extra=6) == (3, 4, 5, {"extra": 6})
+    assert m.kw_only_plus_more(2, k=3, extra=4) == (2, -1, 3, {"extra": 4})
+
+    with pytest.raises(TypeError) as excinfo:
+        assert m.kw_only_mixed(i=1) == (1,)
+    assert "incompatible function arguments" in str(excinfo.value)
+
+    with pytest.raises(RuntimeError) as excinfo:
+        m.register_invalid_kw_only(m)
+    assert (
+        msg(excinfo.value)
+        == """
+        arg(): cannot specify an unnamed argument after a kw_only() annotation or args() argument
+    """
+    )
+
+    # https://github.com/pybind/pybind11/pull/3402#issuecomment-963341987
+    x = m.first_arg_kw_only(i=1)
+    x.method()
+    x.method(i=1, j=2)
+    assert (
+        m.first_arg_kw_only.__init__.__doc__
+        == "__init__(self: pybind11_tests.kwargs_and_defaults.first_arg_kw_only, *, i: int = 0) -> None\n"  # noqa: E501 line too long
+    )
+    assert (
+        m.first_arg_kw_only.method.__doc__
+        == "method(self: pybind11_tests.kwargs_and_defaults.first_arg_kw_only, *, i: int = 1, j: int = 2) -> None\n"  # noqa: E501 line too long
+    )
+
+
+def test_positional_only_args(msg):
+    assert m.pos_only_all(1, 2) == (1, 2)
+    assert m.pos_only_all(2, 1) == (2, 1)
+
+    with pytest.raises(TypeError) as excinfo:
+        m.pos_only_all(i=1, j=2)
+    assert "incompatible function arguments" in str(excinfo.value)
+
+    assert m.pos_only_mix(1, 2) == (1, 2)
+    assert m.pos_only_mix(2, j=1) == (2, 1)
+
+    with pytest.raises(TypeError) as excinfo:
+        m.pos_only_mix(i=1, j=2)
+    assert "incompatible function arguments" in str(excinfo.value)
+
+    assert m.pos_kw_only_mix(1, 2, k=3) == (1, 2, 3)
+    assert m.pos_kw_only_mix(1, j=2, k=3) == (1, 2, 3)
+
+    with pytest.raises(TypeError) as excinfo:
+        m.pos_kw_only_mix(i=1, j=2, k=3)
+    assert "incompatible function arguments" in str(excinfo.value)
+
+    with pytest.raises(TypeError) as excinfo:
+        m.pos_kw_only_mix(1, 2, 3)
+    assert "incompatible function arguments" in str(excinfo.value)
+
+    with pytest.raises(TypeError) as excinfo:
+        m.pos_only_def_mix()
+    assert "incompatible function arguments" in str(excinfo.value)
+
+    assert m.pos_only_def_mix(1) == (1, 2, 3)
+    assert m.pos_only_def_mix(1, 4) == (1, 4, 3)
+    assert m.pos_only_def_mix(1, 4, 7) == (1, 4, 7)
+    assert m.pos_only_def_mix(1, 4, k=7) == (1, 4, 7)
+
+    with pytest.raises(TypeError) as excinfo:
+        m.pos_only_def_mix(1, j=4)
+    assert "incompatible function arguments" in str(excinfo.value)
+
+    # Mix it with args and kwargs:
+    assert (
+        m.args_kwonly_full_monty.__doc__
+        == "args_kwonly_full_monty(arg0: int = 1, arg1: int = 2, /, j: float = 3.14159, *args, z: int = 42, **kwargs) -> tuple\n"  # noqa: E501 line too long
+    )
+    assert m.args_kwonly_full_monty() == (1, 2, 3.14159, (), 42, {})
+    assert m.args_kwonly_full_monty(8) == (8, 2, 3.14159, (), 42, {})
+    assert m.args_kwonly_full_monty(8, 9) == (8, 9, 3.14159, (), 42, {})
+    assert m.args_kwonly_full_monty(8, 9, 10) == (8, 9, 10.0, (), 42, {})
+    assert m.args_kwonly_full_monty(3, 4, 5, 6, 7, m=8, z=9) == (
+        3,
+        4,
+        5.0,
+        (
+            6,
+            7,
+        ),
+        9,
+        {"m": 8},
+    )
+    assert m.args_kwonly_full_monty(3, 4, 5, 6, 7, m=8, z=9) == (
+        3,
+        4,
+        5.0,
+        (
+            6,
+            7,
+        ),
+        9,
+        {"m": 8},
+    )
+    assert m.args_kwonly_full_monty(5, j=7, m=8, z=9) == (5, 2, 7.0, (), 9, {"m": 8})
+    assert m.args_kwonly_full_monty(i=5, j=7, m=8, z=9) == (
+        1,
+        2,
+        7.0,
+        (),
+        9,
+        {"i": 5, "m": 8},
+    )
+
+    # pos_only at the beginning of the argument list was "broken" in how it was displayed (though
+    # this is fairly useless in practice).  Related to:
+    # https://github.com/pybind/pybind11/pull/3402#issuecomment-963341987
+    assert (
+        m.first_arg_kw_only.pos_only.__doc__
+        == "pos_only(self: pybind11_tests.kwargs_and_defaults.first_arg_kw_only, /, i: int, j: int) -> None\n"  # noqa: E501 line too long
+    )
+
+
+def test_signatures():
+    assert "kw_only_all(*, i: int, j: int) -> tuple\n" == m.kw_only_all.__doc__
+    assert "kw_only_mixed(i: int, *, j: int) -> tuple\n" == m.kw_only_mixed.__doc__
+    assert "pos_only_all(i: int, j: int, /) -> tuple\n" == m.pos_only_all.__doc__
+    assert "pos_only_mix(i: int, /, j: int) -> tuple\n" == m.pos_only_mix.__doc__
+    assert (
+        "pos_kw_only_mix(i: int, /, j: int, *, k: int) -> tuple\n"
+        == m.pos_kw_only_mix.__doc__
+    )
+
+
+def test_args_refcount():
+    """Issue/PR #1216 - py::args elements get double-inc_ref()ed when combined with regular
+    arguments"""
+    refcount = m.arg_refcount_h
+
+    myval = 54321
+    expected = refcount(myval)
+    assert m.arg_refcount_h(myval) == expected
+    assert m.arg_refcount_o(myval) == expected + 1
+    assert m.arg_refcount_h(myval) == expected
+    assert refcount(myval) == expected
+
+    assert m.mixed_plus_args(1, 2.0, "a", myval) == (1, 2.0, ("a", myval))
+    assert refcount(myval) == expected
+
+    assert m.mixed_plus_kwargs(3, 4.0, a=1, b=myval) == (3, 4.0, {"a": 1, "b": myval})
+    assert refcount(myval) == expected
+
+    assert m.args_function(-1, myval) == (-1, myval)
+    assert refcount(myval) == expected
+
+    assert m.mixed_plus_args_kwargs(5, 6.0, myval, a=myval) == (
+        5,
+        6.0,
+        (myval,),
+        {"a": myval},
+    )
+    assert refcount(myval) == expected
+
+    assert m.args_kwargs_function(7, 8, myval, a=1, b=myval) == (
+        (7, 8, myval),
+        {"a": 1, "b": myval},
+    )
+    assert refcount(myval) == expected
+
+    exp3 = refcount(myval, myval, myval)
+    assert m.args_refcount(myval, myval, myval) == (exp3, exp3, exp3)
+    assert refcount(myval) == expected
+
+    # This function takes the first arg as a `py::object` and the rest as a `py::args`.  Unlike the
+    # previous case, when we have both positional and `py::args` we need to construct a new tuple
+    # for the `py::args`; in the previous case, we could simply inc_ref and pass on Python's input
+    # tuple without having to inc_ref the individual elements, but here we can't, hence the extra
+    # refs.
+    assert m.mixed_args_refcount(myval, myval, myval) == (exp3 + 3, exp3 + 3, exp3 + 3)
+
+    assert m.class_default_argument() == "<class 'decimal.Decimal'>"
```

## extern/pybind11/tests/test_local_bindings.py

 * *Ordering differences only*

```diff
@@ -1,257 +1,257 @@
-import pytest
-
-import env  # noqa: F401
-from pybind11_tests import local_bindings as m
-
-
-def test_load_external():
-    """Load a `py::module_local` type that's only registered in an external module"""
-    import pybind11_cross_module_tests as cm
-
-    assert m.load_external1(cm.ExternalType1(11)) == 11
-    assert m.load_external2(cm.ExternalType2(22)) == 22
-
-    with pytest.raises(TypeError) as excinfo:
-        assert m.load_external2(cm.ExternalType1(21)) == 21
-    assert "incompatible function arguments" in str(excinfo.value)
-
-    with pytest.raises(TypeError) as excinfo:
-        assert m.load_external1(cm.ExternalType2(12)) == 12
-    assert "incompatible function arguments" in str(excinfo.value)
-
-
-def test_local_bindings():
-    """Tests that duplicate `py::module_local` class bindings work across modules"""
-
-    # Make sure we can load the second module with the conflicting (but local) definition:
-    import pybind11_cross_module_tests as cm
-
-    i1 = m.LocalType(5)
-    assert i1.get() == 4
-    assert i1.get3() == 8
-
-    i2 = cm.LocalType(10)
-    assert i2.get() == 11
-    assert i2.get2() == 12
-
-    assert not hasattr(i1, "get2")
-    assert not hasattr(i2, "get3")
-
-    # Loading within the local module
-    assert m.local_value(i1) == 5
-    assert cm.local_value(i2) == 10
-
-    # Cross-module loading works as well (on failure, the type loader looks for
-    # external module-local converters):
-    assert m.local_value(i2) == 10
-    assert cm.local_value(i1) == 5
-
-
-def test_nonlocal_failure():
-    """Tests that attempting to register a non-local type in multiple modules fails"""
-    import pybind11_cross_module_tests as cm
-
-    with pytest.raises(RuntimeError) as excinfo:
-        cm.register_nonlocal()
-    assert (
-        str(excinfo.value) == 'generic_type: type "NonLocalType" is already registered!'
-    )
-
-
-def test_duplicate_local():
-    """Tests expected failure when registering a class twice with py::local in the same module"""
-    with pytest.raises(RuntimeError) as excinfo:
-        m.register_local_external()
-    import pybind11_tests
-
-    assert str(excinfo.value) == (
-        'generic_type: type "LocalExternal" is already registered!'
-        if hasattr(pybind11_tests, "class_")
-        else "test_class not enabled"
-    )
-
-
-def test_stl_bind_local():
-    import pybind11_cross_module_tests as cm
-
-    v1, v2 = m.LocalVec(), cm.LocalVec()
-    v1.append(m.LocalType(1))
-    v1.append(m.LocalType(2))
-    v2.append(cm.LocalType(1))
-    v2.append(cm.LocalType(2))
-
-    # Cross module value loading:
-    v1.append(cm.LocalType(3))
-    v2.append(m.LocalType(3))
-
-    assert [i.get() for i in v1] == [0, 1, 2]
-    assert [i.get() for i in v2] == [2, 3, 4]
-
-    v3, v4 = m.NonLocalVec(), cm.NonLocalVec2()
-    v3.append(m.NonLocalType(1))
-    v3.append(m.NonLocalType(2))
-    v4.append(m.NonLocal2(3))
-    v4.append(m.NonLocal2(4))
-
-    assert [i.get() for i in v3] == [1, 2]
-    assert [i.get() for i in v4] == [13, 14]
-
-    d1, d2 = m.LocalMap(), cm.LocalMap()
-    d1["a"] = v1[0]
-    d1["b"] = v1[1]
-    d2["c"] = v2[0]
-    d2["d"] = v2[1]
-    assert {i: d1[i].get() for i in d1} == {"a": 0, "b": 1}
-    assert {i: d2[i].get() for i in d2} == {"c": 2, "d": 3}
-
-
-def test_stl_bind_global():
-    import pybind11_cross_module_tests as cm
-
-    with pytest.raises(RuntimeError) as excinfo:
-        cm.register_nonlocal_map()
-    assert (
-        str(excinfo.value) == 'generic_type: type "NonLocalMap" is already registered!'
-    )
-
-    with pytest.raises(RuntimeError) as excinfo:
-        cm.register_nonlocal_vec()
-    assert (
-        str(excinfo.value) == 'generic_type: type "NonLocalVec" is already registered!'
-    )
-
-    with pytest.raises(RuntimeError) as excinfo:
-        cm.register_nonlocal_map2()
-    assert (
-        str(excinfo.value) == 'generic_type: type "NonLocalMap2" is already registered!'
-    )
-
-
-def test_mixed_local_global():
-    """Local types take precedence over globally registered types: a module with a `module_local`
-    type can be registered even if the type is already registered globally.  With the module,
-    casting will go to the local type; outside the module casting goes to the global type.
-    """
-    import pybind11_cross_module_tests as cm
-
-    m.register_mixed_global()
-    m.register_mixed_local()
-
-    a = []
-    a.append(m.MixedGlobalLocal(1))
-    a.append(m.MixedLocalGlobal(2))
-    a.append(m.get_mixed_gl(3))
-    a.append(m.get_mixed_lg(4))
-
-    assert [x.get() for x in a] == [101, 1002, 103, 1004]
-
-    cm.register_mixed_global_local()
-    cm.register_mixed_local_global()
-    a.append(m.MixedGlobalLocal(5))
-    a.append(m.MixedLocalGlobal(6))
-    a.append(cm.MixedGlobalLocal(7))
-    a.append(cm.MixedLocalGlobal(8))
-    a.append(m.get_mixed_gl(9))
-    a.append(m.get_mixed_lg(10))
-    a.append(cm.get_mixed_gl(11))
-    a.append(cm.get_mixed_lg(12))
-
-    assert [x.get() for x in a] == [
-        101,
-        1002,
-        103,
-        1004,
-        105,
-        1006,
-        207,
-        2008,
-        109,
-        1010,
-        211,
-        2012,
-    ]
-
-
-def test_internal_locals_differ():
-    """Makes sure the internal local type map differs across the two modules"""
-    import pybind11_cross_module_tests as cm
-
-    assert m.local_cpp_types_addr() != cm.local_cpp_types_addr()
-
-
-@pytest.mark.xfail("env.PYPY and sys.pypy_version_info < (7, 3, 2)")
-def test_stl_caster_vs_stl_bind(msg):
-    """One module uses a generic vector caster from `<pybind11/stl.h>` while the other
-    exports `std::vector<int>` via `py:bind_vector` and `py::module_local`"""
-    import pybind11_cross_module_tests as cm
-
-    v1 = cm.VectorInt([1, 2, 3])
-    assert m.load_vector_via_caster(v1) == 6
-    assert cm.load_vector_via_binding(v1) == 6
-
-    v2 = [1, 2, 3]
-    assert m.load_vector_via_caster(v2) == 6
-    with pytest.raises(TypeError) as excinfo:
-        cm.load_vector_via_binding(v2)
-    assert (
-        msg(excinfo.value)
-        == """
-    load_vector_via_binding(): incompatible function arguments. The following argument types are supported:
-        1. (arg0: pybind11_cross_module_tests.VectorInt) -> int
-
-    Invoked with: [1, 2, 3]
-    """
-    )
-
-
-def test_cross_module_calls():
-    import pybind11_cross_module_tests as cm
-
-    v1 = m.LocalVec()
-    v1.append(m.LocalType(1))
-    v2 = cm.LocalVec()
-    v2.append(cm.LocalType(2))
-
-    # Returning the self pointer should get picked up as returning an existing
-    # instance (even when that instance is of a foreign, non-local type).
-    assert m.return_self(v1) is v1
-    assert cm.return_self(v2) is v2
-    assert m.return_self(v2) is v2
-    assert cm.return_self(v1) is v1
-
-    assert m.LocalVec is not cm.LocalVec
-    # Returning a copy, on the other hand, always goes to the local type,
-    # regardless of where the source type came from.
-    assert type(m.return_copy(v1)) is m.LocalVec
-    assert type(m.return_copy(v2)) is m.LocalVec
-    assert type(cm.return_copy(v1)) is cm.LocalVec
-    assert type(cm.return_copy(v2)) is cm.LocalVec
-
-    # Test the example given in the documentation (which also tests inheritance casting):
-    mycat = m.Cat("Fluffy")
-    mydog = cm.Dog("Rover")
-    assert mycat.get_name() == "Fluffy"
-    assert mydog.name() == "Rover"
-    assert m.Cat.__base__.__name__ == "Pet"
-    assert cm.Dog.__base__.__name__ == "Pet"
-    assert m.Cat.__base__ is not cm.Dog.__base__
-    assert m.pet_name(mycat) == "Fluffy"
-    assert m.pet_name(mydog) == "Rover"
-    assert cm.pet_name(mycat) == "Fluffy"
-    assert cm.pet_name(mydog) == "Rover"
-
-    assert m.MixGL is not cm.MixGL
-    a = m.MixGL(1)
-    b = cm.MixGL(2)
-    assert m.get_gl_value(a) == 11
-    assert m.get_gl_value(b) == 12
-    assert cm.get_gl_value(a) == 101
-    assert cm.get_gl_value(b) == 102
-
-    c, d = m.MixGL2(3), cm.MixGL2(4)
-    with pytest.raises(TypeError) as excinfo:
-        m.get_gl_value(c)
-    assert "incompatible function arguments" in str(excinfo.value)
-    with pytest.raises(TypeError) as excinfo:
-        m.get_gl_value(d)
-    assert "incompatible function arguments" in str(excinfo.value)
+import pytest
+
+import env  # noqa: F401
+from pybind11_tests import local_bindings as m
+
+
+def test_load_external():
+    """Load a `py::module_local` type that's only registered in an external module"""
+    import pybind11_cross_module_tests as cm
+
+    assert m.load_external1(cm.ExternalType1(11)) == 11
+    assert m.load_external2(cm.ExternalType2(22)) == 22
+
+    with pytest.raises(TypeError) as excinfo:
+        assert m.load_external2(cm.ExternalType1(21)) == 21
+    assert "incompatible function arguments" in str(excinfo.value)
+
+    with pytest.raises(TypeError) as excinfo:
+        assert m.load_external1(cm.ExternalType2(12)) == 12
+    assert "incompatible function arguments" in str(excinfo.value)
+
+
+def test_local_bindings():
+    """Tests that duplicate `py::module_local` class bindings work across modules"""
+
+    # Make sure we can load the second module with the conflicting (but local) definition:
+    import pybind11_cross_module_tests as cm
+
+    i1 = m.LocalType(5)
+    assert i1.get() == 4
+    assert i1.get3() == 8
+
+    i2 = cm.LocalType(10)
+    assert i2.get() == 11
+    assert i2.get2() == 12
+
+    assert not hasattr(i1, "get2")
+    assert not hasattr(i2, "get3")
+
+    # Loading within the local module
+    assert m.local_value(i1) == 5
+    assert cm.local_value(i2) == 10
+
+    # Cross-module loading works as well (on failure, the type loader looks for
+    # external module-local converters):
+    assert m.local_value(i2) == 10
+    assert cm.local_value(i1) == 5
+
+
+def test_nonlocal_failure():
+    """Tests that attempting to register a non-local type in multiple modules fails"""
+    import pybind11_cross_module_tests as cm
+
+    with pytest.raises(RuntimeError) as excinfo:
+        cm.register_nonlocal()
+    assert (
+        str(excinfo.value) == 'generic_type: type "NonLocalType" is already registered!'
+    )
+
+
+def test_duplicate_local():
+    """Tests expected failure when registering a class twice with py::local in the same module"""
+    with pytest.raises(RuntimeError) as excinfo:
+        m.register_local_external()
+    import pybind11_tests
+
+    assert str(excinfo.value) == (
+        'generic_type: type "LocalExternal" is already registered!'
+        if hasattr(pybind11_tests, "class_")
+        else "test_class not enabled"
+    )
+
+
+def test_stl_bind_local():
+    import pybind11_cross_module_tests as cm
+
+    v1, v2 = m.LocalVec(), cm.LocalVec()
+    v1.append(m.LocalType(1))
+    v1.append(m.LocalType(2))
+    v2.append(cm.LocalType(1))
+    v2.append(cm.LocalType(2))
+
+    # Cross module value loading:
+    v1.append(cm.LocalType(3))
+    v2.append(m.LocalType(3))
+
+    assert [i.get() for i in v1] == [0, 1, 2]
+    assert [i.get() for i in v2] == [2, 3, 4]
+
+    v3, v4 = m.NonLocalVec(), cm.NonLocalVec2()
+    v3.append(m.NonLocalType(1))
+    v3.append(m.NonLocalType(2))
+    v4.append(m.NonLocal2(3))
+    v4.append(m.NonLocal2(4))
+
+    assert [i.get() for i in v3] == [1, 2]
+    assert [i.get() for i in v4] == [13, 14]
+
+    d1, d2 = m.LocalMap(), cm.LocalMap()
+    d1["a"] = v1[0]
+    d1["b"] = v1[1]
+    d2["c"] = v2[0]
+    d2["d"] = v2[1]
+    assert {i: d1[i].get() for i in d1} == {"a": 0, "b": 1}
+    assert {i: d2[i].get() for i in d2} == {"c": 2, "d": 3}
+
+
+def test_stl_bind_global():
+    import pybind11_cross_module_tests as cm
+
+    with pytest.raises(RuntimeError) as excinfo:
+        cm.register_nonlocal_map()
+    assert (
+        str(excinfo.value) == 'generic_type: type "NonLocalMap" is already registered!'
+    )
+
+    with pytest.raises(RuntimeError) as excinfo:
+        cm.register_nonlocal_vec()
+    assert (
+        str(excinfo.value) == 'generic_type: type "NonLocalVec" is already registered!'
+    )
+
+    with pytest.raises(RuntimeError) as excinfo:
+        cm.register_nonlocal_map2()
+    assert (
+        str(excinfo.value) == 'generic_type: type "NonLocalMap2" is already registered!'
+    )
+
+
+def test_mixed_local_global():
+    """Local types take precedence over globally registered types: a module with a `module_local`
+    type can be registered even if the type is already registered globally.  With the module,
+    casting will go to the local type; outside the module casting goes to the global type.
+    """
+    import pybind11_cross_module_tests as cm
+
+    m.register_mixed_global()
+    m.register_mixed_local()
+
+    a = []
+    a.append(m.MixedGlobalLocal(1))
+    a.append(m.MixedLocalGlobal(2))
+    a.append(m.get_mixed_gl(3))
+    a.append(m.get_mixed_lg(4))
+
+    assert [x.get() for x in a] == [101, 1002, 103, 1004]
+
+    cm.register_mixed_global_local()
+    cm.register_mixed_local_global()
+    a.append(m.MixedGlobalLocal(5))
+    a.append(m.MixedLocalGlobal(6))
+    a.append(cm.MixedGlobalLocal(7))
+    a.append(cm.MixedLocalGlobal(8))
+    a.append(m.get_mixed_gl(9))
+    a.append(m.get_mixed_lg(10))
+    a.append(cm.get_mixed_gl(11))
+    a.append(cm.get_mixed_lg(12))
+
+    assert [x.get() for x in a] == [
+        101,
+        1002,
+        103,
+        1004,
+        105,
+        1006,
+        207,
+        2008,
+        109,
+        1010,
+        211,
+        2012,
+    ]
+
+
+def test_internal_locals_differ():
+    """Makes sure the internal local type map differs across the two modules"""
+    import pybind11_cross_module_tests as cm
+
+    assert m.local_cpp_types_addr() != cm.local_cpp_types_addr()
+
+
+@pytest.mark.xfail("env.PYPY and sys.pypy_version_info < (7, 3, 2)")
+def test_stl_caster_vs_stl_bind(msg):
+    """One module uses a generic vector caster from `<pybind11/stl.h>` while the other
+    exports `std::vector<int>` via `py:bind_vector` and `py::module_local`"""
+    import pybind11_cross_module_tests as cm
+
+    v1 = cm.VectorInt([1, 2, 3])
+    assert m.load_vector_via_caster(v1) == 6
+    assert cm.load_vector_via_binding(v1) == 6
+
+    v2 = [1, 2, 3]
+    assert m.load_vector_via_caster(v2) == 6
+    with pytest.raises(TypeError) as excinfo:
+        cm.load_vector_via_binding(v2)
+    assert (
+        msg(excinfo.value)
+        == """
+    load_vector_via_binding(): incompatible function arguments. The following argument types are supported:
+        1. (arg0: pybind11_cross_module_tests.VectorInt) -> int
+
+    Invoked with: [1, 2, 3]
+    """
+    )
+
+
+def test_cross_module_calls():
+    import pybind11_cross_module_tests as cm
+
+    v1 = m.LocalVec()
+    v1.append(m.LocalType(1))
+    v2 = cm.LocalVec()
+    v2.append(cm.LocalType(2))
+
+    # Returning the self pointer should get picked up as returning an existing
+    # instance (even when that instance is of a foreign, non-local type).
+    assert m.return_self(v1) is v1
+    assert cm.return_self(v2) is v2
+    assert m.return_self(v2) is v2
+    assert cm.return_self(v1) is v1
+
+    assert m.LocalVec is not cm.LocalVec
+    # Returning a copy, on the other hand, always goes to the local type,
+    # regardless of where the source type came from.
+    assert type(m.return_copy(v1)) is m.LocalVec
+    assert type(m.return_copy(v2)) is m.LocalVec
+    assert type(cm.return_copy(v1)) is cm.LocalVec
+    assert type(cm.return_copy(v2)) is cm.LocalVec
+
+    # Test the example given in the documentation (which also tests inheritance casting):
+    mycat = m.Cat("Fluffy")
+    mydog = cm.Dog("Rover")
+    assert mycat.get_name() == "Fluffy"
+    assert mydog.name() == "Rover"
+    assert m.Cat.__base__.__name__ == "Pet"
+    assert cm.Dog.__base__.__name__ == "Pet"
+    assert m.Cat.__base__ is not cm.Dog.__base__
+    assert m.pet_name(mycat) == "Fluffy"
+    assert m.pet_name(mydog) == "Rover"
+    assert cm.pet_name(mycat) == "Fluffy"
+    assert cm.pet_name(mydog) == "Rover"
+
+    assert m.MixGL is not cm.MixGL
+    a = m.MixGL(1)
+    b = cm.MixGL(2)
+    assert m.get_gl_value(a) == 11
+    assert m.get_gl_value(b) == 12
+    assert cm.get_gl_value(a) == 101
+    assert cm.get_gl_value(b) == 102
+
+    c, d = m.MixGL2(3), cm.MixGL2(4)
+    with pytest.raises(TypeError) as excinfo:
+        m.get_gl_value(c)
+    assert "incompatible function arguments" in str(excinfo.value)
+    with pytest.raises(TypeError) as excinfo:
+        m.get_gl_value(d)
+    assert "incompatible function arguments" in str(excinfo.value)
```

## extern/pybind11/tests/test_methods_and_attributes.py

 * *Ordering differences only*

```diff
@@ -1,527 +1,527 @@
-import sys
-
-import pytest
-
-import env  # noqa: F401
-from pybind11_tests import ConstructorStats
-from pybind11_tests import methods_and_attributes as m
-
-NO_GETTER_MSG = (
-    "unreadable attribute" if sys.version_info < (3, 11) else "object has no getter"
-)
-NO_SETTER_MSG = (
-    "can't set attribute" if sys.version_info < (3, 11) else "object has no setter"
-)
-NO_DELETER_MSG = (
-    "can't delete attribute" if sys.version_info < (3, 11) else "object has no deleter"
-)
-
-
-def test_methods_and_attributes():
-    instance1 = m.ExampleMandA()
-    instance2 = m.ExampleMandA(32)
-
-    instance1.add1(instance2)
-    instance1.add2(instance2)
-    instance1.add3(instance2)
-    instance1.add4(instance2)
-    instance1.add5(instance2)
-    instance1.add6(32)
-    instance1.add7(32)
-    instance1.add8(32)
-    instance1.add9(32)
-    instance1.add10(32)
-
-    assert str(instance1) == "ExampleMandA[value=320]"
-    assert str(instance2) == "ExampleMandA[value=32]"
-    assert str(instance1.self1()) == "ExampleMandA[value=320]"
-    assert str(instance1.self2()) == "ExampleMandA[value=320]"
-    assert str(instance1.self3()) == "ExampleMandA[value=320]"
-    assert str(instance1.self4()) == "ExampleMandA[value=320]"
-    assert str(instance1.self5()) == "ExampleMandA[value=320]"
-
-    assert instance1.internal1() == 320
-    assert instance1.internal2() == 320
-    assert instance1.internal3() == 320
-    assert instance1.internal4() == 320
-    assert instance1.internal5() == 320
-
-    assert instance1.overloaded() == "()"
-    assert instance1.overloaded(0) == "(int)"
-    assert instance1.overloaded(1, 1.0) == "(int, float)"
-    assert instance1.overloaded(2.0, 2) == "(float, int)"
-    assert instance1.overloaded(3, 3) == "(int, int)"
-    assert instance1.overloaded(4.0, 4.0) == "(float, float)"
-    assert instance1.overloaded_const(-3) == "(int) const"
-    assert instance1.overloaded_const(5, 5.0) == "(int, float) const"
-    assert instance1.overloaded_const(6.0, 6) == "(float, int) const"
-    assert instance1.overloaded_const(7, 7) == "(int, int) const"
-    assert instance1.overloaded_const(8.0, 8.0) == "(float, float) const"
-    assert instance1.overloaded_float(1, 1) == "(float, float)"
-    assert instance1.overloaded_float(1, 1.0) == "(float, float)"
-    assert instance1.overloaded_float(1.0, 1) == "(float, float)"
-    assert instance1.overloaded_float(1.0, 1.0) == "(float, float)"
-
-    assert instance1.value == 320
-    instance1.value = 100
-    assert str(instance1) == "ExampleMandA[value=100]"
-
-    cstats = ConstructorStats.get(m.ExampleMandA)
-    assert cstats.alive() == 2
-    del instance1, instance2
-    assert cstats.alive() == 0
-    assert cstats.values() == ["32"]
-    assert cstats.default_constructions == 1
-    assert cstats.copy_constructions == 2
-    assert cstats.move_constructions >= 2
-    assert cstats.copy_assignments == 0
-    assert cstats.move_assignments == 0
-
-
-def test_copy_method():
-    """Issue #443: calling copied methods fails in Python 3"""
-
-    m.ExampleMandA.add2c = m.ExampleMandA.add2
-    m.ExampleMandA.add2d = m.ExampleMandA.add2b
-    a = m.ExampleMandA(123)
-    assert a.value == 123
-    a.add2(m.ExampleMandA(-100))
-    assert a.value == 23
-    a.add2b(m.ExampleMandA(20))
-    assert a.value == 43
-    a.add2c(m.ExampleMandA(6))
-    assert a.value == 49
-    a.add2d(m.ExampleMandA(-7))
-    assert a.value == 42
-
-
-def test_properties():
-    instance = m.TestProperties()
-
-    assert instance.def_readonly == 1
-    with pytest.raises(AttributeError):
-        instance.def_readonly = 2
-
-    instance.def_readwrite = 2
-    assert instance.def_readwrite == 2
-
-    assert instance.def_property_readonly == 2
-    with pytest.raises(AttributeError):
-        instance.def_property_readonly = 3
-
-    instance.def_property = 3
-    assert instance.def_property == 3
-
-    with pytest.raises(AttributeError) as excinfo:
-        dummy = instance.def_property_writeonly  # unused var
-    assert NO_GETTER_MSG in str(excinfo.value)
-
-    instance.def_property_writeonly = 4
-    assert instance.def_property_readonly == 4
-
-    with pytest.raises(AttributeError) as excinfo:
-        dummy = instance.def_property_impossible  # noqa: F841 unused var
-    assert NO_GETTER_MSG in str(excinfo.value)
-
-    with pytest.raises(AttributeError) as excinfo:
-        instance.def_property_impossible = 5
-    assert NO_SETTER_MSG in str(excinfo.value)
-
-
-def test_static_properties():
-    assert m.TestProperties.def_readonly_static == 1
-    with pytest.raises(AttributeError) as excinfo:
-        m.TestProperties.def_readonly_static = 2
-    assert NO_SETTER_MSG in str(excinfo.value)
-
-    m.TestProperties.def_readwrite_static = 2
-    assert m.TestProperties.def_readwrite_static == 2
-
-    with pytest.raises(AttributeError) as excinfo:
-        dummy = m.TestProperties.def_writeonly_static  # unused var
-    assert NO_GETTER_MSG in str(excinfo.value)
-
-    m.TestProperties.def_writeonly_static = 3
-    assert m.TestProperties.def_readonly_static == 3
-
-    assert m.TestProperties.def_property_readonly_static == 3
-    with pytest.raises(AttributeError) as excinfo:
-        m.TestProperties.def_property_readonly_static = 99
-    assert NO_SETTER_MSG in str(excinfo.value)
-
-    m.TestProperties.def_property_static = 4
-    assert m.TestProperties.def_property_static == 4
-
-    with pytest.raises(AttributeError) as excinfo:
-        dummy = m.TestProperties.def_property_writeonly_static
-    assert NO_GETTER_MSG in str(excinfo.value)
-
-    m.TestProperties.def_property_writeonly_static = 5
-    assert m.TestProperties.def_property_static == 5
-
-    # Static property read and write via instance
-    instance = m.TestProperties()
-
-    m.TestProperties.def_readwrite_static = 0
-    assert m.TestProperties.def_readwrite_static == 0
-    assert instance.def_readwrite_static == 0
-
-    instance.def_readwrite_static = 2
-    assert m.TestProperties.def_readwrite_static == 2
-    assert instance.def_readwrite_static == 2
-
-    with pytest.raises(AttributeError) as excinfo:
-        dummy = instance.def_property_writeonly_static  # noqa: F841 unused var
-    assert NO_GETTER_MSG in str(excinfo.value)
-
-    instance.def_property_writeonly_static = 4
-    assert instance.def_property_static == 4
-
-    # It should be possible to override properties in derived classes
-    assert m.TestPropertiesOverride().def_readonly == 99
-    assert m.TestPropertiesOverride.def_readonly_static == 99
-
-    # Only static attributes can be deleted
-    del m.TestPropertiesOverride.def_readonly_static
-    assert (
-        hasattr(m.TestPropertiesOverride, "def_readonly_static")
-        and m.TestPropertiesOverride.def_readonly_static
-        is m.TestProperties.def_readonly_static
-    )
-    assert "def_readonly_static" not in m.TestPropertiesOverride.__dict__
-    properties_override = m.TestPropertiesOverride()
-    with pytest.raises(AttributeError) as excinfo:
-        del properties_override.def_readonly
-    assert NO_DELETER_MSG in str(excinfo.value)
-
-
-def test_static_cls():
-    """Static property getter and setters expect the type object as the their only argument"""
-
-    instance = m.TestProperties()
-    assert m.TestProperties.static_cls is m.TestProperties
-    assert instance.static_cls is m.TestProperties
-
-    def check_self(self):
-        assert self is m.TestProperties
-
-    m.TestProperties.static_cls = check_self
-    instance.static_cls = check_self
-
-
-def test_metaclass_override():
-    """Overriding pybind11's default metaclass changes the behavior of `static_property`"""
-
-    assert type(m.ExampleMandA).__name__ == "pybind11_type"
-    assert type(m.MetaclassOverride).__name__ == "type"
-
-    assert m.MetaclassOverride.readonly == 1
-    assert (
-        type(m.MetaclassOverride.__dict__["readonly"]).__name__
-        == "pybind11_static_property"
-    )
-
-    # Regular `type` replaces the property instead of calling `__set__()`
-    m.MetaclassOverride.readonly = 2
-    assert m.MetaclassOverride.readonly == 2
-    assert isinstance(m.MetaclassOverride.__dict__["readonly"], int)
-
-
-def test_no_mixed_overloads():
-    from pybind11_tests import detailed_error_messages_enabled
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.ExampleMandA.add_mixed_overloads1()
-    assert str(
-        excinfo.value
-    ) == "overloading a method with both static and instance methods is not supported; " + (
-        "#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for more details"
-        if not detailed_error_messages_enabled
-        else "error while attempting to bind static method ExampleMandA.overload_mixed1"
-        "(arg0: float) -> str"
-    )
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.ExampleMandA.add_mixed_overloads2()
-    assert str(
-        excinfo.value
-    ) == "overloading a method with both static and instance methods is not supported; " + (
-        "#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for more details"
-        if not detailed_error_messages_enabled
-        else "error while attempting to bind instance method ExampleMandA.overload_mixed2"
-        "(self: pybind11_tests.methods_and_attributes.ExampleMandA, arg0: int, arg1: int)"
-        " -> str"
-    )
-
-
-@pytest.mark.parametrize("access", ["ro", "rw", "static_ro", "static_rw"])
-def test_property_return_value_policies(access):
-    if not access.startswith("static"):
-        obj = m.TestPropRVP()
-    else:
-        obj = m.TestPropRVP
-
-    ref = getattr(obj, access + "_ref")
-    assert ref.value == 1
-    ref.value = 2
-    assert getattr(obj, access + "_ref").value == 2
-    ref.value = 1  # restore original value for static properties
-
-    copy = getattr(obj, access + "_copy")
-    assert copy.value == 1
-    copy.value = 2
-    assert getattr(obj, access + "_copy").value == 1
-
-    copy = getattr(obj, access + "_func")
-    assert copy.value == 1
-    copy.value = 2
-    assert getattr(obj, access + "_func").value == 1
-
-
-def test_property_rvalue_policy():
-    """When returning an rvalue, the return value policy is automatically changed from
-    `reference(_internal)` to `move`. The following would not work otherwise."""
-
-    instance = m.TestPropRVP()
-    o = instance.rvalue
-    assert o.value == 1
-
-    os = m.TestPropRVP.static_rvalue
-    assert os.value == 1
-
-
-# https://foss.heptapod.net/pypy/pypy/-/issues/2447
-@pytest.mark.xfail("env.PYPY")
-def test_dynamic_attributes():
-    instance = m.DynamicClass()
-    assert not hasattr(instance, "foo")
-    assert "foo" not in dir(instance)
-
-    # Dynamically add attribute
-    instance.foo = 42
-    assert hasattr(instance, "foo")
-    assert instance.foo == 42
-    assert "foo" in dir(instance)
-
-    # __dict__ should be accessible and replaceable
-    assert "foo" in instance.__dict__
-    instance.__dict__ = {"bar": True}
-    assert not hasattr(instance, "foo")
-    assert hasattr(instance, "bar")
-
-    with pytest.raises(TypeError) as excinfo:
-        instance.__dict__ = []
-    assert str(excinfo.value) == "__dict__ must be set to a dictionary, not a 'list'"
-
-    cstats = ConstructorStats.get(m.DynamicClass)
-    assert cstats.alive() == 1
-    del instance
-    assert cstats.alive() == 0
-
-    # Derived classes should work as well
-    class PythonDerivedDynamicClass(m.DynamicClass):
-        pass
-
-    for cls in m.CppDerivedDynamicClass, PythonDerivedDynamicClass:
-        derived = cls()
-        derived.foobar = 100
-        assert derived.foobar == 100
-
-        assert cstats.alive() == 1
-        del derived
-        assert cstats.alive() == 0
-
-
-# https://foss.heptapod.net/pypy/pypy/-/issues/2447
-@pytest.mark.xfail("env.PYPY")
-def test_cyclic_gc():
-    # One object references itself
-    instance = m.DynamicClass()
-    instance.circular_reference = instance
-
-    cstats = ConstructorStats.get(m.DynamicClass)
-    assert cstats.alive() == 1
-    del instance
-    assert cstats.alive() == 0
-
-    # Two object reference each other
-    i1 = m.DynamicClass()
-    i2 = m.DynamicClass()
-    i1.cycle = i2
-    i2.cycle = i1
-
-    assert cstats.alive() == 2
-    del i1, i2
-    assert cstats.alive() == 0
-
-
-def test_bad_arg_default(msg):
-    from pybind11_tests import detailed_error_messages_enabled
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.bad_arg_def_named()
-    assert msg(excinfo.value) == (
-        "arg(): could not convert default argument 'a: UnregisteredType' in function "
-        "'should_fail' into a Python object (type not registered yet?)"
-        if detailed_error_messages_enabled
-        else "arg(): could not convert default argument into a Python object (type not registered "
-        "yet?). #define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for more information."
-    )
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.bad_arg_def_unnamed()
-    assert msg(excinfo.value) == (
-        "arg(): could not convert default argument 'UnregisteredType' in function "
-        "'should_fail' into a Python object (type not registered yet?)"
-        if detailed_error_messages_enabled
-        else "arg(): could not convert default argument into a Python object (type not registered "
-        "yet?). #define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for more information."
-    )
-
-
-def test_accepts_none(msg):
-    a = m.NoneTester()
-    assert m.no_none1(a) == 42
-    assert m.no_none2(a) == 42
-    assert m.no_none3(a) == 42
-    assert m.no_none4(a) == 42
-    assert m.no_none5(a) == 42
-    assert m.ok_none1(a) == 42
-    assert m.ok_none2(a) == 42
-    assert m.ok_none3(a) == 42
-    assert m.ok_none4(a) == 42
-    assert m.ok_none5(a) == 42
-
-    with pytest.raises(TypeError) as excinfo:
-        m.no_none1(None)
-    assert "incompatible function arguments" in str(excinfo.value)
-    with pytest.raises(TypeError) as excinfo:
-        m.no_none2(None)
-    assert "incompatible function arguments" in str(excinfo.value)
-    with pytest.raises(TypeError) as excinfo:
-        m.no_none3(None)
-    assert "incompatible function arguments" in str(excinfo.value)
-    with pytest.raises(TypeError) as excinfo:
-        m.no_none4(None)
-    assert "incompatible function arguments" in str(excinfo.value)
-    with pytest.raises(TypeError) as excinfo:
-        m.no_none5(None)
-    assert "incompatible function arguments" in str(excinfo.value)
-
-    # The first one still raises because you can't pass None as a lvalue reference arg:
-    with pytest.raises(TypeError) as excinfo:
-        assert m.ok_none1(None) == -1
-    assert (
-        msg(excinfo.value)
-        == """
-        ok_none1(): incompatible function arguments. The following argument types are supported:
-            1. (arg0: m.methods_and_attributes.NoneTester) -> int
-
-        Invoked with: None
-    """
-    )
-
-    # The rest take the argument as pointer or holder, and accept None:
-    assert m.ok_none2(None) == -1
-    assert m.ok_none3(None) == -1
-    assert m.ok_none4(None) == -1
-    assert m.ok_none5(None) == -1
-
-    with pytest.raises(TypeError) as excinfo:
-        m.no_none_kwarg(None)
-    assert "incompatible function arguments" in str(excinfo.value)
-    with pytest.raises(TypeError) as excinfo:
-        m.no_none_kwarg(a=None)
-    assert "incompatible function arguments" in str(excinfo.value)
-    with pytest.raises(TypeError) as excinfo:
-        m.no_none_kwarg_kw_only(None)
-    assert "incompatible function arguments" in str(excinfo.value)
-    with pytest.raises(TypeError) as excinfo:
-        m.no_none_kwarg_kw_only(a=None)
-    assert "incompatible function arguments" in str(excinfo.value)
-
-
-def test_casts_none():
-    """#2778: implicit casting from None to object (not pointer)"""
-    a = m.NoneCastTester()
-    assert m.ok_obj_or_none(a) == -1
-    a = m.NoneCastTester(4)
-    assert m.ok_obj_or_none(a) == 4
-    a = m.NoneCastTester(None)
-    assert m.ok_obj_or_none(a) == -1
-    assert m.ok_obj_or_none(None) == -1
-
-
-def test_str_issue(msg):
-    """#283: __str__ called on uninitialized instance when constructor arguments invalid"""
-
-    assert str(m.StrIssue(3)) == "StrIssue[3]"
-
-    with pytest.raises(TypeError) as excinfo:
-        str(m.StrIssue("no", "such", "constructor"))
-    assert (
-        msg(excinfo.value)
-        == """
-        __init__(): incompatible constructor arguments. The following argument types are supported:
-            1. m.methods_and_attributes.StrIssue(arg0: int)
-            2. m.methods_and_attributes.StrIssue()
-
-        Invoked with: 'no', 'such', 'constructor'
-    """
-    )
-
-
-def test_unregistered_base_implementations():
-    a = m.RegisteredDerived()
-    a.do_nothing()
-    assert a.rw_value == 42
-    assert a.ro_value == 1.25
-    a.rw_value += 5
-    assert a.sum() == 48.25
-    a.increase_value()
-    assert a.rw_value == 48
-    assert a.ro_value == 1.5
-    assert a.sum() == 49.5
-    assert a.rw_value_prop == 48
-    a.rw_value_prop += 1
-    assert a.rw_value_prop == 49
-    a.increase_value()
-    assert a.ro_value_prop == 1.75
-
-
-def test_ref_qualified():
-    """Tests that explicit lvalue ref-qualified methods can be called just like their
-    non ref-qualified counterparts."""
-
-    r = m.RefQualified()
-    assert r.value == 0
-    r.refQualified(17)
-    assert r.value == 17
-    assert r.constRefQualified(23) == 40
-
-
-def test_overload_ordering():
-    "Check to see if the normal overload order (first defined) and prepend overload order works"
-    assert m.overload_order("string") == 1
-    assert m.overload_order(0) == 4
-
-    assert "1. overload_order(arg0: int) -> int" in m.overload_order.__doc__
-    assert "2. overload_order(arg0: str) -> int" in m.overload_order.__doc__
-    assert "3. overload_order(arg0: str) -> int" in m.overload_order.__doc__
-    assert "4. overload_order(arg0: int) -> int" in m.overload_order.__doc__
-
-    with pytest.raises(TypeError) as err:
-        m.overload_order(1.1)
-
-    assert "1. (arg0: int) -> int" in str(err.value)
-    assert "2. (arg0: str) -> int" in str(err.value)
-    assert "3. (arg0: str) -> int" in str(err.value)
-    assert "4. (arg0: int) -> int" in str(err.value)
-
-
-def test_rvalue_ref_param():
-    r = m.RValueRefParam()
-    assert r.func1("123") == 3
-    assert r.func2("1234") == 4
-    assert r.func3("12345") == 5
-    assert r.func4("123456") == 6
+import sys
+
+import pytest
+
+import env  # noqa: F401
+from pybind11_tests import ConstructorStats
+from pybind11_tests import methods_and_attributes as m
+
+NO_GETTER_MSG = (
+    "unreadable attribute" if sys.version_info < (3, 11) else "object has no getter"
+)
+NO_SETTER_MSG = (
+    "can't set attribute" if sys.version_info < (3, 11) else "object has no setter"
+)
+NO_DELETER_MSG = (
+    "can't delete attribute" if sys.version_info < (3, 11) else "object has no deleter"
+)
+
+
+def test_methods_and_attributes():
+    instance1 = m.ExampleMandA()
+    instance2 = m.ExampleMandA(32)
+
+    instance1.add1(instance2)
+    instance1.add2(instance2)
+    instance1.add3(instance2)
+    instance1.add4(instance2)
+    instance1.add5(instance2)
+    instance1.add6(32)
+    instance1.add7(32)
+    instance1.add8(32)
+    instance1.add9(32)
+    instance1.add10(32)
+
+    assert str(instance1) == "ExampleMandA[value=320]"
+    assert str(instance2) == "ExampleMandA[value=32]"
+    assert str(instance1.self1()) == "ExampleMandA[value=320]"
+    assert str(instance1.self2()) == "ExampleMandA[value=320]"
+    assert str(instance1.self3()) == "ExampleMandA[value=320]"
+    assert str(instance1.self4()) == "ExampleMandA[value=320]"
+    assert str(instance1.self5()) == "ExampleMandA[value=320]"
+
+    assert instance1.internal1() == 320
+    assert instance1.internal2() == 320
+    assert instance1.internal3() == 320
+    assert instance1.internal4() == 320
+    assert instance1.internal5() == 320
+
+    assert instance1.overloaded() == "()"
+    assert instance1.overloaded(0) == "(int)"
+    assert instance1.overloaded(1, 1.0) == "(int, float)"
+    assert instance1.overloaded(2.0, 2) == "(float, int)"
+    assert instance1.overloaded(3, 3) == "(int, int)"
+    assert instance1.overloaded(4.0, 4.0) == "(float, float)"
+    assert instance1.overloaded_const(-3) == "(int) const"
+    assert instance1.overloaded_const(5, 5.0) == "(int, float) const"
+    assert instance1.overloaded_const(6.0, 6) == "(float, int) const"
+    assert instance1.overloaded_const(7, 7) == "(int, int) const"
+    assert instance1.overloaded_const(8.0, 8.0) == "(float, float) const"
+    assert instance1.overloaded_float(1, 1) == "(float, float)"
+    assert instance1.overloaded_float(1, 1.0) == "(float, float)"
+    assert instance1.overloaded_float(1.0, 1) == "(float, float)"
+    assert instance1.overloaded_float(1.0, 1.0) == "(float, float)"
+
+    assert instance1.value == 320
+    instance1.value = 100
+    assert str(instance1) == "ExampleMandA[value=100]"
+
+    cstats = ConstructorStats.get(m.ExampleMandA)
+    assert cstats.alive() == 2
+    del instance1, instance2
+    assert cstats.alive() == 0
+    assert cstats.values() == ["32"]
+    assert cstats.default_constructions == 1
+    assert cstats.copy_constructions == 2
+    assert cstats.move_constructions >= 2
+    assert cstats.copy_assignments == 0
+    assert cstats.move_assignments == 0
+
+
+def test_copy_method():
+    """Issue #443: calling copied methods fails in Python 3"""
+
+    m.ExampleMandA.add2c = m.ExampleMandA.add2
+    m.ExampleMandA.add2d = m.ExampleMandA.add2b
+    a = m.ExampleMandA(123)
+    assert a.value == 123
+    a.add2(m.ExampleMandA(-100))
+    assert a.value == 23
+    a.add2b(m.ExampleMandA(20))
+    assert a.value == 43
+    a.add2c(m.ExampleMandA(6))
+    assert a.value == 49
+    a.add2d(m.ExampleMandA(-7))
+    assert a.value == 42
+
+
+def test_properties():
+    instance = m.TestProperties()
+
+    assert instance.def_readonly == 1
+    with pytest.raises(AttributeError):
+        instance.def_readonly = 2
+
+    instance.def_readwrite = 2
+    assert instance.def_readwrite == 2
+
+    assert instance.def_property_readonly == 2
+    with pytest.raises(AttributeError):
+        instance.def_property_readonly = 3
+
+    instance.def_property = 3
+    assert instance.def_property == 3
+
+    with pytest.raises(AttributeError) as excinfo:
+        dummy = instance.def_property_writeonly  # unused var
+    assert NO_GETTER_MSG in str(excinfo.value)
+
+    instance.def_property_writeonly = 4
+    assert instance.def_property_readonly == 4
+
+    with pytest.raises(AttributeError) as excinfo:
+        dummy = instance.def_property_impossible  # noqa: F841 unused var
+    assert NO_GETTER_MSG in str(excinfo.value)
+
+    with pytest.raises(AttributeError) as excinfo:
+        instance.def_property_impossible = 5
+    assert NO_SETTER_MSG in str(excinfo.value)
+
+
+def test_static_properties():
+    assert m.TestProperties.def_readonly_static == 1
+    with pytest.raises(AttributeError) as excinfo:
+        m.TestProperties.def_readonly_static = 2
+    assert NO_SETTER_MSG in str(excinfo.value)
+
+    m.TestProperties.def_readwrite_static = 2
+    assert m.TestProperties.def_readwrite_static == 2
+
+    with pytest.raises(AttributeError) as excinfo:
+        dummy = m.TestProperties.def_writeonly_static  # unused var
+    assert NO_GETTER_MSG in str(excinfo.value)
+
+    m.TestProperties.def_writeonly_static = 3
+    assert m.TestProperties.def_readonly_static == 3
+
+    assert m.TestProperties.def_property_readonly_static == 3
+    with pytest.raises(AttributeError) as excinfo:
+        m.TestProperties.def_property_readonly_static = 99
+    assert NO_SETTER_MSG in str(excinfo.value)
+
+    m.TestProperties.def_property_static = 4
+    assert m.TestProperties.def_property_static == 4
+
+    with pytest.raises(AttributeError) as excinfo:
+        dummy = m.TestProperties.def_property_writeonly_static
+    assert NO_GETTER_MSG in str(excinfo.value)
+
+    m.TestProperties.def_property_writeonly_static = 5
+    assert m.TestProperties.def_property_static == 5
+
+    # Static property read and write via instance
+    instance = m.TestProperties()
+
+    m.TestProperties.def_readwrite_static = 0
+    assert m.TestProperties.def_readwrite_static == 0
+    assert instance.def_readwrite_static == 0
+
+    instance.def_readwrite_static = 2
+    assert m.TestProperties.def_readwrite_static == 2
+    assert instance.def_readwrite_static == 2
+
+    with pytest.raises(AttributeError) as excinfo:
+        dummy = instance.def_property_writeonly_static  # noqa: F841 unused var
+    assert NO_GETTER_MSG in str(excinfo.value)
+
+    instance.def_property_writeonly_static = 4
+    assert instance.def_property_static == 4
+
+    # It should be possible to override properties in derived classes
+    assert m.TestPropertiesOverride().def_readonly == 99
+    assert m.TestPropertiesOverride.def_readonly_static == 99
+
+    # Only static attributes can be deleted
+    del m.TestPropertiesOverride.def_readonly_static
+    assert (
+        hasattr(m.TestPropertiesOverride, "def_readonly_static")
+        and m.TestPropertiesOverride.def_readonly_static
+        is m.TestProperties.def_readonly_static
+    )
+    assert "def_readonly_static" not in m.TestPropertiesOverride.__dict__
+    properties_override = m.TestPropertiesOverride()
+    with pytest.raises(AttributeError) as excinfo:
+        del properties_override.def_readonly
+    assert NO_DELETER_MSG in str(excinfo.value)
+
+
+def test_static_cls():
+    """Static property getter and setters expect the type object as the their only argument"""
+
+    instance = m.TestProperties()
+    assert m.TestProperties.static_cls is m.TestProperties
+    assert instance.static_cls is m.TestProperties
+
+    def check_self(self):
+        assert self is m.TestProperties
+
+    m.TestProperties.static_cls = check_self
+    instance.static_cls = check_self
+
+
+def test_metaclass_override():
+    """Overriding pybind11's default metaclass changes the behavior of `static_property`"""
+
+    assert type(m.ExampleMandA).__name__ == "pybind11_type"
+    assert type(m.MetaclassOverride).__name__ == "type"
+
+    assert m.MetaclassOverride.readonly == 1
+    assert (
+        type(m.MetaclassOverride.__dict__["readonly"]).__name__
+        == "pybind11_static_property"
+    )
+
+    # Regular `type` replaces the property instead of calling `__set__()`
+    m.MetaclassOverride.readonly = 2
+    assert m.MetaclassOverride.readonly == 2
+    assert isinstance(m.MetaclassOverride.__dict__["readonly"], int)
+
+
+def test_no_mixed_overloads():
+    from pybind11_tests import detailed_error_messages_enabled
+
+    with pytest.raises(RuntimeError) as excinfo:
+        m.ExampleMandA.add_mixed_overloads1()
+    assert str(
+        excinfo.value
+    ) == "overloading a method with both static and instance methods is not supported; " + (
+        "#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for more details"
+        if not detailed_error_messages_enabled
+        else "error while attempting to bind static method ExampleMandA.overload_mixed1"
+        "(arg0: float) -> str"
+    )
+
+    with pytest.raises(RuntimeError) as excinfo:
+        m.ExampleMandA.add_mixed_overloads2()
+    assert str(
+        excinfo.value
+    ) == "overloading a method with both static and instance methods is not supported; " + (
+        "#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for more details"
+        if not detailed_error_messages_enabled
+        else "error while attempting to bind instance method ExampleMandA.overload_mixed2"
+        "(self: pybind11_tests.methods_and_attributes.ExampleMandA, arg0: int, arg1: int)"
+        " -> str"
+    )
+
+
+@pytest.mark.parametrize("access", ["ro", "rw", "static_ro", "static_rw"])
+def test_property_return_value_policies(access):
+    if not access.startswith("static"):
+        obj = m.TestPropRVP()
+    else:
+        obj = m.TestPropRVP
+
+    ref = getattr(obj, access + "_ref")
+    assert ref.value == 1
+    ref.value = 2
+    assert getattr(obj, access + "_ref").value == 2
+    ref.value = 1  # restore original value for static properties
+
+    copy = getattr(obj, access + "_copy")
+    assert copy.value == 1
+    copy.value = 2
+    assert getattr(obj, access + "_copy").value == 1
+
+    copy = getattr(obj, access + "_func")
+    assert copy.value == 1
+    copy.value = 2
+    assert getattr(obj, access + "_func").value == 1
+
+
+def test_property_rvalue_policy():
+    """When returning an rvalue, the return value policy is automatically changed from
+    `reference(_internal)` to `move`. The following would not work otherwise."""
+
+    instance = m.TestPropRVP()
+    o = instance.rvalue
+    assert o.value == 1
+
+    os = m.TestPropRVP.static_rvalue
+    assert os.value == 1
+
+
+# https://foss.heptapod.net/pypy/pypy/-/issues/2447
+@pytest.mark.xfail("env.PYPY")
+def test_dynamic_attributes():
+    instance = m.DynamicClass()
+    assert not hasattr(instance, "foo")
+    assert "foo" not in dir(instance)
+
+    # Dynamically add attribute
+    instance.foo = 42
+    assert hasattr(instance, "foo")
+    assert instance.foo == 42
+    assert "foo" in dir(instance)
+
+    # __dict__ should be accessible and replaceable
+    assert "foo" in instance.__dict__
+    instance.__dict__ = {"bar": True}
+    assert not hasattr(instance, "foo")
+    assert hasattr(instance, "bar")
+
+    with pytest.raises(TypeError) as excinfo:
+        instance.__dict__ = []
+    assert str(excinfo.value) == "__dict__ must be set to a dictionary, not a 'list'"
+
+    cstats = ConstructorStats.get(m.DynamicClass)
+    assert cstats.alive() == 1
+    del instance
+    assert cstats.alive() == 0
+
+    # Derived classes should work as well
+    class PythonDerivedDynamicClass(m.DynamicClass):
+        pass
+
+    for cls in m.CppDerivedDynamicClass, PythonDerivedDynamicClass:
+        derived = cls()
+        derived.foobar = 100
+        assert derived.foobar == 100
+
+        assert cstats.alive() == 1
+        del derived
+        assert cstats.alive() == 0
+
+
+# https://foss.heptapod.net/pypy/pypy/-/issues/2447
+@pytest.mark.xfail("env.PYPY")
+def test_cyclic_gc():
+    # One object references itself
+    instance = m.DynamicClass()
+    instance.circular_reference = instance
+
+    cstats = ConstructorStats.get(m.DynamicClass)
+    assert cstats.alive() == 1
+    del instance
+    assert cstats.alive() == 0
+
+    # Two object reference each other
+    i1 = m.DynamicClass()
+    i2 = m.DynamicClass()
+    i1.cycle = i2
+    i2.cycle = i1
+
+    assert cstats.alive() == 2
+    del i1, i2
+    assert cstats.alive() == 0
+
+
+def test_bad_arg_default(msg):
+    from pybind11_tests import detailed_error_messages_enabled
+
+    with pytest.raises(RuntimeError) as excinfo:
+        m.bad_arg_def_named()
+    assert msg(excinfo.value) == (
+        "arg(): could not convert default argument 'a: UnregisteredType' in function "
+        "'should_fail' into a Python object (type not registered yet?)"
+        if detailed_error_messages_enabled
+        else "arg(): could not convert default argument into a Python object (type not registered "
+        "yet?). #define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for more information."
+    )
+
+    with pytest.raises(RuntimeError) as excinfo:
+        m.bad_arg_def_unnamed()
+    assert msg(excinfo.value) == (
+        "arg(): could not convert default argument 'UnregisteredType' in function "
+        "'should_fail' into a Python object (type not registered yet?)"
+        if detailed_error_messages_enabled
+        else "arg(): could not convert default argument into a Python object (type not registered "
+        "yet?). #define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for more information."
+    )
+
+
+def test_accepts_none(msg):
+    a = m.NoneTester()
+    assert m.no_none1(a) == 42
+    assert m.no_none2(a) == 42
+    assert m.no_none3(a) == 42
+    assert m.no_none4(a) == 42
+    assert m.no_none5(a) == 42
+    assert m.ok_none1(a) == 42
+    assert m.ok_none2(a) == 42
+    assert m.ok_none3(a) == 42
+    assert m.ok_none4(a) == 42
+    assert m.ok_none5(a) == 42
+
+    with pytest.raises(TypeError) as excinfo:
+        m.no_none1(None)
+    assert "incompatible function arguments" in str(excinfo.value)
+    with pytest.raises(TypeError) as excinfo:
+        m.no_none2(None)
+    assert "incompatible function arguments" in str(excinfo.value)
+    with pytest.raises(TypeError) as excinfo:
+        m.no_none3(None)
+    assert "incompatible function arguments" in str(excinfo.value)
+    with pytest.raises(TypeError) as excinfo:
+        m.no_none4(None)
+    assert "incompatible function arguments" in str(excinfo.value)
+    with pytest.raises(TypeError) as excinfo:
+        m.no_none5(None)
+    assert "incompatible function arguments" in str(excinfo.value)
+
+    # The first one still raises because you can't pass None as a lvalue reference arg:
+    with pytest.raises(TypeError) as excinfo:
+        assert m.ok_none1(None) == -1
+    assert (
+        msg(excinfo.value)
+        == """
+        ok_none1(): incompatible function arguments. The following argument types are supported:
+            1. (arg0: m.methods_and_attributes.NoneTester) -> int
+
+        Invoked with: None
+    """
+    )
+
+    # The rest take the argument as pointer or holder, and accept None:
+    assert m.ok_none2(None) == -1
+    assert m.ok_none3(None) == -1
+    assert m.ok_none4(None) == -1
+    assert m.ok_none5(None) == -1
+
+    with pytest.raises(TypeError) as excinfo:
+        m.no_none_kwarg(None)
+    assert "incompatible function arguments" in str(excinfo.value)
+    with pytest.raises(TypeError) as excinfo:
+        m.no_none_kwarg(a=None)
+    assert "incompatible function arguments" in str(excinfo.value)
+    with pytest.raises(TypeError) as excinfo:
+        m.no_none_kwarg_kw_only(None)
+    assert "incompatible function arguments" in str(excinfo.value)
+    with pytest.raises(TypeError) as excinfo:
+        m.no_none_kwarg_kw_only(a=None)
+    assert "incompatible function arguments" in str(excinfo.value)
+
+
+def test_casts_none():
+    """#2778: implicit casting from None to object (not pointer)"""
+    a = m.NoneCastTester()
+    assert m.ok_obj_or_none(a) == -1
+    a = m.NoneCastTester(4)
+    assert m.ok_obj_or_none(a) == 4
+    a = m.NoneCastTester(None)
+    assert m.ok_obj_or_none(a) == -1
+    assert m.ok_obj_or_none(None) == -1
+
+
+def test_str_issue(msg):
+    """#283: __str__ called on uninitialized instance when constructor arguments invalid"""
+
+    assert str(m.StrIssue(3)) == "StrIssue[3]"
+
+    with pytest.raises(TypeError) as excinfo:
+        str(m.StrIssue("no", "such", "constructor"))
+    assert (
+        msg(excinfo.value)
+        == """
+        __init__(): incompatible constructor arguments. The following argument types are supported:
+            1. m.methods_and_attributes.StrIssue(arg0: int)
+            2. m.methods_and_attributes.StrIssue()
+
+        Invoked with: 'no', 'such', 'constructor'
+    """
+    )
+
+
+def test_unregistered_base_implementations():
+    a = m.RegisteredDerived()
+    a.do_nothing()
+    assert a.rw_value == 42
+    assert a.ro_value == 1.25
+    a.rw_value += 5
+    assert a.sum() == 48.25
+    a.increase_value()
+    assert a.rw_value == 48
+    assert a.ro_value == 1.5
+    assert a.sum() == 49.5
+    assert a.rw_value_prop == 48
+    a.rw_value_prop += 1
+    assert a.rw_value_prop == 49
+    a.increase_value()
+    assert a.ro_value_prop == 1.75
+
+
+def test_ref_qualified():
+    """Tests that explicit lvalue ref-qualified methods can be called just like their
+    non ref-qualified counterparts."""
+
+    r = m.RefQualified()
+    assert r.value == 0
+    r.refQualified(17)
+    assert r.value == 17
+    assert r.constRefQualified(23) == 40
+
+
+def test_overload_ordering():
+    "Check to see if the normal overload order (first defined) and prepend overload order works"
+    assert m.overload_order("string") == 1
+    assert m.overload_order(0) == 4
+
+    assert "1. overload_order(arg0: int) -> int" in m.overload_order.__doc__
+    assert "2. overload_order(arg0: str) -> int" in m.overload_order.__doc__
+    assert "3. overload_order(arg0: str) -> int" in m.overload_order.__doc__
+    assert "4. overload_order(arg0: int) -> int" in m.overload_order.__doc__
+
+    with pytest.raises(TypeError) as err:
+        m.overload_order(1.1)
+
+    assert "1. (arg0: int) -> int" in str(err.value)
+    assert "2. (arg0: str) -> int" in str(err.value)
+    assert "3. (arg0: str) -> int" in str(err.value)
+    assert "4. (arg0: int) -> int" in str(err.value)
+
+
+def test_rvalue_ref_param():
+    r = m.RValueRefParam()
+    assert r.func1("123") == 3
+    assert r.func2("1234") == 4
+    assert r.func3("12345") == 5
+    assert r.func4("123456") == 6
```

## extern/pybind11/tests/test_modules.py

 * *Ordering differences only*

```diff
@@ -1,120 +1,120 @@
-import pytest
-
-import env
-from pybind11_tests import ConstructorStats
-from pybind11_tests import modules as m
-from pybind11_tests.modules import subsubmodule as ms
-
-
-def test_nested_modules():
-    import pybind11_tests
-
-    assert pybind11_tests.__name__ == "pybind11_tests"
-    assert pybind11_tests.modules.__name__ == "pybind11_tests.modules"
-    assert (
-        pybind11_tests.modules.subsubmodule.__name__
-        == "pybind11_tests.modules.subsubmodule"
-    )
-    assert m.__name__ == "pybind11_tests.modules"
-    assert ms.__name__ == "pybind11_tests.modules.subsubmodule"
-
-    assert ms.submodule_func() == "submodule_func()"
-
-
-def test_reference_internal():
-    b = ms.B()
-    assert str(b.get_a1()) == "A[1]"
-    assert str(b.a1) == "A[1]"
-    assert str(b.get_a2()) == "A[2]"
-    assert str(b.a2) == "A[2]"
-
-    b.a1 = ms.A(42)
-    b.a2 = ms.A(43)
-    assert str(b.get_a1()) == "A[42]"
-    assert str(b.a1) == "A[42]"
-    assert str(b.get_a2()) == "A[43]"
-    assert str(b.a2) == "A[43]"
-
-    astats, bstats = ConstructorStats.get(ms.A), ConstructorStats.get(ms.B)
-    assert astats.alive() == 2
-    assert bstats.alive() == 1
-    del b
-    assert astats.alive() == 0
-    assert bstats.alive() == 0
-    assert astats.values() == ["1", "2", "42", "43"]
-    assert bstats.values() == []
-    assert astats.default_constructions == 0
-    assert bstats.default_constructions == 1
-    assert astats.copy_constructions == 0
-    assert bstats.copy_constructions == 0
-    # assert astats.move_constructions >= 0  # Don't invoke any
-    # assert bstats.move_constructions >= 0  # Don't invoke any
-    assert astats.copy_assignments == 2
-    assert bstats.copy_assignments == 0
-    assert astats.move_assignments == 0
-    assert bstats.move_assignments == 0
-
-
-def test_importing():
-    from collections import OrderedDict
-
-    from pybind11_tests.modules import OD
-
-    assert OD is OrderedDict
-    assert str(OD([(1, "a"), (2, "b")])) == "OrderedDict([(1, 'a'), (2, 'b')])"
-
-
-def test_pydoc():
-    """Pydoc needs to be able to provide help() for everything inside a pybind11 module"""
-    import pydoc
-
-    import pybind11_tests
-
-    assert pybind11_tests.__name__ == "pybind11_tests"
-    assert pybind11_tests.__doc__ == "pybind11 test module"
-    assert pydoc.text.docmodule(pybind11_tests)
-
-
-def test_duplicate_registration():
-    """Registering two things with the same name"""
-
-    assert m.duplicate_registration() == []
-
-
-def test_builtin_key_type():
-    """Test that all the keys in the builtin modules have type str.
-
-    Previous versions of pybind11 would add a unicode key in python 2.
-    """
-    if hasattr(__builtins__, "keys"):
-        keys = __builtins__.keys()
-    else:  # this is to make pypy happy since builtins is different there.
-        keys = __builtins__.__dict__.keys()
-
-    assert {type(k) for k in keys} == {str}
-
-
-@pytest.mark.xfail("env.PYPY", reason="PyModule_GetName()")
-def test_def_submodule_failures():
-    sm = m.def_submodule(m, b"ScratchSubModuleName")  # Using bytes to show it works.
-    assert sm.__name__ == m.__name__ + "." + "ScratchSubModuleName"
-    malformed_utf8 = b"\x80"
-    if env.PYPY:
-        # It is not worth the effort finding a trigger for a failure when running with PyPy.
-        pytest.skip("Sufficiently exercised on platforms other than PyPy.")
-    else:
-        # Meant to trigger PyModule_GetName() failure:
-        sm_name_orig = sm.__name__
-        sm.__name__ = malformed_utf8
-        try:
-            # We want to assert that a bad __name__ causes some kind of failure, although we do not want to exercise
-            # the internals of PyModule_GetName(). Currently all supported Python versions raise SystemError. If that
-            # changes in future Python versions, simply add the new expected exception types here.
-            with pytest.raises(SystemError):
-                m.def_submodule(sm, b"SubSubModuleName")
-        finally:
-            # Clean up to ensure nothing gets upset by a module with an invalid __name__.
-            sm.__name__ = sm_name_orig  # Purely precautionary.
-    # Meant to trigger PyImport_AddModule() failure:
-    with pytest.raises(UnicodeDecodeError):
-        m.def_submodule(sm, malformed_utf8)
+import pytest
+
+import env
+from pybind11_tests import ConstructorStats
+from pybind11_tests import modules as m
+from pybind11_tests.modules import subsubmodule as ms
+
+
+def test_nested_modules():
+    import pybind11_tests
+
+    assert pybind11_tests.__name__ == "pybind11_tests"
+    assert pybind11_tests.modules.__name__ == "pybind11_tests.modules"
+    assert (
+        pybind11_tests.modules.subsubmodule.__name__
+        == "pybind11_tests.modules.subsubmodule"
+    )
+    assert m.__name__ == "pybind11_tests.modules"
+    assert ms.__name__ == "pybind11_tests.modules.subsubmodule"
+
+    assert ms.submodule_func() == "submodule_func()"
+
+
+def test_reference_internal():
+    b = ms.B()
+    assert str(b.get_a1()) == "A[1]"
+    assert str(b.a1) == "A[1]"
+    assert str(b.get_a2()) == "A[2]"
+    assert str(b.a2) == "A[2]"
+
+    b.a1 = ms.A(42)
+    b.a2 = ms.A(43)
+    assert str(b.get_a1()) == "A[42]"
+    assert str(b.a1) == "A[42]"
+    assert str(b.get_a2()) == "A[43]"
+    assert str(b.a2) == "A[43]"
+
+    astats, bstats = ConstructorStats.get(ms.A), ConstructorStats.get(ms.B)
+    assert astats.alive() == 2
+    assert bstats.alive() == 1
+    del b
+    assert astats.alive() == 0
+    assert bstats.alive() == 0
+    assert astats.values() == ["1", "2", "42", "43"]
+    assert bstats.values() == []
+    assert astats.default_constructions == 0
+    assert bstats.default_constructions == 1
+    assert astats.copy_constructions == 0
+    assert bstats.copy_constructions == 0
+    # assert astats.move_constructions >= 0  # Don't invoke any
+    # assert bstats.move_constructions >= 0  # Don't invoke any
+    assert astats.copy_assignments == 2
+    assert bstats.copy_assignments == 0
+    assert astats.move_assignments == 0
+    assert bstats.move_assignments == 0
+
+
+def test_importing():
+    from collections import OrderedDict
+
+    from pybind11_tests.modules import OD
+
+    assert OD is OrderedDict
+    assert str(OD([(1, "a"), (2, "b")])) == "OrderedDict([(1, 'a'), (2, 'b')])"
+
+
+def test_pydoc():
+    """Pydoc needs to be able to provide help() for everything inside a pybind11 module"""
+    import pydoc
+
+    import pybind11_tests
+
+    assert pybind11_tests.__name__ == "pybind11_tests"
+    assert pybind11_tests.__doc__ == "pybind11 test module"
+    assert pydoc.text.docmodule(pybind11_tests)
+
+
+def test_duplicate_registration():
+    """Registering two things with the same name"""
+
+    assert m.duplicate_registration() == []
+
+
+def test_builtin_key_type():
+    """Test that all the keys in the builtin modules have type str.
+
+    Previous versions of pybind11 would add a unicode key in python 2.
+    """
+    if hasattr(__builtins__, "keys"):
+        keys = __builtins__.keys()
+    else:  # this is to make pypy happy since builtins is different there.
+        keys = __builtins__.__dict__.keys()
+
+    assert {type(k) for k in keys} == {str}
+
+
+@pytest.mark.xfail("env.PYPY", reason="PyModule_GetName()")
+def test_def_submodule_failures():
+    sm = m.def_submodule(m, b"ScratchSubModuleName")  # Using bytes to show it works.
+    assert sm.__name__ == m.__name__ + "." + "ScratchSubModuleName"
+    malformed_utf8 = b"\x80"
+    if env.PYPY:
+        # It is not worth the effort finding a trigger for a failure when running with PyPy.
+        pytest.skip("Sufficiently exercised on platforms other than PyPy.")
+    else:
+        # Meant to trigger PyModule_GetName() failure:
+        sm_name_orig = sm.__name__
+        sm.__name__ = malformed_utf8
+        try:
+            # We want to assert that a bad __name__ causes some kind of failure, although we do not want to exercise
+            # the internals of PyModule_GetName(). Currently all supported Python versions raise SystemError. If that
+            # changes in future Python versions, simply add the new expected exception types here.
+            with pytest.raises(SystemError):
+                m.def_submodule(sm, b"SubSubModuleName")
+        finally:
+            # Clean up to ensure nothing gets upset by a module with an invalid __name__.
+            sm.__name__ = sm_name_orig  # Purely precautionary.
+    # Meant to trigger PyImport_AddModule() failure:
+    with pytest.raises(UnicodeDecodeError):
+        m.def_submodule(sm, malformed_utf8)
```

## extern/pybind11/tests/test_multiple_inheritance.py

 * *Ordering differences only*

```diff
@@ -1,493 +1,493 @@
-import pytest
-
-import env  # noqa: F401
-from pybind11_tests import ConstructorStats
-from pybind11_tests import multiple_inheritance as m
-
-
-def test_multiple_inheritance_cpp():
-    mt = m.MIType(3, 4)
-
-    assert mt.foo() == 3
-    assert mt.bar() == 4
-
-
-@pytest.mark.xfail("env.PYPY")
-def test_multiple_inheritance_mix1():
-    class Base1:
-        def __init__(self, i):
-            self.i = i
-
-        def foo(self):
-            return self.i
-
-    class MITypePy(Base1, m.Base2):
-        def __init__(self, i, j):
-            Base1.__init__(self, i)
-            m.Base2.__init__(self, j)
-
-    mt = MITypePy(3, 4)
-
-    assert mt.foo() == 3
-    assert mt.bar() == 4
-
-
-def test_multiple_inheritance_mix2():
-    class Base2:
-        def __init__(self, i):
-            self.i = i
-
-        def bar(self):
-            return self.i
-
-    class MITypePy(m.Base1, Base2):
-        def __init__(self, i, j):
-            m.Base1.__init__(self, i)
-            Base2.__init__(self, j)
-
-    mt = MITypePy(3, 4)
-
-    assert mt.foo() == 3
-    assert mt.bar() == 4
-
-
-@pytest.mark.xfail("env.PYPY")
-def test_multiple_inheritance_python():
-    class MI1(m.Base1, m.Base2):
-        def __init__(self, i, j):
-            m.Base1.__init__(self, i)
-            m.Base2.__init__(self, j)
-
-    class B1:
-        def v(self):
-            return 1
-
-    class MI2(B1, m.Base1, m.Base2):
-        def __init__(self, i, j):
-            B1.__init__(self)
-            m.Base1.__init__(self, i)
-            m.Base2.__init__(self, j)
-
-    class MI3(MI2):
-        def __init__(self, i, j):
-            MI2.__init__(self, i, j)
-
-    class MI4(MI3, m.Base2):
-        def __init__(self, i, j):
-            MI3.__init__(self, i, j)
-            # This should be ignored (Base2 is already initialized via MI2):
-            m.Base2.__init__(self, i + 100)
-
-    class MI5(m.Base2, B1, m.Base1):
-        def __init__(self, i, j):
-            B1.__init__(self)
-            m.Base1.__init__(self, i)
-            m.Base2.__init__(self, j)
-
-    class MI6(m.Base2, B1):
-        def __init__(self, i):
-            m.Base2.__init__(self, i)
-            B1.__init__(self)
-
-    class B2(B1):
-        def v(self):
-            return 2
-
-    class B3:
-        def v(self):
-            return 3
-
-    class B4(B3, B2):
-        def v(self):
-            return 4
-
-    class MI7(B4, MI6):
-        def __init__(self, i):
-            B4.__init__(self)
-            MI6.__init__(self, i)
-
-    class MI8(MI6, B3):
-        def __init__(self, i):
-            MI6.__init__(self, i)
-            B3.__init__(self)
-
-    class MI8b(B3, MI6):
-        def __init__(self, i):
-            B3.__init__(self)
-            MI6.__init__(self, i)
-
-    mi1 = MI1(1, 2)
-    assert mi1.foo() == 1
-    assert mi1.bar() == 2
-
-    mi2 = MI2(3, 4)
-    assert mi2.v() == 1
-    assert mi2.foo() == 3
-    assert mi2.bar() == 4
-
-    mi3 = MI3(5, 6)
-    assert mi3.v() == 1
-    assert mi3.foo() == 5
-    assert mi3.bar() == 6
-
-    mi4 = MI4(7, 8)
-    assert mi4.v() == 1
-    assert mi4.foo() == 7
-    assert mi4.bar() == 8
-
-    mi5 = MI5(10, 11)
-    assert mi5.v() == 1
-    assert mi5.foo() == 10
-    assert mi5.bar() == 11
-
-    mi6 = MI6(12)
-    assert mi6.v() == 1
-    assert mi6.bar() == 12
-
-    mi7 = MI7(13)
-    assert mi7.v() == 4
-    assert mi7.bar() == 13
-
-    mi8 = MI8(14)
-    assert mi8.v() == 1
-    assert mi8.bar() == 14
-
-    mi8b = MI8b(15)
-    assert mi8b.v() == 3
-    assert mi8b.bar() == 15
-
-
-def test_multiple_inheritance_python_many_bases():
-    class MIMany14(m.BaseN1, m.BaseN2, m.BaseN3, m.BaseN4):
-        def __init__(self):
-            m.BaseN1.__init__(self, 1)
-            m.BaseN2.__init__(self, 2)
-            m.BaseN3.__init__(self, 3)
-            m.BaseN4.__init__(self, 4)
-
-    class MIMany58(m.BaseN5, m.BaseN6, m.BaseN7, m.BaseN8):
-        def __init__(self):
-            m.BaseN5.__init__(self, 5)
-            m.BaseN6.__init__(self, 6)
-            m.BaseN7.__init__(self, 7)
-            m.BaseN8.__init__(self, 8)
-
-    class MIMany916(
-        m.BaseN9,
-        m.BaseN10,
-        m.BaseN11,
-        m.BaseN12,
-        m.BaseN13,
-        m.BaseN14,
-        m.BaseN15,
-        m.BaseN16,
-    ):
-        def __init__(self):
-            m.BaseN9.__init__(self, 9)
-            m.BaseN10.__init__(self, 10)
-            m.BaseN11.__init__(self, 11)
-            m.BaseN12.__init__(self, 12)
-            m.BaseN13.__init__(self, 13)
-            m.BaseN14.__init__(self, 14)
-            m.BaseN15.__init__(self, 15)
-            m.BaseN16.__init__(self, 16)
-
-    class MIMany19(MIMany14, MIMany58, m.BaseN9):
-        def __init__(self):
-            MIMany14.__init__(self)
-            MIMany58.__init__(self)
-            m.BaseN9.__init__(self, 9)
-
-    class MIMany117(MIMany14, MIMany58, MIMany916, m.BaseN17):
-        def __init__(self):
-            MIMany14.__init__(self)
-            MIMany58.__init__(self)
-            MIMany916.__init__(self)
-            m.BaseN17.__init__(self, 17)
-
-    # Inherits from 4 registered C++ classes: can fit in one pointer on any modern arch:
-    a = MIMany14()
-    for i in range(1, 4):
-        assert getattr(a, "f" + str(i))() == 2 * i
-
-    # Inherits from 8: requires 1/2 pointers worth of holder flags on 32/64-bit arch:
-    b = MIMany916()
-    for i in range(9, 16):
-        assert getattr(b, "f" + str(i))() == 2 * i
-
-    # Inherits from 9: requires >= 2 pointers worth of holder flags
-    c = MIMany19()
-    for i in range(1, 9):
-        assert getattr(c, "f" + str(i))() == 2 * i
-
-    # Inherits from 17: requires >= 3 pointers worth of holder flags
-    d = MIMany117()
-    for i in range(1, 17):
-        assert getattr(d, "f" + str(i))() == 2 * i
-
-
-def test_multiple_inheritance_virtbase():
-    class MITypePy(m.Base12a):
-        def __init__(self, i, j):
-            m.Base12a.__init__(self, i, j)
-
-    mt = MITypePy(3, 4)
-    assert mt.bar() == 4
-    assert m.bar_base2a(mt) == 4
-    assert m.bar_base2a_sharedptr(mt) == 4
-
-
-def test_mi_static_properties():
-    """Mixing bases with and without static properties should be possible
-    and the result should be independent of base definition order"""
-
-    for d in (m.VanillaStaticMix1(), m.VanillaStaticMix2()):
-        assert d.vanilla() == "Vanilla"
-        assert d.static_func1() == "WithStatic1"
-        assert d.static_func2() == "WithStatic2"
-        assert d.static_func() == d.__class__.__name__
-
-        m.WithStatic1.static_value1 = 1
-        m.WithStatic2.static_value2 = 2
-        assert d.static_value1 == 1
-        assert d.static_value2 == 2
-        assert d.static_value == 12
-
-        d.static_value1 = 0
-        assert d.static_value1 == 0
-        d.static_value2 = 0
-        assert d.static_value2 == 0
-        d.static_value = 0
-        assert d.static_value == 0
-
-
-# Requires PyPy 6+
-def test_mi_dynamic_attributes():
-    """Mixing bases with and without dynamic attribute support"""
-
-    for d in (m.VanillaDictMix1(), m.VanillaDictMix2()):
-        d.dynamic = 1
-        assert d.dynamic == 1
-
-
-def test_mi_unaligned_base():
-    """Returning an offset (non-first MI) base class pointer should recognize the instance"""
-
-    n_inst = ConstructorStats.detail_reg_inst()
-
-    c = m.I801C()
-    d = m.I801D()
-    # + 4 below because we have the two instances, and each instance has offset base I801B2
-    assert ConstructorStats.detail_reg_inst() == n_inst + 4
-    b1c = m.i801b1_c(c)
-    assert b1c is c
-    b2c = m.i801b2_c(c)
-    assert b2c is c
-    b1d = m.i801b1_d(d)
-    assert b1d is d
-    b2d = m.i801b2_d(d)
-    assert b2d is d
-
-    assert ConstructorStats.detail_reg_inst() == n_inst + 4  # no extra instances
-    del c, b1c, b2c
-    assert ConstructorStats.detail_reg_inst() == n_inst + 2
-    del d, b1d, b2d
-    assert ConstructorStats.detail_reg_inst() == n_inst
-
-
-def test_mi_base_return():
-    """Tests returning an offset (non-first MI) base class pointer to a derived instance"""
-
-    n_inst = ConstructorStats.detail_reg_inst()
-
-    c1 = m.i801c_b1()
-    assert type(c1) is m.I801C
-    assert c1.a == 1
-    assert c1.b == 2
-
-    d1 = m.i801d_b1()
-    assert type(d1) is m.I801D
-    assert d1.a == 1
-    assert d1.b == 2
-
-    assert ConstructorStats.detail_reg_inst() == n_inst + 4
-
-    c2 = m.i801c_b2()
-    assert type(c2) is m.I801C
-    assert c2.a == 1
-    assert c2.b == 2
-
-    d2 = m.i801d_b2()
-    assert type(d2) is m.I801D
-    assert d2.a == 1
-    assert d2.b == 2
-
-    assert ConstructorStats.detail_reg_inst() == n_inst + 8
-
-    del c2
-    assert ConstructorStats.detail_reg_inst() == n_inst + 6
-    del c1, d1, d2
-    assert ConstructorStats.detail_reg_inst() == n_inst
-
-    # Returning an unregistered derived type with a registered base; we won't
-    # pick up the derived type, obviously, but should still work (as an object
-    # of whatever type was returned).
-    e1 = m.i801e_c()
-    assert type(e1) is m.I801C
-    assert e1.a == 1
-    assert e1.b == 2
-
-    e2 = m.i801e_b2()
-    assert type(e2) is m.I801B2
-    assert e2.b == 2
-
-
-def test_diamond_inheritance():
-    """Tests that diamond inheritance works as expected (issue #959)"""
-
-    # Issue #959: this shouldn't segfault:
-    d = m.D()
-
-    # Make sure all the various distinct pointers are all recognized as registered instances:
-    assert d is d.c0()
-    assert d is d.c1()
-    assert d is d.b()
-    assert d is d.c0().b()
-    assert d is d.c1().b()
-    assert d is d.c0().c1().b().c0().b()
-
-
-def test_pr3635_diamond_b():
-    o = m.MVB()
-    assert o.b == 1
-
-    assert o.get_b_b() == 1
-
-
-def test_pr3635_diamond_c():
-    o = m.MVC()
-    assert o.b == 1
-    assert o.c == 2
-
-    assert o.get_b_b() == 1
-    assert o.get_c_b() == 1
-
-    assert o.get_c_c() == 2
-
-
-def test_pr3635_diamond_d0():
-    o = m.MVD0()
-    assert o.b == 1
-    assert o.c == 2
-    assert o.d0 == 3
-
-    assert o.get_b_b() == 1
-    assert o.get_c_b() == 1
-    assert o.get_d0_b() == 1
-
-    assert o.get_c_c() == 2
-    assert o.get_d0_c() == 2
-
-    assert o.get_d0_d0() == 3
-
-
-def test_pr3635_diamond_d1():
-    o = m.MVD1()
-    assert o.b == 1
-    assert o.c == 2
-    assert o.d1 == 4
-
-    assert o.get_b_b() == 1
-    assert o.get_c_b() == 1
-    assert o.get_d1_b() == 1
-
-    assert o.get_c_c() == 2
-    assert o.get_d1_c() == 2
-
-    assert o.get_d1_d1() == 4
-
-
-def test_pr3635_diamond_e():
-    o = m.MVE()
-    assert o.b == 1
-    assert o.c == 2
-    assert o.d0 == 3
-    assert o.d1 == 4
-    assert o.e == 5
-
-    assert o.get_b_b() == 1
-    assert o.get_c_b() == 1
-    assert o.get_d0_b() == 1
-    assert o.get_d1_b() == 1
-    assert o.get_e_b() == 1
-
-    assert o.get_c_c() == 2
-    assert o.get_d0_c() == 2
-    assert o.get_d1_c() == 2
-    assert o.get_e_c() == 2
-
-    assert o.get_d0_d0() == 3
-    assert o.get_e_d0() == 3
-
-    assert o.get_d1_d1() == 4
-    assert o.get_e_d1() == 4
-
-    assert o.get_e_e() == 5
-
-
-def test_pr3635_diamond_f():
-    o = m.MVF()
-    assert o.b == 1
-    assert o.c == 2
-    assert o.d0 == 3
-    assert o.d1 == 4
-    assert o.e == 5
-    assert o.f == 6
-
-    assert o.get_b_b() == 1
-    assert o.get_c_b() == 1
-    assert o.get_d0_b() == 1
-    assert o.get_d1_b() == 1
-    assert o.get_e_b() == 1
-    assert o.get_f_b() == 1
-
-    assert o.get_c_c() == 2
-    assert o.get_d0_c() == 2
-    assert o.get_d1_c() == 2
-    assert o.get_e_c() == 2
-    assert o.get_f_c() == 2
-
-    assert o.get_d0_d0() == 3
-    assert o.get_e_d0() == 3
-    assert o.get_f_d0() == 3
-
-    assert o.get_d1_d1() == 4
-    assert o.get_e_d1() == 4
-    assert o.get_f_d1() == 4
-
-    assert o.get_e_e() == 5
-    assert o.get_f_e() == 5
-
-    assert o.get_f_f() == 6
-
-
-def test_python_inherit_from_mi():
-    """Tests extending a Python class from a single inheritor of a MI class"""
-
-    class PyMVF(m.MVF):
-        g = 7
-
-        def get_g_g(self):
-            return self.g
-
-    o = PyMVF()
-
-    assert o.b == 1
-    assert o.c == 2
-    assert o.d0 == 3
-    assert o.d1 == 4
-    assert o.e == 5
-    assert o.f == 6
-    assert o.g == 7
-
-    assert o.get_g_g() == 7
+import pytest
+
+import env  # noqa: F401
+from pybind11_tests import ConstructorStats
+from pybind11_tests import multiple_inheritance as m
+
+
+def test_multiple_inheritance_cpp():
+    mt = m.MIType(3, 4)
+
+    assert mt.foo() == 3
+    assert mt.bar() == 4
+
+
+@pytest.mark.xfail("env.PYPY")
+def test_multiple_inheritance_mix1():
+    class Base1:
+        def __init__(self, i):
+            self.i = i
+
+        def foo(self):
+            return self.i
+
+    class MITypePy(Base1, m.Base2):
+        def __init__(self, i, j):
+            Base1.__init__(self, i)
+            m.Base2.__init__(self, j)
+
+    mt = MITypePy(3, 4)
+
+    assert mt.foo() == 3
+    assert mt.bar() == 4
+
+
+def test_multiple_inheritance_mix2():
+    class Base2:
+        def __init__(self, i):
+            self.i = i
+
+        def bar(self):
+            return self.i
+
+    class MITypePy(m.Base1, Base2):
+        def __init__(self, i, j):
+            m.Base1.__init__(self, i)
+            Base2.__init__(self, j)
+
+    mt = MITypePy(3, 4)
+
+    assert mt.foo() == 3
+    assert mt.bar() == 4
+
+
+@pytest.mark.xfail("env.PYPY")
+def test_multiple_inheritance_python():
+    class MI1(m.Base1, m.Base2):
+        def __init__(self, i, j):
+            m.Base1.__init__(self, i)
+            m.Base2.__init__(self, j)
+
+    class B1:
+        def v(self):
+            return 1
+
+    class MI2(B1, m.Base1, m.Base2):
+        def __init__(self, i, j):
+            B1.__init__(self)
+            m.Base1.__init__(self, i)
+            m.Base2.__init__(self, j)
+
+    class MI3(MI2):
+        def __init__(self, i, j):
+            MI2.__init__(self, i, j)
+
+    class MI4(MI3, m.Base2):
+        def __init__(self, i, j):
+            MI3.__init__(self, i, j)
+            # This should be ignored (Base2 is already initialized via MI2):
+            m.Base2.__init__(self, i + 100)
+
+    class MI5(m.Base2, B1, m.Base1):
+        def __init__(self, i, j):
+            B1.__init__(self)
+            m.Base1.__init__(self, i)
+            m.Base2.__init__(self, j)
+
+    class MI6(m.Base2, B1):
+        def __init__(self, i):
+            m.Base2.__init__(self, i)
+            B1.__init__(self)
+
+    class B2(B1):
+        def v(self):
+            return 2
+
+    class B3:
+        def v(self):
+            return 3
+
+    class B4(B3, B2):
+        def v(self):
+            return 4
+
+    class MI7(B4, MI6):
+        def __init__(self, i):
+            B4.__init__(self)
+            MI6.__init__(self, i)
+
+    class MI8(MI6, B3):
+        def __init__(self, i):
+            MI6.__init__(self, i)
+            B3.__init__(self)
+
+    class MI8b(B3, MI6):
+        def __init__(self, i):
+            B3.__init__(self)
+            MI6.__init__(self, i)
+
+    mi1 = MI1(1, 2)
+    assert mi1.foo() == 1
+    assert mi1.bar() == 2
+
+    mi2 = MI2(3, 4)
+    assert mi2.v() == 1
+    assert mi2.foo() == 3
+    assert mi2.bar() == 4
+
+    mi3 = MI3(5, 6)
+    assert mi3.v() == 1
+    assert mi3.foo() == 5
+    assert mi3.bar() == 6
+
+    mi4 = MI4(7, 8)
+    assert mi4.v() == 1
+    assert mi4.foo() == 7
+    assert mi4.bar() == 8
+
+    mi5 = MI5(10, 11)
+    assert mi5.v() == 1
+    assert mi5.foo() == 10
+    assert mi5.bar() == 11
+
+    mi6 = MI6(12)
+    assert mi6.v() == 1
+    assert mi6.bar() == 12
+
+    mi7 = MI7(13)
+    assert mi7.v() == 4
+    assert mi7.bar() == 13
+
+    mi8 = MI8(14)
+    assert mi8.v() == 1
+    assert mi8.bar() == 14
+
+    mi8b = MI8b(15)
+    assert mi8b.v() == 3
+    assert mi8b.bar() == 15
+
+
+def test_multiple_inheritance_python_many_bases():
+    class MIMany14(m.BaseN1, m.BaseN2, m.BaseN3, m.BaseN4):
+        def __init__(self):
+            m.BaseN1.__init__(self, 1)
+            m.BaseN2.__init__(self, 2)
+            m.BaseN3.__init__(self, 3)
+            m.BaseN4.__init__(self, 4)
+
+    class MIMany58(m.BaseN5, m.BaseN6, m.BaseN7, m.BaseN8):
+        def __init__(self):
+            m.BaseN5.__init__(self, 5)
+            m.BaseN6.__init__(self, 6)
+            m.BaseN7.__init__(self, 7)
+            m.BaseN8.__init__(self, 8)
+
+    class MIMany916(
+        m.BaseN9,
+        m.BaseN10,
+        m.BaseN11,
+        m.BaseN12,
+        m.BaseN13,
+        m.BaseN14,
+        m.BaseN15,
+        m.BaseN16,
+    ):
+        def __init__(self):
+            m.BaseN9.__init__(self, 9)
+            m.BaseN10.__init__(self, 10)
+            m.BaseN11.__init__(self, 11)
+            m.BaseN12.__init__(self, 12)
+            m.BaseN13.__init__(self, 13)
+            m.BaseN14.__init__(self, 14)
+            m.BaseN15.__init__(self, 15)
+            m.BaseN16.__init__(self, 16)
+
+    class MIMany19(MIMany14, MIMany58, m.BaseN9):
+        def __init__(self):
+            MIMany14.__init__(self)
+            MIMany58.__init__(self)
+            m.BaseN9.__init__(self, 9)
+
+    class MIMany117(MIMany14, MIMany58, MIMany916, m.BaseN17):
+        def __init__(self):
+            MIMany14.__init__(self)
+            MIMany58.__init__(self)
+            MIMany916.__init__(self)
+            m.BaseN17.__init__(self, 17)
+
+    # Inherits from 4 registered C++ classes: can fit in one pointer on any modern arch:
+    a = MIMany14()
+    for i in range(1, 4):
+        assert getattr(a, "f" + str(i))() == 2 * i
+
+    # Inherits from 8: requires 1/2 pointers worth of holder flags on 32/64-bit arch:
+    b = MIMany916()
+    for i in range(9, 16):
+        assert getattr(b, "f" + str(i))() == 2 * i
+
+    # Inherits from 9: requires >= 2 pointers worth of holder flags
+    c = MIMany19()
+    for i in range(1, 9):
+        assert getattr(c, "f" + str(i))() == 2 * i
+
+    # Inherits from 17: requires >= 3 pointers worth of holder flags
+    d = MIMany117()
+    for i in range(1, 17):
+        assert getattr(d, "f" + str(i))() == 2 * i
+
+
+def test_multiple_inheritance_virtbase():
+    class MITypePy(m.Base12a):
+        def __init__(self, i, j):
+            m.Base12a.__init__(self, i, j)
+
+    mt = MITypePy(3, 4)
+    assert mt.bar() == 4
+    assert m.bar_base2a(mt) == 4
+    assert m.bar_base2a_sharedptr(mt) == 4
+
+
+def test_mi_static_properties():
+    """Mixing bases with and without static properties should be possible
+    and the result should be independent of base definition order"""
+
+    for d in (m.VanillaStaticMix1(), m.VanillaStaticMix2()):
+        assert d.vanilla() == "Vanilla"
+        assert d.static_func1() == "WithStatic1"
+        assert d.static_func2() == "WithStatic2"
+        assert d.static_func() == d.__class__.__name__
+
+        m.WithStatic1.static_value1 = 1
+        m.WithStatic2.static_value2 = 2
+        assert d.static_value1 == 1
+        assert d.static_value2 == 2
+        assert d.static_value == 12
+
+        d.static_value1 = 0
+        assert d.static_value1 == 0
+        d.static_value2 = 0
+        assert d.static_value2 == 0
+        d.static_value = 0
+        assert d.static_value == 0
+
+
+# Requires PyPy 6+
+def test_mi_dynamic_attributes():
+    """Mixing bases with and without dynamic attribute support"""
+
+    for d in (m.VanillaDictMix1(), m.VanillaDictMix2()):
+        d.dynamic = 1
+        assert d.dynamic == 1
+
+
+def test_mi_unaligned_base():
+    """Returning an offset (non-first MI) base class pointer should recognize the instance"""
+
+    n_inst = ConstructorStats.detail_reg_inst()
+
+    c = m.I801C()
+    d = m.I801D()
+    # + 4 below because we have the two instances, and each instance has offset base I801B2
+    assert ConstructorStats.detail_reg_inst() == n_inst + 4
+    b1c = m.i801b1_c(c)
+    assert b1c is c
+    b2c = m.i801b2_c(c)
+    assert b2c is c
+    b1d = m.i801b1_d(d)
+    assert b1d is d
+    b2d = m.i801b2_d(d)
+    assert b2d is d
+
+    assert ConstructorStats.detail_reg_inst() == n_inst + 4  # no extra instances
+    del c, b1c, b2c
+    assert ConstructorStats.detail_reg_inst() == n_inst + 2
+    del d, b1d, b2d
+    assert ConstructorStats.detail_reg_inst() == n_inst
+
+
+def test_mi_base_return():
+    """Tests returning an offset (non-first MI) base class pointer to a derived instance"""
+
+    n_inst = ConstructorStats.detail_reg_inst()
+
+    c1 = m.i801c_b1()
+    assert type(c1) is m.I801C
+    assert c1.a == 1
+    assert c1.b == 2
+
+    d1 = m.i801d_b1()
+    assert type(d1) is m.I801D
+    assert d1.a == 1
+    assert d1.b == 2
+
+    assert ConstructorStats.detail_reg_inst() == n_inst + 4
+
+    c2 = m.i801c_b2()
+    assert type(c2) is m.I801C
+    assert c2.a == 1
+    assert c2.b == 2
+
+    d2 = m.i801d_b2()
+    assert type(d2) is m.I801D
+    assert d2.a == 1
+    assert d2.b == 2
+
+    assert ConstructorStats.detail_reg_inst() == n_inst + 8
+
+    del c2
+    assert ConstructorStats.detail_reg_inst() == n_inst + 6
+    del c1, d1, d2
+    assert ConstructorStats.detail_reg_inst() == n_inst
+
+    # Returning an unregistered derived type with a registered base; we won't
+    # pick up the derived type, obviously, but should still work (as an object
+    # of whatever type was returned).
+    e1 = m.i801e_c()
+    assert type(e1) is m.I801C
+    assert e1.a == 1
+    assert e1.b == 2
+
+    e2 = m.i801e_b2()
+    assert type(e2) is m.I801B2
+    assert e2.b == 2
+
+
+def test_diamond_inheritance():
+    """Tests that diamond inheritance works as expected (issue #959)"""
+
+    # Issue #959: this shouldn't segfault:
+    d = m.D()
+
+    # Make sure all the various distinct pointers are all recognized as registered instances:
+    assert d is d.c0()
+    assert d is d.c1()
+    assert d is d.b()
+    assert d is d.c0().b()
+    assert d is d.c1().b()
+    assert d is d.c0().c1().b().c0().b()
+
+
+def test_pr3635_diamond_b():
+    o = m.MVB()
+    assert o.b == 1
+
+    assert o.get_b_b() == 1
+
+
+def test_pr3635_diamond_c():
+    o = m.MVC()
+    assert o.b == 1
+    assert o.c == 2
+
+    assert o.get_b_b() == 1
+    assert o.get_c_b() == 1
+
+    assert o.get_c_c() == 2
+
+
+def test_pr3635_diamond_d0():
+    o = m.MVD0()
+    assert o.b == 1
+    assert o.c == 2
+    assert o.d0 == 3
+
+    assert o.get_b_b() == 1
+    assert o.get_c_b() == 1
+    assert o.get_d0_b() == 1
+
+    assert o.get_c_c() == 2
+    assert o.get_d0_c() == 2
+
+    assert o.get_d0_d0() == 3
+
+
+def test_pr3635_diamond_d1():
+    o = m.MVD1()
+    assert o.b == 1
+    assert o.c == 2
+    assert o.d1 == 4
+
+    assert o.get_b_b() == 1
+    assert o.get_c_b() == 1
+    assert o.get_d1_b() == 1
+
+    assert o.get_c_c() == 2
+    assert o.get_d1_c() == 2
+
+    assert o.get_d1_d1() == 4
+
+
+def test_pr3635_diamond_e():
+    o = m.MVE()
+    assert o.b == 1
+    assert o.c == 2
+    assert o.d0 == 3
+    assert o.d1 == 4
+    assert o.e == 5
+
+    assert o.get_b_b() == 1
+    assert o.get_c_b() == 1
+    assert o.get_d0_b() == 1
+    assert o.get_d1_b() == 1
+    assert o.get_e_b() == 1
+
+    assert o.get_c_c() == 2
+    assert o.get_d0_c() == 2
+    assert o.get_d1_c() == 2
+    assert o.get_e_c() == 2
+
+    assert o.get_d0_d0() == 3
+    assert o.get_e_d0() == 3
+
+    assert o.get_d1_d1() == 4
+    assert o.get_e_d1() == 4
+
+    assert o.get_e_e() == 5
+
+
+def test_pr3635_diamond_f():
+    o = m.MVF()
+    assert o.b == 1
+    assert o.c == 2
+    assert o.d0 == 3
+    assert o.d1 == 4
+    assert o.e == 5
+    assert o.f == 6
+
+    assert o.get_b_b() == 1
+    assert o.get_c_b() == 1
+    assert o.get_d0_b() == 1
+    assert o.get_d1_b() == 1
+    assert o.get_e_b() == 1
+    assert o.get_f_b() == 1
+
+    assert o.get_c_c() == 2
+    assert o.get_d0_c() == 2
+    assert o.get_d1_c() == 2
+    assert o.get_e_c() == 2
+    assert o.get_f_c() == 2
+
+    assert o.get_d0_d0() == 3
+    assert o.get_e_d0() == 3
+    assert o.get_f_d0() == 3
+
+    assert o.get_d1_d1() == 4
+    assert o.get_e_d1() == 4
+    assert o.get_f_d1() == 4
+
+    assert o.get_e_e() == 5
+    assert o.get_f_e() == 5
+
+    assert o.get_f_f() == 6
+
+
+def test_python_inherit_from_mi():
+    """Tests extending a Python class from a single inheritor of a MI class"""
+
+    class PyMVF(m.MVF):
+        g = 7
+
+        def get_g_g(self):
+            return self.g
+
+    o = PyMVF()
+
+    assert o.b == 1
+    assert o.c == 2
+    assert o.d0 == 3
+    assert o.d1 == 4
+    assert o.e == 5
+    assert o.f == 6
+    assert o.g == 7
+
+    assert o.get_g_g() == 7
```

## extern/pybind11/tests/test_numpy_array.py

 * *Ordering differences only*

```diff
@@ -1,593 +1,593 @@
-import pytest
-
-import env  # noqa: F401
-from pybind11_tests import numpy_array as m
-
-np = pytest.importorskip("numpy")
-
-
-def test_dtypes():
-    # See issue #1328.
-    # - Platform-dependent sizes.
-    for size_check in m.get_platform_dtype_size_checks():
-        print(size_check)
-        assert size_check.size_cpp == size_check.size_numpy, size_check
-    # - Concrete sizes.
-    for check in m.get_concrete_dtype_checks():
-        print(check)
-        assert check.numpy == check.pybind11, check
-        if check.numpy.num != check.pybind11.num:
-            print(
-                f"NOTE: typenum mismatch for {check}: {check.numpy.num} != {check.pybind11.num}"
-            )
-
-
-@pytest.fixture(scope="function")
-def arr():
-    return np.array([[1, 2, 3], [4, 5, 6]], "=u2")
-
-
-def test_array_attributes():
-    a = np.array(0, "f8")
-    assert m.ndim(a) == 0
-    assert all(m.shape(a) == [])
-    assert all(m.strides(a) == [])
-    with pytest.raises(IndexError) as excinfo:
-        m.shape(a, 0)
-    assert str(excinfo.value) == "invalid axis: 0 (ndim = 0)"
-    with pytest.raises(IndexError) as excinfo:
-        m.strides(a, 0)
-    assert str(excinfo.value) == "invalid axis: 0 (ndim = 0)"
-    assert m.writeable(a)
-    assert m.size(a) == 1
-    assert m.itemsize(a) == 8
-    assert m.nbytes(a) == 8
-    assert m.owndata(a)
-
-    a = np.array([[1, 2, 3], [4, 5, 6]], "u2").view()
-    a.flags.writeable = False
-    assert m.ndim(a) == 2
-    assert all(m.shape(a) == [2, 3])
-    assert m.shape(a, 0) == 2
-    assert m.shape(a, 1) == 3
-    assert all(m.strides(a) == [6, 2])
-    assert m.strides(a, 0) == 6
-    assert m.strides(a, 1) == 2
-    with pytest.raises(IndexError) as excinfo:
-        m.shape(a, 2)
-    assert str(excinfo.value) == "invalid axis: 2 (ndim = 2)"
-    with pytest.raises(IndexError) as excinfo:
-        m.strides(a, 2)
-    assert str(excinfo.value) == "invalid axis: 2 (ndim = 2)"
-    assert not m.writeable(a)
-    assert m.size(a) == 6
-    assert m.itemsize(a) == 2
-    assert m.nbytes(a) == 12
-    assert not m.owndata(a)
-
-
-@pytest.mark.parametrize(
-    "args, ret", [([], 0), ([0], 0), ([1], 3), ([0, 1], 1), ([1, 2], 5)]
-)
-def test_index_offset(arr, args, ret):
-    assert m.index_at(arr, *args) == ret
-    assert m.index_at_t(arr, *args) == ret
-    assert m.offset_at(arr, *args) == ret * arr.dtype.itemsize
-    assert m.offset_at_t(arr, *args) == ret * arr.dtype.itemsize
-
-
-def test_dim_check_fail(arr):
-    for func in (
-        m.index_at,
-        m.index_at_t,
-        m.offset_at,
-        m.offset_at_t,
-        m.data,
-        m.data_t,
-        m.mutate_data,
-        m.mutate_data_t,
-    ):
-        with pytest.raises(IndexError) as excinfo:
-            func(arr, 1, 2, 3)
-        assert str(excinfo.value) == "too many indices for an array: 3 (ndim = 2)"
-
-
-@pytest.mark.parametrize(
-    "args, ret",
-    [
-        ([], [1, 2, 3, 4, 5, 6]),
-        ([1], [4, 5, 6]),
-        ([0, 1], [2, 3, 4, 5, 6]),
-        ([1, 2], [6]),
-    ],
-)
-def test_data(arr, args, ret):
-    from sys import byteorder
-
-    assert all(m.data_t(arr, *args) == ret)
-    assert all(m.data(arr, *args)[(0 if byteorder == "little" else 1) :: 2] == ret)
-    assert all(m.data(arr, *args)[(1 if byteorder == "little" else 0) :: 2] == 0)
-
-
-@pytest.mark.parametrize("dim", [0, 1, 3])
-def test_at_fail(arr, dim):
-    for func in m.at_t, m.mutate_at_t:
-        with pytest.raises(IndexError) as excinfo:
-            func(arr, *([0] * dim))
-        assert str(excinfo.value) == f"index dimension mismatch: {dim} (ndim = 2)"
-
-
-def test_at(arr):
-    assert m.at_t(arr, 0, 2) == 3
-    assert m.at_t(arr, 1, 0) == 4
-
-    assert all(m.mutate_at_t(arr, 0, 2).ravel() == [1, 2, 4, 4, 5, 6])
-    assert all(m.mutate_at_t(arr, 1, 0).ravel() == [1, 2, 4, 5, 5, 6])
-
-
-def test_mutate_readonly(arr):
-    arr.flags.writeable = False
-    for func, args in (
-        (m.mutate_data, ()),
-        (m.mutate_data_t, ()),
-        (m.mutate_at_t, (0, 0)),
-    ):
-        with pytest.raises(ValueError) as excinfo:
-            func(arr, *args)
-        assert str(excinfo.value) == "array is not writeable"
-
-
-def test_mutate_data(arr):
-    assert all(m.mutate_data(arr).ravel() == [2, 4, 6, 8, 10, 12])
-    assert all(m.mutate_data(arr).ravel() == [4, 8, 12, 16, 20, 24])
-    assert all(m.mutate_data(arr, 1).ravel() == [4, 8, 12, 32, 40, 48])
-    assert all(m.mutate_data(arr, 0, 1).ravel() == [4, 16, 24, 64, 80, 96])
-    assert all(m.mutate_data(arr, 1, 2).ravel() == [4, 16, 24, 64, 80, 192])
-
-    assert all(m.mutate_data_t(arr).ravel() == [5, 17, 25, 65, 81, 193])
-    assert all(m.mutate_data_t(arr).ravel() == [6, 18, 26, 66, 82, 194])
-    assert all(m.mutate_data_t(arr, 1).ravel() == [6, 18, 26, 67, 83, 195])
-    assert all(m.mutate_data_t(arr, 0, 1).ravel() == [6, 19, 27, 68, 84, 196])
-    assert all(m.mutate_data_t(arr, 1, 2).ravel() == [6, 19, 27, 68, 84, 197])
-
-
-def test_bounds_check(arr):
-    for func in (
-        m.index_at,
-        m.index_at_t,
-        m.data,
-        m.data_t,
-        m.mutate_data,
-        m.mutate_data_t,
-        m.at_t,
-        m.mutate_at_t,
-    ):
-        with pytest.raises(IndexError) as excinfo:
-            func(arr, 2, 0)
-        assert str(excinfo.value) == "index 2 is out of bounds for axis 0 with size 2"
-        with pytest.raises(IndexError) as excinfo:
-            func(arr, 0, 4)
-        assert str(excinfo.value) == "index 4 is out of bounds for axis 1 with size 3"
-
-
-def test_make_c_f_array():
-    assert m.make_c_array().flags.c_contiguous
-    assert not m.make_c_array().flags.f_contiguous
-    assert m.make_f_array().flags.f_contiguous
-    assert not m.make_f_array().flags.c_contiguous
-
-
-def test_make_empty_shaped_array():
-    m.make_empty_shaped_array()
-
-    # empty shape means numpy scalar, PEP 3118
-    assert m.scalar_int().ndim == 0
-    assert m.scalar_int().shape == ()
-    assert m.scalar_int() == 42
-
-
-def test_wrap():
-    def assert_references(a, b, base=None):
-        if base is None:
-            base = a
-        assert a is not b
-        assert a.__array_interface__["data"][0] == b.__array_interface__["data"][0]
-        assert a.shape == b.shape
-        assert a.strides == b.strides
-        assert a.flags.c_contiguous == b.flags.c_contiguous
-        assert a.flags.f_contiguous == b.flags.f_contiguous
-        assert a.flags.writeable == b.flags.writeable
-        assert a.flags.aligned == b.flags.aligned
-        # 1.13 supported Python 3.6
-        if tuple(int(x) for x in np.__version__.split(".")[:2]) >= (1, 14):
-            assert a.flags.writebackifcopy == b.flags.writebackifcopy
-        else:
-            assert a.flags.updateifcopy == b.flags.updateifcopy
-        assert np.all(a == b)
-        assert not b.flags.owndata
-        assert b.base is base
-        if a.flags.writeable and a.ndim == 2:
-            a[0, 0] = 1234
-            assert b[0, 0] == 1234
-
-    a1 = np.array([1, 2], dtype=np.int16)
-    assert a1.flags.owndata and a1.base is None
-    a2 = m.wrap(a1)
-    assert_references(a1, a2)
-
-    a1 = np.array([[1, 2], [3, 4]], dtype=np.float32, order="F")
-    assert a1.flags.owndata and a1.base is None
-    a2 = m.wrap(a1)
-    assert_references(a1, a2)
-
-    a1 = np.array([[1, 2], [3, 4]], dtype=np.float32, order="C")
-    a1.flags.writeable = False
-    a2 = m.wrap(a1)
-    assert_references(a1, a2)
-
-    a1 = np.random.random((4, 4, 4))
-    a2 = m.wrap(a1)
-    assert_references(a1, a2)
-
-    a1t = a1.transpose()
-    a2 = m.wrap(a1t)
-    assert_references(a1t, a2, a1)
-
-    a1d = a1.diagonal()
-    a2 = m.wrap(a1d)
-    assert_references(a1d, a2, a1)
-
-    a1m = a1[::-1, ::-1, ::-1]
-    a2 = m.wrap(a1m)
-    assert_references(a1m, a2, a1)
-
-
-def test_numpy_view(capture):
-    with capture:
-        ac = m.ArrayClass()
-        ac_view_1 = ac.numpy_view()
-        ac_view_2 = ac.numpy_view()
-        assert np.all(ac_view_1 == np.array([1, 2], dtype=np.int32))
-        del ac
-        pytest.gc_collect()
-    assert (
-        capture
-        == """
-        ArrayClass()
-        ArrayClass::numpy_view()
-        ArrayClass::numpy_view()
-    """
-    )
-    ac_view_1[0] = 4
-    ac_view_1[1] = 3
-    assert ac_view_2[0] == 4
-    assert ac_view_2[1] == 3
-    with capture:
-        del ac_view_1
-        del ac_view_2
-        pytest.gc_collect()
-        pytest.gc_collect()
-    assert (
-        capture
-        == """
-        ~ArrayClass()
-    """
-    )
-
-
-def test_cast_numpy_int64_to_uint64():
-    m.function_taking_uint64(123)
-    m.function_taking_uint64(np.uint64(123))
-
-
-def test_isinstance():
-    assert m.isinstance_untyped(np.array([1, 2, 3]), "not an array")
-    assert m.isinstance_typed(np.array([1.0, 2.0, 3.0]))
-
-
-def test_constructors():
-    defaults = m.default_constructors()
-    for a in defaults.values():
-        assert a.size == 0
-    assert defaults["array"].dtype == np.array([]).dtype
-    assert defaults["array_t<int32>"].dtype == np.int32
-    assert defaults["array_t<double>"].dtype == np.float64
-
-    results = m.converting_constructors([1, 2, 3])
-    for a in results.values():
-        np.testing.assert_array_equal(a, [1, 2, 3])
-    assert results["array"].dtype == np.int_
-    assert results["array_t<int32>"].dtype == np.int32
-    assert results["array_t<double>"].dtype == np.float64
-
-
-def test_overload_resolution(msg):
-    # Exact overload matches:
-    assert m.overloaded(np.array([1], dtype="float64")) == "double"
-    assert m.overloaded(np.array([1], dtype="float32")) == "float"
-    assert m.overloaded(np.array([1], dtype="ushort")) == "unsigned short"
-    assert m.overloaded(np.array([1], dtype="intc")) == "int"
-    assert m.overloaded(np.array([1], dtype="longlong")) == "long long"
-    assert m.overloaded(np.array([1], dtype="complex")) == "double complex"
-    assert m.overloaded(np.array([1], dtype="csingle")) == "float complex"
-
-    # No exact match, should call first convertible version:
-    assert m.overloaded(np.array([1], dtype="uint8")) == "double"
-
-    with pytest.raises(TypeError) as excinfo:
-        m.overloaded("not an array")
-    assert (
-        msg(excinfo.value)
-        == """
-        overloaded(): incompatible function arguments. The following argument types are supported:
-            1. (arg0: numpy.ndarray[numpy.float64]) -> str
-            2. (arg0: numpy.ndarray[numpy.float32]) -> str
-            3. (arg0: numpy.ndarray[numpy.int32]) -> str
-            4. (arg0: numpy.ndarray[numpy.uint16]) -> str
-            5. (arg0: numpy.ndarray[numpy.int64]) -> str
-            6. (arg0: numpy.ndarray[numpy.complex128]) -> str
-            7. (arg0: numpy.ndarray[numpy.complex64]) -> str
-
-        Invoked with: 'not an array'
-    """
-    )
-
-    assert m.overloaded2(np.array([1], dtype="float64")) == "double"
-    assert m.overloaded2(np.array([1], dtype="float32")) == "float"
-    assert m.overloaded2(np.array([1], dtype="complex64")) == "float complex"
-    assert m.overloaded2(np.array([1], dtype="complex128")) == "double complex"
-    assert m.overloaded2(np.array([1], dtype="float32")) == "float"
-
-    assert m.overloaded3(np.array([1], dtype="float64")) == "double"
-    assert m.overloaded3(np.array([1], dtype="intc")) == "int"
-    expected_exc = """
-        overloaded3(): incompatible function arguments. The following argument types are supported:
-            1. (arg0: numpy.ndarray[numpy.int32]) -> str
-            2. (arg0: numpy.ndarray[numpy.float64]) -> str
-
-        Invoked with: """
-
-    with pytest.raises(TypeError) as excinfo:
-        m.overloaded3(np.array([1], dtype="uintc"))
-    assert msg(excinfo.value) == expected_exc + repr(np.array([1], dtype="uint32"))
-    with pytest.raises(TypeError) as excinfo:
-        m.overloaded3(np.array([1], dtype="float32"))
-    assert msg(excinfo.value) == expected_exc + repr(np.array([1.0], dtype="float32"))
-    with pytest.raises(TypeError) as excinfo:
-        m.overloaded3(np.array([1], dtype="complex"))
-    assert msg(excinfo.value) == expected_exc + repr(np.array([1.0 + 0.0j]))
-
-    # Exact matches:
-    assert m.overloaded4(np.array([1], dtype="double")) == "double"
-    assert m.overloaded4(np.array([1], dtype="longlong")) == "long long"
-    # Non-exact matches requiring conversion.  Since float to integer isn't a
-    # save conversion, it should go to the double overload, but short can go to
-    # either (and so should end up on the first-registered, the long long).
-    assert m.overloaded4(np.array([1], dtype="float32")) == "double"
-    assert m.overloaded4(np.array([1], dtype="short")) == "long long"
-
-    assert m.overloaded5(np.array([1], dtype="double")) == "double"
-    assert m.overloaded5(np.array([1], dtype="uintc")) == "unsigned int"
-    assert m.overloaded5(np.array([1], dtype="float32")) == "unsigned int"
-
-
-def test_greedy_string_overload():
-    """Tests fix for #685 - ndarray shouldn't go to std::string overload"""
-
-    assert m.issue685("abc") == "string"
-    assert m.issue685(np.array([97, 98, 99], dtype="b")) == "array"
-    assert m.issue685(123) == "other"
-
-
-def test_array_unchecked_fixed_dims(msg):
-    z1 = np.array([[1, 2], [3, 4]], dtype="float64")
-    m.proxy_add2(z1, 10)
-    assert np.all(z1 == [[11, 12], [13, 14]])
-
-    with pytest.raises(ValueError) as excinfo:
-        m.proxy_add2(np.array([1.0, 2, 3]), 5.0)
-    assert (
-        msg(excinfo.value) == "array has incorrect number of dimensions: 1; expected 2"
-    )
-
-    expect_c = np.ndarray(shape=(3, 3, 3), buffer=np.array(range(3, 30)), dtype="int")
-    assert np.all(m.proxy_init3(3.0) == expect_c)
-    expect_f = np.transpose(expect_c)
-    assert np.all(m.proxy_init3F(3.0) == expect_f)
-
-    assert m.proxy_squared_L2_norm(np.array(range(6))) == 55
-    assert m.proxy_squared_L2_norm(np.array(range(6), dtype="float64")) == 55
-
-    assert m.proxy_auxiliaries2(z1) == [11, 11, True, 2, 8, 2, 2, 4, 32]
-    assert m.proxy_auxiliaries2(z1) == m.array_auxiliaries2(z1)
-
-    assert m.proxy_auxiliaries1_const_ref(z1[0, :])
-    assert m.proxy_auxiliaries2_const_ref(z1)
-
-
-def test_array_unchecked_dyn_dims():
-    z1 = np.array([[1, 2], [3, 4]], dtype="float64")
-    m.proxy_add2_dyn(z1, 10)
-    assert np.all(z1 == [[11, 12], [13, 14]])
-
-    expect_c = np.ndarray(shape=(3, 3, 3), buffer=np.array(range(3, 30)), dtype="int")
-    assert np.all(m.proxy_init3_dyn(3.0) == expect_c)
-
-    assert m.proxy_auxiliaries2_dyn(z1) == [11, 11, True, 2, 8, 2, 2, 4, 32]
-    assert m.proxy_auxiliaries2_dyn(z1) == m.array_auxiliaries2(z1)
-
-
-def test_array_failure():
-    with pytest.raises(ValueError) as excinfo:
-        m.array_fail_test()
-    assert str(excinfo.value) == "cannot create a pybind11::array from a nullptr"
-
-    with pytest.raises(ValueError) as excinfo:
-        m.array_t_fail_test()
-    assert str(excinfo.value) == "cannot create a pybind11::array_t from a nullptr"
-
-    with pytest.raises(ValueError) as excinfo:
-        m.array_fail_test_negative_size()
-    assert str(excinfo.value) == "negative dimensions are not allowed"
-
-
-def test_initializer_list():
-    assert m.array_initializer_list1().shape == (1,)
-    assert m.array_initializer_list2().shape == (1, 2)
-    assert m.array_initializer_list3().shape == (1, 2, 3)
-    assert m.array_initializer_list4().shape == (1, 2, 3, 4)
-
-
-def test_array_resize():
-    a = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9], dtype="float64")
-    m.array_reshape2(a)
-    assert a.size == 9
-    assert np.all(a == [[1, 2, 3], [4, 5, 6], [7, 8, 9]])
-
-    # total size change should succced with refcheck off
-    m.array_resize3(a, 4, False)
-    assert a.size == 64
-    # ... and fail with refcheck on
-    try:
-        m.array_resize3(a, 3, True)
-    except ValueError as e:
-        assert str(e).startswith("cannot resize an array")
-    # transposed array doesn't own data
-    b = a.transpose()
-    try:
-        m.array_resize3(b, 3, False)
-    except ValueError as e:
-        assert str(e).startswith("cannot resize this array: it does not own its data")
-    # ... but reshape should be fine
-    m.array_reshape2(b)
-    assert b.shape == (8, 8)
-
-
-@pytest.mark.xfail("env.PYPY")
-def test_array_create_and_resize():
-    a = m.create_and_resize(2)
-    assert a.size == 4
-    assert np.all(a == 42.0)
-
-
-def test_array_view():
-    a = np.ones(100 * 4).astype("uint8")
-    a_float_view = m.array_view(a, "float32")
-    assert a_float_view.shape == (100 * 1,)  # 1 / 4 bytes = 8 / 32
-
-    a_int16_view = m.array_view(a, "int16")  # 1 / 2 bytes = 16 / 32
-    assert a_int16_view.shape == (100 * 2,)
-
-
-def test_array_view_invalid():
-    a = np.ones(100 * 4).astype("uint8")
-    with pytest.raises(TypeError):
-        m.array_view(a, "deadly_dtype")
-
-
-def test_reshape_initializer_list():
-    a = np.arange(2 * 7 * 3) + 1
-    x = m.reshape_initializer_list(a, 2, 7, 3)
-    assert x.shape == (2, 7, 3)
-    assert list(x[1][4]) == [34, 35, 36]
-    with pytest.raises(ValueError) as excinfo:
-        m.reshape_initializer_list(a, 1, 7, 3)
-    assert str(excinfo.value) == "cannot reshape array of size 42 into shape (1,7,3)"
-
-
-def test_reshape_tuple():
-    a = np.arange(3 * 7 * 2) + 1
-    x = m.reshape_tuple(a, (3, 7, 2))
-    assert x.shape == (3, 7, 2)
-    assert list(x[1][4]) == [23, 24]
-    y = m.reshape_tuple(x, (x.size,))
-    assert y.shape == (42,)
-    with pytest.raises(ValueError) as excinfo:
-        m.reshape_tuple(a, (3, 7, 1))
-    assert str(excinfo.value) == "cannot reshape array of size 42 into shape (3,7,1)"
-    with pytest.raises(ValueError) as excinfo:
-        m.reshape_tuple(a, ())
-    assert str(excinfo.value) == "cannot reshape array of size 42 into shape ()"
-
-
-def test_index_using_ellipsis():
-    a = m.index_using_ellipsis(np.zeros((5, 6, 7)))
-    assert a.shape == (6,)
-
-
-@pytest.mark.parametrize(
-    "test_func",
-    [
-        m.test_fmt_desc_float,
-        m.test_fmt_desc_double,
-        m.test_fmt_desc_const_float,
-        m.test_fmt_desc_const_double,
-    ],
-)
-def test_format_descriptors_for_floating_point_types(test_func):
-    assert "numpy.ndarray[numpy.float" in test_func.__doc__
-
-
-@pytest.mark.parametrize("forcecast", [False, True])
-@pytest.mark.parametrize("contiguity", [None, "C", "F"])
-@pytest.mark.parametrize("noconvert", [False, True])
-@pytest.mark.filterwarnings(
-    "ignore:Casting complex values to real discards the imaginary part:numpy.ComplexWarning"
-)
-def test_argument_conversions(forcecast, contiguity, noconvert):
-    function_name = "accept_double"
-    if contiguity == "C":
-        function_name += "_c_style"
-    elif contiguity == "F":
-        function_name += "_f_style"
-    if forcecast:
-        function_name += "_forcecast"
-    if noconvert:
-        function_name += "_noconvert"
-    function = getattr(m, function_name)
-
-    for dtype in [np.dtype("float32"), np.dtype("float64"), np.dtype("complex128")]:
-        for order in ["C", "F"]:
-            for shape in [(2, 2), (1, 3, 1, 1), (1, 1, 1), (0,)]:
-                if not noconvert:
-                    # If noconvert is not passed, only complex128 needs to be truncated and
-                    # "cannot be safely obtained". So without `forcecast`, the argument shouldn't
-                    # be accepted.
-                    should_raise = dtype.name == "complex128" and not forcecast
-                else:
-                    # If noconvert is passed, only float64 and the matching order is accepted.
-                    # If at most one dimension has a size greater than 1, the array is also
-                    # trivially contiguous.
-                    trivially_contiguous = sum(1 for d in shape if d > 1) <= 1
-                    should_raise = dtype.name != "float64" or (
-                        contiguity is not None
-                        and contiguity != order
-                        and not trivially_contiguous
-                    )
-
-                array = np.zeros(shape, dtype=dtype, order=order)
-                if not should_raise:
-                    function(array)
-                else:
-                    with pytest.raises(
-                        TypeError, match="incompatible function arguments"
-                    ):
-                        function(array)
-
-
-@pytest.mark.xfail("env.PYPY")
-def test_dtype_refcount_leak():
-    from sys import getrefcount
-
-    dtype = np.dtype(np.float_)
-    a = np.array([1], dtype=dtype)
-    before = getrefcount(dtype)
-    m.ndim(a)
-    after = getrefcount(dtype)
-    assert after == before
-
-
-def test_round_trip_float():
-    arr = np.zeros((), np.float64)
-    arr[()] = 37.2
-    assert m.round_trip_float(arr) == 37.2
+import pytest
+
+import env  # noqa: F401
+from pybind11_tests import numpy_array as m
+
+np = pytest.importorskip("numpy")
+
+
+def test_dtypes():
+    # See issue #1328.
+    # - Platform-dependent sizes.
+    for size_check in m.get_platform_dtype_size_checks():
+        print(size_check)
+        assert size_check.size_cpp == size_check.size_numpy, size_check
+    # - Concrete sizes.
+    for check in m.get_concrete_dtype_checks():
+        print(check)
+        assert check.numpy == check.pybind11, check
+        if check.numpy.num != check.pybind11.num:
+            print(
+                f"NOTE: typenum mismatch for {check}: {check.numpy.num} != {check.pybind11.num}"
+            )
+
+
+@pytest.fixture(scope="function")
+def arr():
+    return np.array([[1, 2, 3], [4, 5, 6]], "=u2")
+
+
+def test_array_attributes():
+    a = np.array(0, "f8")
+    assert m.ndim(a) == 0
+    assert all(m.shape(a) == [])
+    assert all(m.strides(a) == [])
+    with pytest.raises(IndexError) as excinfo:
+        m.shape(a, 0)
+    assert str(excinfo.value) == "invalid axis: 0 (ndim = 0)"
+    with pytest.raises(IndexError) as excinfo:
+        m.strides(a, 0)
+    assert str(excinfo.value) == "invalid axis: 0 (ndim = 0)"
+    assert m.writeable(a)
+    assert m.size(a) == 1
+    assert m.itemsize(a) == 8
+    assert m.nbytes(a) == 8
+    assert m.owndata(a)
+
+    a = np.array([[1, 2, 3], [4, 5, 6]], "u2").view()
+    a.flags.writeable = False
+    assert m.ndim(a) == 2
+    assert all(m.shape(a) == [2, 3])
+    assert m.shape(a, 0) == 2
+    assert m.shape(a, 1) == 3
+    assert all(m.strides(a) == [6, 2])
+    assert m.strides(a, 0) == 6
+    assert m.strides(a, 1) == 2
+    with pytest.raises(IndexError) as excinfo:
+        m.shape(a, 2)
+    assert str(excinfo.value) == "invalid axis: 2 (ndim = 2)"
+    with pytest.raises(IndexError) as excinfo:
+        m.strides(a, 2)
+    assert str(excinfo.value) == "invalid axis: 2 (ndim = 2)"
+    assert not m.writeable(a)
+    assert m.size(a) == 6
+    assert m.itemsize(a) == 2
+    assert m.nbytes(a) == 12
+    assert not m.owndata(a)
+
+
+@pytest.mark.parametrize(
+    "args, ret", [([], 0), ([0], 0), ([1], 3), ([0, 1], 1), ([1, 2], 5)]
+)
+def test_index_offset(arr, args, ret):
+    assert m.index_at(arr, *args) == ret
+    assert m.index_at_t(arr, *args) == ret
+    assert m.offset_at(arr, *args) == ret * arr.dtype.itemsize
+    assert m.offset_at_t(arr, *args) == ret * arr.dtype.itemsize
+
+
+def test_dim_check_fail(arr):
+    for func in (
+        m.index_at,
+        m.index_at_t,
+        m.offset_at,
+        m.offset_at_t,
+        m.data,
+        m.data_t,
+        m.mutate_data,
+        m.mutate_data_t,
+    ):
+        with pytest.raises(IndexError) as excinfo:
+            func(arr, 1, 2, 3)
+        assert str(excinfo.value) == "too many indices for an array: 3 (ndim = 2)"
+
+
+@pytest.mark.parametrize(
+    "args, ret",
+    [
+        ([], [1, 2, 3, 4, 5, 6]),
+        ([1], [4, 5, 6]),
+        ([0, 1], [2, 3, 4, 5, 6]),
+        ([1, 2], [6]),
+    ],
+)
+def test_data(arr, args, ret):
+    from sys import byteorder
+
+    assert all(m.data_t(arr, *args) == ret)
+    assert all(m.data(arr, *args)[(0 if byteorder == "little" else 1) :: 2] == ret)
+    assert all(m.data(arr, *args)[(1 if byteorder == "little" else 0) :: 2] == 0)
+
+
+@pytest.mark.parametrize("dim", [0, 1, 3])
+def test_at_fail(arr, dim):
+    for func in m.at_t, m.mutate_at_t:
+        with pytest.raises(IndexError) as excinfo:
+            func(arr, *([0] * dim))
+        assert str(excinfo.value) == f"index dimension mismatch: {dim} (ndim = 2)"
+
+
+def test_at(arr):
+    assert m.at_t(arr, 0, 2) == 3
+    assert m.at_t(arr, 1, 0) == 4
+
+    assert all(m.mutate_at_t(arr, 0, 2).ravel() == [1, 2, 4, 4, 5, 6])
+    assert all(m.mutate_at_t(arr, 1, 0).ravel() == [1, 2, 4, 5, 5, 6])
+
+
+def test_mutate_readonly(arr):
+    arr.flags.writeable = False
+    for func, args in (
+        (m.mutate_data, ()),
+        (m.mutate_data_t, ()),
+        (m.mutate_at_t, (0, 0)),
+    ):
+        with pytest.raises(ValueError) as excinfo:
+            func(arr, *args)
+        assert str(excinfo.value) == "array is not writeable"
+
+
+def test_mutate_data(arr):
+    assert all(m.mutate_data(arr).ravel() == [2, 4, 6, 8, 10, 12])
+    assert all(m.mutate_data(arr).ravel() == [4, 8, 12, 16, 20, 24])
+    assert all(m.mutate_data(arr, 1).ravel() == [4, 8, 12, 32, 40, 48])
+    assert all(m.mutate_data(arr, 0, 1).ravel() == [4, 16, 24, 64, 80, 96])
+    assert all(m.mutate_data(arr, 1, 2).ravel() == [4, 16, 24, 64, 80, 192])
+
+    assert all(m.mutate_data_t(arr).ravel() == [5, 17, 25, 65, 81, 193])
+    assert all(m.mutate_data_t(arr).ravel() == [6, 18, 26, 66, 82, 194])
+    assert all(m.mutate_data_t(arr, 1).ravel() == [6, 18, 26, 67, 83, 195])
+    assert all(m.mutate_data_t(arr, 0, 1).ravel() == [6, 19, 27, 68, 84, 196])
+    assert all(m.mutate_data_t(arr, 1, 2).ravel() == [6, 19, 27, 68, 84, 197])
+
+
+def test_bounds_check(arr):
+    for func in (
+        m.index_at,
+        m.index_at_t,
+        m.data,
+        m.data_t,
+        m.mutate_data,
+        m.mutate_data_t,
+        m.at_t,
+        m.mutate_at_t,
+    ):
+        with pytest.raises(IndexError) as excinfo:
+            func(arr, 2, 0)
+        assert str(excinfo.value) == "index 2 is out of bounds for axis 0 with size 2"
+        with pytest.raises(IndexError) as excinfo:
+            func(arr, 0, 4)
+        assert str(excinfo.value) == "index 4 is out of bounds for axis 1 with size 3"
+
+
+def test_make_c_f_array():
+    assert m.make_c_array().flags.c_contiguous
+    assert not m.make_c_array().flags.f_contiguous
+    assert m.make_f_array().flags.f_contiguous
+    assert not m.make_f_array().flags.c_contiguous
+
+
+def test_make_empty_shaped_array():
+    m.make_empty_shaped_array()
+
+    # empty shape means numpy scalar, PEP 3118
+    assert m.scalar_int().ndim == 0
+    assert m.scalar_int().shape == ()
+    assert m.scalar_int() == 42
+
+
+def test_wrap():
+    def assert_references(a, b, base=None):
+        if base is None:
+            base = a
+        assert a is not b
+        assert a.__array_interface__["data"][0] == b.__array_interface__["data"][0]
+        assert a.shape == b.shape
+        assert a.strides == b.strides
+        assert a.flags.c_contiguous == b.flags.c_contiguous
+        assert a.flags.f_contiguous == b.flags.f_contiguous
+        assert a.flags.writeable == b.flags.writeable
+        assert a.flags.aligned == b.flags.aligned
+        # 1.13 supported Python 3.6
+        if tuple(int(x) for x in np.__version__.split(".")[:2]) >= (1, 14):
+            assert a.flags.writebackifcopy == b.flags.writebackifcopy
+        else:
+            assert a.flags.updateifcopy == b.flags.updateifcopy
+        assert np.all(a == b)
+        assert not b.flags.owndata
+        assert b.base is base
+        if a.flags.writeable and a.ndim == 2:
+            a[0, 0] = 1234
+            assert b[0, 0] == 1234
+
+    a1 = np.array([1, 2], dtype=np.int16)
+    assert a1.flags.owndata and a1.base is None
+    a2 = m.wrap(a1)
+    assert_references(a1, a2)
+
+    a1 = np.array([[1, 2], [3, 4]], dtype=np.float32, order="F")
+    assert a1.flags.owndata and a1.base is None
+    a2 = m.wrap(a1)
+    assert_references(a1, a2)
+
+    a1 = np.array([[1, 2], [3, 4]], dtype=np.float32, order="C")
+    a1.flags.writeable = False
+    a2 = m.wrap(a1)
+    assert_references(a1, a2)
+
+    a1 = np.random.random((4, 4, 4))
+    a2 = m.wrap(a1)
+    assert_references(a1, a2)
+
+    a1t = a1.transpose()
+    a2 = m.wrap(a1t)
+    assert_references(a1t, a2, a1)
+
+    a1d = a1.diagonal()
+    a2 = m.wrap(a1d)
+    assert_references(a1d, a2, a1)
+
+    a1m = a1[::-1, ::-1, ::-1]
+    a2 = m.wrap(a1m)
+    assert_references(a1m, a2, a1)
+
+
+def test_numpy_view(capture):
+    with capture:
+        ac = m.ArrayClass()
+        ac_view_1 = ac.numpy_view()
+        ac_view_2 = ac.numpy_view()
+        assert np.all(ac_view_1 == np.array([1, 2], dtype=np.int32))
+        del ac
+        pytest.gc_collect()
+    assert (
+        capture
+        == """
+        ArrayClass()
+        ArrayClass::numpy_view()
+        ArrayClass::numpy_view()
+    """
+    )
+    ac_view_1[0] = 4
+    ac_view_1[1] = 3
+    assert ac_view_2[0] == 4
+    assert ac_view_2[1] == 3
+    with capture:
+        del ac_view_1
+        del ac_view_2
+        pytest.gc_collect()
+        pytest.gc_collect()
+    assert (
+        capture
+        == """
+        ~ArrayClass()
+    """
+    )
+
+
+def test_cast_numpy_int64_to_uint64():
+    m.function_taking_uint64(123)
+    m.function_taking_uint64(np.uint64(123))
+
+
+def test_isinstance():
+    assert m.isinstance_untyped(np.array([1, 2, 3]), "not an array")
+    assert m.isinstance_typed(np.array([1.0, 2.0, 3.0]))
+
+
+def test_constructors():
+    defaults = m.default_constructors()
+    for a in defaults.values():
+        assert a.size == 0
+    assert defaults["array"].dtype == np.array([]).dtype
+    assert defaults["array_t<int32>"].dtype == np.int32
+    assert defaults["array_t<double>"].dtype == np.float64
+
+    results = m.converting_constructors([1, 2, 3])
+    for a in results.values():
+        np.testing.assert_array_equal(a, [1, 2, 3])
+    assert results["array"].dtype == np.int_
+    assert results["array_t<int32>"].dtype == np.int32
+    assert results["array_t<double>"].dtype == np.float64
+
+
+def test_overload_resolution(msg):
+    # Exact overload matches:
+    assert m.overloaded(np.array([1], dtype="float64")) == "double"
+    assert m.overloaded(np.array([1], dtype="float32")) == "float"
+    assert m.overloaded(np.array([1], dtype="ushort")) == "unsigned short"
+    assert m.overloaded(np.array([1], dtype="intc")) == "int"
+    assert m.overloaded(np.array([1], dtype="longlong")) == "long long"
+    assert m.overloaded(np.array([1], dtype="complex")) == "double complex"
+    assert m.overloaded(np.array([1], dtype="csingle")) == "float complex"
+
+    # No exact match, should call first convertible version:
+    assert m.overloaded(np.array([1], dtype="uint8")) == "double"
+
+    with pytest.raises(TypeError) as excinfo:
+        m.overloaded("not an array")
+    assert (
+        msg(excinfo.value)
+        == """
+        overloaded(): incompatible function arguments. The following argument types are supported:
+            1. (arg0: numpy.ndarray[numpy.float64]) -> str
+            2. (arg0: numpy.ndarray[numpy.float32]) -> str
+            3. (arg0: numpy.ndarray[numpy.int32]) -> str
+            4. (arg0: numpy.ndarray[numpy.uint16]) -> str
+            5. (arg0: numpy.ndarray[numpy.int64]) -> str
+            6. (arg0: numpy.ndarray[numpy.complex128]) -> str
+            7. (arg0: numpy.ndarray[numpy.complex64]) -> str
+
+        Invoked with: 'not an array'
+    """
+    )
+
+    assert m.overloaded2(np.array([1], dtype="float64")) == "double"
+    assert m.overloaded2(np.array([1], dtype="float32")) == "float"
+    assert m.overloaded2(np.array([1], dtype="complex64")) == "float complex"
+    assert m.overloaded2(np.array([1], dtype="complex128")) == "double complex"
+    assert m.overloaded2(np.array([1], dtype="float32")) == "float"
+
+    assert m.overloaded3(np.array([1], dtype="float64")) == "double"
+    assert m.overloaded3(np.array([1], dtype="intc")) == "int"
+    expected_exc = """
+        overloaded3(): incompatible function arguments. The following argument types are supported:
+            1. (arg0: numpy.ndarray[numpy.int32]) -> str
+            2. (arg0: numpy.ndarray[numpy.float64]) -> str
+
+        Invoked with: """
+
+    with pytest.raises(TypeError) as excinfo:
+        m.overloaded3(np.array([1], dtype="uintc"))
+    assert msg(excinfo.value) == expected_exc + repr(np.array([1], dtype="uint32"))
+    with pytest.raises(TypeError) as excinfo:
+        m.overloaded3(np.array([1], dtype="float32"))
+    assert msg(excinfo.value) == expected_exc + repr(np.array([1.0], dtype="float32"))
+    with pytest.raises(TypeError) as excinfo:
+        m.overloaded3(np.array([1], dtype="complex"))
+    assert msg(excinfo.value) == expected_exc + repr(np.array([1.0 + 0.0j]))
+
+    # Exact matches:
+    assert m.overloaded4(np.array([1], dtype="double")) == "double"
+    assert m.overloaded4(np.array([1], dtype="longlong")) == "long long"
+    # Non-exact matches requiring conversion.  Since float to integer isn't a
+    # save conversion, it should go to the double overload, but short can go to
+    # either (and so should end up on the first-registered, the long long).
+    assert m.overloaded4(np.array([1], dtype="float32")) == "double"
+    assert m.overloaded4(np.array([1], dtype="short")) == "long long"
+
+    assert m.overloaded5(np.array([1], dtype="double")) == "double"
+    assert m.overloaded5(np.array([1], dtype="uintc")) == "unsigned int"
+    assert m.overloaded5(np.array([1], dtype="float32")) == "unsigned int"
+
+
+def test_greedy_string_overload():
+    """Tests fix for #685 - ndarray shouldn't go to std::string overload"""
+
+    assert m.issue685("abc") == "string"
+    assert m.issue685(np.array([97, 98, 99], dtype="b")) == "array"
+    assert m.issue685(123) == "other"
+
+
+def test_array_unchecked_fixed_dims(msg):
+    z1 = np.array([[1, 2], [3, 4]], dtype="float64")
+    m.proxy_add2(z1, 10)
+    assert np.all(z1 == [[11, 12], [13, 14]])
+
+    with pytest.raises(ValueError) as excinfo:
+        m.proxy_add2(np.array([1.0, 2, 3]), 5.0)
+    assert (
+        msg(excinfo.value) == "array has incorrect number of dimensions: 1; expected 2"
+    )
+
+    expect_c = np.ndarray(shape=(3, 3, 3), buffer=np.array(range(3, 30)), dtype="int")
+    assert np.all(m.proxy_init3(3.0) == expect_c)
+    expect_f = np.transpose(expect_c)
+    assert np.all(m.proxy_init3F(3.0) == expect_f)
+
+    assert m.proxy_squared_L2_norm(np.array(range(6))) == 55
+    assert m.proxy_squared_L2_norm(np.array(range(6), dtype="float64")) == 55
+
+    assert m.proxy_auxiliaries2(z1) == [11, 11, True, 2, 8, 2, 2, 4, 32]
+    assert m.proxy_auxiliaries2(z1) == m.array_auxiliaries2(z1)
+
+    assert m.proxy_auxiliaries1_const_ref(z1[0, :])
+    assert m.proxy_auxiliaries2_const_ref(z1)
+
+
+def test_array_unchecked_dyn_dims():
+    z1 = np.array([[1, 2], [3, 4]], dtype="float64")
+    m.proxy_add2_dyn(z1, 10)
+    assert np.all(z1 == [[11, 12], [13, 14]])
+
+    expect_c = np.ndarray(shape=(3, 3, 3), buffer=np.array(range(3, 30)), dtype="int")
+    assert np.all(m.proxy_init3_dyn(3.0) == expect_c)
+
+    assert m.proxy_auxiliaries2_dyn(z1) == [11, 11, True, 2, 8, 2, 2, 4, 32]
+    assert m.proxy_auxiliaries2_dyn(z1) == m.array_auxiliaries2(z1)
+
+
+def test_array_failure():
+    with pytest.raises(ValueError) as excinfo:
+        m.array_fail_test()
+    assert str(excinfo.value) == "cannot create a pybind11::array from a nullptr"
+
+    with pytest.raises(ValueError) as excinfo:
+        m.array_t_fail_test()
+    assert str(excinfo.value) == "cannot create a pybind11::array_t from a nullptr"
+
+    with pytest.raises(ValueError) as excinfo:
+        m.array_fail_test_negative_size()
+    assert str(excinfo.value) == "negative dimensions are not allowed"
+
+
+def test_initializer_list():
+    assert m.array_initializer_list1().shape == (1,)
+    assert m.array_initializer_list2().shape == (1, 2)
+    assert m.array_initializer_list3().shape == (1, 2, 3)
+    assert m.array_initializer_list4().shape == (1, 2, 3, 4)
+
+
+def test_array_resize():
+    a = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9], dtype="float64")
+    m.array_reshape2(a)
+    assert a.size == 9
+    assert np.all(a == [[1, 2, 3], [4, 5, 6], [7, 8, 9]])
+
+    # total size change should succced with refcheck off
+    m.array_resize3(a, 4, False)
+    assert a.size == 64
+    # ... and fail with refcheck on
+    try:
+        m.array_resize3(a, 3, True)
+    except ValueError as e:
+        assert str(e).startswith("cannot resize an array")
+    # transposed array doesn't own data
+    b = a.transpose()
+    try:
+        m.array_resize3(b, 3, False)
+    except ValueError as e:
+        assert str(e).startswith("cannot resize this array: it does not own its data")
+    # ... but reshape should be fine
+    m.array_reshape2(b)
+    assert b.shape == (8, 8)
+
+
+@pytest.mark.xfail("env.PYPY")
+def test_array_create_and_resize():
+    a = m.create_and_resize(2)
+    assert a.size == 4
+    assert np.all(a == 42.0)
+
+
+def test_array_view():
+    a = np.ones(100 * 4).astype("uint8")
+    a_float_view = m.array_view(a, "float32")
+    assert a_float_view.shape == (100 * 1,)  # 1 / 4 bytes = 8 / 32
+
+    a_int16_view = m.array_view(a, "int16")  # 1 / 2 bytes = 16 / 32
+    assert a_int16_view.shape == (100 * 2,)
+
+
+def test_array_view_invalid():
+    a = np.ones(100 * 4).astype("uint8")
+    with pytest.raises(TypeError):
+        m.array_view(a, "deadly_dtype")
+
+
+def test_reshape_initializer_list():
+    a = np.arange(2 * 7 * 3) + 1
+    x = m.reshape_initializer_list(a, 2, 7, 3)
+    assert x.shape == (2, 7, 3)
+    assert list(x[1][4]) == [34, 35, 36]
+    with pytest.raises(ValueError) as excinfo:
+        m.reshape_initializer_list(a, 1, 7, 3)
+    assert str(excinfo.value) == "cannot reshape array of size 42 into shape (1,7,3)"
+
+
+def test_reshape_tuple():
+    a = np.arange(3 * 7 * 2) + 1
+    x = m.reshape_tuple(a, (3, 7, 2))
+    assert x.shape == (3, 7, 2)
+    assert list(x[1][4]) == [23, 24]
+    y = m.reshape_tuple(x, (x.size,))
+    assert y.shape == (42,)
+    with pytest.raises(ValueError) as excinfo:
+        m.reshape_tuple(a, (3, 7, 1))
+    assert str(excinfo.value) == "cannot reshape array of size 42 into shape (3,7,1)"
+    with pytest.raises(ValueError) as excinfo:
+        m.reshape_tuple(a, ())
+    assert str(excinfo.value) == "cannot reshape array of size 42 into shape ()"
+
+
+def test_index_using_ellipsis():
+    a = m.index_using_ellipsis(np.zeros((5, 6, 7)))
+    assert a.shape == (6,)
+
+
+@pytest.mark.parametrize(
+    "test_func",
+    [
+        m.test_fmt_desc_float,
+        m.test_fmt_desc_double,
+        m.test_fmt_desc_const_float,
+        m.test_fmt_desc_const_double,
+    ],
+)
+def test_format_descriptors_for_floating_point_types(test_func):
+    assert "numpy.ndarray[numpy.float" in test_func.__doc__
+
+
+@pytest.mark.parametrize("forcecast", [False, True])
+@pytest.mark.parametrize("contiguity", [None, "C", "F"])
+@pytest.mark.parametrize("noconvert", [False, True])
+@pytest.mark.filterwarnings(
+    "ignore:Casting complex values to real discards the imaginary part:numpy.ComplexWarning"
+)
+def test_argument_conversions(forcecast, contiguity, noconvert):
+    function_name = "accept_double"
+    if contiguity == "C":
+        function_name += "_c_style"
+    elif contiguity == "F":
+        function_name += "_f_style"
+    if forcecast:
+        function_name += "_forcecast"
+    if noconvert:
+        function_name += "_noconvert"
+    function = getattr(m, function_name)
+
+    for dtype in [np.dtype("float32"), np.dtype("float64"), np.dtype("complex128")]:
+        for order in ["C", "F"]:
+            for shape in [(2, 2), (1, 3, 1, 1), (1, 1, 1), (0,)]:
+                if not noconvert:
+                    # If noconvert is not passed, only complex128 needs to be truncated and
+                    # "cannot be safely obtained". So without `forcecast`, the argument shouldn't
+                    # be accepted.
+                    should_raise = dtype.name == "complex128" and not forcecast
+                else:
+                    # If noconvert is passed, only float64 and the matching order is accepted.
+                    # If at most one dimension has a size greater than 1, the array is also
+                    # trivially contiguous.
+                    trivially_contiguous = sum(1 for d in shape if d > 1) <= 1
+                    should_raise = dtype.name != "float64" or (
+                        contiguity is not None
+                        and contiguity != order
+                        and not trivially_contiguous
+                    )
+
+                array = np.zeros(shape, dtype=dtype, order=order)
+                if not should_raise:
+                    function(array)
+                else:
+                    with pytest.raises(
+                        TypeError, match="incompatible function arguments"
+                    ):
+                        function(array)
+
+
+@pytest.mark.xfail("env.PYPY")
+def test_dtype_refcount_leak():
+    from sys import getrefcount
+
+    dtype = np.dtype(np.float_)
+    a = np.array([1], dtype=dtype)
+    before = getrefcount(dtype)
+    m.ndim(a)
+    after = getrefcount(dtype)
+    assert after == before
+
+
+def test_round_trip_float():
+    arr = np.zeros((), np.float64)
+    arr[()] = 37.2
+    assert m.round_trip_float(arr) == 37.2
```

## extern/pybind11/tests/test_numpy_dtypes.py

 * *Ordering differences only*

```diff
@@ -1,446 +1,446 @@
-import re
-
-import pytest
-
-import env  # noqa: F401
-from pybind11_tests import numpy_dtypes as m
-
-np = pytest.importorskip("numpy")
-
-
-@pytest.fixture(scope="module")
-def simple_dtype():
-    ld = np.dtype("longdouble")
-    return np.dtype(
-        {
-            "names": ["bool_", "uint_", "float_", "ldbl_"],
-            "formats": ["?", "u4", "f4", f"f{ld.itemsize}"],
-            "offsets": [0, 4, 8, (16 if ld.alignment > 4 else 12)],
-        }
-    )
-
-
-@pytest.fixture(scope="module")
-def packed_dtype():
-    return np.dtype([("bool_", "?"), ("uint_", "u4"), ("float_", "f4"), ("ldbl_", "g")])
-
-
-def dt_fmt():
-    from sys import byteorder
-
-    e = "<" if byteorder == "little" else ">"
-    return (
-        "{{'names':['bool_','uint_','float_','ldbl_'],"
-        "'formats':['?','" + e + "u4','" + e + "f4','" + e + "f{}'],"
-        "'offsets':[0,4,8,{}],'itemsize':{}}}"
-    )
-
-
-def simple_dtype_fmt():
-    ld = np.dtype("longdouble")
-    simple_ld_off = 12 + 4 * (ld.alignment > 4)
-    return dt_fmt().format(ld.itemsize, simple_ld_off, simple_ld_off + ld.itemsize)
-
-
-def packed_dtype_fmt():
-    from sys import byteorder
-
-    return "[('bool_','?'),('uint_','{e}u4'),('float_','{e}f4'),('ldbl_','{e}f{}')]".format(
-        np.dtype("longdouble").itemsize, e="<" if byteorder == "little" else ">"
-    )
-
-
-def partial_ld_offset():
-    return (
-        12
-        + 4 * (np.dtype("uint64").alignment > 4)
-        + 8
-        + 8 * (np.dtype("longdouble").alignment > 8)
-    )
-
-
-def partial_dtype_fmt():
-    ld = np.dtype("longdouble")
-    partial_ld_off = partial_ld_offset()
-    partial_size = partial_ld_off + ld.itemsize
-    partial_end_padding = partial_size % np.dtype("uint64").alignment
-    return dt_fmt().format(
-        ld.itemsize, partial_ld_off, partial_size + partial_end_padding
-    )
-
-
-def partial_nested_fmt():
-    ld = np.dtype("longdouble")
-    partial_nested_off = 8 + 8 * (ld.alignment > 8)
-    partial_ld_off = partial_ld_offset()
-    partial_size = partial_ld_off + ld.itemsize
-    partial_end_padding = partial_size % np.dtype("uint64").alignment
-    partial_nested_size = partial_nested_off * 2 + partial_size + partial_end_padding
-    return "{{'names':['a'],'formats':[{}],'offsets':[{}],'itemsize':{}}}".format(
-        partial_dtype_fmt(), partial_nested_off, partial_nested_size
-    )
-
-
-def assert_equal(actual, expected_data, expected_dtype):
-    np.testing.assert_equal(actual, np.array(expected_data, dtype=expected_dtype))
-
-
-def test_format_descriptors():
-    with pytest.raises(RuntimeError) as excinfo:
-        m.get_format_unbound()
-    assert re.match(
-        "^NumPy type info missing for .*UnboundStruct.*$", str(excinfo.value)
-    )
-
-    ld = np.dtype("longdouble")
-    ldbl_fmt = ("4x" if ld.alignment > 4 else "") + ld.char
-    ss_fmt = "^T{?:bool_:3xI:uint_:f:float_:" + ldbl_fmt + ":ldbl_:}"
-    dbl = np.dtype("double")
-    end_padding = ld.itemsize % np.dtype("uint64").alignment
-    partial_fmt = (
-        "^T{?:bool_:3xI:uint_:f:float_:"
-        + str(4 * (dbl.alignment > 4) + dbl.itemsize + 8 * (ld.alignment > 8))
-        + "xg:ldbl_:"
-        + (str(end_padding) + "x}" if end_padding > 0 else "}")
-    )
-    nested_extra = str(max(8, ld.alignment))
-    assert m.print_format_descriptors() == [
-        ss_fmt,
-        "^T{?:bool_:I:uint_:f:float_:g:ldbl_:}",
-        "^T{" + ss_fmt + ":a:^T{?:bool_:I:uint_:f:float_:g:ldbl_:}:b:}",
-        partial_fmt,
-        "^T{" + nested_extra + "x" + partial_fmt + ":a:" + nested_extra + "x}",
-        "^T{3s:a:3s:b:}",
-        "^T{(3)4s:a:(2)i:b:(3)B:c:1x(4, 2)f:d:}",
-        "^T{q:e1:B:e2:}",
-        "^T{Zf:cflt:Zd:cdbl:}",
-    ]
-
-
-def test_dtype(simple_dtype):
-    from sys import byteorder
-
-    e = "<" if byteorder == "little" else ">"
-
-    assert [x.replace(" ", "") for x in m.print_dtypes()] == [
-        simple_dtype_fmt(),
-        packed_dtype_fmt(),
-        f"[('a',{simple_dtype_fmt()}),('b',{packed_dtype_fmt()})]",
-        partial_dtype_fmt(),
-        partial_nested_fmt(),
-        "[('a','S3'),('b','S3')]",
-        (
-            "{{'names':['a','b','c','d'],"
-            + "'formats':[('S4',(3,)),('"
-            + e
-            + "i4',(2,)),('u1',(3,)),('"
-            + e
-            + "f4',(4,2))],"
-            + "'offsets':[0,12,20,24],'itemsize':56}}"
-        ).format(e=e),
-        "[('e1','" + e + "i8'),('e2','u1')]",
-        "[('x','i1'),('y','" + e + "u8')]",
-        "[('cflt','" + e + "c8'),('cdbl','" + e + "c16')]",
-    ]
-
-    d1 = np.dtype(
-        {
-            "names": ["a", "b"],
-            "formats": ["int32", "float64"],
-            "offsets": [1, 10],
-            "itemsize": 20,
-        }
-    )
-    d2 = np.dtype([("a", "i4"), ("b", "f4")])
-    assert m.test_dtype_ctors() == [
-        np.dtype("int32"),
-        np.dtype("float64"),
-        np.dtype("bool"),
-        d1,
-        d1,
-        np.dtype("uint32"),
-        d2,
-        np.dtype("d"),
-    ]
-
-    assert m.test_dtype_methods() == [
-        np.dtype("int32"),
-        simple_dtype,
-        False,
-        True,
-        np.dtype("int32").itemsize,
-        simple_dtype.itemsize,
-    ]
-
-    assert m.trailing_padding_dtype() == m.buffer_to_dtype(
-        np.zeros(1, m.trailing_padding_dtype())
-    )
-
-    expected_chars = "bhilqBHILQefdgFDG?MmO"
-    assert m.test_dtype_kind() == list("iiiiiuuuuuffffcccbMmO")
-    assert m.test_dtype_char_() == list(expected_chars)
-    assert m.test_dtype_num() == [np.dtype(ch).num for ch in expected_chars]
-    assert m.test_dtype_byteorder() == [np.dtype(ch).byteorder for ch in expected_chars]
-    assert m.test_dtype_alignment() == [np.dtype(ch).alignment for ch in expected_chars]
-    assert m.test_dtype_flags() == [chr(np.dtype(ch).flags) for ch in expected_chars]
-
-
-def test_recarray(simple_dtype, packed_dtype):
-    elements = [(False, 0, 0.0, -0.0), (True, 1, 1.5, -2.5), (False, 2, 3.0, -5.0)]
-
-    for func, dtype in [
-        (m.create_rec_simple, simple_dtype),
-        (m.create_rec_packed, packed_dtype),
-    ]:
-        arr = func(0)
-        assert arr.dtype == dtype
-        assert_equal(arr, [], simple_dtype)
-        assert_equal(arr, [], packed_dtype)
-
-        arr = func(3)
-        assert arr.dtype == dtype
-        assert_equal(arr, elements, simple_dtype)
-        assert_equal(arr, elements, packed_dtype)
-
-        # Show what recarray's look like in NumPy.
-        assert type(arr[0]) == np.void
-        assert type(arr[0].item()) == tuple
-
-        if dtype == simple_dtype:
-            assert m.print_rec_simple(arr) == [
-                "s:0,0,0,-0",
-                "s:1,1,1.5,-2.5",
-                "s:0,2,3,-5",
-            ]
-        else:
-            assert m.print_rec_packed(arr) == [
-                "p:0,0,0,-0",
-                "p:1,1,1.5,-2.5",
-                "p:0,2,3,-5",
-            ]
-
-    nested_dtype = np.dtype([("a", simple_dtype), ("b", packed_dtype)])
-
-    arr = m.create_rec_nested(0)
-    assert arr.dtype == nested_dtype
-    assert_equal(arr, [], nested_dtype)
-
-    arr = m.create_rec_nested(3)
-    assert arr.dtype == nested_dtype
-    assert_equal(
-        arr,
-        [
-            ((False, 0, 0.0, -0.0), (True, 1, 1.5, -2.5)),
-            ((True, 1, 1.5, -2.5), (False, 2, 3.0, -5.0)),
-            ((False, 2, 3.0, -5.0), (True, 3, 4.5, -7.5)),
-        ],
-        nested_dtype,
-    )
-    assert m.print_rec_nested(arr) == [
-        "n:a=s:0,0,0,-0;b=p:1,1,1.5,-2.5",
-        "n:a=s:1,1,1.5,-2.5;b=p:0,2,3,-5",
-        "n:a=s:0,2,3,-5;b=p:1,3,4.5,-7.5",
-    ]
-
-    arr = m.create_rec_partial(3)
-    assert str(arr.dtype).replace(" ", "") == partial_dtype_fmt()
-    partial_dtype = arr.dtype
-    assert "" not in arr.dtype.fields
-    assert partial_dtype.itemsize > simple_dtype.itemsize
-    assert_equal(arr, elements, simple_dtype)
-    assert_equal(arr, elements, packed_dtype)
-
-    arr = m.create_rec_partial_nested(3)
-    assert str(arr.dtype).replace(" ", "") == partial_nested_fmt()
-    assert "" not in arr.dtype.fields
-    assert "" not in arr.dtype.fields["a"][0].fields
-    assert arr.dtype.itemsize > partial_dtype.itemsize
-    np.testing.assert_equal(arr["a"], m.create_rec_partial(3))
-
-
-def test_array_constructors():
-    data = np.arange(1, 7, dtype="int32")
-    for i in range(8):
-        np.testing.assert_array_equal(m.test_array_ctors(10 + i), data.reshape((3, 2)))
-        np.testing.assert_array_equal(m.test_array_ctors(20 + i), data.reshape((3, 2)))
-    for i in range(5):
-        np.testing.assert_array_equal(m.test_array_ctors(30 + i), data)
-        np.testing.assert_array_equal(m.test_array_ctors(40 + i), data)
-
-
-def test_string_array():
-    arr = m.create_string_array(True)
-    assert str(arr.dtype) == "[('a', 'S3'), ('b', 'S3')]"
-    assert m.print_string_array(arr) == [
-        "a='',b=''",
-        "a='a',b='a'",
-        "a='ab',b='ab'",
-        "a='abc',b='abc'",
-    ]
-    dtype = arr.dtype
-    assert arr["a"].tolist() == [b"", b"a", b"ab", b"abc"]
-    assert arr["b"].tolist() == [b"", b"a", b"ab", b"abc"]
-    arr = m.create_string_array(False)
-    assert dtype == arr.dtype
-
-
-def test_array_array():
-    from sys import byteorder
-
-    e = "<" if byteorder == "little" else ">"
-
-    arr = m.create_array_array(3)
-    assert str(arr.dtype).replace(" ", "") == (
-        "{{'names':['a','b','c','d'],"
-        + "'formats':[('S4',(3,)),('"
-        + e
-        + "i4',(2,)),('u1',(3,)),('{e}f4',(4,2))],"
-        + "'offsets':[0,12,20,24],'itemsize':56}}"
-    ).format(e=e)
-    assert m.print_array_array(arr) == [
-        "a={{A,B,C,D},{K,L,M,N},{U,V,W,X}},b={0,1},"
-        + "c={0,1,2},d={{0,1},{10,11},{20,21},{30,31}}",
-        "a={{W,X,Y,Z},{G,H,I,J},{Q,R,S,T}},b={1000,1001},"
-        + "c={10,11,12},d={{100,101},{110,111},{120,121},{130,131}}",
-        "a={{S,T,U,V},{C,D,E,F},{M,N,O,P}},b={2000,2001},"
-        + "c={20,21,22},d={{200,201},{210,211},{220,221},{230,231}}",
-    ]
-    assert arr["a"].tolist() == [
-        [b"ABCD", b"KLMN", b"UVWX"],
-        [b"WXYZ", b"GHIJ", b"QRST"],
-        [b"STUV", b"CDEF", b"MNOP"],
-    ]
-    assert arr["b"].tolist() == [[0, 1], [1000, 1001], [2000, 2001]]
-    assert m.create_array_array(0).dtype == arr.dtype
-
-
-def test_enum_array():
-    from sys import byteorder
-
-    e = "<" if byteorder == "little" else ">"
-
-    arr = m.create_enum_array(3)
-    dtype = arr.dtype
-    assert dtype == np.dtype([("e1", e + "i8"), ("e2", "u1")])
-    assert m.print_enum_array(arr) == ["e1=A,e2=X", "e1=B,e2=Y", "e1=A,e2=X"]
-    assert arr["e1"].tolist() == [-1, 1, -1]
-    assert arr["e2"].tolist() == [1, 2, 1]
-    assert m.create_enum_array(0).dtype == dtype
-
-
-def test_complex_array():
-    from sys import byteorder
-
-    e = "<" if byteorder == "little" else ">"
-
-    arr = m.create_complex_array(3)
-    dtype = arr.dtype
-    assert dtype == np.dtype([("cflt", e + "c8"), ("cdbl", e + "c16")])
-    assert m.print_complex_array(arr) == [
-        "c:(0,0.25),(0.5,0.75)",
-        "c:(1,1.25),(1.5,1.75)",
-        "c:(2,2.25),(2.5,2.75)",
-    ]
-    assert arr["cflt"].tolist() == [0.0 + 0.25j, 1.0 + 1.25j, 2.0 + 2.25j]
-    assert arr["cdbl"].tolist() == [0.5 + 0.75j, 1.5 + 1.75j, 2.5 + 2.75j]
-    assert m.create_complex_array(0).dtype == dtype
-
-
-def test_signature(doc):
-    assert (
-        doc(m.create_rec_nested)
-        == "create_rec_nested(arg0: int) -> numpy.ndarray[NestedStruct]"
-    )
-
-
-def test_scalar_conversion():
-    n = 3
-    arrays = [
-        m.create_rec_simple(n),
-        m.create_rec_packed(n),
-        m.create_rec_nested(n),
-        m.create_enum_array(n),
-    ]
-    funcs = [m.f_simple, m.f_packed, m.f_nested]
-
-    for i, func in enumerate(funcs):
-        for j, arr in enumerate(arrays):
-            if i == j and i < 2:
-                assert [func(arr[k]) for k in range(n)] == [k * 10 for k in range(n)]
-            else:
-                with pytest.raises(TypeError) as excinfo:
-                    func(arr[0])
-                assert "incompatible function arguments" in str(excinfo.value)
-
-
-def test_vectorize():
-    n = 3
-    array = m.create_rec_simple(n)
-    values = m.f_simple_vectorized(array)
-    np.testing.assert_array_equal(values, [0, 10, 20])
-    array_2 = m.f_simple_pass_thru_vectorized(array)
-    np.testing.assert_array_equal(array, array_2)
-
-
-def test_cls_and_dtype_conversion(simple_dtype):
-    s = m.SimpleStruct()
-    assert s.astuple() == (False, 0, 0.0, 0.0)
-    assert m.SimpleStruct.fromtuple(s.astuple()).astuple() == s.astuple()
-
-    s.uint_ = 2
-    assert m.f_simple(s) == 20
-
-    # Try as recarray of shape==(1,).
-    s_recarray = np.array([(False, 2, 0.0, 0.0)], dtype=simple_dtype)
-    # Show that this will work for vectorized case.
-    np.testing.assert_array_equal(m.f_simple_vectorized(s_recarray), [20])
-
-    # Show as a scalar that inherits from np.generic.
-    s_scalar = s_recarray[0]
-    assert isinstance(s_scalar, np.void)
-    assert m.f_simple(s_scalar) == 20
-
-    # Show that an *array* scalar (np.ndarray.shape == ()) does not convert.
-    # More specifically, conversion to SimpleStruct is not implicit.
-    s_recarray_scalar = s_recarray.reshape(())
-    assert isinstance(s_recarray_scalar, np.ndarray)
-    assert s_recarray_scalar.dtype == simple_dtype
-    with pytest.raises(TypeError) as excinfo:
-        m.f_simple(s_recarray_scalar)
-    assert "incompatible function arguments" in str(excinfo.value)
-    # Explicitly convert to m.SimpleStruct.
-    assert m.f_simple(m.SimpleStruct.fromtuple(s_recarray_scalar.item())) == 20
-
-    # Show that an array of dtype=object does *not* convert.
-    s_array_object = np.array([s])
-    assert s_array_object.dtype == object
-    with pytest.raises(TypeError) as excinfo:
-        m.f_simple_vectorized(s_array_object)
-    assert "incompatible function arguments" in str(excinfo.value)
-    # Explicitly convert to `np.array(..., dtype=simple_dtype)`
-    s_array = np.array([s.astuple()], dtype=simple_dtype)
-    np.testing.assert_array_equal(m.f_simple_vectorized(s_array), [20])
-
-
-def test_register_dtype():
-    with pytest.raises(RuntimeError) as excinfo:
-        m.register_dtype()
-    assert "dtype is already registered" in str(excinfo.value)
-
-
-@pytest.mark.xfail("env.PYPY")
-def test_str_leak():
-    from sys import getrefcount
-
-    fmt = "f4"
-    pytest.gc_collect()
-    start = getrefcount(fmt)
-    d = m.dtype_wrapper(fmt)
-    assert d is np.dtype("f4")
-    del d
-    pytest.gc_collect()
-    assert getrefcount(fmt) == start
-
-
-def test_compare_buffer_info():
-    assert all(m.compare_buffer_info())
+import re
+
+import pytest
+
+import env  # noqa: F401
+from pybind11_tests import numpy_dtypes as m
+
+np = pytest.importorskip("numpy")
+
+
+@pytest.fixture(scope="module")
+def simple_dtype():
+    ld = np.dtype("longdouble")
+    return np.dtype(
+        {
+            "names": ["bool_", "uint_", "float_", "ldbl_"],
+            "formats": ["?", "u4", "f4", f"f{ld.itemsize}"],
+            "offsets": [0, 4, 8, (16 if ld.alignment > 4 else 12)],
+        }
+    )
+
+
+@pytest.fixture(scope="module")
+def packed_dtype():
+    return np.dtype([("bool_", "?"), ("uint_", "u4"), ("float_", "f4"), ("ldbl_", "g")])
+
+
+def dt_fmt():
+    from sys import byteorder
+
+    e = "<" if byteorder == "little" else ">"
+    return (
+        "{{'names':['bool_','uint_','float_','ldbl_'],"
+        "'formats':['?','" + e + "u4','" + e + "f4','" + e + "f{}'],"
+        "'offsets':[0,4,8,{}],'itemsize':{}}}"
+    )
+
+
+def simple_dtype_fmt():
+    ld = np.dtype("longdouble")
+    simple_ld_off = 12 + 4 * (ld.alignment > 4)
+    return dt_fmt().format(ld.itemsize, simple_ld_off, simple_ld_off + ld.itemsize)
+
+
+def packed_dtype_fmt():
+    from sys import byteorder
+
+    return "[('bool_','?'),('uint_','{e}u4'),('float_','{e}f4'),('ldbl_','{e}f{}')]".format(
+        np.dtype("longdouble").itemsize, e="<" if byteorder == "little" else ">"
+    )
+
+
+def partial_ld_offset():
+    return (
+        12
+        + 4 * (np.dtype("uint64").alignment > 4)
+        + 8
+        + 8 * (np.dtype("longdouble").alignment > 8)
+    )
+
+
+def partial_dtype_fmt():
+    ld = np.dtype("longdouble")
+    partial_ld_off = partial_ld_offset()
+    partial_size = partial_ld_off + ld.itemsize
+    partial_end_padding = partial_size % np.dtype("uint64").alignment
+    return dt_fmt().format(
+        ld.itemsize, partial_ld_off, partial_size + partial_end_padding
+    )
+
+
+def partial_nested_fmt():
+    ld = np.dtype("longdouble")
+    partial_nested_off = 8 + 8 * (ld.alignment > 8)
+    partial_ld_off = partial_ld_offset()
+    partial_size = partial_ld_off + ld.itemsize
+    partial_end_padding = partial_size % np.dtype("uint64").alignment
+    partial_nested_size = partial_nested_off * 2 + partial_size + partial_end_padding
+    return "{{'names':['a'],'formats':[{}],'offsets':[{}],'itemsize':{}}}".format(
+        partial_dtype_fmt(), partial_nested_off, partial_nested_size
+    )
+
+
+def assert_equal(actual, expected_data, expected_dtype):
+    np.testing.assert_equal(actual, np.array(expected_data, dtype=expected_dtype))
+
+
+def test_format_descriptors():
+    with pytest.raises(RuntimeError) as excinfo:
+        m.get_format_unbound()
+    assert re.match(
+        "^NumPy type info missing for .*UnboundStruct.*$", str(excinfo.value)
+    )
+
+    ld = np.dtype("longdouble")
+    ldbl_fmt = ("4x" if ld.alignment > 4 else "") + ld.char
+    ss_fmt = "^T{?:bool_:3xI:uint_:f:float_:" + ldbl_fmt + ":ldbl_:}"
+    dbl = np.dtype("double")
+    end_padding = ld.itemsize % np.dtype("uint64").alignment
+    partial_fmt = (
+        "^T{?:bool_:3xI:uint_:f:float_:"
+        + str(4 * (dbl.alignment > 4) + dbl.itemsize + 8 * (ld.alignment > 8))
+        + "xg:ldbl_:"
+        + (str(end_padding) + "x}" if end_padding > 0 else "}")
+    )
+    nested_extra = str(max(8, ld.alignment))
+    assert m.print_format_descriptors() == [
+        ss_fmt,
+        "^T{?:bool_:I:uint_:f:float_:g:ldbl_:}",
+        "^T{" + ss_fmt + ":a:^T{?:bool_:I:uint_:f:float_:g:ldbl_:}:b:}",
+        partial_fmt,
+        "^T{" + nested_extra + "x" + partial_fmt + ":a:" + nested_extra + "x}",
+        "^T{3s:a:3s:b:}",
+        "^T{(3)4s:a:(2)i:b:(3)B:c:1x(4, 2)f:d:}",
+        "^T{q:e1:B:e2:}",
+        "^T{Zf:cflt:Zd:cdbl:}",
+    ]
+
+
+def test_dtype(simple_dtype):
+    from sys import byteorder
+
+    e = "<" if byteorder == "little" else ">"
+
+    assert [x.replace(" ", "") for x in m.print_dtypes()] == [
+        simple_dtype_fmt(),
+        packed_dtype_fmt(),
+        f"[('a',{simple_dtype_fmt()}),('b',{packed_dtype_fmt()})]",
+        partial_dtype_fmt(),
+        partial_nested_fmt(),
+        "[('a','S3'),('b','S3')]",
+        (
+            "{{'names':['a','b','c','d'],"
+            + "'formats':[('S4',(3,)),('"
+            + e
+            + "i4',(2,)),('u1',(3,)),('"
+            + e
+            + "f4',(4,2))],"
+            + "'offsets':[0,12,20,24],'itemsize':56}}"
+        ).format(e=e),
+        "[('e1','" + e + "i8'),('e2','u1')]",
+        "[('x','i1'),('y','" + e + "u8')]",
+        "[('cflt','" + e + "c8'),('cdbl','" + e + "c16')]",
+    ]
+
+    d1 = np.dtype(
+        {
+            "names": ["a", "b"],
+            "formats": ["int32", "float64"],
+            "offsets": [1, 10],
+            "itemsize": 20,
+        }
+    )
+    d2 = np.dtype([("a", "i4"), ("b", "f4")])
+    assert m.test_dtype_ctors() == [
+        np.dtype("int32"),
+        np.dtype("float64"),
+        np.dtype("bool"),
+        d1,
+        d1,
+        np.dtype("uint32"),
+        d2,
+        np.dtype("d"),
+    ]
+
+    assert m.test_dtype_methods() == [
+        np.dtype("int32"),
+        simple_dtype,
+        False,
+        True,
+        np.dtype("int32").itemsize,
+        simple_dtype.itemsize,
+    ]
+
+    assert m.trailing_padding_dtype() == m.buffer_to_dtype(
+        np.zeros(1, m.trailing_padding_dtype())
+    )
+
+    expected_chars = "bhilqBHILQefdgFDG?MmO"
+    assert m.test_dtype_kind() == list("iiiiiuuuuuffffcccbMmO")
+    assert m.test_dtype_char_() == list(expected_chars)
+    assert m.test_dtype_num() == [np.dtype(ch).num for ch in expected_chars]
+    assert m.test_dtype_byteorder() == [np.dtype(ch).byteorder for ch in expected_chars]
+    assert m.test_dtype_alignment() == [np.dtype(ch).alignment for ch in expected_chars]
+    assert m.test_dtype_flags() == [chr(np.dtype(ch).flags) for ch in expected_chars]
+
+
+def test_recarray(simple_dtype, packed_dtype):
+    elements = [(False, 0, 0.0, -0.0), (True, 1, 1.5, -2.5), (False, 2, 3.0, -5.0)]
+
+    for func, dtype in [
+        (m.create_rec_simple, simple_dtype),
+        (m.create_rec_packed, packed_dtype),
+    ]:
+        arr = func(0)
+        assert arr.dtype == dtype
+        assert_equal(arr, [], simple_dtype)
+        assert_equal(arr, [], packed_dtype)
+
+        arr = func(3)
+        assert arr.dtype == dtype
+        assert_equal(arr, elements, simple_dtype)
+        assert_equal(arr, elements, packed_dtype)
+
+        # Show what recarray's look like in NumPy.
+        assert type(arr[0]) == np.void
+        assert type(arr[0].item()) == tuple
+
+        if dtype == simple_dtype:
+            assert m.print_rec_simple(arr) == [
+                "s:0,0,0,-0",
+                "s:1,1,1.5,-2.5",
+                "s:0,2,3,-5",
+            ]
+        else:
+            assert m.print_rec_packed(arr) == [
+                "p:0,0,0,-0",
+                "p:1,1,1.5,-2.5",
+                "p:0,2,3,-5",
+            ]
+
+    nested_dtype = np.dtype([("a", simple_dtype), ("b", packed_dtype)])
+
+    arr = m.create_rec_nested(0)
+    assert arr.dtype == nested_dtype
+    assert_equal(arr, [], nested_dtype)
+
+    arr = m.create_rec_nested(3)
+    assert arr.dtype == nested_dtype
+    assert_equal(
+        arr,
+        [
+            ((False, 0, 0.0, -0.0), (True, 1, 1.5, -2.5)),
+            ((True, 1, 1.5, -2.5), (False, 2, 3.0, -5.0)),
+            ((False, 2, 3.0, -5.0), (True, 3, 4.5, -7.5)),
+        ],
+        nested_dtype,
+    )
+    assert m.print_rec_nested(arr) == [
+        "n:a=s:0,0,0,-0;b=p:1,1,1.5,-2.5",
+        "n:a=s:1,1,1.5,-2.5;b=p:0,2,3,-5",
+        "n:a=s:0,2,3,-5;b=p:1,3,4.5,-7.5",
+    ]
+
+    arr = m.create_rec_partial(3)
+    assert str(arr.dtype).replace(" ", "") == partial_dtype_fmt()
+    partial_dtype = arr.dtype
+    assert "" not in arr.dtype.fields
+    assert partial_dtype.itemsize > simple_dtype.itemsize
+    assert_equal(arr, elements, simple_dtype)
+    assert_equal(arr, elements, packed_dtype)
+
+    arr = m.create_rec_partial_nested(3)
+    assert str(arr.dtype).replace(" ", "") == partial_nested_fmt()
+    assert "" not in arr.dtype.fields
+    assert "" not in arr.dtype.fields["a"][0].fields
+    assert arr.dtype.itemsize > partial_dtype.itemsize
+    np.testing.assert_equal(arr["a"], m.create_rec_partial(3))
+
+
+def test_array_constructors():
+    data = np.arange(1, 7, dtype="int32")
+    for i in range(8):
+        np.testing.assert_array_equal(m.test_array_ctors(10 + i), data.reshape((3, 2)))
+        np.testing.assert_array_equal(m.test_array_ctors(20 + i), data.reshape((3, 2)))
+    for i in range(5):
+        np.testing.assert_array_equal(m.test_array_ctors(30 + i), data)
+        np.testing.assert_array_equal(m.test_array_ctors(40 + i), data)
+
+
+def test_string_array():
+    arr = m.create_string_array(True)
+    assert str(arr.dtype) == "[('a', 'S3'), ('b', 'S3')]"
+    assert m.print_string_array(arr) == [
+        "a='',b=''",
+        "a='a',b='a'",
+        "a='ab',b='ab'",
+        "a='abc',b='abc'",
+    ]
+    dtype = arr.dtype
+    assert arr["a"].tolist() == [b"", b"a", b"ab", b"abc"]
+    assert arr["b"].tolist() == [b"", b"a", b"ab", b"abc"]
+    arr = m.create_string_array(False)
+    assert dtype == arr.dtype
+
+
+def test_array_array():
+    from sys import byteorder
+
+    e = "<" if byteorder == "little" else ">"
+
+    arr = m.create_array_array(3)
+    assert str(arr.dtype).replace(" ", "") == (
+        "{{'names':['a','b','c','d'],"
+        + "'formats':[('S4',(3,)),('"
+        + e
+        + "i4',(2,)),('u1',(3,)),('{e}f4',(4,2))],"
+        + "'offsets':[0,12,20,24],'itemsize':56}}"
+    ).format(e=e)
+    assert m.print_array_array(arr) == [
+        "a={{A,B,C,D},{K,L,M,N},{U,V,W,X}},b={0,1},"
+        + "c={0,1,2},d={{0,1},{10,11},{20,21},{30,31}}",
+        "a={{W,X,Y,Z},{G,H,I,J},{Q,R,S,T}},b={1000,1001},"
+        + "c={10,11,12},d={{100,101},{110,111},{120,121},{130,131}}",
+        "a={{S,T,U,V},{C,D,E,F},{M,N,O,P}},b={2000,2001},"
+        + "c={20,21,22},d={{200,201},{210,211},{220,221},{230,231}}",
+    ]
+    assert arr["a"].tolist() == [
+        [b"ABCD", b"KLMN", b"UVWX"],
+        [b"WXYZ", b"GHIJ", b"QRST"],
+        [b"STUV", b"CDEF", b"MNOP"],
+    ]
+    assert arr["b"].tolist() == [[0, 1], [1000, 1001], [2000, 2001]]
+    assert m.create_array_array(0).dtype == arr.dtype
+
+
+def test_enum_array():
+    from sys import byteorder
+
+    e = "<" if byteorder == "little" else ">"
+
+    arr = m.create_enum_array(3)
+    dtype = arr.dtype
+    assert dtype == np.dtype([("e1", e + "i8"), ("e2", "u1")])
+    assert m.print_enum_array(arr) == ["e1=A,e2=X", "e1=B,e2=Y", "e1=A,e2=X"]
+    assert arr["e1"].tolist() == [-1, 1, -1]
+    assert arr["e2"].tolist() == [1, 2, 1]
+    assert m.create_enum_array(0).dtype == dtype
+
+
+def test_complex_array():
+    from sys import byteorder
+
+    e = "<" if byteorder == "little" else ">"
+
+    arr = m.create_complex_array(3)
+    dtype = arr.dtype
+    assert dtype == np.dtype([("cflt", e + "c8"), ("cdbl", e + "c16")])
+    assert m.print_complex_array(arr) == [
+        "c:(0,0.25),(0.5,0.75)",
+        "c:(1,1.25),(1.5,1.75)",
+        "c:(2,2.25),(2.5,2.75)",
+    ]
+    assert arr["cflt"].tolist() == [0.0 + 0.25j, 1.0 + 1.25j, 2.0 + 2.25j]
+    assert arr["cdbl"].tolist() == [0.5 + 0.75j, 1.5 + 1.75j, 2.5 + 2.75j]
+    assert m.create_complex_array(0).dtype == dtype
+
+
+def test_signature(doc):
+    assert (
+        doc(m.create_rec_nested)
+        == "create_rec_nested(arg0: int) -> numpy.ndarray[NestedStruct]"
+    )
+
+
+def test_scalar_conversion():
+    n = 3
+    arrays = [
+        m.create_rec_simple(n),
+        m.create_rec_packed(n),
+        m.create_rec_nested(n),
+        m.create_enum_array(n),
+    ]
+    funcs = [m.f_simple, m.f_packed, m.f_nested]
+
+    for i, func in enumerate(funcs):
+        for j, arr in enumerate(arrays):
+            if i == j and i < 2:
+                assert [func(arr[k]) for k in range(n)] == [k * 10 for k in range(n)]
+            else:
+                with pytest.raises(TypeError) as excinfo:
+                    func(arr[0])
+                assert "incompatible function arguments" in str(excinfo.value)
+
+
+def test_vectorize():
+    n = 3
+    array = m.create_rec_simple(n)
+    values = m.f_simple_vectorized(array)
+    np.testing.assert_array_equal(values, [0, 10, 20])
+    array_2 = m.f_simple_pass_thru_vectorized(array)
+    np.testing.assert_array_equal(array, array_2)
+
+
+def test_cls_and_dtype_conversion(simple_dtype):
+    s = m.SimpleStruct()
+    assert s.astuple() == (False, 0, 0.0, 0.0)
+    assert m.SimpleStruct.fromtuple(s.astuple()).astuple() == s.astuple()
+
+    s.uint_ = 2
+    assert m.f_simple(s) == 20
+
+    # Try as recarray of shape==(1,).
+    s_recarray = np.array([(False, 2, 0.0, 0.0)], dtype=simple_dtype)
+    # Show that this will work for vectorized case.
+    np.testing.assert_array_equal(m.f_simple_vectorized(s_recarray), [20])
+
+    # Show as a scalar that inherits from np.generic.
+    s_scalar = s_recarray[0]
+    assert isinstance(s_scalar, np.void)
+    assert m.f_simple(s_scalar) == 20
+
+    # Show that an *array* scalar (np.ndarray.shape == ()) does not convert.
+    # More specifically, conversion to SimpleStruct is not implicit.
+    s_recarray_scalar = s_recarray.reshape(())
+    assert isinstance(s_recarray_scalar, np.ndarray)
+    assert s_recarray_scalar.dtype == simple_dtype
+    with pytest.raises(TypeError) as excinfo:
+        m.f_simple(s_recarray_scalar)
+    assert "incompatible function arguments" in str(excinfo.value)
+    # Explicitly convert to m.SimpleStruct.
+    assert m.f_simple(m.SimpleStruct.fromtuple(s_recarray_scalar.item())) == 20
+
+    # Show that an array of dtype=object does *not* convert.
+    s_array_object = np.array([s])
+    assert s_array_object.dtype == object
+    with pytest.raises(TypeError) as excinfo:
+        m.f_simple_vectorized(s_array_object)
+    assert "incompatible function arguments" in str(excinfo.value)
+    # Explicitly convert to `np.array(..., dtype=simple_dtype)`
+    s_array = np.array([s.astuple()], dtype=simple_dtype)
+    np.testing.assert_array_equal(m.f_simple_vectorized(s_array), [20])
+
+
+def test_register_dtype():
+    with pytest.raises(RuntimeError) as excinfo:
+        m.register_dtype()
+    assert "dtype is already registered" in str(excinfo.value)
+
+
+@pytest.mark.xfail("env.PYPY")
+def test_str_leak():
+    from sys import getrefcount
+
+    fmt = "f4"
+    pytest.gc_collect()
+    start = getrefcount(fmt)
+    d = m.dtype_wrapper(fmt)
+    assert d is np.dtype("f4")
+    del d
+    pytest.gc_collect()
+    assert getrefcount(fmt) == start
+
+
+def test_compare_buffer_info():
+    assert all(m.compare_buffer_info())
```

## extern/pybind11/tests/test_numpy_vectorize.py

 * *Ordering differences only*

```diff
@@ -1,266 +1,266 @@
-import pytest
-
-from pybind11_tests import numpy_vectorize as m
-
-np = pytest.importorskip("numpy")
-
-
-def test_vectorize(capture):
-    assert np.isclose(m.vectorized_func3(np.array(3 + 7j)), [6 + 14j])
-
-    for f in [m.vectorized_func, m.vectorized_func2]:
-        with capture:
-            assert np.isclose(f(1, 2, 3), 6)
-        assert capture == "my_func(x:int=1, y:float=2, z:float=3)"
-        with capture:
-            assert np.isclose(f(np.array(1), np.array(2), 3), 6)
-        assert capture == "my_func(x:int=1, y:float=2, z:float=3)"
-        with capture:
-            assert np.allclose(f(np.array([1, 3]), np.array([2, 4]), 3), [6, 36])
-        assert (
-            capture
-            == """
-            my_func(x:int=1, y:float=2, z:float=3)
-            my_func(x:int=3, y:float=4, z:float=3)
-        """
-        )
-        with capture:
-            a = np.array([[1, 2], [3, 4]], order="F")
-            b = np.array([[10, 20], [30, 40]], order="F")
-            c = 3
-            result = f(a, b, c)
-            assert np.allclose(result, a * b * c)
-            assert result.flags.f_contiguous
-        # All inputs are F order and full or singletons, so we the result is in col-major order:
-        assert (
-            capture
-            == """
-            my_func(x:int=1, y:float=10, z:float=3)
-            my_func(x:int=3, y:float=30, z:float=3)
-            my_func(x:int=2, y:float=20, z:float=3)
-            my_func(x:int=4, y:float=40, z:float=3)
-        """
-        )
-        with capture:
-            a, b, c = (
-                np.array([[1, 3, 5], [7, 9, 11]]),
-                np.array([[2, 4, 6], [8, 10, 12]]),
-                3,
-            )
-            assert np.allclose(f(a, b, c), a * b * c)
-        assert (
-            capture
-            == """
-            my_func(x:int=1, y:float=2, z:float=3)
-            my_func(x:int=3, y:float=4, z:float=3)
-            my_func(x:int=5, y:float=6, z:float=3)
-            my_func(x:int=7, y:float=8, z:float=3)
-            my_func(x:int=9, y:float=10, z:float=3)
-            my_func(x:int=11, y:float=12, z:float=3)
-        """
-        )
-        with capture:
-            a, b, c = np.array([[1, 2, 3], [4, 5, 6]]), np.array([2, 3, 4]), 2
-            assert np.allclose(f(a, b, c), a * b * c)
-        assert (
-            capture
-            == """
-            my_func(x:int=1, y:float=2, z:float=2)
-            my_func(x:int=2, y:float=3, z:float=2)
-            my_func(x:int=3, y:float=4, z:float=2)
-            my_func(x:int=4, y:float=2, z:float=2)
-            my_func(x:int=5, y:float=3, z:float=2)
-            my_func(x:int=6, y:float=4, z:float=2)
-        """
-        )
-        with capture:
-            a, b, c = np.array([[1, 2, 3], [4, 5, 6]]), np.array([[2], [3]]), 2
-            assert np.allclose(f(a, b, c), a * b * c)
-        assert (
-            capture
-            == """
-            my_func(x:int=1, y:float=2, z:float=2)
-            my_func(x:int=2, y:float=2, z:float=2)
-            my_func(x:int=3, y:float=2, z:float=2)
-            my_func(x:int=4, y:float=3, z:float=2)
-            my_func(x:int=5, y:float=3, z:float=2)
-            my_func(x:int=6, y:float=3, z:float=2)
-        """
-        )
-        with capture:
-            a, b, c = (
-                np.array([[1, 2, 3], [4, 5, 6]], order="F"),
-                np.array([[2], [3]]),
-                2,
-            )
-            assert np.allclose(f(a, b, c), a * b * c)
-        assert (
-            capture
-            == """
-            my_func(x:int=1, y:float=2, z:float=2)
-            my_func(x:int=2, y:float=2, z:float=2)
-            my_func(x:int=3, y:float=2, z:float=2)
-            my_func(x:int=4, y:float=3, z:float=2)
-            my_func(x:int=5, y:float=3, z:float=2)
-            my_func(x:int=6, y:float=3, z:float=2)
-        """
-        )
-        with capture:
-            a, b, c = np.array([[1, 2, 3], [4, 5, 6]])[::, ::2], np.array([[2], [3]]), 2
-            assert np.allclose(f(a, b, c), a * b * c)
-        assert (
-            capture
-            == """
-            my_func(x:int=1, y:float=2, z:float=2)
-            my_func(x:int=3, y:float=2, z:float=2)
-            my_func(x:int=4, y:float=3, z:float=2)
-            my_func(x:int=6, y:float=3, z:float=2)
-        """
-        )
-        with capture:
-            a, b, c = (
-                np.array([[1, 2, 3], [4, 5, 6]], order="F")[::, ::2],
-                np.array([[2], [3]]),
-                2,
-            )
-            assert np.allclose(f(a, b, c), a * b * c)
-        assert (
-            capture
-            == """
-            my_func(x:int=1, y:float=2, z:float=2)
-            my_func(x:int=3, y:float=2, z:float=2)
-            my_func(x:int=4, y:float=3, z:float=2)
-            my_func(x:int=6, y:float=3, z:float=2)
-        """
-        )
-
-
-def test_type_selection():
-    assert m.selective_func(np.array([1], dtype=np.int32)) == "Int branch taken."
-    assert m.selective_func(np.array([1.0], dtype=np.float32)) == "Float branch taken."
-    assert (
-        m.selective_func(np.array([1.0j], dtype=np.complex64))
-        == "Complex float branch taken."
-    )
-
-
-def test_docs(doc):
-    assert (
-        doc(m.vectorized_func)
-        == """
-        vectorized_func(arg0: numpy.ndarray[numpy.int32], arg1: numpy.ndarray[numpy.float32], arg2: numpy.ndarray[numpy.float64]) -> object
-    """  # noqa: E501 line too long
-    )
-
-
-def test_trivial_broadcasting():
-    trivial, vectorized_is_trivial = m.trivial, m.vectorized_is_trivial
-
-    assert vectorized_is_trivial(1, 2, 3) == trivial.c_trivial
-    assert vectorized_is_trivial(np.array(1), np.array(2), 3) == trivial.c_trivial
-    assert (
-        vectorized_is_trivial(np.array([1, 3]), np.array([2, 4]), 3)
-        == trivial.c_trivial
-    )
-    assert trivial.c_trivial == vectorized_is_trivial(
-        np.array([[1, 3, 5], [7, 9, 11]]), np.array([[2, 4, 6], [8, 10, 12]]), 3
-    )
-    assert (
-        vectorized_is_trivial(np.array([[1, 2, 3], [4, 5, 6]]), np.array([2, 3, 4]), 2)
-        == trivial.non_trivial
-    )
-    assert (
-        vectorized_is_trivial(np.array([[1, 2, 3], [4, 5, 6]]), np.array([[2], [3]]), 2)
-        == trivial.non_trivial
-    )
-    z1 = np.array([[1, 2, 3, 4], [5, 6, 7, 8]], dtype="int32")
-    z2 = np.array(z1, dtype="float32")
-    z3 = np.array(z1, dtype="float64")
-    assert vectorized_is_trivial(z1, z2, z3) == trivial.c_trivial
-    assert vectorized_is_trivial(1, z2, z3) == trivial.c_trivial
-    assert vectorized_is_trivial(z1, 1, z3) == trivial.c_trivial
-    assert vectorized_is_trivial(z1, z2, 1) == trivial.c_trivial
-    assert vectorized_is_trivial(z1[::2, ::2], 1, 1) == trivial.non_trivial
-    assert vectorized_is_trivial(1, 1, z1[::2, ::2]) == trivial.c_trivial
-    assert vectorized_is_trivial(1, 1, z3[::2, ::2]) == trivial.non_trivial
-    assert vectorized_is_trivial(z1, 1, z3[1::4, 1::4]) == trivial.c_trivial
-
-    y1 = np.array(z1, order="F")
-    y2 = np.array(y1)
-    y3 = np.array(y1)
-    assert vectorized_is_trivial(y1, y2, y3) == trivial.f_trivial
-    assert vectorized_is_trivial(y1, 1, 1) == trivial.f_trivial
-    assert vectorized_is_trivial(1, y2, 1) == trivial.f_trivial
-    assert vectorized_is_trivial(1, 1, y3) == trivial.f_trivial
-    assert vectorized_is_trivial(y1, z2, 1) == trivial.non_trivial
-    assert vectorized_is_trivial(z1[1::4, 1::4], y2, 1) == trivial.f_trivial
-    assert vectorized_is_trivial(y1[1::4, 1::4], z2, 1) == trivial.c_trivial
-
-    assert m.vectorized_func(z1, z2, z3).flags.c_contiguous
-    assert m.vectorized_func(y1, y2, y3).flags.f_contiguous
-    assert m.vectorized_func(z1, 1, 1).flags.c_contiguous
-    assert m.vectorized_func(1, y2, 1).flags.f_contiguous
-    assert m.vectorized_func(z1[1::4, 1::4], y2, 1).flags.f_contiguous
-    assert m.vectorized_func(y1[1::4, 1::4], z2, 1).flags.c_contiguous
-
-
-def test_passthrough_arguments(doc):
-    assert doc(m.vec_passthrough) == (
-        "vec_passthrough("
-        + ", ".join(
-            [
-                "arg0: float",
-                "arg1: numpy.ndarray[numpy.float64]",
-                "arg2: numpy.ndarray[numpy.float64]",
-                "arg3: numpy.ndarray[numpy.int32]",
-                "arg4: int",
-                "arg5: m.numpy_vectorize.NonPODClass",
-                "arg6: numpy.ndarray[numpy.float64]",
-            ]
-        )
-        + ") -> object"
-    )
-
-    b = np.array([[10, 20, 30]], dtype="float64")
-    c = np.array([100, 200])  # NOT a vectorized argument
-    d = np.array([[1000], [2000], [3000]], dtype="int")
-    g = np.array([[1000000, 2000000, 3000000]], dtype="int")  # requires casting
-    assert np.all(
-        m.vec_passthrough(1, b, c, d, 10000, m.NonPODClass(100000), g)
-        == np.array(
-            [
-                [1111111, 2111121, 3111131],
-                [1112111, 2112121, 3112131],
-                [1113111, 2113121, 3113131],
-            ]
-        )
-    )
-
-
-def test_method_vectorization():
-    o = m.VectorizeTestClass(3)
-    x = np.array([1, 2], dtype="int")
-    y = np.array([[10], [20]], dtype="float32")
-    assert np.all(o.method(x, y) == [[14, 15], [24, 25]])
-
-
-def test_array_collapse():
-    assert not isinstance(m.vectorized_func(1, 2, 3), np.ndarray)
-    assert not isinstance(m.vectorized_func(np.array(1), 2, 3), np.ndarray)
-    z = m.vectorized_func([1], 2, 3)
-    assert isinstance(z, np.ndarray)
-    assert z.shape == (1,)
-    z = m.vectorized_func(1, [[[2]]], 3)
-    assert isinstance(z, np.ndarray)
-    assert z.shape == (1, 1, 1)
-
-
-def test_vectorized_noreturn():
-    x = m.NonPODClass(0)
-    assert x.value == 0
-    m.add_to(x, [1, 2, 3, 4])
-    assert x.value == 10
-    m.add_to(x, 1)
-    assert x.value == 11
-    m.add_to(x, [[1, 1], [2, 3]])
-    assert x.value == 18
+import pytest
+
+from pybind11_tests import numpy_vectorize as m
+
+np = pytest.importorskip("numpy")
+
+
+def test_vectorize(capture):
+    assert np.isclose(m.vectorized_func3(np.array(3 + 7j)), [6 + 14j])
+
+    for f in [m.vectorized_func, m.vectorized_func2]:
+        with capture:
+            assert np.isclose(f(1, 2, 3), 6)
+        assert capture == "my_func(x:int=1, y:float=2, z:float=3)"
+        with capture:
+            assert np.isclose(f(np.array(1), np.array(2), 3), 6)
+        assert capture == "my_func(x:int=1, y:float=2, z:float=3)"
+        with capture:
+            assert np.allclose(f(np.array([1, 3]), np.array([2, 4]), 3), [6, 36])
+        assert (
+            capture
+            == """
+            my_func(x:int=1, y:float=2, z:float=3)
+            my_func(x:int=3, y:float=4, z:float=3)
+        """
+        )
+        with capture:
+            a = np.array([[1, 2], [3, 4]], order="F")
+            b = np.array([[10, 20], [30, 40]], order="F")
+            c = 3
+            result = f(a, b, c)
+            assert np.allclose(result, a * b * c)
+            assert result.flags.f_contiguous
+        # All inputs are F order and full or singletons, so we the result is in col-major order:
+        assert (
+            capture
+            == """
+            my_func(x:int=1, y:float=10, z:float=3)
+            my_func(x:int=3, y:float=30, z:float=3)
+            my_func(x:int=2, y:float=20, z:float=3)
+            my_func(x:int=4, y:float=40, z:float=3)
+        """
+        )
+        with capture:
+            a, b, c = (
+                np.array([[1, 3, 5], [7, 9, 11]]),
+                np.array([[2, 4, 6], [8, 10, 12]]),
+                3,
+            )
+            assert np.allclose(f(a, b, c), a * b * c)
+        assert (
+            capture
+            == """
+            my_func(x:int=1, y:float=2, z:float=3)
+            my_func(x:int=3, y:float=4, z:float=3)
+            my_func(x:int=5, y:float=6, z:float=3)
+            my_func(x:int=7, y:float=8, z:float=3)
+            my_func(x:int=9, y:float=10, z:float=3)
+            my_func(x:int=11, y:float=12, z:float=3)
+        """
+        )
+        with capture:
+            a, b, c = np.array([[1, 2, 3], [4, 5, 6]]), np.array([2, 3, 4]), 2
+            assert np.allclose(f(a, b, c), a * b * c)
+        assert (
+            capture
+            == """
+            my_func(x:int=1, y:float=2, z:float=2)
+            my_func(x:int=2, y:float=3, z:float=2)
+            my_func(x:int=3, y:float=4, z:float=2)
+            my_func(x:int=4, y:float=2, z:float=2)
+            my_func(x:int=5, y:float=3, z:float=2)
+            my_func(x:int=6, y:float=4, z:float=2)
+        """
+        )
+        with capture:
+            a, b, c = np.array([[1, 2, 3], [4, 5, 6]]), np.array([[2], [3]]), 2
+            assert np.allclose(f(a, b, c), a * b * c)
+        assert (
+            capture
+            == """
+            my_func(x:int=1, y:float=2, z:float=2)
+            my_func(x:int=2, y:float=2, z:float=2)
+            my_func(x:int=3, y:float=2, z:float=2)
+            my_func(x:int=4, y:float=3, z:float=2)
+            my_func(x:int=5, y:float=3, z:float=2)
+            my_func(x:int=6, y:float=3, z:float=2)
+        """
+        )
+        with capture:
+            a, b, c = (
+                np.array([[1, 2, 3], [4, 5, 6]], order="F"),
+                np.array([[2], [3]]),
+                2,
+            )
+            assert np.allclose(f(a, b, c), a * b * c)
+        assert (
+            capture
+            == """
+            my_func(x:int=1, y:float=2, z:float=2)
+            my_func(x:int=2, y:float=2, z:float=2)
+            my_func(x:int=3, y:float=2, z:float=2)
+            my_func(x:int=4, y:float=3, z:float=2)
+            my_func(x:int=5, y:float=3, z:float=2)
+            my_func(x:int=6, y:float=3, z:float=2)
+        """
+        )
+        with capture:
+            a, b, c = np.array([[1, 2, 3], [4, 5, 6]])[::, ::2], np.array([[2], [3]]), 2
+            assert np.allclose(f(a, b, c), a * b * c)
+        assert (
+            capture
+            == """
+            my_func(x:int=1, y:float=2, z:float=2)
+            my_func(x:int=3, y:float=2, z:float=2)
+            my_func(x:int=4, y:float=3, z:float=2)
+            my_func(x:int=6, y:float=3, z:float=2)
+        """
+        )
+        with capture:
+            a, b, c = (
+                np.array([[1, 2, 3], [4, 5, 6]], order="F")[::, ::2],
+                np.array([[2], [3]]),
+                2,
+            )
+            assert np.allclose(f(a, b, c), a * b * c)
+        assert (
+            capture
+            == """
+            my_func(x:int=1, y:float=2, z:float=2)
+            my_func(x:int=3, y:float=2, z:float=2)
+            my_func(x:int=4, y:float=3, z:float=2)
+            my_func(x:int=6, y:float=3, z:float=2)
+        """
+        )
+
+
+def test_type_selection():
+    assert m.selective_func(np.array([1], dtype=np.int32)) == "Int branch taken."
+    assert m.selective_func(np.array([1.0], dtype=np.float32)) == "Float branch taken."
+    assert (
+        m.selective_func(np.array([1.0j], dtype=np.complex64))
+        == "Complex float branch taken."
+    )
+
+
+def test_docs(doc):
+    assert (
+        doc(m.vectorized_func)
+        == """
+        vectorized_func(arg0: numpy.ndarray[numpy.int32], arg1: numpy.ndarray[numpy.float32], arg2: numpy.ndarray[numpy.float64]) -> object
+    """  # noqa: E501 line too long
+    )
+
+
+def test_trivial_broadcasting():
+    trivial, vectorized_is_trivial = m.trivial, m.vectorized_is_trivial
+
+    assert vectorized_is_trivial(1, 2, 3) == trivial.c_trivial
+    assert vectorized_is_trivial(np.array(1), np.array(2), 3) == trivial.c_trivial
+    assert (
+        vectorized_is_trivial(np.array([1, 3]), np.array([2, 4]), 3)
+        == trivial.c_trivial
+    )
+    assert trivial.c_trivial == vectorized_is_trivial(
+        np.array([[1, 3, 5], [7, 9, 11]]), np.array([[2, 4, 6], [8, 10, 12]]), 3
+    )
+    assert (
+        vectorized_is_trivial(np.array([[1, 2, 3], [4, 5, 6]]), np.array([2, 3, 4]), 2)
+        == trivial.non_trivial
+    )
+    assert (
+        vectorized_is_trivial(np.array([[1, 2, 3], [4, 5, 6]]), np.array([[2], [3]]), 2)
+        == trivial.non_trivial
+    )
+    z1 = np.array([[1, 2, 3, 4], [5, 6, 7, 8]], dtype="int32")
+    z2 = np.array(z1, dtype="float32")
+    z3 = np.array(z1, dtype="float64")
+    assert vectorized_is_trivial(z1, z2, z3) == trivial.c_trivial
+    assert vectorized_is_trivial(1, z2, z3) == trivial.c_trivial
+    assert vectorized_is_trivial(z1, 1, z3) == trivial.c_trivial
+    assert vectorized_is_trivial(z1, z2, 1) == trivial.c_trivial
+    assert vectorized_is_trivial(z1[::2, ::2], 1, 1) == trivial.non_trivial
+    assert vectorized_is_trivial(1, 1, z1[::2, ::2]) == trivial.c_trivial
+    assert vectorized_is_trivial(1, 1, z3[::2, ::2]) == trivial.non_trivial
+    assert vectorized_is_trivial(z1, 1, z3[1::4, 1::4]) == trivial.c_trivial
+
+    y1 = np.array(z1, order="F")
+    y2 = np.array(y1)
+    y3 = np.array(y1)
+    assert vectorized_is_trivial(y1, y2, y3) == trivial.f_trivial
+    assert vectorized_is_trivial(y1, 1, 1) == trivial.f_trivial
+    assert vectorized_is_trivial(1, y2, 1) == trivial.f_trivial
+    assert vectorized_is_trivial(1, 1, y3) == trivial.f_trivial
+    assert vectorized_is_trivial(y1, z2, 1) == trivial.non_trivial
+    assert vectorized_is_trivial(z1[1::4, 1::4], y2, 1) == trivial.f_trivial
+    assert vectorized_is_trivial(y1[1::4, 1::4], z2, 1) == trivial.c_trivial
+
+    assert m.vectorized_func(z1, z2, z3).flags.c_contiguous
+    assert m.vectorized_func(y1, y2, y3).flags.f_contiguous
+    assert m.vectorized_func(z1, 1, 1).flags.c_contiguous
+    assert m.vectorized_func(1, y2, 1).flags.f_contiguous
+    assert m.vectorized_func(z1[1::4, 1::4], y2, 1).flags.f_contiguous
+    assert m.vectorized_func(y1[1::4, 1::4], z2, 1).flags.c_contiguous
+
+
+def test_passthrough_arguments(doc):
+    assert doc(m.vec_passthrough) == (
+        "vec_passthrough("
+        + ", ".join(
+            [
+                "arg0: float",
+                "arg1: numpy.ndarray[numpy.float64]",
+                "arg2: numpy.ndarray[numpy.float64]",
+                "arg3: numpy.ndarray[numpy.int32]",
+                "arg4: int",
+                "arg5: m.numpy_vectorize.NonPODClass",
+                "arg6: numpy.ndarray[numpy.float64]",
+            ]
+        )
+        + ") -> object"
+    )
+
+    b = np.array([[10, 20, 30]], dtype="float64")
+    c = np.array([100, 200])  # NOT a vectorized argument
+    d = np.array([[1000], [2000], [3000]], dtype="int")
+    g = np.array([[1000000, 2000000, 3000000]], dtype="int")  # requires casting
+    assert np.all(
+        m.vec_passthrough(1, b, c, d, 10000, m.NonPODClass(100000), g)
+        == np.array(
+            [
+                [1111111, 2111121, 3111131],
+                [1112111, 2112121, 3112131],
+                [1113111, 2113121, 3113131],
+            ]
+        )
+    )
+
+
+def test_method_vectorization():
+    o = m.VectorizeTestClass(3)
+    x = np.array([1, 2], dtype="int")
+    y = np.array([[10], [20]], dtype="float32")
+    assert np.all(o.method(x, y) == [[14, 15], [24, 25]])
+
+
+def test_array_collapse():
+    assert not isinstance(m.vectorized_func(1, 2, 3), np.ndarray)
+    assert not isinstance(m.vectorized_func(np.array(1), 2, 3), np.ndarray)
+    z = m.vectorized_func([1], 2, 3)
+    assert isinstance(z, np.ndarray)
+    assert z.shape == (1,)
+    z = m.vectorized_func(1, [[[2]]], 3)
+    assert isinstance(z, np.ndarray)
+    assert z.shape == (1, 1, 1)
+
+
+def test_vectorized_noreturn():
+    x = m.NonPODClass(0)
+    assert x.value == 0
+    m.add_to(x, [1, 2, 3, 4])
+    assert x.value == 10
+    m.add_to(x, 1)
+    assert x.value == 11
+    m.add_to(x, [[1, 1], [2, 3]])
+    assert x.value == 18
```

## extern/pybind11/tests/test_opaque_types.py

 * *Ordering differences only*

```diff
@@ -1,58 +1,58 @@
-import pytest
-
-from pybind11_tests import ConstructorStats, UserType
-from pybind11_tests import opaque_types as m
-
-
-def test_string_list():
-    lst = m.StringList()
-    lst.push_back("Element 1")
-    lst.push_back("Element 2")
-    assert m.print_opaque_list(lst) == "Opaque list: [Element 1, Element 2]"
-    assert lst.back() == "Element 2"
-
-    for i, k in enumerate(lst, start=1):
-        assert k == f"Element {i}"
-    lst.pop_back()
-    assert m.print_opaque_list(lst) == "Opaque list: [Element 1]"
-
-    cvp = m.ClassWithSTLVecProperty()
-    assert m.print_opaque_list(cvp.stringList) == "Opaque list: []"
-
-    cvp.stringList = lst
-    cvp.stringList.push_back("Element 3")
-    assert m.print_opaque_list(cvp.stringList) == "Opaque list: [Element 1, Element 3]"
-
-
-def test_pointers(msg):
-    living_before = ConstructorStats.get(UserType).alive()
-    assert m.get_void_ptr_value(m.return_void_ptr()) == 0x1234
-    assert m.get_void_ptr_value(UserType())  # Should also work for other C++ types
-    assert ConstructorStats.get(UserType).alive() == living_before
-
-    with pytest.raises(TypeError) as excinfo:
-        m.get_void_ptr_value([1, 2, 3])  # This should not work
-    assert (
-        msg(excinfo.value)
-        == """
-        get_void_ptr_value(): incompatible function arguments. The following argument types are supported:
-            1. (arg0: capsule) -> int
-
-        Invoked with: [1, 2, 3]
-    """
-    )
-
-    assert m.return_null_str() is None
-    assert m.get_null_str_value(m.return_null_str()) is not None
-
-    ptr = m.return_unique_ptr()
-    assert "StringList" in repr(ptr)
-    assert m.print_opaque_list(ptr) == "Opaque list: [some value]"
-
-
-def test_unions():
-    int_float_union = m.IntFloat()
-    int_float_union.i = 42
-    assert int_float_union.i == 42
-    int_float_union.f = 3.0
-    assert int_float_union.f == 3.0
+import pytest
+
+from pybind11_tests import ConstructorStats, UserType
+from pybind11_tests import opaque_types as m
+
+
+def test_string_list():
+    lst = m.StringList()
+    lst.push_back("Element 1")
+    lst.push_back("Element 2")
+    assert m.print_opaque_list(lst) == "Opaque list: [Element 1, Element 2]"
+    assert lst.back() == "Element 2"
+
+    for i, k in enumerate(lst, start=1):
+        assert k == f"Element {i}"
+    lst.pop_back()
+    assert m.print_opaque_list(lst) == "Opaque list: [Element 1]"
+
+    cvp = m.ClassWithSTLVecProperty()
+    assert m.print_opaque_list(cvp.stringList) == "Opaque list: []"
+
+    cvp.stringList = lst
+    cvp.stringList.push_back("Element 3")
+    assert m.print_opaque_list(cvp.stringList) == "Opaque list: [Element 1, Element 3]"
+
+
+def test_pointers(msg):
+    living_before = ConstructorStats.get(UserType).alive()
+    assert m.get_void_ptr_value(m.return_void_ptr()) == 0x1234
+    assert m.get_void_ptr_value(UserType())  # Should also work for other C++ types
+    assert ConstructorStats.get(UserType).alive() == living_before
+
+    with pytest.raises(TypeError) as excinfo:
+        m.get_void_ptr_value([1, 2, 3])  # This should not work
+    assert (
+        msg(excinfo.value)
+        == """
+        get_void_ptr_value(): incompatible function arguments. The following argument types are supported:
+            1. (arg0: capsule) -> int
+
+        Invoked with: [1, 2, 3]
+    """
+    )
+
+    assert m.return_null_str() is None
+    assert m.get_null_str_value(m.return_null_str()) is not None
+
+    ptr = m.return_unique_ptr()
+    assert "StringList" in repr(ptr)
+    assert m.print_opaque_list(ptr) == "Opaque list: [some value]"
+
+
+def test_unions():
+    int_float_union = m.IntFloat()
+    int_float_union.i = 42
+    assert int_float_union.i == 42
+    int_float_union.f = 3.0
+    assert int_float_union.f == 3.0
```

## extern/pybind11/tests/test_operator_overloading.py

 * *Ordering differences only*

```diff
@@ -1,151 +1,151 @@
-import pytest
-
-from pybind11_tests import ConstructorStats
-from pybind11_tests import operators as m
-
-
-def test_operator_overloading():
-    v1 = m.Vector2(1, 2)
-    v2 = m.Vector(3, -1)
-    v3 = m.Vector2(1, 2)  # Same value as v1, but different instance.
-    assert v1 is not v3
-
-    assert str(v1) == "[1.000000, 2.000000]"
-    assert str(v2) == "[3.000000, -1.000000]"
-
-    assert str(-v2) == "[-3.000000, 1.000000]"
-
-    assert str(v1 + v2) == "[4.000000, 1.000000]"
-    assert str(v1 - v2) == "[-2.000000, 3.000000]"
-    assert str(v1 - 8) == "[-7.000000, -6.000000]"
-    assert str(v1 + 8) == "[9.000000, 10.000000]"
-    assert str(v1 * 8) == "[8.000000, 16.000000]"
-    assert str(v1 / 8) == "[0.125000, 0.250000]"
-    assert str(8 - v1) == "[7.000000, 6.000000]"
-    assert str(8 + v1) == "[9.000000, 10.000000]"
-    assert str(8 * v1) == "[8.000000, 16.000000]"
-    assert str(8 / v1) == "[8.000000, 4.000000]"
-    assert str(v1 * v2) == "[3.000000, -2.000000]"
-    assert str(v2 / v1) == "[3.000000, -0.500000]"
-
-    assert v1 == v3
-    assert v1 != v2
-    assert hash(v1) == 4
-    # TODO(eric.cousineau): Make this work.
-    # assert abs(v1) == "abs(Vector2)"
-
-    v1 += 2 * v2
-    assert str(v1) == "[7.000000, 0.000000]"
-    v1 -= v2
-    assert str(v1) == "[4.000000, 1.000000]"
-    v1 *= 2
-    assert str(v1) == "[8.000000, 2.000000]"
-    v1 /= 16
-    assert str(v1) == "[0.500000, 0.125000]"
-    v1 *= v2
-    assert str(v1) == "[1.500000, -0.125000]"
-    v2 /= v1
-    assert str(v2) == "[2.000000, 8.000000]"
-
-    cstats = ConstructorStats.get(m.Vector2)
-    assert cstats.alive() == 3
-    del v1
-    assert cstats.alive() == 2
-    del v2
-    assert cstats.alive() == 1
-    del v3
-    assert cstats.alive() == 0
-    assert cstats.values() == [
-        "[1.000000, 2.000000]",
-        "[3.000000, -1.000000]",
-        "[1.000000, 2.000000]",
-        "[-3.000000, 1.000000]",
-        "[4.000000, 1.000000]",
-        "[-2.000000, 3.000000]",
-        "[-7.000000, -6.000000]",
-        "[9.000000, 10.000000]",
-        "[8.000000, 16.000000]",
-        "[0.125000, 0.250000]",
-        "[7.000000, 6.000000]",
-        "[9.000000, 10.000000]",
-        "[8.000000, 16.000000]",
-        "[8.000000, 4.000000]",
-        "[3.000000, -2.000000]",
-        "[3.000000, -0.500000]",
-        "[6.000000, -2.000000]",
-    ]
-    assert cstats.default_constructions == 0
-    assert cstats.copy_constructions == 0
-    assert cstats.move_constructions >= 10
-    assert cstats.copy_assignments == 0
-    assert cstats.move_assignments == 0
-
-
-def test_operators_notimplemented():
-    """#393: need to return NotSupported to ensure correct arithmetic operator behavior"""
-
-    c1, c2 = m.C1(), m.C2()
-    assert c1 + c1 == 11
-    assert c2 + c2 == 22
-    assert c2 + c1 == 21
-    assert c1 + c2 == 12
-
-
-def test_nested():
-    """#328: first member in a class can't be used in operators"""
-
-    a = m.NestA()
-    b = m.NestB()
-    c = m.NestC()
-
-    a += 10
-    assert m.get_NestA(a) == 13
-    b.a += 100
-    assert m.get_NestA(b.a) == 103
-    c.b.a += 1000
-    assert m.get_NestA(c.b.a) == 1003
-    b -= 1
-    assert m.get_NestB(b) == 3
-    c.b -= 3
-    assert m.get_NestB(c.b) == 1
-    c *= 7
-    assert m.get_NestC(c) == 35
-
-    abase = a.as_base()
-    assert abase.value == -2
-    a.as_base().value += 44
-    assert abase.value == 42
-    assert c.b.a.as_base().value == -2
-    c.b.a.as_base().value += 44
-    assert c.b.a.as_base().value == 42
-
-    del c
-    pytest.gc_collect()
-    del a  # Shouldn't delete while abase is still alive
-    pytest.gc_collect()
-
-    assert abase.value == 42
-    del abase, b
-    pytest.gc_collect()
-
-
-def test_overriding_eq_reset_hash():
-    assert m.Comparable(15) is not m.Comparable(15)
-    assert m.Comparable(15) == m.Comparable(15)
-
-    with pytest.raises(TypeError) as excinfo:
-        hash(m.Comparable(15))
-    assert str(excinfo.value).startswith("unhashable type:")
-
-    for hashable in (m.Hashable, m.Hashable2):
-        assert hashable(15) is not hashable(15)
-        assert hashable(15) == hashable(15)
-
-        assert hash(hashable(15)) == 15
-        assert hash(hashable(15)) == hash(hashable(15))
-
-
-def test_return_set_of_unhashable():
-    with pytest.raises(TypeError) as excinfo:
-        m.get_unhashable_HashMe_set()
-    assert str(excinfo.value.__cause__).startswith("unhashable type:")
+import pytest
+
+from pybind11_tests import ConstructorStats
+from pybind11_tests import operators as m
+
+
+def test_operator_overloading():
+    v1 = m.Vector2(1, 2)
+    v2 = m.Vector(3, -1)
+    v3 = m.Vector2(1, 2)  # Same value as v1, but different instance.
+    assert v1 is not v3
+
+    assert str(v1) == "[1.000000, 2.000000]"
+    assert str(v2) == "[3.000000, -1.000000]"
+
+    assert str(-v2) == "[-3.000000, 1.000000]"
+
+    assert str(v1 + v2) == "[4.000000, 1.000000]"
+    assert str(v1 - v2) == "[-2.000000, 3.000000]"
+    assert str(v1 - 8) == "[-7.000000, -6.000000]"
+    assert str(v1 + 8) == "[9.000000, 10.000000]"
+    assert str(v1 * 8) == "[8.000000, 16.000000]"
+    assert str(v1 / 8) == "[0.125000, 0.250000]"
+    assert str(8 - v1) == "[7.000000, 6.000000]"
+    assert str(8 + v1) == "[9.000000, 10.000000]"
+    assert str(8 * v1) == "[8.000000, 16.000000]"
+    assert str(8 / v1) == "[8.000000, 4.000000]"
+    assert str(v1 * v2) == "[3.000000, -2.000000]"
+    assert str(v2 / v1) == "[3.000000, -0.500000]"
+
+    assert v1 == v3
+    assert v1 != v2
+    assert hash(v1) == 4
+    # TODO(eric.cousineau): Make this work.
+    # assert abs(v1) == "abs(Vector2)"
+
+    v1 += 2 * v2
+    assert str(v1) == "[7.000000, 0.000000]"
+    v1 -= v2
+    assert str(v1) == "[4.000000, 1.000000]"
+    v1 *= 2
+    assert str(v1) == "[8.000000, 2.000000]"
+    v1 /= 16
+    assert str(v1) == "[0.500000, 0.125000]"
+    v1 *= v2
+    assert str(v1) == "[1.500000, -0.125000]"
+    v2 /= v1
+    assert str(v2) == "[2.000000, 8.000000]"
+
+    cstats = ConstructorStats.get(m.Vector2)
+    assert cstats.alive() == 3
+    del v1
+    assert cstats.alive() == 2
+    del v2
+    assert cstats.alive() == 1
+    del v3
+    assert cstats.alive() == 0
+    assert cstats.values() == [
+        "[1.000000, 2.000000]",
+        "[3.000000, -1.000000]",
+        "[1.000000, 2.000000]",
+        "[-3.000000, 1.000000]",
+        "[4.000000, 1.000000]",
+        "[-2.000000, 3.000000]",
+        "[-7.000000, -6.000000]",
+        "[9.000000, 10.000000]",
+        "[8.000000, 16.000000]",
+        "[0.125000, 0.250000]",
+        "[7.000000, 6.000000]",
+        "[9.000000, 10.000000]",
+        "[8.000000, 16.000000]",
+        "[8.000000, 4.000000]",
+        "[3.000000, -2.000000]",
+        "[3.000000, -0.500000]",
+        "[6.000000, -2.000000]",
+    ]
+    assert cstats.default_constructions == 0
+    assert cstats.copy_constructions == 0
+    assert cstats.move_constructions >= 10
+    assert cstats.copy_assignments == 0
+    assert cstats.move_assignments == 0
+
+
+def test_operators_notimplemented():
+    """#393: need to return NotSupported to ensure correct arithmetic operator behavior"""
+
+    c1, c2 = m.C1(), m.C2()
+    assert c1 + c1 == 11
+    assert c2 + c2 == 22
+    assert c2 + c1 == 21
+    assert c1 + c2 == 12
+
+
+def test_nested():
+    """#328: first member in a class can't be used in operators"""
+
+    a = m.NestA()
+    b = m.NestB()
+    c = m.NestC()
+
+    a += 10
+    assert m.get_NestA(a) == 13
+    b.a += 100
+    assert m.get_NestA(b.a) == 103
+    c.b.a += 1000
+    assert m.get_NestA(c.b.a) == 1003
+    b -= 1
+    assert m.get_NestB(b) == 3
+    c.b -= 3
+    assert m.get_NestB(c.b) == 1
+    c *= 7
+    assert m.get_NestC(c) == 35
+
+    abase = a.as_base()
+    assert abase.value == -2
+    a.as_base().value += 44
+    assert abase.value == 42
+    assert c.b.a.as_base().value == -2
+    c.b.a.as_base().value += 44
+    assert c.b.a.as_base().value == 42
+
+    del c
+    pytest.gc_collect()
+    del a  # Shouldn't delete while abase is still alive
+    pytest.gc_collect()
+
+    assert abase.value == 42
+    del abase, b
+    pytest.gc_collect()
+
+
+def test_overriding_eq_reset_hash():
+    assert m.Comparable(15) is not m.Comparable(15)
+    assert m.Comparable(15) == m.Comparable(15)
+
+    with pytest.raises(TypeError) as excinfo:
+        hash(m.Comparable(15))
+    assert str(excinfo.value).startswith("unhashable type:")
+
+    for hashable in (m.Hashable, m.Hashable2):
+        assert hashable(15) is not hashable(15)
+        assert hashable(15) == hashable(15)
+
+        assert hash(hashable(15)) == 15
+        assert hash(hashable(15)) == hash(hashable(15))
+
+
+def test_return_set_of_unhashable():
+    with pytest.raises(TypeError) as excinfo:
+        m.get_unhashable_HashMe_set()
+    assert str(excinfo.value.__cause__).startswith("unhashable type:")
```

## extern/pybind11/tests/test_pickling.py

 * *Ordering differences only*

```diff
@@ -1,93 +1,93 @@
-import pickle
-import re
-
-import pytest
-
-import env
-from pybind11_tests import pickling as m
-
-
-def test_pickle_simple_callable():
-    assert m.simple_callable() == 20220426
-    if env.PYPY:
-        serialized = pickle.dumps(m.simple_callable)
-        deserialized = pickle.loads(serialized)
-        assert deserialized() == 20220426
-    else:
-        # To document broken behavior: currently it fails universally with
-        # all C Python versions.
-        with pytest.raises(TypeError) as excinfo:
-            pickle.dumps(m.simple_callable)
-        assert re.search("can.*t pickle .*PyCapsule.* object", str(excinfo.value))
-
-
-@pytest.mark.parametrize("cls_name", ["Pickleable", "PickleableNew"])
-def test_roundtrip(cls_name):
-    cls = getattr(m, cls_name)
-    p = cls("test_value")
-    p.setExtra1(15)
-    p.setExtra2(48)
-
-    data = pickle.dumps(p, 2)  # Must use pickle protocol >= 2
-    p2 = pickle.loads(data)
-    assert p2.value() == p.value()
-    assert p2.extra1() == p.extra1()
-    assert p2.extra2() == p.extra2()
-
-
-@pytest.mark.xfail("env.PYPY")
-@pytest.mark.parametrize("cls_name", ["PickleableWithDict", "PickleableWithDictNew"])
-def test_roundtrip_with_dict(cls_name):
-    cls = getattr(m, cls_name)
-    p = cls("test_value")
-    p.extra = 15
-    p.dynamic = "Attribute"
-
-    data = pickle.dumps(p, pickle.HIGHEST_PROTOCOL)
-    p2 = pickle.loads(data)
-    assert p2.value == p.value
-    assert p2.extra == p.extra
-    assert p2.dynamic == p.dynamic
-
-
-def test_enum_pickle():
-    from pybind11_tests import enums as e
-
-    data = pickle.dumps(e.EOne, 2)
-    assert e.EOne == pickle.loads(data)
-
-
-#
-# exercise_trampoline
-#
-class SimplePyDerived(m.SimpleBase):
-    pass
-
-
-def test_roundtrip_simple_py_derived():
-    p = SimplePyDerived()
-    p.num = 202
-    p.stored_in_dict = 303
-    data = pickle.dumps(p, pickle.HIGHEST_PROTOCOL)
-    p2 = pickle.loads(data)
-    assert isinstance(p2, SimplePyDerived)
-    assert p2.num == 202
-    assert p2.stored_in_dict == 303
-
-
-def test_roundtrip_simple_cpp_derived():
-    p = m.make_SimpleCppDerivedAsBase()
-    assert m.check_dynamic_cast_SimpleCppDerived(p)
-    p.num = 404
-    if not env.PYPY:
-        # To ensure that this unit test is not accidentally invalidated.
-        with pytest.raises(AttributeError):
-            # Mimics the `setstate` C++ implementation.
-            setattr(p, "__dict__", {})  # noqa: B010
-    data = pickle.dumps(p, pickle.HIGHEST_PROTOCOL)
-    p2 = pickle.loads(data)
-    assert isinstance(p2, m.SimpleBase)
-    assert p2.num == 404
-    # Issue #3062: pickleable base C++ classes can incur object slicing
-    #              if derived typeid is not registered with pybind11
-    assert not m.check_dynamic_cast_SimpleCppDerived(p2)
+import pickle
+import re
+
+import pytest
+
+import env
+from pybind11_tests import pickling as m
+
+
+def test_pickle_simple_callable():
+    assert m.simple_callable() == 20220426
+    if env.PYPY:
+        serialized = pickle.dumps(m.simple_callable)
+        deserialized = pickle.loads(serialized)
+        assert deserialized() == 20220426
+    else:
+        # To document broken behavior: currently it fails universally with
+        # all C Python versions.
+        with pytest.raises(TypeError) as excinfo:
+            pickle.dumps(m.simple_callable)
+        assert re.search("can.*t pickle .*PyCapsule.* object", str(excinfo.value))
+
+
+@pytest.mark.parametrize("cls_name", ["Pickleable", "PickleableNew"])
+def test_roundtrip(cls_name):
+    cls = getattr(m, cls_name)
+    p = cls("test_value")
+    p.setExtra1(15)
+    p.setExtra2(48)
+
+    data = pickle.dumps(p, 2)  # Must use pickle protocol >= 2
+    p2 = pickle.loads(data)
+    assert p2.value() == p.value()
+    assert p2.extra1() == p.extra1()
+    assert p2.extra2() == p.extra2()
+
+
+@pytest.mark.xfail("env.PYPY")
+@pytest.mark.parametrize("cls_name", ["PickleableWithDict", "PickleableWithDictNew"])
+def test_roundtrip_with_dict(cls_name):
+    cls = getattr(m, cls_name)
+    p = cls("test_value")
+    p.extra = 15
+    p.dynamic = "Attribute"
+
+    data = pickle.dumps(p, pickle.HIGHEST_PROTOCOL)
+    p2 = pickle.loads(data)
+    assert p2.value == p.value
+    assert p2.extra == p.extra
+    assert p2.dynamic == p.dynamic
+
+
+def test_enum_pickle():
+    from pybind11_tests import enums as e
+
+    data = pickle.dumps(e.EOne, 2)
+    assert e.EOne == pickle.loads(data)
+
+
+#
+# exercise_trampoline
+#
+class SimplePyDerived(m.SimpleBase):
+    pass
+
+
+def test_roundtrip_simple_py_derived():
+    p = SimplePyDerived()
+    p.num = 202
+    p.stored_in_dict = 303
+    data = pickle.dumps(p, pickle.HIGHEST_PROTOCOL)
+    p2 = pickle.loads(data)
+    assert isinstance(p2, SimplePyDerived)
+    assert p2.num == 202
+    assert p2.stored_in_dict == 303
+
+
+def test_roundtrip_simple_cpp_derived():
+    p = m.make_SimpleCppDerivedAsBase()
+    assert m.check_dynamic_cast_SimpleCppDerived(p)
+    p.num = 404
+    if not env.PYPY:
+        # To ensure that this unit test is not accidentally invalidated.
+        with pytest.raises(AttributeError):
+            # Mimics the `setstate` C++ implementation.
+            setattr(p, "__dict__", {})  # noqa: B010
+    data = pickle.dumps(p, pickle.HIGHEST_PROTOCOL)
+    p2 = pickle.loads(data)
+    assert isinstance(p2, m.SimpleBase)
+    assert p2.num == 404
+    # Issue #3062: pickleable base C++ classes can incur object slicing
+    #              if derived typeid is not registered with pybind11
+    assert not m.check_dynamic_cast_SimpleCppDerived(p2)
```

## extern/pybind11/tests/test_pytypes.py

 * *Ordering differences only*

```diff
@@ -1,885 +1,885 @@
-import contextlib
-import sys
-import types
-
-import pytest
-
-import env
-from pybind11_tests import detailed_error_messages_enabled
-from pybind11_tests import pytypes as m
-
-
-def test_obj_class_name():
-    assert m.obj_class_name(None) == "NoneType"
-    assert m.obj_class_name(list) == "list"
-    assert m.obj_class_name([]) == "list"
-
-
-def test_handle_from_move_only_type_with_operator_PyObject():  # noqa: N802
-    assert m.handle_from_move_only_type_with_operator_PyObject_ncnst()
-    assert m.handle_from_move_only_type_with_operator_PyObject_const()
-
-
-def test_bool(doc):
-    assert doc(m.get_bool) == "get_bool() -> bool"
-
-
-def test_int(doc):
-    assert doc(m.get_int) == "get_int() -> int"
-
-
-def test_iterator(doc):
-    assert doc(m.get_iterator) == "get_iterator() -> Iterator"
-
-
-@pytest.mark.parametrize(
-    "pytype, from_iter_func",
-    [
-        (frozenset, m.get_frozenset_from_iterable),
-        (list, m.get_list_from_iterable),
-        (set, m.get_set_from_iterable),
-        (tuple, m.get_tuple_from_iterable),
-    ],
-)
-def test_from_iterable(pytype, from_iter_func):
-    my_iter = iter(range(10))
-    s = from_iter_func(my_iter)
-    assert type(s) == pytype
-    assert s == pytype(range(10))
-
-
-def test_iterable(doc):
-    assert doc(m.get_iterable) == "get_iterable() -> Iterable"
-
-
-def test_float(doc):
-    assert doc(m.get_float) == "get_float() -> float"
-
-
-def test_list(capture, doc):
-    assert m.list_no_args() == []
-    assert m.list_ssize_t() == []
-    assert m.list_size_t() == []
-    lins = [1, 2]
-    m.list_insert_ssize_t(lins)
-    assert lins == [1, 83, 2]
-    m.list_insert_size_t(lins)
-    assert lins == [1, 83, 2, 57]
-
-    with capture:
-        lst = m.get_list()
-        assert lst == ["inserted-0", "overwritten", "inserted-2"]
-
-        lst.append("value2")
-        m.print_list(lst)
-    assert (
-        capture.unordered
-        == """
-        Entry at position 0: value
-        list item 0: inserted-0
-        list item 1: overwritten
-        list item 2: inserted-2
-        list item 3: value2
-    """
-    )
-
-    assert doc(m.get_list) == "get_list() -> list"
-    assert doc(m.print_list) == "print_list(arg0: list) -> None"
-
-
-def test_none(capture, doc):
-    assert doc(m.get_none) == "get_none() -> None"
-    assert doc(m.print_none) == "print_none(arg0: None) -> None"
-
-
-def test_set(capture, doc):
-    s = m.get_set()
-    assert isinstance(s, set)
-    assert s == {"key1", "key2", "key3"}
-
-    s.add("key4")
-    with capture:
-        m.print_anyset(s)
-    assert (
-        capture.unordered
-        == """
-        key: key1
-        key: key2
-        key: key3
-        key: key4
-    """
-    )
-
-    m.set_add(s, "key5")
-    assert m.anyset_size(s) == 5
-
-    m.set_clear(s)
-    assert m.anyset_empty(s)
-
-    assert not m.anyset_contains(set(), 42)
-    assert m.anyset_contains({42}, 42)
-    assert m.anyset_contains({"foo"}, "foo")
-
-    assert doc(m.get_set) == "get_set() -> set"
-    assert doc(m.print_anyset) == "print_anyset(arg0: anyset) -> None"
-
-
-def test_frozenset(capture, doc):
-    s = m.get_frozenset()
-    assert isinstance(s, frozenset)
-    assert s == frozenset({"key1", "key2", "key3"})
-
-    with capture:
-        m.print_anyset(s)
-    assert (
-        capture.unordered
-        == """
-        key: key1
-        key: key2
-        key: key3
-    """
-    )
-    assert m.anyset_size(s) == 3
-    assert not m.anyset_empty(s)
-
-    assert not m.anyset_contains(frozenset(), 42)
-    assert m.anyset_contains(frozenset({42}), 42)
-    assert m.anyset_contains(frozenset({"foo"}), "foo")
-
-    assert doc(m.get_frozenset) == "get_frozenset() -> frozenset"
-
-
-def test_dict(capture, doc):
-    d = m.get_dict()
-    assert d == {"key": "value"}
-
-    with capture:
-        d["key2"] = "value2"
-        m.print_dict(d)
-    assert (
-        capture.unordered
-        == """
-        key: key, value=value
-        key: key2, value=value2
-    """
-    )
-
-    assert not m.dict_contains({}, 42)
-    assert m.dict_contains({42: None}, 42)
-    assert m.dict_contains({"foo": None}, "foo")
-
-    assert doc(m.get_dict) == "get_dict() -> dict"
-    assert doc(m.print_dict) == "print_dict(arg0: dict) -> None"
-
-    assert m.dict_keyword_constructor() == {"x": 1, "y": 2, "z": 3}
-
-
-class CustomContains:
-    d = {"key": None}
-
-    def __contains__(self, m):
-        return m in self.d
-
-
-@pytest.mark.parametrize(
-    "arg,func",
-    [
-        (set(), m.anyset_contains),
-        (dict(), m.dict_contains),
-        (CustomContains(), m.obj_contains),
-    ],
-)
-@pytest.mark.xfail("env.PYPY and sys.pypy_version_info < (7, 3, 10)", strict=False)
-def test_unhashable_exceptions(arg, func):
-    class Unhashable:
-        __hash__ = None
-
-    with pytest.raises(TypeError) as exc_info:
-        func(arg, Unhashable())
-    assert "unhashable type:" in str(exc_info.value)
-
-
-def test_tuple():
-    assert m.tuple_no_args() == ()
-    assert m.tuple_ssize_t() == ()
-    assert m.tuple_size_t() == ()
-    assert m.get_tuple() == (42, None, "spam")
-
-
-def test_simple_namespace():
-    ns = m.get_simple_namespace()
-    assert ns.attr == 42
-    assert ns.x == "foo"
-    assert ns.right == 2
-    assert not hasattr(ns, "wrong")
-
-
-def test_str(doc):
-    assert m.str_from_char_ssize_t().encode().decode() == "red"
-    assert m.str_from_char_size_t().encode().decode() == "blue"
-    assert m.str_from_string().encode().decode() == "baz"
-    assert m.str_from_bytes().encode().decode() == "boo"
-
-    assert doc(m.str_from_bytes) == "str_from_bytes() -> str"
-
-    class A:
-        def __str__(self):
-            return "this is a str"
-
-        def __repr__(self):
-            return "this is a repr"
-
-    assert m.str_from_object(A()) == "this is a str"
-    assert m.repr_from_object(A()) == "this is a repr"
-    assert m.str_from_handle(A()) == "this is a str"
-
-    s1, s2 = m.str_format()
-    assert s1 == "1 + 2 = 3"
-    assert s1 == s2
-
-    malformed_utf8 = b"\x80"
-    if hasattr(m, "PYBIND11_STR_LEGACY_PERMISSIVE"):
-        assert m.str_from_object(malformed_utf8) is malformed_utf8
-    else:
-        assert m.str_from_object(malformed_utf8) == "b'\\x80'"
-    assert m.str_from_handle(malformed_utf8) == "b'\\x80'"
-
-    assert m.str_from_string_from_str("this is a str") == "this is a str"
-    ucs_surrogates_str = "\udcc3"
-    with pytest.raises(UnicodeEncodeError):
-        m.str_from_string_from_str(ucs_surrogates_str)
-
-
-@pytest.mark.parametrize(
-    "func",
-    [
-        m.str_from_bytes_input,
-        m.str_from_cstr_input,
-        m.str_from_std_string_input,
-    ],
-)
-def test_surrogate_pairs_unicode_error(func):
-    input_str = "\ud83d\ude4f".encode("utf-8", "surrogatepass")
-    with pytest.raises(UnicodeDecodeError):
-        func(input_str)
-
-
-def test_bytes(doc):
-    assert m.bytes_from_char_ssize_t().decode() == "green"
-    assert m.bytes_from_char_size_t().decode() == "purple"
-    assert m.bytes_from_string().decode() == "foo"
-    assert m.bytes_from_str().decode() == "bar"
-
-    assert doc(m.bytes_from_str) == "bytes_from_str() -> bytes"
-
-
-def test_bytearray(doc):
-    assert m.bytearray_from_char_ssize_t().decode() == "$%"
-    assert m.bytearray_from_char_size_t().decode() == "@$!"
-    assert m.bytearray_from_string().decode() == "foo"
-    assert m.bytearray_size() == len("foo")
-
-
-def test_capsule(capture):
-    pytest.gc_collect()
-    with capture:
-        a = m.return_capsule_with_destructor()
-        del a
-        pytest.gc_collect()
-    assert (
-        capture.unordered
-        == """
-        creating capsule
-        destructing capsule
-    """
-    )
-
-    with capture:
-        a = m.return_renamed_capsule_with_destructor()
-        del a
-        pytest.gc_collect()
-    assert (
-        capture.unordered
-        == """
-        creating capsule
-        renaming capsule
-        destructing capsule
-    """
-    )
-
-    with capture:
-        a = m.return_capsule_with_destructor_2()
-        del a
-        pytest.gc_collect()
-    assert (
-        capture.unordered
-        == """
-        creating capsule
-        destructing capsule: 1234
-    """
-    )
-
-    with capture:
-        a = m.return_renamed_capsule_with_destructor_2()
-        del a
-        pytest.gc_collect()
-    assert (
-        capture.unordered
-        == """
-        creating capsule
-        renaming capsule
-        destructing capsule: 1234
-    """
-    )
-
-    with capture:
-        a = m.return_capsule_with_name_and_destructor()
-        del a
-        pytest.gc_collect()
-    assert (
-        capture.unordered
-        == """
-        created capsule (1234, 'pointer type description')
-        destructing capsule (1234, 'pointer type description')
-    """
-    )
-
-    with capture:
-        a = m.return_capsule_with_explicit_nullptr_dtor()
-        del a
-        pytest.gc_collect()
-    assert (
-        capture.unordered
-        == """
-        creating capsule with explicit nullptr dtor
-    """
-    )
-
-
-def test_accessors():
-    class SubTestObject:
-        attr_obj = 1
-        attr_char = 2
-
-    class TestObject:
-        basic_attr = 1
-        begin_end = [1, 2, 3]
-        d = {"operator[object]": 1, "operator[char *]": 2}
-        sub = SubTestObject()
-
-        def func(self, x, *args):
-            return self.basic_attr + x + sum(args)
-
-    d = m.accessor_api(TestObject())
-    assert d["basic_attr"] == 1
-    assert d["begin_end"] == [1, 2, 3]
-    assert d["operator[object]"] == 1
-    assert d["operator[char *]"] == 2
-    assert d["attr(object)"] == 1
-    assert d["attr(char *)"] == 2
-    assert d["missing_attr_ptr"] == "raised"
-    assert d["missing_attr_chain"] == "raised"
-    assert d["is_none"] is False
-    assert d["operator()"] == 2
-    assert d["operator*"] == 7
-    assert d["implicit_list"] == [1, 2, 3]
-    assert all(x in TestObject.__dict__ for x in d["implicit_dict"])
-
-    assert m.tuple_accessor(tuple()) == (0, 1, 2)
-
-    d = m.accessor_assignment()
-    assert d["get"] == 0
-    assert d["deferred_get"] == 0
-    assert d["set"] == 1
-    assert d["deferred_set"] == 1
-    assert d["var"] == 99
-
-
-def test_accessor_moves():
-    inc_refs = m.accessor_moves()
-    if inc_refs:
-        assert inc_refs == [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]
-    else:
-        pytest.skip("Not defined: PYBIND11_HANDLE_REF_DEBUG")
-
-
-def test_constructors():
-    """C++ default and converting constructors are equivalent to type calls in Python"""
-    types = [bytes, bytearray, str, bool, int, float, tuple, list, dict, set]
-    expected = {t.__name__: t() for t in types}
-    assert m.default_constructors() == expected
-
-    data = {
-        bytes: b"41",  # Currently no supported or working conversions.
-        bytearray: bytearray(b"41"),
-        str: 42,
-        bool: "Not empty",
-        int: "42",
-        float: "+1e3",
-        tuple: range(3),
-        list: range(3),
-        dict: [("two", 2), ("one", 1), ("three", 3)],
-        set: [4, 4, 5, 6, 6, 6],
-        frozenset: [4, 4, 5, 6, 6, 6],
-        memoryview: b"abc",
-    }
-    inputs = {k.__name__: v for k, v in data.items()}
-    expected = {k.__name__: k(v) for k, v in data.items()}
-
-    assert m.converting_constructors(inputs) == expected
-    assert m.cast_functions(inputs) == expected
-
-    # Converting constructors and cast functions should just reference rather
-    # than copy when no conversion is needed:
-    noconv1 = m.converting_constructors(expected)
-    for k in noconv1:
-        assert noconv1[k] is expected[k]
-
-    noconv2 = m.cast_functions(expected)
-    for k in noconv2:
-        assert noconv2[k] is expected[k]
-
-
-def test_non_converting_constructors():
-    non_converting_test_cases = [
-        ("bytes", range(10)),
-        ("none", 42),
-        ("ellipsis", 42),
-        ("type", 42),
-    ]
-    for t, v in non_converting_test_cases:
-        for move in [True, False]:
-            with pytest.raises(TypeError) as excinfo:
-                m.nonconverting_constructor(t, v, move)
-            expected_error = (
-                f"Object of type '{type(v).__name__}' is not an instance of '{t}'"
-            )
-            assert str(excinfo.value) == expected_error
-
-
-def test_pybind11_str_raw_str():
-    # specifically to exercise pybind11::str::raw_str
-    cvt = m.convert_to_pybind11_str
-    assert cvt("Str") == "Str"
-    assert cvt(b"Bytes") == "b'Bytes'"
-    assert cvt(None) == "None"
-    assert cvt(False) == "False"
-    assert cvt(True) == "True"
-    assert cvt(42) == "42"
-    assert cvt(2**65) == "36893488147419103232"
-    assert cvt(-1.50) == "-1.5"
-    assert cvt(()) == "()"
-    assert cvt((18,)) == "(18,)"
-    assert cvt([]) == "[]"
-    assert cvt([28]) == "[28]"
-    assert cvt({}) == "{}"
-    assert cvt({3: 4}) == "{3: 4}"
-    assert cvt(set()) == "set()"
-    assert cvt({3, 3}) == "{3}"
-
-    valid_orig = "Ǳ"
-    valid_utf8 = valid_orig.encode("utf-8")
-    valid_cvt = cvt(valid_utf8)
-    if hasattr(m, "PYBIND11_STR_LEGACY_PERMISSIVE"):
-        assert valid_cvt is valid_utf8
-    else:
-        assert type(valid_cvt) is str
-        assert valid_cvt == "b'\\xc7\\xb1'"
-
-    malformed_utf8 = b"\x80"
-    if hasattr(m, "PYBIND11_STR_LEGACY_PERMISSIVE"):
-        assert cvt(malformed_utf8) is malformed_utf8
-    else:
-        malformed_cvt = cvt(malformed_utf8)
-        assert type(malformed_cvt) is str
-        assert malformed_cvt == "b'\\x80'"
-
-
-def test_implicit_casting():
-    """Tests implicit casting when assigning or appending to dicts and lists."""
-    z = m.get_implicit_casting()
-    assert z["d"] == {
-        "char*_i1": "abc",
-        "char*_i2": "abc",
-        "char*_e": "abc",
-        "char*_p": "abc",
-        "str_i1": "str",
-        "str_i2": "str1",
-        "str_e": "str2",
-        "str_p": "str3",
-        "int_i1": 42,
-        "int_i2": 42,
-        "int_e": 43,
-        "int_p": 44,
-    }
-    assert z["l"] == [3, 6, 9, 12, 15]
-
-
-def test_print(capture):
-    with capture:
-        m.print_function()
-    assert (
-        capture
-        == """
-        Hello, World!
-        1 2.0 three True -- multiple args
-        *args-and-a-custom-separator
-        no new line here -- next print
-        flush
-        py::print + str.format = this
-    """
-    )
-    assert capture.stderr == "this goes to stderr"
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.print_failure()
-    assert str(excinfo.value) == "Unable to convert call argument " + (
-        "'1' of type 'UnregisteredType' to Python object"
-        if detailed_error_messages_enabled
-        else "to Python object (#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for details)"
-    )
-
-
-def test_hash():
-    class Hashable:
-        def __init__(self, value):
-            self.value = value
-
-        def __hash__(self):
-            return self.value
-
-    class Unhashable:
-        __hash__ = None
-
-    assert m.hash_function(Hashable(42)) == 42
-    with pytest.raises(TypeError):
-        m.hash_function(Unhashable())
-
-
-def test_number_protocol():
-    for a, b in [(1, 1), (3, 5)]:
-        li = [
-            a == b,
-            a != b,
-            a < b,
-            a <= b,
-            a > b,
-            a >= b,
-            a + b,
-            a - b,
-            a * b,
-            a / b,
-            a | b,
-            a & b,
-            a ^ b,
-            a >> b,
-            a << b,
-        ]
-        assert m.test_number_protocol(a, b) == li
-
-
-def test_list_slicing():
-    li = list(range(100))
-    assert li[::2] == m.test_list_slicing(li)
-
-
-def test_issue2361():
-    # See issue #2361
-    assert m.issue2361_str_implicit_copy_none() == "None"
-    with pytest.raises(TypeError) as excinfo:
-        assert m.issue2361_dict_implicit_copy_none()
-    assert "NoneType" in str(excinfo.value)
-    assert "iterable" in str(excinfo.value)
-
-
-@pytest.mark.parametrize(
-    "method, args, fmt, expected_view",
-    [
-        (m.test_memoryview_object, (b"red",), "B", b"red"),
-        (m.test_memoryview_buffer_info, (b"green",), "B", b"green"),
-        (m.test_memoryview_from_buffer, (False,), "h", [3, 1, 4, 1, 5]),
-        (m.test_memoryview_from_buffer, (True,), "H", [2, 7, 1, 8]),
-        (m.test_memoryview_from_buffer_nativeformat, (), "@i", [4, 7, 5]),
-    ],
-)
-def test_memoryview(method, args, fmt, expected_view):
-    view = method(*args)
-    assert isinstance(view, memoryview)
-    assert view.format == fmt
-    assert list(view) == list(expected_view)
-
-
-@pytest.mark.xfail("env.PYPY", reason="getrefcount is not available")
-@pytest.mark.parametrize(
-    "method",
-    [
-        m.test_memoryview_object,
-        m.test_memoryview_buffer_info,
-    ],
-)
-def test_memoryview_refcount(method):
-    buf = b"\x0a\x0b\x0c\x0d"
-    ref_before = sys.getrefcount(buf)
-    view = method(buf)
-    ref_after = sys.getrefcount(buf)
-    assert ref_before < ref_after
-    assert list(view) == list(buf)
-
-
-def test_memoryview_from_buffer_empty_shape():
-    view = m.test_memoryview_from_buffer_empty_shape()
-    assert isinstance(view, memoryview)
-    assert view.format == "B"
-    assert bytes(view) == b""
-
-
-def test_test_memoryview_from_buffer_invalid_strides():
-    with pytest.raises(RuntimeError):
-        m.test_memoryview_from_buffer_invalid_strides()
-
-
-def test_test_memoryview_from_buffer_nullptr():
-    with pytest.raises(ValueError):
-        m.test_memoryview_from_buffer_nullptr()
-
-
-def test_memoryview_from_memory():
-    view = m.test_memoryview_from_memory()
-    assert isinstance(view, memoryview)
-    assert view.format == "B"
-    assert bytes(view) == b"\xff\xe1\xab\x37"
-
-
-def test_builtin_functions():
-    assert m.get_len([i for i in range(42)]) == 42
-    with pytest.raises(TypeError) as exc_info:
-        m.get_len(i for i in range(42))
-    assert str(exc_info.value) in [
-        "object of type 'generator' has no len()",
-        "'generator' has no length",
-    ]  # PyPy
-
-
-def test_isinstance_string_types():
-    assert m.isinstance_pybind11_bytes(b"")
-    assert not m.isinstance_pybind11_bytes("")
-
-    assert m.isinstance_pybind11_str("")
-    if hasattr(m, "PYBIND11_STR_LEGACY_PERMISSIVE"):
-        assert m.isinstance_pybind11_str(b"")
-    else:
-        assert not m.isinstance_pybind11_str(b"")
-
-
-def test_pass_bytes_or_unicode_to_string_types():
-    assert m.pass_to_pybind11_bytes(b"Bytes") == 5
-    with pytest.raises(TypeError):
-        m.pass_to_pybind11_bytes("Str")
-
-    if hasattr(m, "PYBIND11_STR_LEGACY_PERMISSIVE"):
-        assert m.pass_to_pybind11_str(b"Bytes") == 5
-    else:
-        with pytest.raises(TypeError):
-            m.pass_to_pybind11_str(b"Bytes")
-    assert m.pass_to_pybind11_str("Str") == 3
-
-    assert m.pass_to_std_string(b"Bytes") == 5
-    assert m.pass_to_std_string("Str") == 3
-
-    malformed_utf8 = b"\x80"
-    if hasattr(m, "PYBIND11_STR_LEGACY_PERMISSIVE"):
-        assert m.pass_to_pybind11_str(malformed_utf8) == 1
-    else:
-        with pytest.raises(TypeError):
-            m.pass_to_pybind11_str(malformed_utf8)
-
-
-@pytest.mark.parametrize(
-    "create_weakref, create_weakref_with_callback",
-    [
-        (m.weakref_from_handle, m.weakref_from_handle_and_function),
-        (m.weakref_from_object, m.weakref_from_object_and_function),
-    ],
-)
-def test_weakref(create_weakref, create_weakref_with_callback):
-    from weakref import getweakrefcount
-
-    # Apparently, you cannot weakly reference an object()
-    class WeaklyReferenced:
-        pass
-
-    callback_called = False
-
-    def callback(wr):
-        nonlocal callback_called
-        callback_called = True
-
-    obj = WeaklyReferenced()
-    assert getweakrefcount(obj) == 0
-    wr = create_weakref(obj)
-    assert getweakrefcount(obj) == 1
-
-    obj = WeaklyReferenced()
-    assert getweakrefcount(obj) == 0
-    wr = create_weakref_with_callback(obj, callback)  # noqa: F841
-    assert getweakrefcount(obj) == 1
-    assert not callback_called
-    del obj
-    pytest.gc_collect()
-    assert callback_called
-
-
-@pytest.mark.parametrize(
-    "create_weakref, has_callback",
-    [
-        (m.weakref_from_handle, False),
-        (m.weakref_from_object, False),
-        (m.weakref_from_handle_and_function, True),
-        (m.weakref_from_object_and_function, True),
-    ],
-)
-def test_weakref_err(create_weakref, has_callback):
-    class C:
-        __slots__ = []
-
-    def callback(_):
-        pass
-
-    ob = C()
-    # Should raise TypeError on CPython
-    with pytest.raises(TypeError) if not env.PYPY else contextlib.nullcontext():
-        if has_callback:
-            _ = create_weakref(ob, callback)
-        else:
-            _ = create_weakref(ob)
-
-
-def test_cpp_iterators():
-    assert m.tuple_iterator() == 12
-    assert m.dict_iterator() == 305 + 711
-    assert m.passed_iterator(iter((-7, 3))) == -4
-
-
-def test_implementation_details():
-    lst = [39, 43, 92, 49, 22, 29, 93, 98, 26, 57, 8]
-    tup = tuple(lst)
-    assert m.sequence_item_get_ssize_t(lst) == 43
-    assert m.sequence_item_set_ssize_t(lst) is None
-    assert lst[1] == "peppa"
-    assert m.sequence_item_get_size_t(lst) == 92
-    assert m.sequence_item_set_size_t(lst) is None
-    assert lst[2] == "george"
-    assert m.list_item_get_ssize_t(lst) == 49
-    assert m.list_item_set_ssize_t(lst) is None
-    assert lst[3] == "rebecca"
-    assert m.list_item_get_size_t(lst) == 22
-    assert m.list_item_set_size_t(lst) is None
-    assert lst[4] == "richard"
-    assert m.tuple_item_get_ssize_t(tup) == 29
-    assert m.tuple_item_set_ssize_t() == ("emely", "edmond")
-    assert m.tuple_item_get_size_t(tup) == 93
-    assert m.tuple_item_set_size_t() == ("candy", "cat")
-
-
-def test_external_float_():
-    r1 = m.square_float_(2.0)
-    assert r1 == 4.0
-
-
-def test_tuple_rvalue_getter():
-    pop = 1000
-    tup = tuple(range(pop))
-    m.tuple_rvalue_getter(tup)
-
-
-def test_list_rvalue_getter():
-    pop = 1000
-    my_list = list(range(pop))
-    m.list_rvalue_getter(my_list)
-
-
-def test_populate_dict_rvalue():
-    pop = 1000
-    my_dict = {i: i for i in range(pop)}
-    assert m.populate_dict_rvalue(pop) == my_dict
-
-
-def test_populate_obj_str_attrs():
-    pop = 1000
-    o = types.SimpleNamespace(**{str(i): i for i in range(pop)})
-    new_o = m.populate_obj_str_attrs(o, pop)
-    new_attrs = {k: v for k, v in new_o.__dict__.items() if not k.startswith("_")}
-    assert all(isinstance(v, str) for v in new_attrs.values())
-    assert len(new_attrs) == pop
-
-
-@pytest.mark.parametrize(
-    "a,b", [("foo", "bar"), (1, 2), (1.0, 2.0), (list(range(3)), list(range(3, 6)))]
-)
-def test_inplace_append(a, b):
-    expected = a + b
-    assert m.inplace_append(a, b) == expected
-
-
-@pytest.mark.parametrize("a,b", [(3, 2), (3.0, 2.0), (set(range(3)), set(range(2)))])
-def test_inplace_subtract(a, b):
-    expected = a - b
-    assert m.inplace_subtract(a, b) == expected
-
-
-@pytest.mark.parametrize("a,b", [(3, 2), (3.0, 2.0), ([1], 3)])
-def test_inplace_multiply(a, b):
-    expected = a * b
-    assert m.inplace_multiply(a, b) == expected
-
-
-@pytest.mark.parametrize("a,b", [(6, 3), (6.0, 3.0)])
-def test_inplace_divide(a, b):
-    expected = a / b
-    assert m.inplace_divide(a, b) == expected
-
-
-@pytest.mark.parametrize(
-    "a,b",
-    [
-        (False, True),
-        (
-            set(),
-            {
-                1,
-            },
-        ),
-    ],
-)
-def test_inplace_or(a, b):
-    expected = a | b
-    assert m.inplace_or(a, b) == expected
-
-
-@pytest.mark.parametrize(
-    "a,b",
-    [
-        (True, False),
-        (
-            {1, 2, 3},
-            {
-                1,
-            },
-        ),
-    ],
-)
-def test_inplace_and(a, b):
-    expected = a & b
-    assert m.inplace_and(a, b) == expected
-
-
-@pytest.mark.parametrize("a,b", [(8, 1), (-3, 2)])
-def test_inplace_lshift(a, b):
-    expected = a << b
-    assert m.inplace_lshift(a, b) == expected
-
-
-@pytest.mark.parametrize("a,b", [(8, 1), (-2, 2)])
-def test_inplace_rshift(a, b):
-    expected = a >> b
-    assert m.inplace_rshift(a, b) == expected
+import contextlib
+import sys
+import types
+
+import pytest
+
+import env
+from pybind11_tests import detailed_error_messages_enabled
+from pybind11_tests import pytypes as m
+
+
+def test_obj_class_name():
+    assert m.obj_class_name(None) == "NoneType"
+    assert m.obj_class_name(list) == "list"
+    assert m.obj_class_name([]) == "list"
+
+
+def test_handle_from_move_only_type_with_operator_PyObject():  # noqa: N802
+    assert m.handle_from_move_only_type_with_operator_PyObject_ncnst()
+    assert m.handle_from_move_only_type_with_operator_PyObject_const()
+
+
+def test_bool(doc):
+    assert doc(m.get_bool) == "get_bool() -> bool"
+
+
+def test_int(doc):
+    assert doc(m.get_int) == "get_int() -> int"
+
+
+def test_iterator(doc):
+    assert doc(m.get_iterator) == "get_iterator() -> Iterator"
+
+
+@pytest.mark.parametrize(
+    "pytype, from_iter_func",
+    [
+        (frozenset, m.get_frozenset_from_iterable),
+        (list, m.get_list_from_iterable),
+        (set, m.get_set_from_iterable),
+        (tuple, m.get_tuple_from_iterable),
+    ],
+)
+def test_from_iterable(pytype, from_iter_func):
+    my_iter = iter(range(10))
+    s = from_iter_func(my_iter)
+    assert type(s) == pytype
+    assert s == pytype(range(10))
+
+
+def test_iterable(doc):
+    assert doc(m.get_iterable) == "get_iterable() -> Iterable"
+
+
+def test_float(doc):
+    assert doc(m.get_float) == "get_float() -> float"
+
+
+def test_list(capture, doc):
+    assert m.list_no_args() == []
+    assert m.list_ssize_t() == []
+    assert m.list_size_t() == []
+    lins = [1, 2]
+    m.list_insert_ssize_t(lins)
+    assert lins == [1, 83, 2]
+    m.list_insert_size_t(lins)
+    assert lins == [1, 83, 2, 57]
+
+    with capture:
+        lst = m.get_list()
+        assert lst == ["inserted-0", "overwritten", "inserted-2"]
+
+        lst.append("value2")
+        m.print_list(lst)
+    assert (
+        capture.unordered
+        == """
+        Entry at position 0: value
+        list item 0: inserted-0
+        list item 1: overwritten
+        list item 2: inserted-2
+        list item 3: value2
+    """
+    )
+
+    assert doc(m.get_list) == "get_list() -> list"
+    assert doc(m.print_list) == "print_list(arg0: list) -> None"
+
+
+def test_none(capture, doc):
+    assert doc(m.get_none) == "get_none() -> None"
+    assert doc(m.print_none) == "print_none(arg0: None) -> None"
+
+
+def test_set(capture, doc):
+    s = m.get_set()
+    assert isinstance(s, set)
+    assert s == {"key1", "key2", "key3"}
+
+    s.add("key4")
+    with capture:
+        m.print_anyset(s)
+    assert (
+        capture.unordered
+        == """
+        key: key1
+        key: key2
+        key: key3
+        key: key4
+    """
+    )
+
+    m.set_add(s, "key5")
+    assert m.anyset_size(s) == 5
+
+    m.set_clear(s)
+    assert m.anyset_empty(s)
+
+    assert not m.anyset_contains(set(), 42)
+    assert m.anyset_contains({42}, 42)
+    assert m.anyset_contains({"foo"}, "foo")
+
+    assert doc(m.get_set) == "get_set() -> set"
+    assert doc(m.print_anyset) == "print_anyset(arg0: anyset) -> None"
+
+
+def test_frozenset(capture, doc):
+    s = m.get_frozenset()
+    assert isinstance(s, frozenset)
+    assert s == frozenset({"key1", "key2", "key3"})
+
+    with capture:
+        m.print_anyset(s)
+    assert (
+        capture.unordered
+        == """
+        key: key1
+        key: key2
+        key: key3
+    """
+    )
+    assert m.anyset_size(s) == 3
+    assert not m.anyset_empty(s)
+
+    assert not m.anyset_contains(frozenset(), 42)
+    assert m.anyset_contains(frozenset({42}), 42)
+    assert m.anyset_contains(frozenset({"foo"}), "foo")
+
+    assert doc(m.get_frozenset) == "get_frozenset() -> frozenset"
+
+
+def test_dict(capture, doc):
+    d = m.get_dict()
+    assert d == {"key": "value"}
+
+    with capture:
+        d["key2"] = "value2"
+        m.print_dict(d)
+    assert (
+        capture.unordered
+        == """
+        key: key, value=value
+        key: key2, value=value2
+    """
+    )
+
+    assert not m.dict_contains({}, 42)
+    assert m.dict_contains({42: None}, 42)
+    assert m.dict_contains({"foo": None}, "foo")
+
+    assert doc(m.get_dict) == "get_dict() -> dict"
+    assert doc(m.print_dict) == "print_dict(arg0: dict) -> None"
+
+    assert m.dict_keyword_constructor() == {"x": 1, "y": 2, "z": 3}
+
+
+class CustomContains:
+    d = {"key": None}
+
+    def __contains__(self, m):
+        return m in self.d
+
+
+@pytest.mark.parametrize(
+    "arg,func",
+    [
+        (set(), m.anyset_contains),
+        (dict(), m.dict_contains),
+        (CustomContains(), m.obj_contains),
+    ],
+)
+@pytest.mark.xfail("env.PYPY and sys.pypy_version_info < (7, 3, 10)", strict=False)
+def test_unhashable_exceptions(arg, func):
+    class Unhashable:
+        __hash__ = None
+
+    with pytest.raises(TypeError) as exc_info:
+        func(arg, Unhashable())
+    assert "unhashable type:" in str(exc_info.value)
+
+
+def test_tuple():
+    assert m.tuple_no_args() == ()
+    assert m.tuple_ssize_t() == ()
+    assert m.tuple_size_t() == ()
+    assert m.get_tuple() == (42, None, "spam")
+
+
+def test_simple_namespace():
+    ns = m.get_simple_namespace()
+    assert ns.attr == 42
+    assert ns.x == "foo"
+    assert ns.right == 2
+    assert not hasattr(ns, "wrong")
+
+
+def test_str(doc):
+    assert m.str_from_char_ssize_t().encode().decode() == "red"
+    assert m.str_from_char_size_t().encode().decode() == "blue"
+    assert m.str_from_string().encode().decode() == "baz"
+    assert m.str_from_bytes().encode().decode() == "boo"
+
+    assert doc(m.str_from_bytes) == "str_from_bytes() -> str"
+
+    class A:
+        def __str__(self):
+            return "this is a str"
+
+        def __repr__(self):
+            return "this is a repr"
+
+    assert m.str_from_object(A()) == "this is a str"
+    assert m.repr_from_object(A()) == "this is a repr"
+    assert m.str_from_handle(A()) == "this is a str"
+
+    s1, s2 = m.str_format()
+    assert s1 == "1 + 2 = 3"
+    assert s1 == s2
+
+    malformed_utf8 = b"\x80"
+    if hasattr(m, "PYBIND11_STR_LEGACY_PERMISSIVE"):
+        assert m.str_from_object(malformed_utf8) is malformed_utf8
+    else:
+        assert m.str_from_object(malformed_utf8) == "b'\\x80'"
+    assert m.str_from_handle(malformed_utf8) == "b'\\x80'"
+
+    assert m.str_from_string_from_str("this is a str") == "this is a str"
+    ucs_surrogates_str = "\udcc3"
+    with pytest.raises(UnicodeEncodeError):
+        m.str_from_string_from_str(ucs_surrogates_str)
+
+
+@pytest.mark.parametrize(
+    "func",
+    [
+        m.str_from_bytes_input,
+        m.str_from_cstr_input,
+        m.str_from_std_string_input,
+    ],
+)
+def test_surrogate_pairs_unicode_error(func):
+    input_str = "\ud83d\ude4f".encode("utf-8", "surrogatepass")
+    with pytest.raises(UnicodeDecodeError):
+        func(input_str)
+
+
+def test_bytes(doc):
+    assert m.bytes_from_char_ssize_t().decode() == "green"
+    assert m.bytes_from_char_size_t().decode() == "purple"
+    assert m.bytes_from_string().decode() == "foo"
+    assert m.bytes_from_str().decode() == "bar"
+
+    assert doc(m.bytes_from_str) == "bytes_from_str() -> bytes"
+
+
+def test_bytearray(doc):
+    assert m.bytearray_from_char_ssize_t().decode() == "$%"
+    assert m.bytearray_from_char_size_t().decode() == "@$!"
+    assert m.bytearray_from_string().decode() == "foo"
+    assert m.bytearray_size() == len("foo")
+
+
+def test_capsule(capture):
+    pytest.gc_collect()
+    with capture:
+        a = m.return_capsule_with_destructor()
+        del a
+        pytest.gc_collect()
+    assert (
+        capture.unordered
+        == """
+        creating capsule
+        destructing capsule
+    """
+    )
+
+    with capture:
+        a = m.return_renamed_capsule_with_destructor()
+        del a
+        pytest.gc_collect()
+    assert (
+        capture.unordered
+        == """
+        creating capsule
+        renaming capsule
+        destructing capsule
+    """
+    )
+
+    with capture:
+        a = m.return_capsule_with_destructor_2()
+        del a
+        pytest.gc_collect()
+    assert (
+        capture.unordered
+        == """
+        creating capsule
+        destructing capsule: 1234
+    """
+    )
+
+    with capture:
+        a = m.return_renamed_capsule_with_destructor_2()
+        del a
+        pytest.gc_collect()
+    assert (
+        capture.unordered
+        == """
+        creating capsule
+        renaming capsule
+        destructing capsule: 1234
+    """
+    )
+
+    with capture:
+        a = m.return_capsule_with_name_and_destructor()
+        del a
+        pytest.gc_collect()
+    assert (
+        capture.unordered
+        == """
+        created capsule (1234, 'pointer type description')
+        destructing capsule (1234, 'pointer type description')
+    """
+    )
+
+    with capture:
+        a = m.return_capsule_with_explicit_nullptr_dtor()
+        del a
+        pytest.gc_collect()
+    assert (
+        capture.unordered
+        == """
+        creating capsule with explicit nullptr dtor
+    """
+    )
+
+
+def test_accessors():
+    class SubTestObject:
+        attr_obj = 1
+        attr_char = 2
+
+    class TestObject:
+        basic_attr = 1
+        begin_end = [1, 2, 3]
+        d = {"operator[object]": 1, "operator[char *]": 2}
+        sub = SubTestObject()
+
+        def func(self, x, *args):
+            return self.basic_attr + x + sum(args)
+
+    d = m.accessor_api(TestObject())
+    assert d["basic_attr"] == 1
+    assert d["begin_end"] == [1, 2, 3]
+    assert d["operator[object]"] == 1
+    assert d["operator[char *]"] == 2
+    assert d["attr(object)"] == 1
+    assert d["attr(char *)"] == 2
+    assert d["missing_attr_ptr"] == "raised"
+    assert d["missing_attr_chain"] == "raised"
+    assert d["is_none"] is False
+    assert d["operator()"] == 2
+    assert d["operator*"] == 7
+    assert d["implicit_list"] == [1, 2, 3]
+    assert all(x in TestObject.__dict__ for x in d["implicit_dict"])
+
+    assert m.tuple_accessor(tuple()) == (0, 1, 2)
+
+    d = m.accessor_assignment()
+    assert d["get"] == 0
+    assert d["deferred_get"] == 0
+    assert d["set"] == 1
+    assert d["deferred_set"] == 1
+    assert d["var"] == 99
+
+
+def test_accessor_moves():
+    inc_refs = m.accessor_moves()
+    if inc_refs:
+        assert inc_refs == [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]
+    else:
+        pytest.skip("Not defined: PYBIND11_HANDLE_REF_DEBUG")
+
+
+def test_constructors():
+    """C++ default and converting constructors are equivalent to type calls in Python"""
+    types = [bytes, bytearray, str, bool, int, float, tuple, list, dict, set]
+    expected = {t.__name__: t() for t in types}
+    assert m.default_constructors() == expected
+
+    data = {
+        bytes: b"41",  # Currently no supported or working conversions.
+        bytearray: bytearray(b"41"),
+        str: 42,
+        bool: "Not empty",
+        int: "42",
+        float: "+1e3",
+        tuple: range(3),
+        list: range(3),
+        dict: [("two", 2), ("one", 1), ("three", 3)],
+        set: [4, 4, 5, 6, 6, 6],
+        frozenset: [4, 4, 5, 6, 6, 6],
+        memoryview: b"abc",
+    }
+    inputs = {k.__name__: v for k, v in data.items()}
+    expected = {k.__name__: k(v) for k, v in data.items()}
+
+    assert m.converting_constructors(inputs) == expected
+    assert m.cast_functions(inputs) == expected
+
+    # Converting constructors and cast functions should just reference rather
+    # than copy when no conversion is needed:
+    noconv1 = m.converting_constructors(expected)
+    for k in noconv1:
+        assert noconv1[k] is expected[k]
+
+    noconv2 = m.cast_functions(expected)
+    for k in noconv2:
+        assert noconv2[k] is expected[k]
+
+
+def test_non_converting_constructors():
+    non_converting_test_cases = [
+        ("bytes", range(10)),
+        ("none", 42),
+        ("ellipsis", 42),
+        ("type", 42),
+    ]
+    for t, v in non_converting_test_cases:
+        for move in [True, False]:
+            with pytest.raises(TypeError) as excinfo:
+                m.nonconverting_constructor(t, v, move)
+            expected_error = (
+                f"Object of type '{type(v).__name__}' is not an instance of '{t}'"
+            )
+            assert str(excinfo.value) == expected_error
+
+
+def test_pybind11_str_raw_str():
+    # specifically to exercise pybind11::str::raw_str
+    cvt = m.convert_to_pybind11_str
+    assert cvt("Str") == "Str"
+    assert cvt(b"Bytes") == "b'Bytes'"
+    assert cvt(None) == "None"
+    assert cvt(False) == "False"
+    assert cvt(True) == "True"
+    assert cvt(42) == "42"
+    assert cvt(2**65) == "36893488147419103232"
+    assert cvt(-1.50) == "-1.5"
+    assert cvt(()) == "()"
+    assert cvt((18,)) == "(18,)"
+    assert cvt([]) == "[]"
+    assert cvt([28]) == "[28]"
+    assert cvt({}) == "{}"
+    assert cvt({3: 4}) == "{3: 4}"
+    assert cvt(set()) == "set()"
+    assert cvt({3, 3}) == "{3}"
+
+    valid_orig = "Ǳ"
+    valid_utf8 = valid_orig.encode("utf-8")
+    valid_cvt = cvt(valid_utf8)
+    if hasattr(m, "PYBIND11_STR_LEGACY_PERMISSIVE"):
+        assert valid_cvt is valid_utf8
+    else:
+        assert type(valid_cvt) is str
+        assert valid_cvt == "b'\\xc7\\xb1'"
+
+    malformed_utf8 = b"\x80"
+    if hasattr(m, "PYBIND11_STR_LEGACY_PERMISSIVE"):
+        assert cvt(malformed_utf8) is malformed_utf8
+    else:
+        malformed_cvt = cvt(malformed_utf8)
+        assert type(malformed_cvt) is str
+        assert malformed_cvt == "b'\\x80'"
+
+
+def test_implicit_casting():
+    """Tests implicit casting when assigning or appending to dicts and lists."""
+    z = m.get_implicit_casting()
+    assert z["d"] == {
+        "char*_i1": "abc",
+        "char*_i2": "abc",
+        "char*_e": "abc",
+        "char*_p": "abc",
+        "str_i1": "str",
+        "str_i2": "str1",
+        "str_e": "str2",
+        "str_p": "str3",
+        "int_i1": 42,
+        "int_i2": 42,
+        "int_e": 43,
+        "int_p": 44,
+    }
+    assert z["l"] == [3, 6, 9, 12, 15]
+
+
+def test_print(capture):
+    with capture:
+        m.print_function()
+    assert (
+        capture
+        == """
+        Hello, World!
+        1 2.0 three True -- multiple args
+        *args-and-a-custom-separator
+        no new line here -- next print
+        flush
+        py::print + str.format = this
+    """
+    )
+    assert capture.stderr == "this goes to stderr"
+
+    with pytest.raises(RuntimeError) as excinfo:
+        m.print_failure()
+    assert str(excinfo.value) == "Unable to convert call argument " + (
+        "'1' of type 'UnregisteredType' to Python object"
+        if detailed_error_messages_enabled
+        else "to Python object (#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for details)"
+    )
+
+
+def test_hash():
+    class Hashable:
+        def __init__(self, value):
+            self.value = value
+
+        def __hash__(self):
+            return self.value
+
+    class Unhashable:
+        __hash__ = None
+
+    assert m.hash_function(Hashable(42)) == 42
+    with pytest.raises(TypeError):
+        m.hash_function(Unhashable())
+
+
+def test_number_protocol():
+    for a, b in [(1, 1), (3, 5)]:
+        li = [
+            a == b,
+            a != b,
+            a < b,
+            a <= b,
+            a > b,
+            a >= b,
+            a + b,
+            a - b,
+            a * b,
+            a / b,
+            a | b,
+            a & b,
+            a ^ b,
+            a >> b,
+            a << b,
+        ]
+        assert m.test_number_protocol(a, b) == li
+
+
+def test_list_slicing():
+    li = list(range(100))
+    assert li[::2] == m.test_list_slicing(li)
+
+
+def test_issue2361():
+    # See issue #2361
+    assert m.issue2361_str_implicit_copy_none() == "None"
+    with pytest.raises(TypeError) as excinfo:
+        assert m.issue2361_dict_implicit_copy_none()
+    assert "NoneType" in str(excinfo.value)
+    assert "iterable" in str(excinfo.value)
+
+
+@pytest.mark.parametrize(
+    "method, args, fmt, expected_view",
+    [
+        (m.test_memoryview_object, (b"red",), "B", b"red"),
+        (m.test_memoryview_buffer_info, (b"green",), "B", b"green"),
+        (m.test_memoryview_from_buffer, (False,), "h", [3, 1, 4, 1, 5]),
+        (m.test_memoryview_from_buffer, (True,), "H", [2, 7, 1, 8]),
+        (m.test_memoryview_from_buffer_nativeformat, (), "@i", [4, 7, 5]),
+    ],
+)
+def test_memoryview(method, args, fmt, expected_view):
+    view = method(*args)
+    assert isinstance(view, memoryview)
+    assert view.format == fmt
+    assert list(view) == list(expected_view)
+
+
+@pytest.mark.xfail("env.PYPY", reason="getrefcount is not available")
+@pytest.mark.parametrize(
+    "method",
+    [
+        m.test_memoryview_object,
+        m.test_memoryview_buffer_info,
+    ],
+)
+def test_memoryview_refcount(method):
+    buf = b"\x0a\x0b\x0c\x0d"
+    ref_before = sys.getrefcount(buf)
+    view = method(buf)
+    ref_after = sys.getrefcount(buf)
+    assert ref_before < ref_after
+    assert list(view) == list(buf)
+
+
+def test_memoryview_from_buffer_empty_shape():
+    view = m.test_memoryview_from_buffer_empty_shape()
+    assert isinstance(view, memoryview)
+    assert view.format == "B"
+    assert bytes(view) == b""
+
+
+def test_test_memoryview_from_buffer_invalid_strides():
+    with pytest.raises(RuntimeError):
+        m.test_memoryview_from_buffer_invalid_strides()
+
+
+def test_test_memoryview_from_buffer_nullptr():
+    with pytest.raises(ValueError):
+        m.test_memoryview_from_buffer_nullptr()
+
+
+def test_memoryview_from_memory():
+    view = m.test_memoryview_from_memory()
+    assert isinstance(view, memoryview)
+    assert view.format == "B"
+    assert bytes(view) == b"\xff\xe1\xab\x37"
+
+
+def test_builtin_functions():
+    assert m.get_len([i for i in range(42)]) == 42
+    with pytest.raises(TypeError) as exc_info:
+        m.get_len(i for i in range(42))
+    assert str(exc_info.value) in [
+        "object of type 'generator' has no len()",
+        "'generator' has no length",
+    ]  # PyPy
+
+
+def test_isinstance_string_types():
+    assert m.isinstance_pybind11_bytes(b"")
+    assert not m.isinstance_pybind11_bytes("")
+
+    assert m.isinstance_pybind11_str("")
+    if hasattr(m, "PYBIND11_STR_LEGACY_PERMISSIVE"):
+        assert m.isinstance_pybind11_str(b"")
+    else:
+        assert not m.isinstance_pybind11_str(b"")
+
+
+def test_pass_bytes_or_unicode_to_string_types():
+    assert m.pass_to_pybind11_bytes(b"Bytes") == 5
+    with pytest.raises(TypeError):
+        m.pass_to_pybind11_bytes("Str")
+
+    if hasattr(m, "PYBIND11_STR_LEGACY_PERMISSIVE"):
+        assert m.pass_to_pybind11_str(b"Bytes") == 5
+    else:
+        with pytest.raises(TypeError):
+            m.pass_to_pybind11_str(b"Bytes")
+    assert m.pass_to_pybind11_str("Str") == 3
+
+    assert m.pass_to_std_string(b"Bytes") == 5
+    assert m.pass_to_std_string("Str") == 3
+
+    malformed_utf8 = b"\x80"
+    if hasattr(m, "PYBIND11_STR_LEGACY_PERMISSIVE"):
+        assert m.pass_to_pybind11_str(malformed_utf8) == 1
+    else:
+        with pytest.raises(TypeError):
+            m.pass_to_pybind11_str(malformed_utf8)
+
+
+@pytest.mark.parametrize(
+    "create_weakref, create_weakref_with_callback",
+    [
+        (m.weakref_from_handle, m.weakref_from_handle_and_function),
+        (m.weakref_from_object, m.weakref_from_object_and_function),
+    ],
+)
+def test_weakref(create_weakref, create_weakref_with_callback):
+    from weakref import getweakrefcount
+
+    # Apparently, you cannot weakly reference an object()
+    class WeaklyReferenced:
+        pass
+
+    callback_called = False
+
+    def callback(wr):
+        nonlocal callback_called
+        callback_called = True
+
+    obj = WeaklyReferenced()
+    assert getweakrefcount(obj) == 0
+    wr = create_weakref(obj)
+    assert getweakrefcount(obj) == 1
+
+    obj = WeaklyReferenced()
+    assert getweakrefcount(obj) == 0
+    wr = create_weakref_with_callback(obj, callback)  # noqa: F841
+    assert getweakrefcount(obj) == 1
+    assert not callback_called
+    del obj
+    pytest.gc_collect()
+    assert callback_called
+
+
+@pytest.mark.parametrize(
+    "create_weakref, has_callback",
+    [
+        (m.weakref_from_handle, False),
+        (m.weakref_from_object, False),
+        (m.weakref_from_handle_and_function, True),
+        (m.weakref_from_object_and_function, True),
+    ],
+)
+def test_weakref_err(create_weakref, has_callback):
+    class C:
+        __slots__ = []
+
+    def callback(_):
+        pass
+
+    ob = C()
+    # Should raise TypeError on CPython
+    with pytest.raises(TypeError) if not env.PYPY else contextlib.nullcontext():
+        if has_callback:
+            _ = create_weakref(ob, callback)
+        else:
+            _ = create_weakref(ob)
+
+
+def test_cpp_iterators():
+    assert m.tuple_iterator() == 12
+    assert m.dict_iterator() == 305 + 711
+    assert m.passed_iterator(iter((-7, 3))) == -4
+
+
+def test_implementation_details():
+    lst = [39, 43, 92, 49, 22, 29, 93, 98, 26, 57, 8]
+    tup = tuple(lst)
+    assert m.sequence_item_get_ssize_t(lst) == 43
+    assert m.sequence_item_set_ssize_t(lst) is None
+    assert lst[1] == "peppa"
+    assert m.sequence_item_get_size_t(lst) == 92
+    assert m.sequence_item_set_size_t(lst) is None
+    assert lst[2] == "george"
+    assert m.list_item_get_ssize_t(lst) == 49
+    assert m.list_item_set_ssize_t(lst) is None
+    assert lst[3] == "rebecca"
+    assert m.list_item_get_size_t(lst) == 22
+    assert m.list_item_set_size_t(lst) is None
+    assert lst[4] == "richard"
+    assert m.tuple_item_get_ssize_t(tup) == 29
+    assert m.tuple_item_set_ssize_t() == ("emely", "edmond")
+    assert m.tuple_item_get_size_t(tup) == 93
+    assert m.tuple_item_set_size_t() == ("candy", "cat")
+
+
+def test_external_float_():
+    r1 = m.square_float_(2.0)
+    assert r1 == 4.0
+
+
+def test_tuple_rvalue_getter():
+    pop = 1000
+    tup = tuple(range(pop))
+    m.tuple_rvalue_getter(tup)
+
+
+def test_list_rvalue_getter():
+    pop = 1000
+    my_list = list(range(pop))
+    m.list_rvalue_getter(my_list)
+
+
+def test_populate_dict_rvalue():
+    pop = 1000
+    my_dict = {i: i for i in range(pop)}
+    assert m.populate_dict_rvalue(pop) == my_dict
+
+
+def test_populate_obj_str_attrs():
+    pop = 1000
+    o = types.SimpleNamespace(**{str(i): i for i in range(pop)})
+    new_o = m.populate_obj_str_attrs(o, pop)
+    new_attrs = {k: v for k, v in new_o.__dict__.items() if not k.startswith("_")}
+    assert all(isinstance(v, str) for v in new_attrs.values())
+    assert len(new_attrs) == pop
+
+
+@pytest.mark.parametrize(
+    "a,b", [("foo", "bar"), (1, 2), (1.0, 2.0), (list(range(3)), list(range(3, 6)))]
+)
+def test_inplace_append(a, b):
+    expected = a + b
+    assert m.inplace_append(a, b) == expected
+
+
+@pytest.mark.parametrize("a,b", [(3, 2), (3.0, 2.0), (set(range(3)), set(range(2)))])
+def test_inplace_subtract(a, b):
+    expected = a - b
+    assert m.inplace_subtract(a, b) == expected
+
+
+@pytest.mark.parametrize("a,b", [(3, 2), (3.0, 2.0), ([1], 3)])
+def test_inplace_multiply(a, b):
+    expected = a * b
+    assert m.inplace_multiply(a, b) == expected
+
+
+@pytest.mark.parametrize("a,b", [(6, 3), (6.0, 3.0)])
+def test_inplace_divide(a, b):
+    expected = a / b
+    assert m.inplace_divide(a, b) == expected
+
+
+@pytest.mark.parametrize(
+    "a,b",
+    [
+        (False, True),
+        (
+            set(),
+            {
+                1,
+            },
+        ),
+    ],
+)
+def test_inplace_or(a, b):
+    expected = a | b
+    assert m.inplace_or(a, b) == expected
+
+
+@pytest.mark.parametrize(
+    "a,b",
+    [
+        (True, False),
+        (
+            {1, 2, 3},
+            {
+                1,
+            },
+        ),
+    ],
+)
+def test_inplace_and(a, b):
+    expected = a & b
+    assert m.inplace_and(a, b) == expected
+
+
+@pytest.mark.parametrize("a,b", [(8, 1), (-3, 2)])
+def test_inplace_lshift(a, b):
+    expected = a << b
+    assert m.inplace_lshift(a, b) == expected
+
+
+@pytest.mark.parametrize("a,b", [(8, 1), (-2, 2)])
+def test_inplace_rshift(a, b):
+    expected = a >> b
+    assert m.inplace_rshift(a, b) == expected
```

## extern/pybind11/tests/test_sequences_and_iterators.py

 * *Ordering differences only*

```diff
@@ -1,251 +1,251 @@
-import pytest
-from pytest import approx
-
-from pybind11_tests import ConstructorStats
-from pybind11_tests import sequences_and_iterators as m
-
-
-def test_slice_constructors():
-    assert m.make_forward_slice_size_t() == slice(0, -1, 1)
-    assert m.make_reversed_slice_object() == slice(None, None, -1)
-
-
-@pytest.mark.skipif(not m.has_optional, reason="no <optional>")
-def test_slice_constructors_explicit_optional():
-    assert m.make_reversed_slice_size_t_optional() == slice(None, None, -1)
-    assert m.make_reversed_slice_size_t_optional_verbose() == slice(None, None, -1)
-
-
-def test_generalized_iterators():
-    assert list(m.IntPairs([(1, 2), (3, 4), (0, 5)]).nonzero()) == [(1, 2), (3, 4)]
-    assert list(m.IntPairs([(1, 2), (2, 0), (0, 3), (4, 5)]).nonzero()) == [(1, 2)]
-    assert list(m.IntPairs([(0, 3), (1, 2), (3, 4)]).nonzero()) == []
-
-    assert list(m.IntPairs([(1, 2), (3, 4), (0, 5)]).nonzero_keys()) == [1, 3]
-    assert list(m.IntPairs([(1, 2), (2, 0), (0, 3), (4, 5)]).nonzero_keys()) == [1]
-    assert list(m.IntPairs([(0, 3), (1, 2), (3, 4)]).nonzero_keys()) == []
-
-    assert list(m.IntPairs([(1, 2), (3, 4), (0, 5)]).nonzero_values()) == [2, 4]
-    assert list(m.IntPairs([(1, 2), (2, 0), (0, 3), (4, 5)]).nonzero_values()) == [2]
-    assert list(m.IntPairs([(0, 3), (1, 2), (3, 4)]).nonzero_values()) == []
-
-    # __next__ must continue to raise StopIteration
-    it = m.IntPairs([(0, 0)]).nonzero()
-    for _ in range(3):
-        with pytest.raises(StopIteration):
-            next(it)
-
-    it = m.IntPairs([(0, 0)]).nonzero_keys()
-    for _ in range(3):
-        with pytest.raises(StopIteration):
-            next(it)
-
-
-def test_nonref_iterators():
-    pairs = m.IntPairs([(1, 2), (3, 4), (0, 5)])
-    assert list(pairs.nonref()) == [(1, 2), (3, 4), (0, 5)]
-    assert list(pairs.nonref_keys()) == [1, 3, 0]
-    assert list(pairs.nonref_values()) == [2, 4, 5]
-
-
-def test_generalized_iterators_simple():
-    assert list(m.IntPairs([(1, 2), (3, 4), (0, 5)]).simple_iterator()) == [
-        (1, 2),
-        (3, 4),
-        (0, 5),
-    ]
-    assert list(m.IntPairs([(1, 2), (3, 4), (0, 5)]).simple_keys()) == [1, 3, 0]
-    assert list(m.IntPairs([(1, 2), (3, 4), (0, 5)]).simple_values()) == [2, 4, 5]
-
-
-def test_iterator_referencing():
-    """Test that iterators reference rather than copy their referents."""
-    vec = m.VectorNonCopyableInt()
-    vec.append(3)
-    vec.append(5)
-    assert [int(x) for x in vec] == [3, 5]
-    # Increment everything to make sure the referents can be mutated
-    for x in vec:
-        x.set(int(x) + 1)
-    assert [int(x) for x in vec] == [4, 6]
-
-    vec = m.VectorNonCopyableIntPair()
-    vec.append([3, 4])
-    vec.append([5, 7])
-    assert [int(x) for x in vec.keys()] == [3, 5]
-    assert [int(x) for x in vec.values()] == [4, 7]
-    for x in vec.keys():
-        x.set(int(x) + 1)
-    for x in vec.values():
-        x.set(int(x) + 10)
-    assert [int(x) for x in vec.keys()] == [4, 6]
-    assert [int(x) for x in vec.values()] == [14, 17]
-
-
-def test_sliceable():
-    sliceable = m.Sliceable(100)
-    assert sliceable[::] == (0, 100, 1)
-    assert sliceable[10::] == (10, 100, 1)
-    assert sliceable[:10:] == (0, 10, 1)
-    assert sliceable[::10] == (0, 100, 10)
-    assert sliceable[-10::] == (90, 100, 1)
-    assert sliceable[:-10:] == (0, 90, 1)
-    assert sliceable[::-10] == (99, -1, -10)
-    assert sliceable[50:60:1] == (50, 60, 1)
-    assert sliceable[50:60:-1] == (50, 60, -1)
-
-
-def test_sequence():
-    cstats = ConstructorStats.get(m.Sequence)
-
-    s = m.Sequence(5)
-    assert cstats.values() == ["of size", "5"]
-
-    assert "Sequence" in repr(s)
-    assert len(s) == 5
-    assert s[0] == 0 and s[3] == 0
-    assert 12.34 not in s
-    s[0], s[3] = 12.34, 56.78
-    assert 12.34 in s
-    assert s[0] == approx(12.34, rel=1e-05)
-    assert s[3] == approx(56.78, rel=1e-05)
-
-    rev = reversed(s)
-    assert cstats.values() == ["of size", "5"]
-
-    rev2 = s[::-1]
-    assert cstats.values() == ["of size", "5"]
-
-    it = iter(m.Sequence(0))
-    for _ in range(3):  # __next__ must continue to raise StopIteration
-        with pytest.raises(StopIteration):
-            next(it)
-    assert cstats.values() == ["of size", "0"]
-
-    expected = [0, 56.78, 0, 0, 12.34]
-    assert rev == approx(expected, rel=1e-05)
-    assert rev2 == approx(expected, rel=1e-05)
-    assert rev == rev2
-
-    rev[0::2] = m.Sequence([2.0, 2.0, 2.0])
-    assert cstats.values() == ["of size", "3", "from std::vector"]
-
-    assert rev == approx([2, 56.78, 2, 0, 2], rel=1e-05)
-
-    assert cstats.alive() == 4
-    del it
-    assert cstats.alive() == 3
-    del s
-    assert cstats.alive() == 2
-    del rev
-    assert cstats.alive() == 1
-    del rev2
-    assert cstats.alive() == 0
-
-    assert cstats.values() == []
-    assert cstats.default_constructions == 0
-    assert cstats.copy_constructions == 0
-    assert cstats.move_constructions >= 1
-    assert cstats.copy_assignments == 0
-    assert cstats.move_assignments == 0
-
-
-def test_sequence_length():
-    """#2076: Exception raised by len(arg) should be propagated"""
-
-    class BadLen(RuntimeError):
-        pass
-
-    class SequenceLike:
-        def __getitem__(self, i):
-            return None
-
-        def __len__(self):
-            raise BadLen()
-
-    with pytest.raises(BadLen):
-        m.sequence_length(SequenceLike())
-
-    assert m.sequence_length([1, 2, 3]) == 3
-    assert m.sequence_length("hello") == 5
-
-
-def test_map_iterator():
-    sm = m.StringMap({"hi": "bye", "black": "white"})
-    assert sm["hi"] == "bye"
-    assert len(sm) == 2
-    assert sm["black"] == "white"
-
-    with pytest.raises(KeyError):
-        assert sm["orange"]
-    sm["orange"] = "banana"
-    assert sm["orange"] == "banana"
-
-    expected = {"hi": "bye", "black": "white", "orange": "banana"}
-    for k in sm:
-        assert sm[k] == expected[k]
-    for k, v in sm.items():
-        assert v == expected[k]
-    assert list(sm.values()) == [expected[k] for k in sm]
-
-    it = iter(m.StringMap({}))
-    for _ in range(3):  # __next__ must continue to raise StopIteration
-        with pytest.raises(StopIteration):
-            next(it)
-
-
-def test_python_iterator_in_cpp():
-    t = (1, 2, 3)
-    assert m.object_to_list(t) == [1, 2, 3]
-    assert m.object_to_list(iter(t)) == [1, 2, 3]
-    assert m.iterator_to_list(iter(t)) == [1, 2, 3]
-
-    with pytest.raises(TypeError) as excinfo:
-        m.object_to_list(1)
-    assert "object is not iterable" in str(excinfo.value)
-
-    with pytest.raises(TypeError) as excinfo:
-        m.iterator_to_list(1)
-    assert "incompatible function arguments" in str(excinfo.value)
-
-    def bad_next_call():
-        raise RuntimeError("py::iterator::advance() should propagate errors")
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.iterator_to_list(iter(bad_next_call, None))
-    assert str(excinfo.value) == "py::iterator::advance() should propagate errors"
-
-    lst = [1, None, 0, None]
-    assert m.count_none(lst) == 2
-    assert m.find_none(lst) is True
-    assert m.count_nonzeros({"a": 0, "b": 1, "c": 2}) == 2
-
-    r = range(5)
-    assert all(m.tuple_iterator(tuple(r)))
-    assert all(m.list_iterator(list(r)))
-    assert all(m.sequence_iterator(r))
-
-
-def test_iterator_passthrough():
-    """#181: iterator passthrough did not compile"""
-    from pybind11_tests.sequences_and_iterators import iterator_passthrough
-
-    values = [3, 5, 7, 9, 11, 13, 15]
-    assert list(iterator_passthrough(iter(values))) == values
-
-
-def test_iterator_rvp():
-    """#388: Can't make iterators via make_iterator() with different r/v policies"""
-    import pybind11_tests.sequences_and_iterators as m
-
-    assert list(m.make_iterator_1()) == [1, 2, 3]
-    assert list(m.make_iterator_2()) == [1, 2, 3]
-    assert not isinstance(m.make_iterator_1(), type(m.make_iterator_2()))
-
-
-def test_carray_iterator():
-    """#4100: Check for proper iterator overload with C-Arrays"""
-    args_gt = list(float(i) for i in range(3))
-    arr_h = m.CArrayHolder(*args_gt)
-    args = list(arr_h)
-    assert args_gt == args
+import pytest
+from pytest import approx
+
+from pybind11_tests import ConstructorStats
+from pybind11_tests import sequences_and_iterators as m
+
+
+def test_slice_constructors():
+    assert m.make_forward_slice_size_t() == slice(0, -1, 1)
+    assert m.make_reversed_slice_object() == slice(None, None, -1)
+
+
+@pytest.mark.skipif(not m.has_optional, reason="no <optional>")
+def test_slice_constructors_explicit_optional():
+    assert m.make_reversed_slice_size_t_optional() == slice(None, None, -1)
+    assert m.make_reversed_slice_size_t_optional_verbose() == slice(None, None, -1)
+
+
+def test_generalized_iterators():
+    assert list(m.IntPairs([(1, 2), (3, 4), (0, 5)]).nonzero()) == [(1, 2), (3, 4)]
+    assert list(m.IntPairs([(1, 2), (2, 0), (0, 3), (4, 5)]).nonzero()) == [(1, 2)]
+    assert list(m.IntPairs([(0, 3), (1, 2), (3, 4)]).nonzero()) == []
+
+    assert list(m.IntPairs([(1, 2), (3, 4), (0, 5)]).nonzero_keys()) == [1, 3]
+    assert list(m.IntPairs([(1, 2), (2, 0), (0, 3), (4, 5)]).nonzero_keys()) == [1]
+    assert list(m.IntPairs([(0, 3), (1, 2), (3, 4)]).nonzero_keys()) == []
+
+    assert list(m.IntPairs([(1, 2), (3, 4), (0, 5)]).nonzero_values()) == [2, 4]
+    assert list(m.IntPairs([(1, 2), (2, 0), (0, 3), (4, 5)]).nonzero_values()) == [2]
+    assert list(m.IntPairs([(0, 3), (1, 2), (3, 4)]).nonzero_values()) == []
+
+    # __next__ must continue to raise StopIteration
+    it = m.IntPairs([(0, 0)]).nonzero()
+    for _ in range(3):
+        with pytest.raises(StopIteration):
+            next(it)
+
+    it = m.IntPairs([(0, 0)]).nonzero_keys()
+    for _ in range(3):
+        with pytest.raises(StopIteration):
+            next(it)
+
+
+def test_nonref_iterators():
+    pairs = m.IntPairs([(1, 2), (3, 4), (0, 5)])
+    assert list(pairs.nonref()) == [(1, 2), (3, 4), (0, 5)]
+    assert list(pairs.nonref_keys()) == [1, 3, 0]
+    assert list(pairs.nonref_values()) == [2, 4, 5]
+
+
+def test_generalized_iterators_simple():
+    assert list(m.IntPairs([(1, 2), (3, 4), (0, 5)]).simple_iterator()) == [
+        (1, 2),
+        (3, 4),
+        (0, 5),
+    ]
+    assert list(m.IntPairs([(1, 2), (3, 4), (0, 5)]).simple_keys()) == [1, 3, 0]
+    assert list(m.IntPairs([(1, 2), (3, 4), (0, 5)]).simple_values()) == [2, 4, 5]
+
+
+def test_iterator_referencing():
+    """Test that iterators reference rather than copy their referents."""
+    vec = m.VectorNonCopyableInt()
+    vec.append(3)
+    vec.append(5)
+    assert [int(x) for x in vec] == [3, 5]
+    # Increment everything to make sure the referents can be mutated
+    for x in vec:
+        x.set(int(x) + 1)
+    assert [int(x) for x in vec] == [4, 6]
+
+    vec = m.VectorNonCopyableIntPair()
+    vec.append([3, 4])
+    vec.append([5, 7])
+    assert [int(x) for x in vec.keys()] == [3, 5]
+    assert [int(x) for x in vec.values()] == [4, 7]
+    for x in vec.keys():
+        x.set(int(x) + 1)
+    for x in vec.values():
+        x.set(int(x) + 10)
+    assert [int(x) for x in vec.keys()] == [4, 6]
+    assert [int(x) for x in vec.values()] == [14, 17]
+
+
+def test_sliceable():
+    sliceable = m.Sliceable(100)
+    assert sliceable[::] == (0, 100, 1)
+    assert sliceable[10::] == (10, 100, 1)
+    assert sliceable[:10:] == (0, 10, 1)
+    assert sliceable[::10] == (0, 100, 10)
+    assert sliceable[-10::] == (90, 100, 1)
+    assert sliceable[:-10:] == (0, 90, 1)
+    assert sliceable[::-10] == (99, -1, -10)
+    assert sliceable[50:60:1] == (50, 60, 1)
+    assert sliceable[50:60:-1] == (50, 60, -1)
+
+
+def test_sequence():
+    cstats = ConstructorStats.get(m.Sequence)
+
+    s = m.Sequence(5)
+    assert cstats.values() == ["of size", "5"]
+
+    assert "Sequence" in repr(s)
+    assert len(s) == 5
+    assert s[0] == 0 and s[3] == 0
+    assert 12.34 not in s
+    s[0], s[3] = 12.34, 56.78
+    assert 12.34 in s
+    assert s[0] == approx(12.34, rel=1e-05)
+    assert s[3] == approx(56.78, rel=1e-05)
+
+    rev = reversed(s)
+    assert cstats.values() == ["of size", "5"]
+
+    rev2 = s[::-1]
+    assert cstats.values() == ["of size", "5"]
+
+    it = iter(m.Sequence(0))
+    for _ in range(3):  # __next__ must continue to raise StopIteration
+        with pytest.raises(StopIteration):
+            next(it)
+    assert cstats.values() == ["of size", "0"]
+
+    expected = [0, 56.78, 0, 0, 12.34]
+    assert rev == approx(expected, rel=1e-05)
+    assert rev2 == approx(expected, rel=1e-05)
+    assert rev == rev2
+
+    rev[0::2] = m.Sequence([2.0, 2.0, 2.0])
+    assert cstats.values() == ["of size", "3", "from std::vector"]
+
+    assert rev == approx([2, 56.78, 2, 0, 2], rel=1e-05)
+
+    assert cstats.alive() == 4
+    del it
+    assert cstats.alive() == 3
+    del s
+    assert cstats.alive() == 2
+    del rev
+    assert cstats.alive() == 1
+    del rev2
+    assert cstats.alive() == 0
+
+    assert cstats.values() == []
+    assert cstats.default_constructions == 0
+    assert cstats.copy_constructions == 0
+    assert cstats.move_constructions >= 1
+    assert cstats.copy_assignments == 0
+    assert cstats.move_assignments == 0
+
+
+def test_sequence_length():
+    """#2076: Exception raised by len(arg) should be propagated"""
+
+    class BadLen(RuntimeError):
+        pass
+
+    class SequenceLike:
+        def __getitem__(self, i):
+            return None
+
+        def __len__(self):
+            raise BadLen()
+
+    with pytest.raises(BadLen):
+        m.sequence_length(SequenceLike())
+
+    assert m.sequence_length([1, 2, 3]) == 3
+    assert m.sequence_length("hello") == 5
+
+
+def test_map_iterator():
+    sm = m.StringMap({"hi": "bye", "black": "white"})
+    assert sm["hi"] == "bye"
+    assert len(sm) == 2
+    assert sm["black"] == "white"
+
+    with pytest.raises(KeyError):
+        assert sm["orange"]
+    sm["orange"] = "banana"
+    assert sm["orange"] == "banana"
+
+    expected = {"hi": "bye", "black": "white", "orange": "banana"}
+    for k in sm:
+        assert sm[k] == expected[k]
+    for k, v in sm.items():
+        assert v == expected[k]
+    assert list(sm.values()) == [expected[k] for k in sm]
+
+    it = iter(m.StringMap({}))
+    for _ in range(3):  # __next__ must continue to raise StopIteration
+        with pytest.raises(StopIteration):
+            next(it)
+
+
+def test_python_iterator_in_cpp():
+    t = (1, 2, 3)
+    assert m.object_to_list(t) == [1, 2, 3]
+    assert m.object_to_list(iter(t)) == [1, 2, 3]
+    assert m.iterator_to_list(iter(t)) == [1, 2, 3]
+
+    with pytest.raises(TypeError) as excinfo:
+        m.object_to_list(1)
+    assert "object is not iterable" in str(excinfo.value)
+
+    with pytest.raises(TypeError) as excinfo:
+        m.iterator_to_list(1)
+    assert "incompatible function arguments" in str(excinfo.value)
+
+    def bad_next_call():
+        raise RuntimeError("py::iterator::advance() should propagate errors")
+
+    with pytest.raises(RuntimeError) as excinfo:
+        m.iterator_to_list(iter(bad_next_call, None))
+    assert str(excinfo.value) == "py::iterator::advance() should propagate errors"
+
+    lst = [1, None, 0, None]
+    assert m.count_none(lst) == 2
+    assert m.find_none(lst) is True
+    assert m.count_nonzeros({"a": 0, "b": 1, "c": 2}) == 2
+
+    r = range(5)
+    assert all(m.tuple_iterator(tuple(r)))
+    assert all(m.list_iterator(list(r)))
+    assert all(m.sequence_iterator(r))
+
+
+def test_iterator_passthrough():
+    """#181: iterator passthrough did not compile"""
+    from pybind11_tests.sequences_and_iterators import iterator_passthrough
+
+    values = [3, 5, 7, 9, 11, 13, 15]
+    assert list(iterator_passthrough(iter(values))) == values
+
+
+def test_iterator_rvp():
+    """#388: Can't make iterators via make_iterator() with different r/v policies"""
+    import pybind11_tests.sequences_and_iterators as m
+
+    assert list(m.make_iterator_1()) == [1, 2, 3]
+    assert list(m.make_iterator_2()) == [1, 2, 3]
+    assert not isinstance(m.make_iterator_1(), type(m.make_iterator_2()))
+
+
+def test_carray_iterator():
+    """#4100: Check for proper iterator overload with C-Arrays"""
+    args_gt = list(float(i) for i in range(3))
+    arr_h = m.CArrayHolder(*args_gt)
+    args = list(arr_h)
+    assert args_gt == args
```

## extern/pybind11/tests/test_smart_ptr.py

 * *Ordering differences only*

```diff
@@ -1,315 +1,315 @@
-import pytest
-
-m = pytest.importorskip("pybind11_tests.smart_ptr")
-from pybind11_tests import ConstructorStats  # noqa: E402
-
-
-def test_smart_ptr(capture):
-    # Object1
-    for i, o in enumerate(
-        [m.make_object_1(), m.make_object_2(), m.MyObject1(3)], start=1
-    ):
-        assert o.getRefCount() == 1
-        with capture:
-            m.print_object_1(o)
-            m.print_object_2(o)
-            m.print_object_3(o)
-            m.print_object_4(o)
-        assert capture == f"MyObject1[{i}]\n" * 4
-
-    for i, o in enumerate(
-        [m.make_myobject1_1(), m.make_myobject1_2(), m.MyObject1(6), 7], start=4
-    ):
-        print(o)
-        with capture:
-            if not isinstance(o, int):
-                m.print_object_1(o)
-                m.print_object_2(o)
-                m.print_object_3(o)
-                m.print_object_4(o)
-            m.print_myobject1_1(o)
-            m.print_myobject1_2(o)
-            m.print_myobject1_3(o)
-            m.print_myobject1_4(o)
-
-        times = 4 if isinstance(o, int) else 8
-        assert capture == f"MyObject1[{i}]\n" * times
-
-    cstats = ConstructorStats.get(m.MyObject1)
-    assert cstats.alive() == 0
-    expected_values = [f"MyObject1[{i}]" for i in range(1, 7)] + ["MyObject1[7]"] * 4
-    assert cstats.values() == expected_values
-    assert cstats.default_constructions == 0
-    assert cstats.copy_constructions == 0
-    # assert cstats.move_constructions >= 0 # Doesn't invoke any
-    assert cstats.copy_assignments == 0
-    assert cstats.move_assignments == 0
-
-    # Object2
-    for i, o in zip(
-        [8, 6, 7], [m.MyObject2(8), m.make_myobject2_1(), m.make_myobject2_2()]
-    ):
-        print(o)
-        with capture:
-            m.print_myobject2_1(o)
-            m.print_myobject2_2(o)
-            m.print_myobject2_3(o)
-            m.print_myobject2_4(o)
-        assert capture == f"MyObject2[{i}]\n" * 4
-
-    cstats = ConstructorStats.get(m.MyObject2)
-    assert cstats.alive() == 1
-    o = None
-    assert cstats.alive() == 0
-    assert cstats.values() == ["MyObject2[8]", "MyObject2[6]", "MyObject2[7]"]
-    assert cstats.default_constructions == 0
-    assert cstats.copy_constructions == 0
-    # assert cstats.move_constructions >= 0 # Doesn't invoke any
-    assert cstats.copy_assignments == 0
-    assert cstats.move_assignments == 0
-
-    # Object3
-    for i, o in zip(
-        [9, 8, 9], [m.MyObject3(9), m.make_myobject3_1(), m.make_myobject3_2()]
-    ):
-        print(o)
-        with capture:
-            m.print_myobject3_1(o)
-            m.print_myobject3_2(o)
-            m.print_myobject3_3(o)
-            m.print_myobject3_4(o)
-        assert capture == f"MyObject3[{i}]\n" * 4
-
-    cstats = ConstructorStats.get(m.MyObject3)
-    assert cstats.alive() == 1
-    o = None
-    assert cstats.alive() == 0
-    assert cstats.values() == ["MyObject3[9]", "MyObject3[8]", "MyObject3[9]"]
-    assert cstats.default_constructions == 0
-    assert cstats.copy_constructions == 0
-    # assert cstats.move_constructions >= 0 # Doesn't invoke any
-    assert cstats.copy_assignments == 0
-    assert cstats.move_assignments == 0
-
-    # Object
-    cstats = ConstructorStats.get(m.Object)
-    assert cstats.alive() == 0
-    assert cstats.values() == []
-    assert cstats.default_constructions == 10
-    assert cstats.copy_constructions == 0
-    # assert cstats.move_constructions >= 0 # Doesn't invoke any
-    assert cstats.copy_assignments == 0
-    assert cstats.move_assignments == 0
-
-    # ref<>
-    cstats = m.cstats_ref()
-    assert cstats.alive() == 0
-    assert cstats.values() == ["from pointer"] * 10
-    assert cstats.default_constructions == 30
-    assert cstats.copy_constructions == 12
-    # assert cstats.move_constructions >= 0 # Doesn't invoke any
-    assert cstats.copy_assignments == 30
-    assert cstats.move_assignments == 0
-
-
-def test_smart_ptr_refcounting():
-    assert m.test_object1_refcounting()
-
-
-def test_unique_nodelete():
-    o = m.MyObject4(23)
-    assert o.value == 23
-    cstats = ConstructorStats.get(m.MyObject4)
-    assert cstats.alive() == 1
-    del o
-    assert cstats.alive() == 1
-    m.MyObject4.cleanup_all_instances()
-    assert cstats.alive() == 0
-
-
-def test_unique_nodelete4a():
-    o = m.MyObject4a(23)
-    assert o.value == 23
-    cstats = ConstructorStats.get(m.MyObject4a)
-    assert cstats.alive() == 1
-    del o
-    assert cstats.alive() == 1
-    m.MyObject4a.cleanup_all_instances()
-    assert cstats.alive() == 0
-
-
-def test_unique_deleter():
-    m.MyObject4a(0)
-    o = m.MyObject4b(23)
-    assert o.value == 23
-    cstats4a = ConstructorStats.get(m.MyObject4a)
-    assert cstats4a.alive() == 2
-    cstats4b = ConstructorStats.get(m.MyObject4b)
-    assert cstats4b.alive() == 1
-    del o
-    assert cstats4a.alive() == 1  # Should now only be one leftover
-    assert cstats4b.alive() == 0  # Should be deleted
-    m.MyObject4a.cleanup_all_instances()
-    assert cstats4a.alive() == 0
-    assert cstats4b.alive() == 0
-
-
-def test_large_holder():
-    o = m.MyObject5(5)
-    assert o.value == 5
-    cstats = ConstructorStats.get(m.MyObject5)
-    assert cstats.alive() == 1
-    del o
-    assert cstats.alive() == 0
-
-
-def test_shared_ptr_and_references():
-    s = m.SharedPtrRef()
-    stats = ConstructorStats.get(m.A)
-    assert stats.alive() == 2
-
-    ref = s.ref  # init_holder_helper(holder_ptr=false, owned=false)
-    assert stats.alive() == 2
-    assert s.set_ref(ref)
-    with pytest.raises(RuntimeError) as excinfo:
-        assert s.set_holder(ref)
-    assert "Unable to cast from non-held to held instance" in str(excinfo.value)
-
-    copy = s.copy  # init_holder_helper(holder_ptr=false, owned=true)
-    assert stats.alive() == 3
-    assert s.set_ref(copy)
-    assert s.set_holder(copy)
-
-    holder_ref = s.holder_ref  # init_holder_helper(holder_ptr=true, owned=false)
-    assert stats.alive() == 3
-    assert s.set_ref(holder_ref)
-    assert s.set_holder(holder_ref)
-
-    holder_copy = s.holder_copy  # init_holder_helper(holder_ptr=true, owned=true)
-    assert stats.alive() == 3
-    assert s.set_ref(holder_copy)
-    assert s.set_holder(holder_copy)
-
-    del ref, copy, holder_ref, holder_copy, s
-    assert stats.alive() == 0
-
-
-def test_shared_ptr_from_this_and_references():
-    s = m.SharedFromThisRef()
-    stats = ConstructorStats.get(m.B)
-    assert stats.alive() == 2
-
-    ref = s.ref  # init_holder_helper(holder_ptr=false, owned=false, bad_wp=false)
-    assert stats.alive() == 2
-    assert s.set_ref(ref)
-    assert s.set_holder(
-        ref
-    )  # std::enable_shared_from_this can create a holder from a reference
-
-    bad_wp = s.bad_wp  # init_holder_helper(holder_ptr=false, owned=false, bad_wp=true)
-    assert stats.alive() == 2
-    assert s.set_ref(bad_wp)
-    with pytest.raises(RuntimeError) as excinfo:
-        assert s.set_holder(bad_wp)
-    assert "Unable to cast from non-held to held instance" in str(excinfo.value)
-
-    copy = s.copy  # init_holder_helper(holder_ptr=false, owned=true, bad_wp=false)
-    assert stats.alive() == 3
-    assert s.set_ref(copy)
-    assert s.set_holder(copy)
-
-    holder_ref = (
-        s.holder_ref
-    )  # init_holder_helper(holder_ptr=true, owned=false, bad_wp=false)
-    assert stats.alive() == 3
-    assert s.set_ref(holder_ref)
-    assert s.set_holder(holder_ref)
-
-    holder_copy = (
-        s.holder_copy
-    )  # init_holder_helper(holder_ptr=true, owned=true, bad_wp=false)
-    assert stats.alive() == 3
-    assert s.set_ref(holder_copy)
-    assert s.set_holder(holder_copy)
-
-    del ref, bad_wp, copy, holder_ref, holder_copy, s
-    assert stats.alive() == 0
-
-    z = m.SharedFromThisVirt.get()
-    y = m.SharedFromThisVirt.get()
-    assert y is z
-
-
-def test_move_only_holder():
-    a = m.TypeWithMoveOnlyHolder.make()
-    b = m.TypeWithMoveOnlyHolder.make_as_object()
-    stats = ConstructorStats.get(m.TypeWithMoveOnlyHolder)
-    assert stats.alive() == 2
-    del b
-    assert stats.alive() == 1
-    del a
-    assert stats.alive() == 0
-
-
-def test_holder_with_addressof_operator():
-    # this test must not throw exception from c++
-    a = m.TypeForHolderWithAddressOf.make()
-    a.print_object_1()
-    a.print_object_2()
-    a.print_object_3()
-    a.print_object_4()
-
-    stats = ConstructorStats.get(m.TypeForHolderWithAddressOf)
-    assert stats.alive() == 1
-
-    np = m.TypeForHolderWithAddressOf.make()
-    assert stats.alive() == 2
-    del a
-    assert stats.alive() == 1
-    del np
-    assert stats.alive() == 0
-
-    b = m.TypeForHolderWithAddressOf.make()
-    c = b
-    assert b.get() is c.get()
-    assert stats.alive() == 1
-
-    del b
-    assert stats.alive() == 1
-
-    del c
-    assert stats.alive() == 0
-
-
-def test_move_only_holder_with_addressof_operator():
-    a = m.TypeForMoveOnlyHolderWithAddressOf.make()
-    a.print_object()
-
-    stats = ConstructorStats.get(m.TypeForMoveOnlyHolderWithAddressOf)
-    assert stats.alive() == 1
-
-    a.value = 42
-    assert a.value == 42
-
-    del a
-    assert stats.alive() == 0
-
-
-def test_smart_ptr_from_default():
-    instance = m.HeldByDefaultHolder()
-    with pytest.raises(RuntimeError) as excinfo:
-        m.HeldByDefaultHolder.load_shared_ptr(instance)
-    assert (
-        "Unable to load a custom holder type from a "
-        "default-holder instance" in str(excinfo.value)
-    )
-
-
-def test_shared_ptr_gc():
-    """#187: issue involving std::shared_ptr<> return value policy & garbage collection"""
-    el = m.ElementList()
-    for i in range(10):
-        el.add(m.ElementA(i))
-    pytest.gc_collect()
-    for i, v in enumerate(el.get()):
-        assert i == v.value()
+import pytest
+
+m = pytest.importorskip("pybind11_tests.smart_ptr")
+from pybind11_tests import ConstructorStats  # noqa: E402
+
+
+def test_smart_ptr(capture):
+    # Object1
+    for i, o in enumerate(
+        [m.make_object_1(), m.make_object_2(), m.MyObject1(3)], start=1
+    ):
+        assert o.getRefCount() == 1
+        with capture:
+            m.print_object_1(o)
+            m.print_object_2(o)
+            m.print_object_3(o)
+            m.print_object_4(o)
+        assert capture == f"MyObject1[{i}]\n" * 4
+
+    for i, o in enumerate(
+        [m.make_myobject1_1(), m.make_myobject1_2(), m.MyObject1(6), 7], start=4
+    ):
+        print(o)
+        with capture:
+            if not isinstance(o, int):
+                m.print_object_1(o)
+                m.print_object_2(o)
+                m.print_object_3(o)
+                m.print_object_4(o)
+            m.print_myobject1_1(o)
+            m.print_myobject1_2(o)
+            m.print_myobject1_3(o)
+            m.print_myobject1_4(o)
+
+        times = 4 if isinstance(o, int) else 8
+        assert capture == f"MyObject1[{i}]\n" * times
+
+    cstats = ConstructorStats.get(m.MyObject1)
+    assert cstats.alive() == 0
+    expected_values = [f"MyObject1[{i}]" for i in range(1, 7)] + ["MyObject1[7]"] * 4
+    assert cstats.values() == expected_values
+    assert cstats.default_constructions == 0
+    assert cstats.copy_constructions == 0
+    # assert cstats.move_constructions >= 0 # Doesn't invoke any
+    assert cstats.copy_assignments == 0
+    assert cstats.move_assignments == 0
+
+    # Object2
+    for i, o in zip(
+        [8, 6, 7], [m.MyObject2(8), m.make_myobject2_1(), m.make_myobject2_2()]
+    ):
+        print(o)
+        with capture:
+            m.print_myobject2_1(o)
+            m.print_myobject2_2(o)
+            m.print_myobject2_3(o)
+            m.print_myobject2_4(o)
+        assert capture == f"MyObject2[{i}]\n" * 4
+
+    cstats = ConstructorStats.get(m.MyObject2)
+    assert cstats.alive() == 1
+    o = None
+    assert cstats.alive() == 0
+    assert cstats.values() == ["MyObject2[8]", "MyObject2[6]", "MyObject2[7]"]
+    assert cstats.default_constructions == 0
+    assert cstats.copy_constructions == 0
+    # assert cstats.move_constructions >= 0 # Doesn't invoke any
+    assert cstats.copy_assignments == 0
+    assert cstats.move_assignments == 0
+
+    # Object3
+    for i, o in zip(
+        [9, 8, 9], [m.MyObject3(9), m.make_myobject3_1(), m.make_myobject3_2()]
+    ):
+        print(o)
+        with capture:
+            m.print_myobject3_1(o)
+            m.print_myobject3_2(o)
+            m.print_myobject3_3(o)
+            m.print_myobject3_4(o)
+        assert capture == f"MyObject3[{i}]\n" * 4
+
+    cstats = ConstructorStats.get(m.MyObject3)
+    assert cstats.alive() == 1
+    o = None
+    assert cstats.alive() == 0
+    assert cstats.values() == ["MyObject3[9]", "MyObject3[8]", "MyObject3[9]"]
+    assert cstats.default_constructions == 0
+    assert cstats.copy_constructions == 0
+    # assert cstats.move_constructions >= 0 # Doesn't invoke any
+    assert cstats.copy_assignments == 0
+    assert cstats.move_assignments == 0
+
+    # Object
+    cstats = ConstructorStats.get(m.Object)
+    assert cstats.alive() == 0
+    assert cstats.values() == []
+    assert cstats.default_constructions == 10
+    assert cstats.copy_constructions == 0
+    # assert cstats.move_constructions >= 0 # Doesn't invoke any
+    assert cstats.copy_assignments == 0
+    assert cstats.move_assignments == 0
+
+    # ref<>
+    cstats = m.cstats_ref()
+    assert cstats.alive() == 0
+    assert cstats.values() == ["from pointer"] * 10
+    assert cstats.default_constructions == 30
+    assert cstats.copy_constructions == 12
+    # assert cstats.move_constructions >= 0 # Doesn't invoke any
+    assert cstats.copy_assignments == 30
+    assert cstats.move_assignments == 0
+
+
+def test_smart_ptr_refcounting():
+    assert m.test_object1_refcounting()
+
+
+def test_unique_nodelete():
+    o = m.MyObject4(23)
+    assert o.value == 23
+    cstats = ConstructorStats.get(m.MyObject4)
+    assert cstats.alive() == 1
+    del o
+    assert cstats.alive() == 1
+    m.MyObject4.cleanup_all_instances()
+    assert cstats.alive() == 0
+
+
+def test_unique_nodelete4a():
+    o = m.MyObject4a(23)
+    assert o.value == 23
+    cstats = ConstructorStats.get(m.MyObject4a)
+    assert cstats.alive() == 1
+    del o
+    assert cstats.alive() == 1
+    m.MyObject4a.cleanup_all_instances()
+    assert cstats.alive() == 0
+
+
+def test_unique_deleter():
+    m.MyObject4a(0)
+    o = m.MyObject4b(23)
+    assert o.value == 23
+    cstats4a = ConstructorStats.get(m.MyObject4a)
+    assert cstats4a.alive() == 2
+    cstats4b = ConstructorStats.get(m.MyObject4b)
+    assert cstats4b.alive() == 1
+    del o
+    assert cstats4a.alive() == 1  # Should now only be one leftover
+    assert cstats4b.alive() == 0  # Should be deleted
+    m.MyObject4a.cleanup_all_instances()
+    assert cstats4a.alive() == 0
+    assert cstats4b.alive() == 0
+
+
+def test_large_holder():
+    o = m.MyObject5(5)
+    assert o.value == 5
+    cstats = ConstructorStats.get(m.MyObject5)
+    assert cstats.alive() == 1
+    del o
+    assert cstats.alive() == 0
+
+
+def test_shared_ptr_and_references():
+    s = m.SharedPtrRef()
+    stats = ConstructorStats.get(m.A)
+    assert stats.alive() == 2
+
+    ref = s.ref  # init_holder_helper(holder_ptr=false, owned=false)
+    assert stats.alive() == 2
+    assert s.set_ref(ref)
+    with pytest.raises(RuntimeError) as excinfo:
+        assert s.set_holder(ref)
+    assert "Unable to cast from non-held to held instance" in str(excinfo.value)
+
+    copy = s.copy  # init_holder_helper(holder_ptr=false, owned=true)
+    assert stats.alive() == 3
+    assert s.set_ref(copy)
+    assert s.set_holder(copy)
+
+    holder_ref = s.holder_ref  # init_holder_helper(holder_ptr=true, owned=false)
+    assert stats.alive() == 3
+    assert s.set_ref(holder_ref)
+    assert s.set_holder(holder_ref)
+
+    holder_copy = s.holder_copy  # init_holder_helper(holder_ptr=true, owned=true)
+    assert stats.alive() == 3
+    assert s.set_ref(holder_copy)
+    assert s.set_holder(holder_copy)
+
+    del ref, copy, holder_ref, holder_copy, s
+    assert stats.alive() == 0
+
+
+def test_shared_ptr_from_this_and_references():
+    s = m.SharedFromThisRef()
+    stats = ConstructorStats.get(m.B)
+    assert stats.alive() == 2
+
+    ref = s.ref  # init_holder_helper(holder_ptr=false, owned=false, bad_wp=false)
+    assert stats.alive() == 2
+    assert s.set_ref(ref)
+    assert s.set_holder(
+        ref
+    )  # std::enable_shared_from_this can create a holder from a reference
+
+    bad_wp = s.bad_wp  # init_holder_helper(holder_ptr=false, owned=false, bad_wp=true)
+    assert stats.alive() == 2
+    assert s.set_ref(bad_wp)
+    with pytest.raises(RuntimeError) as excinfo:
+        assert s.set_holder(bad_wp)
+    assert "Unable to cast from non-held to held instance" in str(excinfo.value)
+
+    copy = s.copy  # init_holder_helper(holder_ptr=false, owned=true, bad_wp=false)
+    assert stats.alive() == 3
+    assert s.set_ref(copy)
+    assert s.set_holder(copy)
+
+    holder_ref = (
+        s.holder_ref
+    )  # init_holder_helper(holder_ptr=true, owned=false, bad_wp=false)
+    assert stats.alive() == 3
+    assert s.set_ref(holder_ref)
+    assert s.set_holder(holder_ref)
+
+    holder_copy = (
+        s.holder_copy
+    )  # init_holder_helper(holder_ptr=true, owned=true, bad_wp=false)
+    assert stats.alive() == 3
+    assert s.set_ref(holder_copy)
+    assert s.set_holder(holder_copy)
+
+    del ref, bad_wp, copy, holder_ref, holder_copy, s
+    assert stats.alive() == 0
+
+    z = m.SharedFromThisVirt.get()
+    y = m.SharedFromThisVirt.get()
+    assert y is z
+
+
+def test_move_only_holder():
+    a = m.TypeWithMoveOnlyHolder.make()
+    b = m.TypeWithMoveOnlyHolder.make_as_object()
+    stats = ConstructorStats.get(m.TypeWithMoveOnlyHolder)
+    assert stats.alive() == 2
+    del b
+    assert stats.alive() == 1
+    del a
+    assert stats.alive() == 0
+
+
+def test_holder_with_addressof_operator():
+    # this test must not throw exception from c++
+    a = m.TypeForHolderWithAddressOf.make()
+    a.print_object_1()
+    a.print_object_2()
+    a.print_object_3()
+    a.print_object_4()
+
+    stats = ConstructorStats.get(m.TypeForHolderWithAddressOf)
+    assert stats.alive() == 1
+
+    np = m.TypeForHolderWithAddressOf.make()
+    assert stats.alive() == 2
+    del a
+    assert stats.alive() == 1
+    del np
+    assert stats.alive() == 0
+
+    b = m.TypeForHolderWithAddressOf.make()
+    c = b
+    assert b.get() is c.get()
+    assert stats.alive() == 1
+
+    del b
+    assert stats.alive() == 1
+
+    del c
+    assert stats.alive() == 0
+
+
+def test_move_only_holder_with_addressof_operator():
+    a = m.TypeForMoveOnlyHolderWithAddressOf.make()
+    a.print_object()
+
+    stats = ConstructorStats.get(m.TypeForMoveOnlyHolderWithAddressOf)
+    assert stats.alive() == 1
+
+    a.value = 42
+    assert a.value == 42
+
+    del a
+    assert stats.alive() == 0
+
+
+def test_smart_ptr_from_default():
+    instance = m.HeldByDefaultHolder()
+    with pytest.raises(RuntimeError) as excinfo:
+        m.HeldByDefaultHolder.load_shared_ptr(instance)
+    assert (
+        "Unable to load a custom holder type from a "
+        "default-holder instance" in str(excinfo.value)
+    )
+
+
+def test_shared_ptr_gc():
+    """#187: issue involving std::shared_ptr<> return value policy & garbage collection"""
+    el = m.ElementList()
+    for i in range(10):
+        el.add(m.ElementA(i))
+    pytest.gc_collect()
+    for i, v in enumerate(el.get()):
+        assert i == v.value()
```

## extern/pybind11/tests/test_stl.py

 * *Ordering differences only*

```diff
@@ -1,377 +1,377 @@
-import pytest
-
-from pybind11_tests import ConstructorStats, UserType
-from pybind11_tests import stl as m
-
-
-def test_vector(doc):
-    """std::vector <-> list"""
-    lst = m.cast_vector()
-    assert lst == [1]
-    lst.append(2)
-    assert m.load_vector(lst)
-    assert m.load_vector(tuple(lst))
-
-    assert m.cast_bool_vector() == [True, False]
-    assert m.load_bool_vector([True, False])
-    assert m.load_bool_vector(tuple([True, False]))
-
-    assert doc(m.cast_vector) == "cast_vector() -> List[int]"
-    assert doc(m.load_vector) == "load_vector(arg0: List[int]) -> bool"
-
-    # Test regression caused by 936: pointers to stl containers weren't castable
-    assert m.cast_ptr_vector() == ["lvalue", "lvalue"]
-
-
-def test_deque(doc):
-    """std::deque <-> list"""
-    lst = m.cast_deque()
-    assert lst == [1]
-    lst.append(2)
-    assert m.load_deque(lst)
-    assert m.load_deque(tuple(lst))
-
-
-def test_array(doc):
-    """std::array <-> list"""
-    lst = m.cast_array()
-    assert lst == [1, 2]
-    assert m.load_array(lst)
-    assert m.load_array(tuple(lst))
-
-    assert doc(m.cast_array) == "cast_array() -> List[int[2]]"
-    assert doc(m.load_array) == "load_array(arg0: List[int[2]]) -> bool"
-
-
-def test_valarray(doc):
-    """std::valarray <-> list"""
-    lst = m.cast_valarray()
-    assert lst == [1, 4, 9]
-    assert m.load_valarray(lst)
-    assert m.load_valarray(tuple(lst))
-
-    assert doc(m.cast_valarray) == "cast_valarray() -> List[int]"
-    assert doc(m.load_valarray) == "load_valarray(arg0: List[int]) -> bool"
-
-
-def test_map(doc):
-    """std::map <-> dict"""
-    d = m.cast_map()
-    assert d == {"key": "value"}
-    assert "key" in d
-    d["key2"] = "value2"
-    assert "key2" in d
-    assert m.load_map(d)
-
-    assert doc(m.cast_map) == "cast_map() -> Dict[str, str]"
-    assert doc(m.load_map) == "load_map(arg0: Dict[str, str]) -> bool"
-
-
-def test_set(doc):
-    """std::set <-> set"""
-    s = m.cast_set()
-    assert s == {"key1", "key2"}
-    s.add("key3")
-    assert m.load_set(s)
-    assert m.load_set(frozenset(s))
-
-    assert doc(m.cast_set) == "cast_set() -> Set[str]"
-    assert doc(m.load_set) == "load_set(arg0: Set[str]) -> bool"
-
-
-def test_recursive_casting():
-    """Tests that stl casters preserve lvalue/rvalue context for container values"""
-    assert m.cast_rv_vector() == ["rvalue", "rvalue"]
-    assert m.cast_lv_vector() == ["lvalue", "lvalue"]
-    assert m.cast_rv_array() == ["rvalue", "rvalue", "rvalue"]
-    assert m.cast_lv_array() == ["lvalue", "lvalue"]
-    assert m.cast_rv_map() == {"a": "rvalue"}
-    assert m.cast_lv_map() == {"a": "lvalue", "b": "lvalue"}
-    assert m.cast_rv_nested() == [[[{"b": "rvalue", "c": "rvalue"}], [{"a": "rvalue"}]]]
-    assert m.cast_lv_nested() == {
-        "a": [[["lvalue", "lvalue"]], [["lvalue", "lvalue"]]],
-        "b": [[["lvalue", "lvalue"], ["lvalue", "lvalue"]]],
-    }
-
-    # Issue #853 test case:
-    z = m.cast_unique_ptr_vector()
-    assert z[0].value == 7 and z[1].value == 42
-
-
-def test_move_out_container():
-    """Properties use the `reference_internal` policy by default. If the underlying function
-    returns an rvalue, the policy is automatically changed to `move` to avoid referencing
-    a temporary. In case the return value is a container of user-defined types, the policy
-    also needs to be applied to the elements, not just the container."""
-    c = m.MoveOutContainer()
-    moved_out_list = c.move_list
-    assert [x.value for x in moved_out_list] == [0, 1, 2]
-
-
-@pytest.mark.skipif(not hasattr(m, "has_optional"), reason="no <optional>")
-def test_optional():
-    assert m.double_or_zero(None) == 0
-    assert m.double_or_zero(42) == 84
-    pytest.raises(TypeError, m.double_or_zero, "foo")
-
-    assert m.half_or_none(0) is None
-    assert m.half_or_none(42) == 21
-    pytest.raises(TypeError, m.half_or_none, "foo")
-
-    assert m.test_nullopt() == 42
-    assert m.test_nullopt(None) == 42
-    assert m.test_nullopt(42) == 42
-    assert m.test_nullopt(43) == 43
-
-    assert m.test_no_assign() == 42
-    assert m.test_no_assign(None) == 42
-    assert m.test_no_assign(m.NoAssign(43)) == 43
-    pytest.raises(TypeError, m.test_no_assign, 43)
-
-    assert m.nodefer_none_optional(None)
-
-    holder = m.OptionalHolder()
-    mvalue = holder.member
-    assert mvalue.initialized
-    assert holder.member_initialized()
-
-    props = m.OptionalProperties()
-    assert int(props.access_by_ref) == 42
-    assert int(props.access_by_copy) == 42
-
-
-@pytest.mark.skipif(
-    not hasattr(m, "has_exp_optional"), reason="no <experimental/optional>"
-)
-def test_exp_optional():
-    assert m.double_or_zero_exp(None) == 0
-    assert m.double_or_zero_exp(42) == 84
-    pytest.raises(TypeError, m.double_or_zero_exp, "foo")
-
-    assert m.half_or_none_exp(0) is None
-    assert m.half_or_none_exp(42) == 21
-    pytest.raises(TypeError, m.half_or_none_exp, "foo")
-
-    assert m.test_nullopt_exp() == 42
-    assert m.test_nullopt_exp(None) == 42
-    assert m.test_nullopt_exp(42) == 42
-    assert m.test_nullopt_exp(43) == 43
-
-    assert m.test_no_assign_exp() == 42
-    assert m.test_no_assign_exp(None) == 42
-    assert m.test_no_assign_exp(m.NoAssign(43)) == 43
-    pytest.raises(TypeError, m.test_no_assign_exp, 43)
-
-    holder = m.OptionalExpHolder()
-    mvalue = holder.member
-    assert mvalue.initialized
-    assert holder.member_initialized()
-
-    props = m.OptionalExpProperties()
-    assert int(props.access_by_ref) == 42
-    assert int(props.access_by_copy) == 42
-
-
-@pytest.mark.skipif(not hasattr(m, "has_boost_optional"), reason="no <boost/optional>")
-def test_boost_optional():
-    assert m.double_or_zero_boost(None) == 0
-    assert m.double_or_zero_boost(42) == 84
-    pytest.raises(TypeError, m.double_or_zero_boost, "foo")
-
-    assert m.half_or_none_boost(0) is None
-    assert m.half_or_none_boost(42) == 21
-    pytest.raises(TypeError, m.half_or_none_boost, "foo")
-
-    assert m.test_nullopt_boost() == 42
-    assert m.test_nullopt_boost(None) == 42
-    assert m.test_nullopt_boost(42) == 42
-    assert m.test_nullopt_boost(43) == 43
-
-    assert m.test_no_assign_boost() == 42
-    assert m.test_no_assign_boost(None) == 42
-    assert m.test_no_assign_boost(m.NoAssign(43)) == 43
-    pytest.raises(TypeError, m.test_no_assign_boost, 43)
-
-    holder = m.OptionalBoostHolder()
-    mvalue = holder.member
-    assert mvalue.initialized
-    assert holder.member_initialized()
-
-    props = m.OptionalBoostProperties()
-    assert int(props.access_by_ref) == 42
-    assert int(props.access_by_copy) == 42
-
-
-def test_reference_sensitive_optional():
-    assert m.double_or_zero_refsensitive(None) == 0
-    assert m.double_or_zero_refsensitive(42) == 84
-    pytest.raises(TypeError, m.double_or_zero_refsensitive, "foo")
-
-    assert m.half_or_none_refsensitive(0) is None
-    assert m.half_or_none_refsensitive(42) == 21
-    pytest.raises(TypeError, m.half_or_none_refsensitive, "foo")
-
-    assert m.test_nullopt_refsensitive() == 42
-    assert m.test_nullopt_refsensitive(None) == 42
-    assert m.test_nullopt_refsensitive(42) == 42
-    assert m.test_nullopt_refsensitive(43) == 43
-
-    assert m.test_no_assign_refsensitive() == 42
-    assert m.test_no_assign_refsensitive(None) == 42
-    assert m.test_no_assign_refsensitive(m.NoAssign(43)) == 43
-    pytest.raises(TypeError, m.test_no_assign_refsensitive, 43)
-
-    holder = m.OptionalRefSensitiveHolder()
-    mvalue = holder.member
-    assert mvalue.initialized
-    assert holder.member_initialized()
-
-    props = m.OptionalRefSensitiveProperties()
-    assert int(props.access_by_ref) == 42
-    assert int(props.access_by_copy) == 42
-
-
-@pytest.mark.skipif(not hasattr(m, "has_filesystem"), reason="no <filesystem>")
-def test_fs_path():
-    from pathlib import Path
-
-    class PseudoStrPath:
-        def __fspath__(self):
-            return "foo/bar"
-
-    class PseudoBytesPath:
-        def __fspath__(self):
-            return b"foo/bar"
-
-    assert m.parent_path(Path("foo/bar")) == Path("foo")
-    assert m.parent_path("foo/bar") == Path("foo")
-    assert m.parent_path(b"foo/bar") == Path("foo")
-    assert m.parent_path(PseudoStrPath()) == Path("foo")
-    assert m.parent_path(PseudoBytesPath()) == Path("foo")
-
-
-@pytest.mark.skipif(not hasattr(m, "load_variant"), reason="no <variant>")
-def test_variant(doc):
-    assert m.load_variant(1) == "int"
-    assert m.load_variant("1") == "std::string"
-    assert m.load_variant(1.0) == "double"
-    assert m.load_variant(None) == "std::nullptr_t"
-
-    assert m.load_variant_2pass(1) == "int"
-    assert m.load_variant_2pass(1.0) == "double"
-
-    assert m.cast_variant() == (5, "Hello")
-
-    assert (
-        doc(m.load_variant) == "load_variant(arg0: Union[int, str, float, None]) -> str"
-    )
-
-
-@pytest.mark.skipif(
-    not hasattr(m, "load_monostate_variant"), reason="no std::monostate"
-)
-def test_variant_monostate(doc):
-    assert m.load_monostate_variant(None) == "std::monostate"
-    assert m.load_monostate_variant(1) == "int"
-    assert m.load_monostate_variant("1") == "std::string"
-
-    assert m.cast_monostate_variant() == (None, 5, "Hello")
-
-    assert (
-        doc(m.load_monostate_variant)
-        == "load_monostate_variant(arg0: Union[None, int, str]) -> str"
-    )
-
-
-def test_vec_of_reference_wrapper():
-    """#171: Can't return reference wrappers (or STL structures containing them)"""
-    assert (
-        str(m.return_vec_of_reference_wrapper(UserType(4)))
-        == "[UserType(1), UserType(2), UserType(3), UserType(4)]"
-    )
-
-
-def test_stl_pass_by_pointer(msg):
-    """Passing nullptr or None to an STL container pointer is not expected to work"""
-    with pytest.raises(TypeError) as excinfo:
-        m.stl_pass_by_pointer()  # default value is `nullptr`
-    assert (
-        msg(excinfo.value)
-        == """
-        stl_pass_by_pointer(): incompatible function arguments. The following argument types are supported:
-            1. (v: List[int] = None) -> List[int]
-
-        Invoked with:
-    """
-    )
-
-    with pytest.raises(TypeError) as excinfo:
-        m.stl_pass_by_pointer(None)
-    assert (
-        msg(excinfo.value)
-        == """
-        stl_pass_by_pointer(): incompatible function arguments. The following argument types are supported:
-            1. (v: List[int] = None) -> List[int]
-
-        Invoked with: None
-    """
-    )
-
-    assert m.stl_pass_by_pointer([1, 2, 3]) == [1, 2, 3]
-
-
-def test_missing_header_message():
-    """Trying convert `list` to a `std::vector`, or vice versa, without including
-    <pybind11/stl.h> should result in a helpful suggestion in the error message"""
-    import pybind11_cross_module_tests as cm
-
-    expected_message = (
-        "Did you forget to `#include <pybind11/stl.h>`? Or <pybind11/complex.h>,\n"
-        "<pybind11/functional.h>, <pybind11/chrono.h>, etc. Some automatic\n"
-        "conversions are optional and require extra headers to be included\n"
-        "when compiling your pybind11 module."
-    )
-
-    with pytest.raises(TypeError) as excinfo:
-        cm.missing_header_arg([1.0, 2.0, 3.0])
-    assert expected_message in str(excinfo.value)
-
-    with pytest.raises(TypeError) as excinfo:
-        cm.missing_header_return()
-    assert expected_message in str(excinfo.value)
-
-
-def test_function_with_string_and_vector_string_arg():
-    """Check if a string is NOT implicitly converted to a list, which was the
-    behavior before fix of issue #1258"""
-    assert m.func_with_string_or_vector_string_arg_overload(("A", "B")) == 2
-    assert m.func_with_string_or_vector_string_arg_overload(["A", "B"]) == 2
-    assert m.func_with_string_or_vector_string_arg_overload("A") == 3
-
-
-def test_stl_ownership():
-    cstats = ConstructorStats.get(m.Placeholder)
-    assert cstats.alive() == 0
-    r = m.test_stl_ownership()
-    assert len(r) == 1
-    del r
-    assert cstats.alive() == 0
-
-
-def test_array_cast_sequence():
-    assert m.array_cast_sequence((1, 2, 3)) == [1, 2, 3]
-
-
-def test_issue_1561():
-    """check fix for issue #1561"""
-    bar = m.Issue1561Outer()
-    bar.list = [m.Issue1561Inner("bar")]
-    bar.list
-    assert bar.list[0].data == "bar"
-
-
-def test_return_vector_bool_raw_ptr():
-    # Add `while True:` for manual leak checking.
-    v = m.return_vector_bool_raw_ptr()
-    assert isinstance(v, list)
-    assert len(v) == 4513
+import pytest
+
+from pybind11_tests import ConstructorStats, UserType
+from pybind11_tests import stl as m
+
+
+def test_vector(doc):
+    """std::vector <-> list"""
+    lst = m.cast_vector()
+    assert lst == [1]
+    lst.append(2)
+    assert m.load_vector(lst)
+    assert m.load_vector(tuple(lst))
+
+    assert m.cast_bool_vector() == [True, False]
+    assert m.load_bool_vector([True, False])
+    assert m.load_bool_vector(tuple([True, False]))
+
+    assert doc(m.cast_vector) == "cast_vector() -> List[int]"
+    assert doc(m.load_vector) == "load_vector(arg0: List[int]) -> bool"
+
+    # Test regression caused by 936: pointers to stl containers weren't castable
+    assert m.cast_ptr_vector() == ["lvalue", "lvalue"]
+
+
+def test_deque(doc):
+    """std::deque <-> list"""
+    lst = m.cast_deque()
+    assert lst == [1]
+    lst.append(2)
+    assert m.load_deque(lst)
+    assert m.load_deque(tuple(lst))
+
+
+def test_array(doc):
+    """std::array <-> list"""
+    lst = m.cast_array()
+    assert lst == [1, 2]
+    assert m.load_array(lst)
+    assert m.load_array(tuple(lst))
+
+    assert doc(m.cast_array) == "cast_array() -> List[int[2]]"
+    assert doc(m.load_array) == "load_array(arg0: List[int[2]]) -> bool"
+
+
+def test_valarray(doc):
+    """std::valarray <-> list"""
+    lst = m.cast_valarray()
+    assert lst == [1, 4, 9]
+    assert m.load_valarray(lst)
+    assert m.load_valarray(tuple(lst))
+
+    assert doc(m.cast_valarray) == "cast_valarray() -> List[int]"
+    assert doc(m.load_valarray) == "load_valarray(arg0: List[int]) -> bool"
+
+
+def test_map(doc):
+    """std::map <-> dict"""
+    d = m.cast_map()
+    assert d == {"key": "value"}
+    assert "key" in d
+    d["key2"] = "value2"
+    assert "key2" in d
+    assert m.load_map(d)
+
+    assert doc(m.cast_map) == "cast_map() -> Dict[str, str]"
+    assert doc(m.load_map) == "load_map(arg0: Dict[str, str]) -> bool"
+
+
+def test_set(doc):
+    """std::set <-> set"""
+    s = m.cast_set()
+    assert s == {"key1", "key2"}
+    s.add("key3")
+    assert m.load_set(s)
+    assert m.load_set(frozenset(s))
+
+    assert doc(m.cast_set) == "cast_set() -> Set[str]"
+    assert doc(m.load_set) == "load_set(arg0: Set[str]) -> bool"
+
+
+def test_recursive_casting():
+    """Tests that stl casters preserve lvalue/rvalue context for container values"""
+    assert m.cast_rv_vector() == ["rvalue", "rvalue"]
+    assert m.cast_lv_vector() == ["lvalue", "lvalue"]
+    assert m.cast_rv_array() == ["rvalue", "rvalue", "rvalue"]
+    assert m.cast_lv_array() == ["lvalue", "lvalue"]
+    assert m.cast_rv_map() == {"a": "rvalue"}
+    assert m.cast_lv_map() == {"a": "lvalue", "b": "lvalue"}
+    assert m.cast_rv_nested() == [[[{"b": "rvalue", "c": "rvalue"}], [{"a": "rvalue"}]]]
+    assert m.cast_lv_nested() == {
+        "a": [[["lvalue", "lvalue"]], [["lvalue", "lvalue"]]],
+        "b": [[["lvalue", "lvalue"], ["lvalue", "lvalue"]]],
+    }
+
+    # Issue #853 test case:
+    z = m.cast_unique_ptr_vector()
+    assert z[0].value == 7 and z[1].value == 42
+
+
+def test_move_out_container():
+    """Properties use the `reference_internal` policy by default. If the underlying function
+    returns an rvalue, the policy is automatically changed to `move` to avoid referencing
+    a temporary. In case the return value is a container of user-defined types, the policy
+    also needs to be applied to the elements, not just the container."""
+    c = m.MoveOutContainer()
+    moved_out_list = c.move_list
+    assert [x.value for x in moved_out_list] == [0, 1, 2]
+
+
+@pytest.mark.skipif(not hasattr(m, "has_optional"), reason="no <optional>")
+def test_optional():
+    assert m.double_or_zero(None) == 0
+    assert m.double_or_zero(42) == 84
+    pytest.raises(TypeError, m.double_or_zero, "foo")
+
+    assert m.half_or_none(0) is None
+    assert m.half_or_none(42) == 21
+    pytest.raises(TypeError, m.half_or_none, "foo")
+
+    assert m.test_nullopt() == 42
+    assert m.test_nullopt(None) == 42
+    assert m.test_nullopt(42) == 42
+    assert m.test_nullopt(43) == 43
+
+    assert m.test_no_assign() == 42
+    assert m.test_no_assign(None) == 42
+    assert m.test_no_assign(m.NoAssign(43)) == 43
+    pytest.raises(TypeError, m.test_no_assign, 43)
+
+    assert m.nodefer_none_optional(None)
+
+    holder = m.OptionalHolder()
+    mvalue = holder.member
+    assert mvalue.initialized
+    assert holder.member_initialized()
+
+    props = m.OptionalProperties()
+    assert int(props.access_by_ref) == 42
+    assert int(props.access_by_copy) == 42
+
+
+@pytest.mark.skipif(
+    not hasattr(m, "has_exp_optional"), reason="no <experimental/optional>"
+)
+def test_exp_optional():
+    assert m.double_or_zero_exp(None) == 0
+    assert m.double_or_zero_exp(42) == 84
+    pytest.raises(TypeError, m.double_or_zero_exp, "foo")
+
+    assert m.half_or_none_exp(0) is None
+    assert m.half_or_none_exp(42) == 21
+    pytest.raises(TypeError, m.half_or_none_exp, "foo")
+
+    assert m.test_nullopt_exp() == 42
+    assert m.test_nullopt_exp(None) == 42
+    assert m.test_nullopt_exp(42) == 42
+    assert m.test_nullopt_exp(43) == 43
+
+    assert m.test_no_assign_exp() == 42
+    assert m.test_no_assign_exp(None) == 42
+    assert m.test_no_assign_exp(m.NoAssign(43)) == 43
+    pytest.raises(TypeError, m.test_no_assign_exp, 43)
+
+    holder = m.OptionalExpHolder()
+    mvalue = holder.member
+    assert mvalue.initialized
+    assert holder.member_initialized()
+
+    props = m.OptionalExpProperties()
+    assert int(props.access_by_ref) == 42
+    assert int(props.access_by_copy) == 42
+
+
+@pytest.mark.skipif(not hasattr(m, "has_boost_optional"), reason="no <boost/optional>")
+def test_boost_optional():
+    assert m.double_or_zero_boost(None) == 0
+    assert m.double_or_zero_boost(42) == 84
+    pytest.raises(TypeError, m.double_or_zero_boost, "foo")
+
+    assert m.half_or_none_boost(0) is None
+    assert m.half_or_none_boost(42) == 21
+    pytest.raises(TypeError, m.half_or_none_boost, "foo")
+
+    assert m.test_nullopt_boost() == 42
+    assert m.test_nullopt_boost(None) == 42
+    assert m.test_nullopt_boost(42) == 42
+    assert m.test_nullopt_boost(43) == 43
+
+    assert m.test_no_assign_boost() == 42
+    assert m.test_no_assign_boost(None) == 42
+    assert m.test_no_assign_boost(m.NoAssign(43)) == 43
+    pytest.raises(TypeError, m.test_no_assign_boost, 43)
+
+    holder = m.OptionalBoostHolder()
+    mvalue = holder.member
+    assert mvalue.initialized
+    assert holder.member_initialized()
+
+    props = m.OptionalBoostProperties()
+    assert int(props.access_by_ref) == 42
+    assert int(props.access_by_copy) == 42
+
+
+def test_reference_sensitive_optional():
+    assert m.double_or_zero_refsensitive(None) == 0
+    assert m.double_or_zero_refsensitive(42) == 84
+    pytest.raises(TypeError, m.double_or_zero_refsensitive, "foo")
+
+    assert m.half_or_none_refsensitive(0) is None
+    assert m.half_or_none_refsensitive(42) == 21
+    pytest.raises(TypeError, m.half_or_none_refsensitive, "foo")
+
+    assert m.test_nullopt_refsensitive() == 42
+    assert m.test_nullopt_refsensitive(None) == 42
+    assert m.test_nullopt_refsensitive(42) == 42
+    assert m.test_nullopt_refsensitive(43) == 43
+
+    assert m.test_no_assign_refsensitive() == 42
+    assert m.test_no_assign_refsensitive(None) == 42
+    assert m.test_no_assign_refsensitive(m.NoAssign(43)) == 43
+    pytest.raises(TypeError, m.test_no_assign_refsensitive, 43)
+
+    holder = m.OptionalRefSensitiveHolder()
+    mvalue = holder.member
+    assert mvalue.initialized
+    assert holder.member_initialized()
+
+    props = m.OptionalRefSensitiveProperties()
+    assert int(props.access_by_ref) == 42
+    assert int(props.access_by_copy) == 42
+
+
+@pytest.mark.skipif(not hasattr(m, "has_filesystem"), reason="no <filesystem>")
+def test_fs_path():
+    from pathlib import Path
+
+    class PseudoStrPath:
+        def __fspath__(self):
+            return "foo/bar"
+
+    class PseudoBytesPath:
+        def __fspath__(self):
+            return b"foo/bar"
+
+    assert m.parent_path(Path("foo/bar")) == Path("foo")
+    assert m.parent_path("foo/bar") == Path("foo")
+    assert m.parent_path(b"foo/bar") == Path("foo")
+    assert m.parent_path(PseudoStrPath()) == Path("foo")
+    assert m.parent_path(PseudoBytesPath()) == Path("foo")
+
+
+@pytest.mark.skipif(not hasattr(m, "load_variant"), reason="no <variant>")
+def test_variant(doc):
+    assert m.load_variant(1) == "int"
+    assert m.load_variant("1") == "std::string"
+    assert m.load_variant(1.0) == "double"
+    assert m.load_variant(None) == "std::nullptr_t"
+
+    assert m.load_variant_2pass(1) == "int"
+    assert m.load_variant_2pass(1.0) == "double"
+
+    assert m.cast_variant() == (5, "Hello")
+
+    assert (
+        doc(m.load_variant) == "load_variant(arg0: Union[int, str, float, None]) -> str"
+    )
+
+
+@pytest.mark.skipif(
+    not hasattr(m, "load_monostate_variant"), reason="no std::monostate"
+)
+def test_variant_monostate(doc):
+    assert m.load_monostate_variant(None) == "std::monostate"
+    assert m.load_monostate_variant(1) == "int"
+    assert m.load_monostate_variant("1") == "std::string"
+
+    assert m.cast_monostate_variant() == (None, 5, "Hello")
+
+    assert (
+        doc(m.load_monostate_variant)
+        == "load_monostate_variant(arg0: Union[None, int, str]) -> str"
+    )
+
+
+def test_vec_of_reference_wrapper():
+    """#171: Can't return reference wrappers (or STL structures containing them)"""
+    assert (
+        str(m.return_vec_of_reference_wrapper(UserType(4)))
+        == "[UserType(1), UserType(2), UserType(3), UserType(4)]"
+    )
+
+
+def test_stl_pass_by_pointer(msg):
+    """Passing nullptr or None to an STL container pointer is not expected to work"""
+    with pytest.raises(TypeError) as excinfo:
+        m.stl_pass_by_pointer()  # default value is `nullptr`
+    assert (
+        msg(excinfo.value)
+        == """
+        stl_pass_by_pointer(): incompatible function arguments. The following argument types are supported:
+            1. (v: List[int] = None) -> List[int]
+
+        Invoked with:
+    """
+    )
+
+    with pytest.raises(TypeError) as excinfo:
+        m.stl_pass_by_pointer(None)
+    assert (
+        msg(excinfo.value)
+        == """
+        stl_pass_by_pointer(): incompatible function arguments. The following argument types are supported:
+            1. (v: List[int] = None) -> List[int]
+
+        Invoked with: None
+    """
+    )
+
+    assert m.stl_pass_by_pointer([1, 2, 3]) == [1, 2, 3]
+
+
+def test_missing_header_message():
+    """Trying convert `list` to a `std::vector`, or vice versa, without including
+    <pybind11/stl.h> should result in a helpful suggestion in the error message"""
+    import pybind11_cross_module_tests as cm
+
+    expected_message = (
+        "Did you forget to `#include <pybind11/stl.h>`? Or <pybind11/complex.h>,\n"
+        "<pybind11/functional.h>, <pybind11/chrono.h>, etc. Some automatic\n"
+        "conversions are optional and require extra headers to be included\n"
+        "when compiling your pybind11 module."
+    )
+
+    with pytest.raises(TypeError) as excinfo:
+        cm.missing_header_arg([1.0, 2.0, 3.0])
+    assert expected_message in str(excinfo.value)
+
+    with pytest.raises(TypeError) as excinfo:
+        cm.missing_header_return()
+    assert expected_message in str(excinfo.value)
+
+
+def test_function_with_string_and_vector_string_arg():
+    """Check if a string is NOT implicitly converted to a list, which was the
+    behavior before fix of issue #1258"""
+    assert m.func_with_string_or_vector_string_arg_overload(("A", "B")) == 2
+    assert m.func_with_string_or_vector_string_arg_overload(["A", "B"]) == 2
+    assert m.func_with_string_or_vector_string_arg_overload("A") == 3
+
+
+def test_stl_ownership():
+    cstats = ConstructorStats.get(m.Placeholder)
+    assert cstats.alive() == 0
+    r = m.test_stl_ownership()
+    assert len(r) == 1
+    del r
+    assert cstats.alive() == 0
+
+
+def test_array_cast_sequence():
+    assert m.array_cast_sequence((1, 2, 3)) == [1, 2, 3]
+
+
+def test_issue_1561():
+    """check fix for issue #1561"""
+    bar = m.Issue1561Outer()
+    bar.list = [m.Issue1561Inner("bar")]
+    bar.list
+    assert bar.list[0].data == "bar"
+
+
+def test_return_vector_bool_raw_ptr():
+    # Add `while True:` for manual leak checking.
+    v = m.return_vector_bool_raw_ptr()
+    assert isinstance(v, list)
+    assert len(v) == 4513
```

## extern/pybind11/tests/test_stl_binders.py

 * *Ordering differences only*

```diff
@@ -1,337 +1,337 @@
-import pytest
-
-from pybind11_tests import stl_binders as m
-
-
-def test_vector_int():
-    v_int = m.VectorInt([0, 0])
-    assert len(v_int) == 2
-    assert bool(v_int) is True
-
-    # test construction from a generator
-    v_int1 = m.VectorInt(x for x in range(5))
-    assert v_int1 == m.VectorInt([0, 1, 2, 3, 4])
-
-    v_int2 = m.VectorInt([0, 0])
-    assert v_int == v_int2
-    v_int2[1] = 1
-    assert v_int != v_int2
-
-    v_int2.append(2)
-    v_int2.insert(0, 1)
-    v_int2.insert(0, 2)
-    v_int2.insert(0, 3)
-    v_int2.insert(6, 3)
-    assert str(v_int2) == "VectorInt[3, 2, 1, 0, 1, 2, 3]"
-    with pytest.raises(IndexError):
-        v_int2.insert(8, 4)
-
-    v_int.append(99)
-    v_int2[2:-2] = v_int
-    assert v_int2 == m.VectorInt([3, 2, 0, 0, 99, 2, 3])
-    del v_int2[1:3]
-    assert v_int2 == m.VectorInt([3, 0, 99, 2, 3])
-    del v_int2[0]
-    assert v_int2 == m.VectorInt([0, 99, 2, 3])
-
-    v_int2.extend(m.VectorInt([4, 5]))
-    assert v_int2 == m.VectorInt([0, 99, 2, 3, 4, 5])
-
-    v_int2.extend([6, 7])
-    assert v_int2 == m.VectorInt([0, 99, 2, 3, 4, 5, 6, 7])
-
-    # test error handling, and that the vector is unchanged
-    with pytest.raises(RuntimeError):
-        v_int2.extend([8, "a"])
-
-    assert v_int2 == m.VectorInt([0, 99, 2, 3, 4, 5, 6, 7])
-
-    # test extending from a generator
-    v_int2.extend(x for x in range(5))
-    assert v_int2 == m.VectorInt([0, 99, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4])
-
-    # test negative indexing
-    assert v_int2[-1] == 4
-
-    # insert with negative index
-    v_int2.insert(-1, 88)
-    assert v_int2 == m.VectorInt([0, 99, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 88, 4])
-
-    # delete negative index
-    del v_int2[-1]
-    assert v_int2 == m.VectorInt([0, 99, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 88])
-
-    v_int2.clear()
-    assert len(v_int2) == 0
-
-
-# Older PyPy's failed here, related to the PyPy's buffer protocol.
-def test_vector_buffer():
-    b = bytearray([1, 2, 3, 4])
-    v = m.VectorUChar(b)
-    assert v[1] == 2
-    v[2] = 5
-    mv = memoryview(v)  # We expose the buffer interface
-    assert mv[2] == 5
-    mv[2] = 6
-    assert v[2] == 6
-
-    mv = memoryview(b)
-    v = m.VectorUChar(mv[::2])
-    assert v[1] == 3
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.create_undeclstruct()  # Undeclared struct contents, no buffer interface
-    assert "NumPy type info missing for " in str(excinfo.value)
-
-
-def test_vector_buffer_numpy():
-    np = pytest.importorskip("numpy")
-    a = np.array([1, 2, 3, 4], dtype=np.int32)
-    with pytest.raises(TypeError):
-        m.VectorInt(a)
-
-    a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]], dtype=np.uintc)
-    v = m.VectorInt(a[0, :])
-    assert len(v) == 4
-    assert v[2] == 3
-    ma = np.asarray(v)
-    ma[2] = 5
-    assert v[2] == 5
-
-    v = m.VectorInt(a[:, 1])
-    assert len(v) == 3
-    assert v[2] == 10
-
-    v = m.get_vectorstruct()
-    assert v[0].x == 5
-    ma = np.asarray(v)
-    ma[1]["x"] = 99
-    assert v[1].x == 99
-
-    v = m.VectorStruct(
-        np.zeros(
-            3,
-            dtype=np.dtype(
-                [("w", "bool"), ("x", "I"), ("y", "float64"), ("z", "bool")], align=True
-            ),
-        )
-    )
-    assert len(v) == 3
-
-    b = np.array([1, 2, 3, 4], dtype=np.uint8)
-    v = m.VectorUChar(b[::2])
-    assert v[1] == 3
-
-
-def test_vector_bool():
-    import pybind11_cross_module_tests as cm
-
-    vv_c = cm.VectorBool()
-    for i in range(10):
-        vv_c.append(i % 2 == 0)
-    for i in range(10):
-        assert vv_c[i] == (i % 2 == 0)
-    assert str(vv_c) == "VectorBool[1, 0, 1, 0, 1, 0, 1, 0, 1, 0]"
-
-
-def test_vector_custom():
-    v_a = m.VectorEl()
-    v_a.append(m.El(1))
-    v_a.append(m.El(2))
-    assert str(v_a) == "VectorEl[El{1}, El{2}]"
-
-    vv_a = m.VectorVectorEl()
-    vv_a.append(v_a)
-    vv_b = vv_a[0]
-    assert str(vv_b) == "VectorEl[El{1}, El{2}]"
-
-
-def test_map_string_double():
-    mm = m.MapStringDouble()
-    mm["a"] = 1
-    mm["b"] = 2.5
-
-    assert list(mm) == ["a", "b"]
-    assert str(mm) == "MapStringDouble{a: 1, b: 2.5}"
-    assert "b" in mm
-    assert "c" not in mm
-    assert 123 not in mm
-
-    # Check that keys, values, items are views, not merely iterable
-    keys = mm.keys()
-    values = mm.values()
-    items = mm.items()
-    assert list(keys) == ["a", "b"]
-    assert len(keys) == 2
-    assert "a" in keys
-    assert "c" not in keys
-    assert 123 not in keys
-    assert list(items) == [("a", 1), ("b", 2.5)]
-    assert len(items) == 2
-    assert ("b", 2.5) in items
-    assert "hello" not in items
-    assert ("b", 2.5, None) not in items
-    assert list(values) == [1, 2.5]
-    assert len(values) == 2
-    assert 1 in values
-    assert 2 not in values
-    # Check that views update when the map is updated
-    mm["c"] = -1
-    assert list(keys) == ["a", "b", "c"]
-    assert list(values) == [1, 2.5, -1]
-    assert list(items) == [("a", 1), ("b", 2.5), ("c", -1)]
-
-    um = m.UnorderedMapStringDouble()
-    um["ua"] = 1.1
-    um["ub"] = 2.6
-
-    assert sorted(list(um)) == ["ua", "ub"]
-    assert list(um.keys()) == list(um)
-    assert sorted(list(um.items())) == [("ua", 1.1), ("ub", 2.6)]
-    assert list(zip(um.keys(), um.values())) == list(um.items())
-    assert "UnorderedMapStringDouble" in str(um)
-
-
-def test_map_string_double_const():
-    mc = m.MapStringDoubleConst()
-    mc["a"] = 10
-    mc["b"] = 20.5
-    assert str(mc) == "MapStringDoubleConst{a: 10, b: 20.5}"
-
-    umc = m.UnorderedMapStringDoubleConst()
-    umc["a"] = 11
-    umc["b"] = 21.5
-
-    str(umc)
-
-
-def test_noncopyable_containers():
-    # std::vector
-    vnc = m.get_vnc(5)
-    for i in range(0, 5):
-        assert vnc[i].value == i + 1
-
-    for i, j in enumerate(vnc, start=1):
-        assert j.value == i
-
-    # std::deque
-    dnc = m.get_dnc(5)
-    for i in range(0, 5):
-        assert dnc[i].value == i + 1
-
-    i = 1
-    for j in dnc:
-        assert j.value == i
-        i += 1
-
-    # std::map
-    mnc = m.get_mnc(5)
-    for i in range(1, 6):
-        assert mnc[i].value == 10 * i
-
-    vsum = 0
-    for k, v in mnc.items():
-        assert v.value == 10 * k
-        vsum += v.value
-
-    assert vsum == 150
-
-    # std::unordered_map
-    mnc = m.get_umnc(5)
-    for i in range(1, 6):
-        assert mnc[i].value == 10 * i
-
-    vsum = 0
-    for k, v in mnc.items():
-        assert v.value == 10 * k
-        vsum += v.value
-
-    assert vsum == 150
-
-    # nested std::map<std::vector>
-    nvnc = m.get_nvnc(5)
-    for i in range(1, 6):
-        for j in range(0, 5):
-            assert nvnc[i][j].value == j + 1
-
-    # Note: maps do not have .values()
-    for _, v in nvnc.items():
-        for i, j in enumerate(v, start=1):
-            assert j.value == i
-
-    # nested std::map<std::map>
-    nmnc = m.get_nmnc(5)
-    for i in range(1, 6):
-        for j in range(10, 60, 10):
-            assert nmnc[i][j].value == 10 * j
-
-    vsum = 0
-    for _, v_o in nmnc.items():
-        for k_i, v_i in v_o.items():
-            assert v_i.value == 10 * k_i
-            vsum += v_i.value
-
-    assert vsum == 7500
-
-    # nested std::unordered_map<std::unordered_map>
-    numnc = m.get_numnc(5)
-    for i in range(1, 6):
-        for j in range(10, 60, 10):
-            assert numnc[i][j].value == 10 * j
-
-    vsum = 0
-    for _, v_o in numnc.items():
-        for k_i, v_i in v_o.items():
-            assert v_i.value == 10 * k_i
-            vsum += v_i.value
-
-    assert vsum == 7500
-
-
-def test_map_delitem():
-    mm = m.MapStringDouble()
-    mm["a"] = 1
-    mm["b"] = 2.5
-
-    assert list(mm) == ["a", "b"]
-    assert list(mm.items()) == [("a", 1), ("b", 2.5)]
-    del mm["a"]
-    assert list(mm) == ["b"]
-    assert list(mm.items()) == [("b", 2.5)]
-
-    um = m.UnorderedMapStringDouble()
-    um["ua"] = 1.1
-    um["ub"] = 2.6
-
-    assert sorted(list(um)) == ["ua", "ub"]
-    assert sorted(list(um.items())) == [("ua", 1.1), ("ub", 2.6)]
-    del um["ua"]
-    assert sorted(list(um)) == ["ub"]
-    assert sorted(list(um.items())) == [("ub", 2.6)]
-
-
-def test_map_view_types():
-    map_string_double = m.MapStringDouble()
-    unordered_map_string_double = m.UnorderedMapStringDouble()
-    map_string_double_const = m.MapStringDoubleConst()
-    unordered_map_string_double_const = m.UnorderedMapStringDoubleConst()
-
-    assert map_string_double.keys().__class__.__name__ == "KeysView[str]"
-    assert map_string_double.values().__class__.__name__ == "ValuesView[float]"
-    assert map_string_double.items().__class__.__name__ == "ItemsView[str, float]"
-
-    keys_type = type(map_string_double.keys())
-    assert type(unordered_map_string_double.keys()) is keys_type
-    assert type(map_string_double_const.keys()) is keys_type
-    assert type(unordered_map_string_double_const.keys()) is keys_type
-
-    values_type = type(map_string_double.values())
-    assert type(unordered_map_string_double.values()) is values_type
-    assert type(map_string_double_const.values()) is values_type
-    assert type(unordered_map_string_double_const.values()) is values_type
-
-    items_type = type(map_string_double.items())
-    assert type(unordered_map_string_double.items()) is items_type
-    assert type(map_string_double_const.items()) is items_type
-    assert type(unordered_map_string_double_const.items()) is items_type
+import pytest
+
+from pybind11_tests import stl_binders as m
+
+
+def test_vector_int():
+    v_int = m.VectorInt([0, 0])
+    assert len(v_int) == 2
+    assert bool(v_int) is True
+
+    # test construction from a generator
+    v_int1 = m.VectorInt(x for x in range(5))
+    assert v_int1 == m.VectorInt([0, 1, 2, 3, 4])
+
+    v_int2 = m.VectorInt([0, 0])
+    assert v_int == v_int2
+    v_int2[1] = 1
+    assert v_int != v_int2
+
+    v_int2.append(2)
+    v_int2.insert(0, 1)
+    v_int2.insert(0, 2)
+    v_int2.insert(0, 3)
+    v_int2.insert(6, 3)
+    assert str(v_int2) == "VectorInt[3, 2, 1, 0, 1, 2, 3]"
+    with pytest.raises(IndexError):
+        v_int2.insert(8, 4)
+
+    v_int.append(99)
+    v_int2[2:-2] = v_int
+    assert v_int2 == m.VectorInt([3, 2, 0, 0, 99, 2, 3])
+    del v_int2[1:3]
+    assert v_int2 == m.VectorInt([3, 0, 99, 2, 3])
+    del v_int2[0]
+    assert v_int2 == m.VectorInt([0, 99, 2, 3])
+
+    v_int2.extend(m.VectorInt([4, 5]))
+    assert v_int2 == m.VectorInt([0, 99, 2, 3, 4, 5])
+
+    v_int2.extend([6, 7])
+    assert v_int2 == m.VectorInt([0, 99, 2, 3, 4, 5, 6, 7])
+
+    # test error handling, and that the vector is unchanged
+    with pytest.raises(RuntimeError):
+        v_int2.extend([8, "a"])
+
+    assert v_int2 == m.VectorInt([0, 99, 2, 3, 4, 5, 6, 7])
+
+    # test extending from a generator
+    v_int2.extend(x for x in range(5))
+    assert v_int2 == m.VectorInt([0, 99, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4])
+
+    # test negative indexing
+    assert v_int2[-1] == 4
+
+    # insert with negative index
+    v_int2.insert(-1, 88)
+    assert v_int2 == m.VectorInt([0, 99, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 88, 4])
+
+    # delete negative index
+    del v_int2[-1]
+    assert v_int2 == m.VectorInt([0, 99, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 88])
+
+    v_int2.clear()
+    assert len(v_int2) == 0
+
+
+# Older PyPy's failed here, related to the PyPy's buffer protocol.
+def test_vector_buffer():
+    b = bytearray([1, 2, 3, 4])
+    v = m.VectorUChar(b)
+    assert v[1] == 2
+    v[2] = 5
+    mv = memoryview(v)  # We expose the buffer interface
+    assert mv[2] == 5
+    mv[2] = 6
+    assert v[2] == 6
+
+    mv = memoryview(b)
+    v = m.VectorUChar(mv[::2])
+    assert v[1] == 3
+
+    with pytest.raises(RuntimeError) as excinfo:
+        m.create_undeclstruct()  # Undeclared struct contents, no buffer interface
+    assert "NumPy type info missing for " in str(excinfo.value)
+
+
+def test_vector_buffer_numpy():
+    np = pytest.importorskip("numpy")
+    a = np.array([1, 2, 3, 4], dtype=np.int32)
+    with pytest.raises(TypeError):
+        m.VectorInt(a)
+
+    a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]], dtype=np.uintc)
+    v = m.VectorInt(a[0, :])
+    assert len(v) == 4
+    assert v[2] == 3
+    ma = np.asarray(v)
+    ma[2] = 5
+    assert v[2] == 5
+
+    v = m.VectorInt(a[:, 1])
+    assert len(v) == 3
+    assert v[2] == 10
+
+    v = m.get_vectorstruct()
+    assert v[0].x == 5
+    ma = np.asarray(v)
+    ma[1]["x"] = 99
+    assert v[1].x == 99
+
+    v = m.VectorStruct(
+        np.zeros(
+            3,
+            dtype=np.dtype(
+                [("w", "bool"), ("x", "I"), ("y", "float64"), ("z", "bool")], align=True
+            ),
+        )
+    )
+    assert len(v) == 3
+
+    b = np.array([1, 2, 3, 4], dtype=np.uint8)
+    v = m.VectorUChar(b[::2])
+    assert v[1] == 3
+
+
+def test_vector_bool():
+    import pybind11_cross_module_tests as cm
+
+    vv_c = cm.VectorBool()
+    for i in range(10):
+        vv_c.append(i % 2 == 0)
+    for i in range(10):
+        assert vv_c[i] == (i % 2 == 0)
+    assert str(vv_c) == "VectorBool[1, 0, 1, 0, 1, 0, 1, 0, 1, 0]"
+
+
+def test_vector_custom():
+    v_a = m.VectorEl()
+    v_a.append(m.El(1))
+    v_a.append(m.El(2))
+    assert str(v_a) == "VectorEl[El{1}, El{2}]"
+
+    vv_a = m.VectorVectorEl()
+    vv_a.append(v_a)
+    vv_b = vv_a[0]
+    assert str(vv_b) == "VectorEl[El{1}, El{2}]"
+
+
+def test_map_string_double():
+    mm = m.MapStringDouble()
+    mm["a"] = 1
+    mm["b"] = 2.5
+
+    assert list(mm) == ["a", "b"]
+    assert str(mm) == "MapStringDouble{a: 1, b: 2.5}"
+    assert "b" in mm
+    assert "c" not in mm
+    assert 123 not in mm
+
+    # Check that keys, values, items are views, not merely iterable
+    keys = mm.keys()
+    values = mm.values()
+    items = mm.items()
+    assert list(keys) == ["a", "b"]
+    assert len(keys) == 2
+    assert "a" in keys
+    assert "c" not in keys
+    assert 123 not in keys
+    assert list(items) == [("a", 1), ("b", 2.5)]
+    assert len(items) == 2
+    assert ("b", 2.5) in items
+    assert "hello" not in items
+    assert ("b", 2.5, None) not in items
+    assert list(values) == [1, 2.5]
+    assert len(values) == 2
+    assert 1 in values
+    assert 2 not in values
+    # Check that views update when the map is updated
+    mm["c"] = -1
+    assert list(keys) == ["a", "b", "c"]
+    assert list(values) == [1, 2.5, -1]
+    assert list(items) == [("a", 1), ("b", 2.5), ("c", -1)]
+
+    um = m.UnorderedMapStringDouble()
+    um["ua"] = 1.1
+    um["ub"] = 2.6
+
+    assert sorted(list(um)) == ["ua", "ub"]
+    assert list(um.keys()) == list(um)
+    assert sorted(list(um.items())) == [("ua", 1.1), ("ub", 2.6)]
+    assert list(zip(um.keys(), um.values())) == list(um.items())
+    assert "UnorderedMapStringDouble" in str(um)
+
+
+def test_map_string_double_const():
+    mc = m.MapStringDoubleConst()
+    mc["a"] = 10
+    mc["b"] = 20.5
+    assert str(mc) == "MapStringDoubleConst{a: 10, b: 20.5}"
+
+    umc = m.UnorderedMapStringDoubleConst()
+    umc["a"] = 11
+    umc["b"] = 21.5
+
+    str(umc)
+
+
+def test_noncopyable_containers():
+    # std::vector
+    vnc = m.get_vnc(5)
+    for i in range(0, 5):
+        assert vnc[i].value == i + 1
+
+    for i, j in enumerate(vnc, start=1):
+        assert j.value == i
+
+    # std::deque
+    dnc = m.get_dnc(5)
+    for i in range(0, 5):
+        assert dnc[i].value == i + 1
+
+    i = 1
+    for j in dnc:
+        assert j.value == i
+        i += 1
+
+    # std::map
+    mnc = m.get_mnc(5)
+    for i in range(1, 6):
+        assert mnc[i].value == 10 * i
+
+    vsum = 0
+    for k, v in mnc.items():
+        assert v.value == 10 * k
+        vsum += v.value
+
+    assert vsum == 150
+
+    # std::unordered_map
+    mnc = m.get_umnc(5)
+    for i in range(1, 6):
+        assert mnc[i].value == 10 * i
+
+    vsum = 0
+    for k, v in mnc.items():
+        assert v.value == 10 * k
+        vsum += v.value
+
+    assert vsum == 150
+
+    # nested std::map<std::vector>
+    nvnc = m.get_nvnc(5)
+    for i in range(1, 6):
+        for j in range(0, 5):
+            assert nvnc[i][j].value == j + 1
+
+    # Note: maps do not have .values()
+    for _, v in nvnc.items():
+        for i, j in enumerate(v, start=1):
+            assert j.value == i
+
+    # nested std::map<std::map>
+    nmnc = m.get_nmnc(5)
+    for i in range(1, 6):
+        for j in range(10, 60, 10):
+            assert nmnc[i][j].value == 10 * j
+
+    vsum = 0
+    for _, v_o in nmnc.items():
+        for k_i, v_i in v_o.items():
+            assert v_i.value == 10 * k_i
+            vsum += v_i.value
+
+    assert vsum == 7500
+
+    # nested std::unordered_map<std::unordered_map>
+    numnc = m.get_numnc(5)
+    for i in range(1, 6):
+        for j in range(10, 60, 10):
+            assert numnc[i][j].value == 10 * j
+
+    vsum = 0
+    for _, v_o in numnc.items():
+        for k_i, v_i in v_o.items():
+            assert v_i.value == 10 * k_i
+            vsum += v_i.value
+
+    assert vsum == 7500
+
+
+def test_map_delitem():
+    mm = m.MapStringDouble()
+    mm["a"] = 1
+    mm["b"] = 2.5
+
+    assert list(mm) == ["a", "b"]
+    assert list(mm.items()) == [("a", 1), ("b", 2.5)]
+    del mm["a"]
+    assert list(mm) == ["b"]
+    assert list(mm.items()) == [("b", 2.5)]
+
+    um = m.UnorderedMapStringDouble()
+    um["ua"] = 1.1
+    um["ub"] = 2.6
+
+    assert sorted(list(um)) == ["ua", "ub"]
+    assert sorted(list(um.items())) == [("ua", 1.1), ("ub", 2.6)]
+    del um["ua"]
+    assert sorted(list(um)) == ["ub"]
+    assert sorted(list(um.items())) == [("ub", 2.6)]
+
+
+def test_map_view_types():
+    map_string_double = m.MapStringDouble()
+    unordered_map_string_double = m.UnorderedMapStringDouble()
+    map_string_double_const = m.MapStringDoubleConst()
+    unordered_map_string_double_const = m.UnorderedMapStringDoubleConst()
+
+    assert map_string_double.keys().__class__.__name__ == "KeysView[str]"
+    assert map_string_double.values().__class__.__name__ == "ValuesView[float]"
+    assert map_string_double.items().__class__.__name__ == "ItemsView[str, float]"
+
+    keys_type = type(map_string_double.keys())
+    assert type(unordered_map_string_double.keys()) is keys_type
+    assert type(map_string_double_const.keys()) is keys_type
+    assert type(unordered_map_string_double_const.keys()) is keys_type
+
+    values_type = type(map_string_double.values())
+    assert type(unordered_map_string_double.values()) is values_type
+    assert type(map_string_double_const.values()) is values_type
+    assert type(unordered_map_string_double_const.values()) is values_type
+
+    items_type = type(map_string_double.items())
+    assert type(unordered_map_string_double.items()) is items_type
+    assert type(map_string_double_const.items()) is items_type
+    assert type(unordered_map_string_double_const.items()) is items_type
```

## extern/pybind11/tests/test_tagbased_polymorphic.py

 * *Ordering differences only*

```diff
@@ -1,28 +1,28 @@
-from pybind11_tests import tagbased_polymorphic as m
-
-
-def test_downcast():
-    zoo = m.create_zoo()
-    assert [type(animal) for animal in zoo] == [
-        m.Labrador,
-        m.Dog,
-        m.Chihuahua,
-        m.Cat,
-        m.Panther,
-    ]
-    assert [animal.name for animal in zoo] == [
-        "Fido",
-        "Ginger",
-        "Hertzl",
-        "Tiger",
-        "Leo",
-    ]
-    zoo[1].sound = "woooooo"
-    assert [dog.bark() for dog in zoo[:3]] == [
-        "Labrador Fido goes WOOF!",
-        "Dog Ginger goes woooooo",
-        "Chihuahua Hertzl goes iyiyiyiyiyi and runs in circles",
-    ]
-    assert [cat.purr() for cat in zoo[3:]] == ["mrowr", "mrrrRRRRRR"]
-    zoo[0].excitement -= 1000
-    assert zoo[0].excitement == 14000
+from pybind11_tests import tagbased_polymorphic as m
+
+
+def test_downcast():
+    zoo = m.create_zoo()
+    assert [type(animal) for animal in zoo] == [
+        m.Labrador,
+        m.Dog,
+        m.Chihuahua,
+        m.Cat,
+        m.Panther,
+    ]
+    assert [animal.name for animal in zoo] == [
+        "Fido",
+        "Ginger",
+        "Hertzl",
+        "Tiger",
+        "Leo",
+    ]
+    zoo[1].sound = "woooooo"
+    assert [dog.bark() for dog in zoo[:3]] == [
+        "Labrador Fido goes WOOF!",
+        "Dog Ginger goes woooooo",
+        "Chihuahua Hertzl goes iyiyiyiyiyi and runs in circles",
+    ]
+    assert [cat.purr() for cat in zoo[3:]] == ["mrowr", "mrrrRRRRRR"]
+    zoo[0].excitement -= 1000
+    assert zoo[0].excitement == 14000
```

## extern/pybind11/tests/test_thread.py

 * *Ordering differences only*

```diff
@@ -1,42 +1,42 @@
-import threading
-
-from pybind11_tests import thread as m
-
-
-class Thread(threading.Thread):
-    def __init__(self, fn):
-        super().__init__()
-        self.fn = fn
-        self.e = None
-
-    def run(self):
-        try:
-            for i in range(10):
-                self.fn(i, i)
-        except Exception as e:
-            self.e = e
-
-    def join(self):
-        super().join()
-        if self.e:
-            raise self.e
-
-
-def test_implicit_conversion():
-    a = Thread(m.test)
-    b = Thread(m.test)
-    c = Thread(m.test)
-    for x in [a, b, c]:
-        x.start()
-    for x in [c, b, a]:
-        x.join()
-
-
-def test_implicit_conversion_no_gil():
-    a = Thread(m.test_no_gil)
-    b = Thread(m.test_no_gil)
-    c = Thread(m.test_no_gil)
-    for x in [a, b, c]:
-        x.start()
-    for x in [c, b, a]:
-        x.join()
+import threading
+
+from pybind11_tests import thread as m
+
+
+class Thread(threading.Thread):
+    def __init__(self, fn):
+        super().__init__()
+        self.fn = fn
+        self.e = None
+
+    def run(self):
+        try:
+            for i in range(10):
+                self.fn(i, i)
+        except Exception as e:
+            self.e = e
+
+    def join(self):
+        super().join()
+        if self.e:
+            raise self.e
+
+
+def test_implicit_conversion():
+    a = Thread(m.test)
+    b = Thread(m.test)
+    c = Thread(m.test)
+    for x in [a, b, c]:
+        x.start()
+    for x in [c, b, a]:
+        x.join()
+
+
+def test_implicit_conversion_no_gil():
+    a = Thread(m.test_no_gil)
+    b = Thread(m.test_no_gil)
+    c = Thread(m.test_no_gil)
+    for x in [a, b, c]:
+        x.start()
+    for x in [c, b, a]:
+        x.join()
```

## extern/pybind11/tests/test_union.py

 * *Ordering differences only*

```diff
@@ -1,8 +1,8 @@
-from pybind11_tests import union_ as m
-
-
-def test_union():
-    instance = m.TestUnion()
-
-    instance.as_uint = 10
-    assert instance.as_int == 10
+from pybind11_tests import union_ as m
+
+
+def test_union():
+    instance = m.TestUnion()
+
+    instance.as_uint = 10
+    assert instance.as_int == 10
```

## extern/pybind11/tests/test_virtual_functions.py

 * *Ordering differences only*

```diff
@@ -1,459 +1,459 @@
-import pytest
-
-import env  # noqa: F401
-
-m = pytest.importorskip("pybind11_tests.virtual_functions")
-from pybind11_tests import ConstructorStats  # noqa: E402
-
-
-def test_override(capture, msg):
-    class ExtendedExampleVirt(m.ExampleVirt):
-        def __init__(self, state):
-            super().__init__(state + 1)
-            self.data = "Hello world"
-
-        def run(self, value):
-            print(f"ExtendedExampleVirt::run({value}), calling parent..")
-            return super().run(value + 1)
-
-        def run_bool(self):
-            print("ExtendedExampleVirt::run_bool()")
-            return False
-
-        def get_string1(self):
-            return "override1"
-
-        def pure_virtual(self):
-            print(f"ExtendedExampleVirt::pure_virtual(): {self.data}")
-
-    class ExtendedExampleVirt2(ExtendedExampleVirt):
-        def __init__(self, state):
-            super().__init__(state + 1)
-
-        def get_string2(self):
-            return "override2"
-
-    ex12 = m.ExampleVirt(10)
-    with capture:
-        assert m.runExampleVirt(ex12, 20) == 30
-    assert (
-        capture
-        == """
-        Original implementation of ExampleVirt::run(state=10, value=20, str1=default1, str2=default2)
-    """
-    )
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.runExampleVirtVirtual(ex12)
-    assert (
-        msg(excinfo.value)
-        == 'Tried to call pure virtual function "ExampleVirt::pure_virtual"'
-    )
-
-    ex12p = ExtendedExampleVirt(10)
-    with capture:
-        assert m.runExampleVirt(ex12p, 20) == 32
-    assert (
-        capture
-        == """
-        ExtendedExampleVirt::run(20), calling parent..
-        Original implementation of ExampleVirt::run(state=11, value=21, str1=override1, str2=default2)
-    """
-    )
-    with capture:
-        assert m.runExampleVirtBool(ex12p) is False
-    assert capture == "ExtendedExampleVirt::run_bool()"
-    with capture:
-        m.runExampleVirtVirtual(ex12p)
-    assert capture == "ExtendedExampleVirt::pure_virtual(): Hello world"
-
-    ex12p2 = ExtendedExampleVirt2(15)
-    with capture:
-        assert m.runExampleVirt(ex12p2, 50) == 68
-    assert (
-        capture
-        == """
-        ExtendedExampleVirt::run(50), calling parent..
-        Original implementation of ExampleVirt::run(state=17, value=51, str1=override1, str2=override2)
-    """
-    )
-
-    cstats = ConstructorStats.get(m.ExampleVirt)
-    assert cstats.alive() == 3
-    del ex12, ex12p, ex12p2
-    assert cstats.alive() == 0
-    assert cstats.values() == ["10", "11", "17"]
-    assert cstats.copy_constructions == 0
-    assert cstats.move_constructions >= 0
-
-
-def test_alias_delay_initialization1(capture):
-    """`A` only initializes its trampoline class when we inherit from it
-
-    If we just create and use an A instance directly, the trampoline initialization is
-    bypassed and we only initialize an A() instead (for performance reasons).
-    """
-
-    class B(m.A):
-        def __init__(self):
-            super().__init__()
-
-        def f(self):
-            print("In python f()")
-
-    # C++ version
-    with capture:
-        a = m.A()
-        m.call_f(a)
-        del a
-        pytest.gc_collect()
-    assert capture == "A.f()"
-
-    # Python version
-    with capture:
-        b = B()
-        m.call_f(b)
-        del b
-        pytest.gc_collect()
-    assert (
-        capture
-        == """
-        PyA.PyA()
-        PyA.f()
-        In python f()
-        PyA.~PyA()
-    """
-    )
-
-
-def test_alias_delay_initialization2(capture):
-    """`A2`, unlike the above, is configured to always initialize the alias
-
-    While the extra initialization and extra class layer has small virtual dispatch
-    performance penalty, it also allows us to do more things with the trampoline
-    class such as defining local variables and performing construction/destruction.
-    """
-
-    class B2(m.A2):
-        def __init__(self):
-            super().__init__()
-
-        def f(self):
-            print("In python B2.f()")
-
-    # No python subclass version
-    with capture:
-        a2 = m.A2()
-        m.call_f(a2)
-        del a2
-        pytest.gc_collect()
-        a3 = m.A2(1)
-        m.call_f(a3)
-        del a3
-        pytest.gc_collect()
-    assert (
-        capture
-        == """
-        PyA2.PyA2()
-        PyA2.f()
-        A2.f()
-        PyA2.~PyA2()
-        PyA2.PyA2()
-        PyA2.f()
-        A2.f()
-        PyA2.~PyA2()
-    """
-    )
-
-    # Python subclass version
-    with capture:
-        b2 = B2()
-        m.call_f(b2)
-        del b2
-        pytest.gc_collect()
-    assert (
-        capture
-        == """
-        PyA2.PyA2()
-        PyA2.f()
-        In python B2.f()
-        PyA2.~PyA2()
-    """
-    )
-
-
-# PyPy: Reference count > 1 causes call with noncopyable instance
-# to fail in ncv1.print_nc()
-@pytest.mark.xfail("env.PYPY")
-@pytest.mark.skipif(
-    not hasattr(m, "NCVirt"), reason="NCVirt does not work on Intel/PGI/NVCC compilers"
-)
-def test_move_support():
-    class NCVirtExt(m.NCVirt):
-        def get_noncopyable(self, a, b):
-            # Constructs and returns a new instance:
-            nc = m.NonCopyable(a * a, b * b)
-            return nc
-
-        def get_movable(self, a, b):
-            # Return a referenced copy
-            self.movable = m.Movable(a, b)
-            return self.movable
-
-    class NCVirtExt2(m.NCVirt):
-        def get_noncopyable(self, a, b):
-            # Keep a reference: this is going to throw an exception
-            self.nc = m.NonCopyable(a, b)
-            return self.nc
-
-        def get_movable(self, a, b):
-            # Return a new instance without storing it
-            return m.Movable(a, b)
-
-    ncv1 = NCVirtExt()
-    assert ncv1.print_nc(2, 3) == "36"
-    assert ncv1.print_movable(4, 5) == "9"
-    ncv2 = NCVirtExt2()
-    assert ncv2.print_movable(7, 7) == "14"
-    # Don't check the exception message here because it differs under debug/non-debug mode
-    with pytest.raises(RuntimeError):
-        ncv2.print_nc(9, 9)
-
-    nc_stats = ConstructorStats.get(m.NonCopyable)
-    mv_stats = ConstructorStats.get(m.Movable)
-    assert nc_stats.alive() == 1
-    assert mv_stats.alive() == 1
-    del ncv1, ncv2
-    assert nc_stats.alive() == 0
-    assert mv_stats.alive() == 0
-    assert nc_stats.values() == ["4", "9", "9", "9"]
-    assert mv_stats.values() == ["4", "5", "7", "7"]
-    assert nc_stats.copy_constructions == 0
-    assert mv_stats.copy_constructions == 1
-    assert nc_stats.move_constructions >= 0
-    assert mv_stats.move_constructions >= 0
-
-
-def test_dispatch_issue(msg):
-    """#159: virtual function dispatch has problems with similar-named functions"""
-
-    class PyClass1(m.DispatchIssue):
-        def dispatch(self):
-            return "Yay.."
-
-    class PyClass2(m.DispatchIssue):
-        def dispatch(self):
-            with pytest.raises(RuntimeError) as excinfo:
-                super().dispatch()
-            assert (
-                msg(excinfo.value)
-                == 'Tried to call pure virtual function "Base::dispatch"'
-            )
-
-            return m.dispatch_issue_go(PyClass1())
-
-    b = PyClass2()
-    assert m.dispatch_issue_go(b) == "Yay.."
-
-
-def test_recursive_dispatch_issue(msg):
-    """#3357: Recursive dispatch fails to find python function override"""
-
-    class Data(m.Data):
-        def __init__(self, value):
-            super().__init__()
-            self.value = value
-
-    class Adder(m.Adder):
-        def __call__(self, first, second, visitor):
-            # lambda is a workaround, which adds extra frame to the
-            # current CPython thread. Removing lambda reveals the bug
-            # [https://github.com/pybind/pybind11/issues/3357]
-            (lambda: visitor(Data(first.value + second.value)))()
-
-    class StoreResultVisitor:
-        def __init__(self):
-            self.result = None
-
-        def __call__(self, data):
-            self.result = data.value
-
-    store = StoreResultVisitor()
-
-    m.add2(Data(1), Data(2), Adder(), store)
-    assert store.result == 3
-
-    # without lambda in Adder class, this function fails with
-    # RuntimeError: Tried to call pure virtual function "AdderBase::__call__"
-    m.add3(Data(1), Data(2), Data(3), Adder(), store)
-    assert store.result == 6
-
-
-def test_override_ref():
-    """#392/397: overriding reference-returning functions"""
-    o = m.OverrideTest("asdf")
-
-    # Not allowed (see associated .cpp comment)
-    # i = o.str_ref()
-    # assert o.str_ref() == "asdf"
-    assert o.str_value() == "asdf"
-
-    assert o.A_value().value == "hi"
-    a = o.A_ref()
-    assert a.value == "hi"
-    a.value = "bye"
-    assert a.value == "bye"
-
-
-def test_inherited_virtuals():
-    class AR(m.A_Repeat):
-        def unlucky_number(self):
-            return 99
-
-    class AT(m.A_Tpl):
-        def unlucky_number(self):
-            return 999
-
-    obj = AR()
-    assert obj.say_something(3) == "hihihi"
-    assert obj.unlucky_number() == 99
-    assert obj.say_everything() == "hi 99"
-
-    obj = AT()
-    assert obj.say_something(3) == "hihihi"
-    assert obj.unlucky_number() == 999
-    assert obj.say_everything() == "hi 999"
-
-    for obj in [m.B_Repeat(), m.B_Tpl()]:
-        assert obj.say_something(3) == "B says hi 3 times"
-        assert obj.unlucky_number() == 13
-        assert obj.lucky_number() == 7.0
-        assert obj.say_everything() == "B says hi 1 times 13"
-
-    for obj in [m.C_Repeat(), m.C_Tpl()]:
-        assert obj.say_something(3) == "B says hi 3 times"
-        assert obj.unlucky_number() == 4444
-        assert obj.lucky_number() == 888.0
-        assert obj.say_everything() == "B says hi 1 times 4444"
-
-    class CR(m.C_Repeat):
-        def lucky_number(self):
-            return m.C_Repeat.lucky_number(self) + 1.25
-
-    obj = CR()
-    assert obj.say_something(3) == "B says hi 3 times"
-    assert obj.unlucky_number() == 4444
-    assert obj.lucky_number() == 889.25
-    assert obj.say_everything() == "B says hi 1 times 4444"
-
-    class CT(m.C_Tpl):
-        pass
-
-    obj = CT()
-    assert obj.say_something(3) == "B says hi 3 times"
-    assert obj.unlucky_number() == 4444
-    assert obj.lucky_number() == 888.0
-    assert obj.say_everything() == "B says hi 1 times 4444"
-
-    class CCR(CR):
-        def lucky_number(self):
-            return CR.lucky_number(self) * 10
-
-    obj = CCR()
-    assert obj.say_something(3) == "B says hi 3 times"
-    assert obj.unlucky_number() == 4444
-    assert obj.lucky_number() == 8892.5
-    assert obj.say_everything() == "B says hi 1 times 4444"
-
-    class CCT(CT):
-        def lucky_number(self):
-            return CT.lucky_number(self) * 1000
-
-    obj = CCT()
-    assert obj.say_something(3) == "B says hi 3 times"
-    assert obj.unlucky_number() == 4444
-    assert obj.lucky_number() == 888000.0
-    assert obj.say_everything() == "B says hi 1 times 4444"
-
-    class DR(m.D_Repeat):
-        def unlucky_number(self):
-            return 123
-
-        def lucky_number(self):
-            return 42.0
-
-    for obj in [m.D_Repeat(), m.D_Tpl()]:
-        assert obj.say_something(3) == "B says hi 3 times"
-        assert obj.unlucky_number() == 4444
-        assert obj.lucky_number() == 888.0
-        assert obj.say_everything() == "B says hi 1 times 4444"
-
-    obj = DR()
-    assert obj.say_something(3) == "B says hi 3 times"
-    assert obj.unlucky_number() == 123
-    assert obj.lucky_number() == 42.0
-    assert obj.say_everything() == "B says hi 1 times 123"
-
-    class DT(m.D_Tpl):
-        def say_something(self, times):
-            return "DT says:" + (" quack" * times)
-
-        def unlucky_number(self):
-            return 1234
-
-        def lucky_number(self):
-            return -4.25
-
-    obj = DT()
-    assert obj.say_something(3) == "DT says: quack quack quack"
-    assert obj.unlucky_number() == 1234
-    assert obj.lucky_number() == -4.25
-    assert obj.say_everything() == "DT says: quack 1234"
-
-    class DT2(DT):
-        def say_something(self, times):
-            return "DT2: " + ("QUACK" * times)
-
-        def unlucky_number(self):
-            return -3
-
-    class BT(m.B_Tpl):
-        def say_something(self, times):
-            return "BT" * times
-
-        def unlucky_number(self):
-            return -7
-
-        def lucky_number(self):
-            return -1.375
-
-    obj = BT()
-    assert obj.say_something(3) == "BTBTBT"
-    assert obj.unlucky_number() == -7
-    assert obj.lucky_number() == -1.375
-    assert obj.say_everything() == "BT -7"
-
-
-def test_issue_1454():
-    # Fix issue #1454 (crash when acquiring/releasing GIL on another thread in Python 2.7)
-    m.test_gil()
-    m.test_gil_from_thread()
-
-
-def test_python_override():
-    def func():
-        class Test(m.test_override_cache_helper):
-            def func(self):
-                return 42
-
-        return Test()
-
-    def func2():
-        class Test(m.test_override_cache_helper):
-            pass
-
-        return Test()
-
-    for _ in range(1500):
-        assert m.test_override_cache(func()) == 42
-        assert m.test_override_cache(func2()) == 0
+import pytest
+
+import env  # noqa: F401
+
+m = pytest.importorskip("pybind11_tests.virtual_functions")
+from pybind11_tests import ConstructorStats  # noqa: E402
+
+
+def test_override(capture, msg):
+    class ExtendedExampleVirt(m.ExampleVirt):
+        def __init__(self, state):
+            super().__init__(state + 1)
+            self.data = "Hello world"
+
+        def run(self, value):
+            print(f"ExtendedExampleVirt::run({value}), calling parent..")
+            return super().run(value + 1)
+
+        def run_bool(self):
+            print("ExtendedExampleVirt::run_bool()")
+            return False
+
+        def get_string1(self):
+            return "override1"
+
+        def pure_virtual(self):
+            print(f"ExtendedExampleVirt::pure_virtual(): {self.data}")
+
+    class ExtendedExampleVirt2(ExtendedExampleVirt):
+        def __init__(self, state):
+            super().__init__(state + 1)
+
+        def get_string2(self):
+            return "override2"
+
+    ex12 = m.ExampleVirt(10)
+    with capture:
+        assert m.runExampleVirt(ex12, 20) == 30
+    assert (
+        capture
+        == """
+        Original implementation of ExampleVirt::run(state=10, value=20, str1=default1, str2=default2)
+    """
+    )
+
+    with pytest.raises(RuntimeError) as excinfo:
+        m.runExampleVirtVirtual(ex12)
+    assert (
+        msg(excinfo.value)
+        == 'Tried to call pure virtual function "ExampleVirt::pure_virtual"'
+    )
+
+    ex12p = ExtendedExampleVirt(10)
+    with capture:
+        assert m.runExampleVirt(ex12p, 20) == 32
+    assert (
+        capture
+        == """
+        ExtendedExampleVirt::run(20), calling parent..
+        Original implementation of ExampleVirt::run(state=11, value=21, str1=override1, str2=default2)
+    """
+    )
+    with capture:
+        assert m.runExampleVirtBool(ex12p) is False
+    assert capture == "ExtendedExampleVirt::run_bool()"
+    with capture:
+        m.runExampleVirtVirtual(ex12p)
+    assert capture == "ExtendedExampleVirt::pure_virtual(): Hello world"
+
+    ex12p2 = ExtendedExampleVirt2(15)
+    with capture:
+        assert m.runExampleVirt(ex12p2, 50) == 68
+    assert (
+        capture
+        == """
+        ExtendedExampleVirt::run(50), calling parent..
+        Original implementation of ExampleVirt::run(state=17, value=51, str1=override1, str2=override2)
+    """
+    )
+
+    cstats = ConstructorStats.get(m.ExampleVirt)
+    assert cstats.alive() == 3
+    del ex12, ex12p, ex12p2
+    assert cstats.alive() == 0
+    assert cstats.values() == ["10", "11", "17"]
+    assert cstats.copy_constructions == 0
+    assert cstats.move_constructions >= 0
+
+
+def test_alias_delay_initialization1(capture):
+    """`A` only initializes its trampoline class when we inherit from it
+
+    If we just create and use an A instance directly, the trampoline initialization is
+    bypassed and we only initialize an A() instead (for performance reasons).
+    """
+
+    class B(m.A):
+        def __init__(self):
+            super().__init__()
+
+        def f(self):
+            print("In python f()")
+
+    # C++ version
+    with capture:
+        a = m.A()
+        m.call_f(a)
+        del a
+        pytest.gc_collect()
+    assert capture == "A.f()"
+
+    # Python version
+    with capture:
+        b = B()
+        m.call_f(b)
+        del b
+        pytest.gc_collect()
+    assert (
+        capture
+        == """
+        PyA.PyA()
+        PyA.f()
+        In python f()
+        PyA.~PyA()
+    """
+    )
+
+
+def test_alias_delay_initialization2(capture):
+    """`A2`, unlike the above, is configured to always initialize the alias
+
+    While the extra initialization and extra class layer has small virtual dispatch
+    performance penalty, it also allows us to do more things with the trampoline
+    class such as defining local variables and performing construction/destruction.
+    """
+
+    class B2(m.A2):
+        def __init__(self):
+            super().__init__()
+
+        def f(self):
+            print("In python B2.f()")
+
+    # No python subclass version
+    with capture:
+        a2 = m.A2()
+        m.call_f(a2)
+        del a2
+        pytest.gc_collect()
+        a3 = m.A2(1)
+        m.call_f(a3)
+        del a3
+        pytest.gc_collect()
+    assert (
+        capture
+        == """
+        PyA2.PyA2()
+        PyA2.f()
+        A2.f()
+        PyA2.~PyA2()
+        PyA2.PyA2()
+        PyA2.f()
+        A2.f()
+        PyA2.~PyA2()
+    """
+    )
+
+    # Python subclass version
+    with capture:
+        b2 = B2()
+        m.call_f(b2)
+        del b2
+        pytest.gc_collect()
+    assert (
+        capture
+        == """
+        PyA2.PyA2()
+        PyA2.f()
+        In python B2.f()
+        PyA2.~PyA2()
+    """
+    )
+
+
+# PyPy: Reference count > 1 causes call with noncopyable instance
+# to fail in ncv1.print_nc()
+@pytest.mark.xfail("env.PYPY")
+@pytest.mark.skipif(
+    not hasattr(m, "NCVirt"), reason="NCVirt does not work on Intel/PGI/NVCC compilers"
+)
+def test_move_support():
+    class NCVirtExt(m.NCVirt):
+        def get_noncopyable(self, a, b):
+            # Constructs and returns a new instance:
+            nc = m.NonCopyable(a * a, b * b)
+            return nc
+
+        def get_movable(self, a, b):
+            # Return a referenced copy
+            self.movable = m.Movable(a, b)
+            return self.movable
+
+    class NCVirtExt2(m.NCVirt):
+        def get_noncopyable(self, a, b):
+            # Keep a reference: this is going to throw an exception
+            self.nc = m.NonCopyable(a, b)
+            return self.nc
+
+        def get_movable(self, a, b):
+            # Return a new instance without storing it
+            return m.Movable(a, b)
+
+    ncv1 = NCVirtExt()
+    assert ncv1.print_nc(2, 3) == "36"
+    assert ncv1.print_movable(4, 5) == "9"
+    ncv2 = NCVirtExt2()
+    assert ncv2.print_movable(7, 7) == "14"
+    # Don't check the exception message here because it differs under debug/non-debug mode
+    with pytest.raises(RuntimeError):
+        ncv2.print_nc(9, 9)
+
+    nc_stats = ConstructorStats.get(m.NonCopyable)
+    mv_stats = ConstructorStats.get(m.Movable)
+    assert nc_stats.alive() == 1
+    assert mv_stats.alive() == 1
+    del ncv1, ncv2
+    assert nc_stats.alive() == 0
+    assert mv_stats.alive() == 0
+    assert nc_stats.values() == ["4", "9", "9", "9"]
+    assert mv_stats.values() == ["4", "5", "7", "7"]
+    assert nc_stats.copy_constructions == 0
+    assert mv_stats.copy_constructions == 1
+    assert nc_stats.move_constructions >= 0
+    assert mv_stats.move_constructions >= 0
+
+
+def test_dispatch_issue(msg):
+    """#159: virtual function dispatch has problems with similar-named functions"""
+
+    class PyClass1(m.DispatchIssue):
+        def dispatch(self):
+            return "Yay.."
+
+    class PyClass2(m.DispatchIssue):
+        def dispatch(self):
+            with pytest.raises(RuntimeError) as excinfo:
+                super().dispatch()
+            assert (
+                msg(excinfo.value)
+                == 'Tried to call pure virtual function "Base::dispatch"'
+            )
+
+            return m.dispatch_issue_go(PyClass1())
+
+    b = PyClass2()
+    assert m.dispatch_issue_go(b) == "Yay.."
+
+
+def test_recursive_dispatch_issue(msg):
+    """#3357: Recursive dispatch fails to find python function override"""
+
+    class Data(m.Data):
+        def __init__(self, value):
+            super().__init__()
+            self.value = value
+
+    class Adder(m.Adder):
+        def __call__(self, first, second, visitor):
+            # lambda is a workaround, which adds extra frame to the
+            # current CPython thread. Removing lambda reveals the bug
+            # [https://github.com/pybind/pybind11/issues/3357]
+            (lambda: visitor(Data(first.value + second.value)))()
+
+    class StoreResultVisitor:
+        def __init__(self):
+            self.result = None
+
+        def __call__(self, data):
+            self.result = data.value
+
+    store = StoreResultVisitor()
+
+    m.add2(Data(1), Data(2), Adder(), store)
+    assert store.result == 3
+
+    # without lambda in Adder class, this function fails with
+    # RuntimeError: Tried to call pure virtual function "AdderBase::__call__"
+    m.add3(Data(1), Data(2), Data(3), Adder(), store)
+    assert store.result == 6
+
+
+def test_override_ref():
+    """#392/397: overriding reference-returning functions"""
+    o = m.OverrideTest("asdf")
+
+    # Not allowed (see associated .cpp comment)
+    # i = o.str_ref()
+    # assert o.str_ref() == "asdf"
+    assert o.str_value() == "asdf"
+
+    assert o.A_value().value == "hi"
+    a = o.A_ref()
+    assert a.value == "hi"
+    a.value = "bye"
+    assert a.value == "bye"
+
+
+def test_inherited_virtuals():
+    class AR(m.A_Repeat):
+        def unlucky_number(self):
+            return 99
+
+    class AT(m.A_Tpl):
+        def unlucky_number(self):
+            return 999
+
+    obj = AR()
+    assert obj.say_something(3) == "hihihi"
+    assert obj.unlucky_number() == 99
+    assert obj.say_everything() == "hi 99"
+
+    obj = AT()
+    assert obj.say_something(3) == "hihihi"
+    assert obj.unlucky_number() == 999
+    assert obj.say_everything() == "hi 999"
+
+    for obj in [m.B_Repeat(), m.B_Tpl()]:
+        assert obj.say_something(3) == "B says hi 3 times"
+        assert obj.unlucky_number() == 13
+        assert obj.lucky_number() == 7.0
+        assert obj.say_everything() == "B says hi 1 times 13"
+
+    for obj in [m.C_Repeat(), m.C_Tpl()]:
+        assert obj.say_something(3) == "B says hi 3 times"
+        assert obj.unlucky_number() == 4444
+        assert obj.lucky_number() == 888.0
+        assert obj.say_everything() == "B says hi 1 times 4444"
+
+    class CR(m.C_Repeat):
+        def lucky_number(self):
+            return m.C_Repeat.lucky_number(self) + 1.25
+
+    obj = CR()
+    assert obj.say_something(3) == "B says hi 3 times"
+    assert obj.unlucky_number() == 4444
+    assert obj.lucky_number() == 889.25
+    assert obj.say_everything() == "B says hi 1 times 4444"
+
+    class CT(m.C_Tpl):
+        pass
+
+    obj = CT()
+    assert obj.say_something(3) == "B says hi 3 times"
+    assert obj.unlucky_number() == 4444
+    assert obj.lucky_number() == 888.0
+    assert obj.say_everything() == "B says hi 1 times 4444"
+
+    class CCR(CR):
+        def lucky_number(self):
+            return CR.lucky_number(self) * 10
+
+    obj = CCR()
+    assert obj.say_something(3) == "B says hi 3 times"
+    assert obj.unlucky_number() == 4444
+    assert obj.lucky_number() == 8892.5
+    assert obj.say_everything() == "B says hi 1 times 4444"
+
+    class CCT(CT):
+        def lucky_number(self):
+            return CT.lucky_number(self) * 1000
+
+    obj = CCT()
+    assert obj.say_something(3) == "B says hi 3 times"
+    assert obj.unlucky_number() == 4444
+    assert obj.lucky_number() == 888000.0
+    assert obj.say_everything() == "B says hi 1 times 4444"
+
+    class DR(m.D_Repeat):
+        def unlucky_number(self):
+            return 123
+
+        def lucky_number(self):
+            return 42.0
+
+    for obj in [m.D_Repeat(), m.D_Tpl()]:
+        assert obj.say_something(3) == "B says hi 3 times"
+        assert obj.unlucky_number() == 4444
+        assert obj.lucky_number() == 888.0
+        assert obj.say_everything() == "B says hi 1 times 4444"
+
+    obj = DR()
+    assert obj.say_something(3) == "B says hi 3 times"
+    assert obj.unlucky_number() == 123
+    assert obj.lucky_number() == 42.0
+    assert obj.say_everything() == "B says hi 1 times 123"
+
+    class DT(m.D_Tpl):
+        def say_something(self, times):
+            return "DT says:" + (" quack" * times)
+
+        def unlucky_number(self):
+            return 1234
+
+        def lucky_number(self):
+            return -4.25
+
+    obj = DT()
+    assert obj.say_something(3) == "DT says: quack quack quack"
+    assert obj.unlucky_number() == 1234
+    assert obj.lucky_number() == -4.25
+    assert obj.say_everything() == "DT says: quack 1234"
+
+    class DT2(DT):
+        def say_something(self, times):
+            return "DT2: " + ("QUACK" * times)
+
+        def unlucky_number(self):
+            return -3
+
+    class BT(m.B_Tpl):
+        def say_something(self, times):
+            return "BT" * times
+
+        def unlucky_number(self):
+            return -7
+
+        def lucky_number(self):
+            return -1.375
+
+    obj = BT()
+    assert obj.say_something(3) == "BTBTBT"
+    assert obj.unlucky_number() == -7
+    assert obj.lucky_number() == -1.375
+    assert obj.say_everything() == "BT -7"
+
+
+def test_issue_1454():
+    # Fix issue #1454 (crash when acquiring/releasing GIL on another thread in Python 2.7)
+    m.test_gil()
+    m.test_gil_from_thread()
+
+
+def test_python_override():
+    def func():
+        class Test(m.test_override_cache_helper):
+            def func(self):
+                return 42
+
+        return Test()
+
+    def func2():
+        class Test(m.test_override_cache_helper):
+            pass
+
+        return Test()
+
+    for _ in range(1500):
+        assert m.test_override_cache(func()) == 42
+        assert m.test_override_cache(func2()) == 0
```

## extern/pybind11/tests/extra_python_package/test_files.py

 * *Ordering differences only*

```diff
@@ -1,288 +1,288 @@
-import contextlib
-import os
-import string
-import subprocess
-import sys
-import tarfile
-import zipfile
-
-# These tests must be run explicitly
-# They require CMake 3.15+ (--install)
-
-DIR = os.path.abspath(os.path.dirname(__file__))
-MAIN_DIR = os.path.dirname(os.path.dirname(DIR))
-
-PKGCONFIG = """\
-prefix=${{pcfiledir}}/../../
-includedir=${{prefix}}/include
-
-Name: pybind11
-Description: Seamless operability between C++11 and Python
-Version: {VERSION}
-Cflags: -I${{includedir}}
-"""
-
-
-main_headers = {
-    "include/pybind11/attr.h",
-    "include/pybind11/buffer_info.h",
-    "include/pybind11/cast.h",
-    "include/pybind11/chrono.h",
-    "include/pybind11/common.h",
-    "include/pybind11/complex.h",
-    "include/pybind11/eigen.h",
-    "include/pybind11/embed.h",
-    "include/pybind11/eval.h",
-    "include/pybind11/functional.h",
-    "include/pybind11/gil.h",
-    "include/pybind11/iostream.h",
-    "include/pybind11/numpy.h",
-    "include/pybind11/operators.h",
-    "include/pybind11/options.h",
-    "include/pybind11/pybind11.h",
-    "include/pybind11/pytypes.h",
-    "include/pybind11/stl.h",
-    "include/pybind11/stl_bind.h",
-}
-
-detail_headers = {
-    "include/pybind11/detail/class.h",
-    "include/pybind11/detail/common.h",
-    "include/pybind11/detail/descr.h",
-    "include/pybind11/detail/init.h",
-    "include/pybind11/detail/internals.h",
-    "include/pybind11/detail/type_caster_base.h",
-    "include/pybind11/detail/typeid.h",
-}
-
-eigen_headers = {
-    "include/pybind11/eigen/matrix.h",
-    "include/pybind11/eigen/tensor.h",
-}
-
-stl_headers = {
-    "include/pybind11/stl/filesystem.h",
-}
-
-cmake_files = {
-    "share/cmake/pybind11/FindPythonLibsNew.cmake",
-    "share/cmake/pybind11/pybind11Common.cmake",
-    "share/cmake/pybind11/pybind11Config.cmake",
-    "share/cmake/pybind11/pybind11ConfigVersion.cmake",
-    "share/cmake/pybind11/pybind11NewTools.cmake",
-    "share/cmake/pybind11/pybind11Targets.cmake",
-    "share/cmake/pybind11/pybind11Tools.cmake",
-}
-
-pkgconfig_files = {
-    "share/pkgconfig/pybind11.pc",
-}
-
-py_files = {
-    "__init__.py",
-    "__main__.py",
-    "_version.py",
-    "commands.py",
-    "py.typed",
-    "setup_helpers.py",
-}
-
-headers = main_headers | detail_headers | eigen_headers | stl_headers
-src_files = headers | cmake_files | pkgconfig_files
-all_files = src_files | py_files
-
-
-sdist_files = {
-    "pybind11",
-    "pybind11/include",
-    "pybind11/include/pybind11",
-    "pybind11/include/pybind11/detail",
-    "pybind11/include/pybind11/eigen",
-    "pybind11/include/pybind11/stl",
-    "pybind11/share",
-    "pybind11/share/cmake",
-    "pybind11/share/cmake/pybind11",
-    "pybind11/share/pkgconfig",
-    "pyproject.toml",
-    "setup.cfg",
-    "setup.py",
-    "LICENSE",
-    "MANIFEST.in",
-    "README.rst",
-    "PKG-INFO",
-}
-
-local_sdist_files = {
-    ".egg-info",
-    ".egg-info/PKG-INFO",
-    ".egg-info/SOURCES.txt",
-    ".egg-info/dependency_links.txt",
-    ".egg-info/not-zip-safe",
-    ".egg-info/top_level.txt",
-}
-
-
-def read_tz_file(tar: tarfile.TarFile, name: str) -> bytes:
-    start = tar.getnames()[0] + "/"
-    inner_file = tar.extractfile(tar.getmember(f"{start}{name}"))
-    assert inner_file
-    with contextlib.closing(inner_file) as f:
-        return f.read()
-
-
-def normalize_line_endings(value: bytes) -> bytes:
-    return value.replace(os.linesep.encode("utf-8"), b"\n")
-
-
-def test_build_sdist(monkeypatch, tmpdir):
-    monkeypatch.chdir(MAIN_DIR)
-
-    subprocess.run(
-        [sys.executable, "-m", "build", "--sdist", f"--outdir={tmpdir}"], check=True
-    )
-
-    (sdist,) = tmpdir.visit("*.tar.gz")
-
-    with tarfile.open(str(sdist), "r:gz") as tar:
-        start = tar.getnames()[0] + "/"
-        version = start[9:-1]
-        simpler = {n.split("/", 1)[-1] for n in tar.getnames()[1:]}
-
-        setup_py = read_tz_file(tar, "setup.py")
-        pyproject_toml = read_tz_file(tar, "pyproject.toml")
-        pkgconfig = read_tz_file(tar, "pybind11/share/pkgconfig/pybind11.pc")
-        cmake_cfg = read_tz_file(
-            tar, "pybind11/share/cmake/pybind11/pybind11Config.cmake"
-        )
-
-    assert (
-        'set(pybind11_INCLUDE_DIR "${PACKAGE_PREFIX_DIR}/include")'
-        in cmake_cfg.decode("utf-8")
-    )
-
-    files = {f"pybind11/{n}" for n in all_files}
-    files |= sdist_files
-    files |= {f"pybind11{n}" for n in local_sdist_files}
-    files.add("pybind11.egg-info/entry_points.txt")
-    files.add("pybind11.egg-info/requires.txt")
-    assert simpler == files
-
-    with open(os.path.join(MAIN_DIR, "tools", "setup_main.py.in"), "rb") as f:
-        contents = (
-            string.Template(f.read().decode("utf-8"))
-            .substitute(version=version, extra_cmd="")
-            .encode("utf-8")
-        )
-    assert setup_py == contents
-
-    with open(os.path.join(MAIN_DIR, "tools", "pyproject.toml"), "rb") as f:
-        contents = f.read()
-    assert pyproject_toml == contents
-
-    simple_version = ".".join(version.split(".")[:3])
-    pkgconfig_expected = PKGCONFIG.format(VERSION=simple_version).encode("utf-8")
-    assert normalize_line_endings(pkgconfig) == pkgconfig_expected
-
-
-def test_build_global_dist(monkeypatch, tmpdir):
-    monkeypatch.chdir(MAIN_DIR)
-    monkeypatch.setenv("PYBIND11_GLOBAL_SDIST", "1")
-    subprocess.run(
-        [sys.executable, "-m", "build", "--sdist", "--outdir", str(tmpdir)], check=True
-    )
-
-    (sdist,) = tmpdir.visit("*.tar.gz")
-
-    with tarfile.open(str(sdist), "r:gz") as tar:
-        start = tar.getnames()[0] + "/"
-        version = start[16:-1]
-        simpler = {n.split("/", 1)[-1] for n in tar.getnames()[1:]}
-
-        setup_py = read_tz_file(tar, "setup.py")
-        pyproject_toml = read_tz_file(tar, "pyproject.toml")
-        pkgconfig = read_tz_file(tar, "pybind11/share/pkgconfig/pybind11.pc")
-        cmake_cfg = read_tz_file(
-            tar, "pybind11/share/cmake/pybind11/pybind11Config.cmake"
-        )
-
-    assert (
-        'set(pybind11_INCLUDE_DIR "${PACKAGE_PREFIX_DIR}/include")'
-        in cmake_cfg.decode("utf-8")
-    )
-
-    files = {f"pybind11/{n}" for n in all_files}
-    files |= sdist_files
-    files |= {f"pybind11_global{n}" for n in local_sdist_files}
-    assert simpler == files
-
-    with open(os.path.join(MAIN_DIR, "tools", "setup_global.py.in"), "rb") as f:
-        contents = (
-            string.Template(f.read().decode())
-            .substitute(version=version, extra_cmd="")
-            .encode("utf-8")
-        )
-        assert setup_py == contents
-
-    with open(os.path.join(MAIN_DIR, "tools", "pyproject.toml"), "rb") as f:
-        contents = f.read()
-        assert pyproject_toml == contents
-
-    simple_version = ".".join(version.split(".")[:3])
-    pkgconfig_expected = PKGCONFIG.format(VERSION=simple_version).encode("utf-8")
-    assert normalize_line_endings(pkgconfig) == pkgconfig_expected
-
-
-def tests_build_wheel(monkeypatch, tmpdir):
-    monkeypatch.chdir(MAIN_DIR)
-
-    subprocess.run(
-        [sys.executable, "-m", "pip", "wheel", ".", "-w", str(tmpdir)], check=True
-    )
-
-    (wheel,) = tmpdir.visit("*.whl")
-
-    files = {f"pybind11/{n}" for n in all_files}
-    files |= {
-        "dist-info/LICENSE",
-        "dist-info/METADATA",
-        "dist-info/RECORD",
-        "dist-info/WHEEL",
-        "dist-info/entry_points.txt",
-        "dist-info/top_level.txt",
-    }
-
-    with zipfile.ZipFile(str(wheel)) as z:
-        names = z.namelist()
-
-    trimmed = {n for n in names if "dist-info" not in n}
-    trimmed |= {f"dist-info/{n.split('/', 1)[-1]}" for n in names if "dist-info" in n}
-    assert files == trimmed
-
-
-def tests_build_global_wheel(monkeypatch, tmpdir):
-    monkeypatch.chdir(MAIN_DIR)
-    monkeypatch.setenv("PYBIND11_GLOBAL_SDIST", "1")
-
-    subprocess.run(
-        [sys.executable, "-m", "pip", "wheel", ".", "-w", str(tmpdir)], check=True
-    )
-
-    (wheel,) = tmpdir.visit("*.whl")
-
-    files = {f"data/data/{n}" for n in src_files}
-    files |= {f"data/headers/{n[8:]}" for n in headers}
-    files |= {
-        "dist-info/LICENSE",
-        "dist-info/METADATA",
-        "dist-info/WHEEL",
-        "dist-info/top_level.txt",
-        "dist-info/RECORD",
-    }
-
-    with zipfile.ZipFile(str(wheel)) as z:
-        names = z.namelist()
-
-    beginning = names[0].split("/", 1)[0].rsplit(".", 1)[0]
-    trimmed = {n[len(beginning) + 1 :] for n in names}
-
-    assert files == trimmed
+import contextlib
+import os
+import string
+import subprocess
+import sys
+import tarfile
+import zipfile
+
+# These tests must be run explicitly
+# They require CMake 3.15+ (--install)
+
+DIR = os.path.abspath(os.path.dirname(__file__))
+MAIN_DIR = os.path.dirname(os.path.dirname(DIR))
+
+PKGCONFIG = """\
+prefix=${{pcfiledir}}/../../
+includedir=${{prefix}}/include
+
+Name: pybind11
+Description: Seamless operability between C++11 and Python
+Version: {VERSION}
+Cflags: -I${{includedir}}
+"""
+
+
+main_headers = {
+    "include/pybind11/attr.h",
+    "include/pybind11/buffer_info.h",
+    "include/pybind11/cast.h",
+    "include/pybind11/chrono.h",
+    "include/pybind11/common.h",
+    "include/pybind11/complex.h",
+    "include/pybind11/eigen.h",
+    "include/pybind11/embed.h",
+    "include/pybind11/eval.h",
+    "include/pybind11/functional.h",
+    "include/pybind11/gil.h",
+    "include/pybind11/iostream.h",
+    "include/pybind11/numpy.h",
+    "include/pybind11/operators.h",
+    "include/pybind11/options.h",
+    "include/pybind11/pybind11.h",
+    "include/pybind11/pytypes.h",
+    "include/pybind11/stl.h",
+    "include/pybind11/stl_bind.h",
+}
+
+detail_headers = {
+    "include/pybind11/detail/class.h",
+    "include/pybind11/detail/common.h",
+    "include/pybind11/detail/descr.h",
+    "include/pybind11/detail/init.h",
+    "include/pybind11/detail/internals.h",
+    "include/pybind11/detail/type_caster_base.h",
+    "include/pybind11/detail/typeid.h",
+}
+
+eigen_headers = {
+    "include/pybind11/eigen/matrix.h",
+    "include/pybind11/eigen/tensor.h",
+}
+
+stl_headers = {
+    "include/pybind11/stl/filesystem.h",
+}
+
+cmake_files = {
+    "share/cmake/pybind11/FindPythonLibsNew.cmake",
+    "share/cmake/pybind11/pybind11Common.cmake",
+    "share/cmake/pybind11/pybind11Config.cmake",
+    "share/cmake/pybind11/pybind11ConfigVersion.cmake",
+    "share/cmake/pybind11/pybind11NewTools.cmake",
+    "share/cmake/pybind11/pybind11Targets.cmake",
+    "share/cmake/pybind11/pybind11Tools.cmake",
+}
+
+pkgconfig_files = {
+    "share/pkgconfig/pybind11.pc",
+}
+
+py_files = {
+    "__init__.py",
+    "__main__.py",
+    "_version.py",
+    "commands.py",
+    "py.typed",
+    "setup_helpers.py",
+}
+
+headers = main_headers | detail_headers | eigen_headers | stl_headers
+src_files = headers | cmake_files | pkgconfig_files
+all_files = src_files | py_files
+
+
+sdist_files = {
+    "pybind11",
+    "pybind11/include",
+    "pybind11/include/pybind11",
+    "pybind11/include/pybind11/detail",
+    "pybind11/include/pybind11/eigen",
+    "pybind11/include/pybind11/stl",
+    "pybind11/share",
+    "pybind11/share/cmake",
+    "pybind11/share/cmake/pybind11",
+    "pybind11/share/pkgconfig",
+    "pyproject.toml",
+    "setup.cfg",
+    "setup.py",
+    "LICENSE",
+    "MANIFEST.in",
+    "README.rst",
+    "PKG-INFO",
+}
+
+local_sdist_files = {
+    ".egg-info",
+    ".egg-info/PKG-INFO",
+    ".egg-info/SOURCES.txt",
+    ".egg-info/dependency_links.txt",
+    ".egg-info/not-zip-safe",
+    ".egg-info/top_level.txt",
+}
+
+
+def read_tz_file(tar: tarfile.TarFile, name: str) -> bytes:
+    start = tar.getnames()[0] + "/"
+    inner_file = tar.extractfile(tar.getmember(f"{start}{name}"))
+    assert inner_file
+    with contextlib.closing(inner_file) as f:
+        return f.read()
+
+
+def normalize_line_endings(value: bytes) -> bytes:
+    return value.replace(os.linesep.encode("utf-8"), b"\n")
+
+
+def test_build_sdist(monkeypatch, tmpdir):
+    monkeypatch.chdir(MAIN_DIR)
+
+    subprocess.run(
+        [sys.executable, "-m", "build", "--sdist", f"--outdir={tmpdir}"], check=True
+    )
+
+    (sdist,) = tmpdir.visit("*.tar.gz")
+
+    with tarfile.open(str(sdist), "r:gz") as tar:
+        start = tar.getnames()[0] + "/"
+        version = start[9:-1]
+        simpler = {n.split("/", 1)[-1] for n in tar.getnames()[1:]}
+
+        setup_py = read_tz_file(tar, "setup.py")
+        pyproject_toml = read_tz_file(tar, "pyproject.toml")
+        pkgconfig = read_tz_file(tar, "pybind11/share/pkgconfig/pybind11.pc")
+        cmake_cfg = read_tz_file(
+            tar, "pybind11/share/cmake/pybind11/pybind11Config.cmake"
+        )
+
+    assert (
+        'set(pybind11_INCLUDE_DIR "${PACKAGE_PREFIX_DIR}/include")'
+        in cmake_cfg.decode("utf-8")
+    )
+
+    files = {f"pybind11/{n}" for n in all_files}
+    files |= sdist_files
+    files |= {f"pybind11{n}" for n in local_sdist_files}
+    files.add("pybind11.egg-info/entry_points.txt")
+    files.add("pybind11.egg-info/requires.txt")
+    assert simpler == files
+
+    with open(os.path.join(MAIN_DIR, "tools", "setup_main.py.in"), "rb") as f:
+        contents = (
+            string.Template(f.read().decode("utf-8"))
+            .substitute(version=version, extra_cmd="")
+            .encode("utf-8")
+        )
+    assert setup_py == contents
+
+    with open(os.path.join(MAIN_DIR, "tools", "pyproject.toml"), "rb") as f:
+        contents = f.read()
+    assert pyproject_toml == contents
+
+    simple_version = ".".join(version.split(".")[:3])
+    pkgconfig_expected = PKGCONFIG.format(VERSION=simple_version).encode("utf-8")
+    assert normalize_line_endings(pkgconfig) == pkgconfig_expected
+
+
+def test_build_global_dist(monkeypatch, tmpdir):
+    monkeypatch.chdir(MAIN_DIR)
+    monkeypatch.setenv("PYBIND11_GLOBAL_SDIST", "1")
+    subprocess.run(
+        [sys.executable, "-m", "build", "--sdist", "--outdir", str(tmpdir)], check=True
+    )
+
+    (sdist,) = tmpdir.visit("*.tar.gz")
+
+    with tarfile.open(str(sdist), "r:gz") as tar:
+        start = tar.getnames()[0] + "/"
+        version = start[16:-1]
+        simpler = {n.split("/", 1)[-1] for n in tar.getnames()[1:]}
+
+        setup_py = read_tz_file(tar, "setup.py")
+        pyproject_toml = read_tz_file(tar, "pyproject.toml")
+        pkgconfig = read_tz_file(tar, "pybind11/share/pkgconfig/pybind11.pc")
+        cmake_cfg = read_tz_file(
+            tar, "pybind11/share/cmake/pybind11/pybind11Config.cmake"
+        )
+
+    assert (
+        'set(pybind11_INCLUDE_DIR "${PACKAGE_PREFIX_DIR}/include")'
+        in cmake_cfg.decode("utf-8")
+    )
+
+    files = {f"pybind11/{n}" for n in all_files}
+    files |= sdist_files
+    files |= {f"pybind11_global{n}" for n in local_sdist_files}
+    assert simpler == files
+
+    with open(os.path.join(MAIN_DIR, "tools", "setup_global.py.in"), "rb") as f:
+        contents = (
+            string.Template(f.read().decode())
+            .substitute(version=version, extra_cmd="")
+            .encode("utf-8")
+        )
+        assert setup_py == contents
+
+    with open(os.path.join(MAIN_DIR, "tools", "pyproject.toml"), "rb") as f:
+        contents = f.read()
+        assert pyproject_toml == contents
+
+    simple_version = ".".join(version.split(".")[:3])
+    pkgconfig_expected = PKGCONFIG.format(VERSION=simple_version).encode("utf-8")
+    assert normalize_line_endings(pkgconfig) == pkgconfig_expected
+
+
+def tests_build_wheel(monkeypatch, tmpdir):
+    monkeypatch.chdir(MAIN_DIR)
+
+    subprocess.run(
+        [sys.executable, "-m", "pip", "wheel", ".", "-w", str(tmpdir)], check=True
+    )
+
+    (wheel,) = tmpdir.visit("*.whl")
+
+    files = {f"pybind11/{n}" for n in all_files}
+    files |= {
+        "dist-info/LICENSE",
+        "dist-info/METADATA",
+        "dist-info/RECORD",
+        "dist-info/WHEEL",
+        "dist-info/entry_points.txt",
+        "dist-info/top_level.txt",
+    }
+
+    with zipfile.ZipFile(str(wheel)) as z:
+        names = z.namelist()
+
+    trimmed = {n for n in names if "dist-info" not in n}
+    trimmed |= {f"dist-info/{n.split('/', 1)[-1]}" for n in names if "dist-info" in n}
+    assert files == trimmed
+
+
+def tests_build_global_wheel(monkeypatch, tmpdir):
+    monkeypatch.chdir(MAIN_DIR)
+    monkeypatch.setenv("PYBIND11_GLOBAL_SDIST", "1")
+
+    subprocess.run(
+        [sys.executable, "-m", "pip", "wheel", ".", "-w", str(tmpdir)], check=True
+    )
+
+    (wheel,) = tmpdir.visit("*.whl")
+
+    files = {f"data/data/{n}" for n in src_files}
+    files |= {f"data/headers/{n[8:]}" for n in headers}
+    files |= {
+        "dist-info/LICENSE",
+        "dist-info/METADATA",
+        "dist-info/WHEEL",
+        "dist-info/top_level.txt",
+        "dist-info/RECORD",
+    }
+
+    with zipfile.ZipFile(str(wheel)) as z:
+        names = z.namelist()
+
+    beginning = names[0].split("/", 1)[0].rsplit(".", 1)[0]
+    trimmed = {n[len(beginning) + 1 :] for n in names}
+
+    assert files == trimmed
```

## extern/pybind11/tests/extra_setuptools/test_setuphelper.py

 * *Ordering differences only*

```diff
@@ -1,151 +1,151 @@
-import os
-import subprocess
-import sys
-from textwrap import dedent
-
-import pytest
-
-DIR = os.path.abspath(os.path.dirname(__file__))
-MAIN_DIR = os.path.dirname(os.path.dirname(DIR))
-WIN = sys.platform.startswith("win32") or sys.platform.startswith("cygwin")
-
-
-@pytest.mark.parametrize("parallel", [False, True])
-@pytest.mark.parametrize("std", [11, 0])
-def test_simple_setup_py(monkeypatch, tmpdir, parallel, std):
-    monkeypatch.chdir(tmpdir)
-    monkeypatch.syspath_prepend(MAIN_DIR)
-
-    (tmpdir / "setup.py").write_text(
-        dedent(
-            f"""\
-            import sys
-            sys.path.append({MAIN_DIR!r})
-
-            from setuptools import setup, Extension
-            from pybind11.setup_helpers import build_ext, Pybind11Extension
-
-            std = {std}
-
-            ext_modules = [
-                Pybind11Extension(
-                    "simple_setup",
-                    sorted(["main.cpp"]),
-                    cxx_std=std,
-                ),
-            ]
-
-            cmdclass = dict()
-            if std == 0:
-                cmdclass["build_ext"] = build_ext
-
-
-            parallel = {parallel}
-            if parallel:
-                from pybind11.setup_helpers import ParallelCompile
-                ParallelCompile().install()
-
-            setup(
-                name="simple_setup_package",
-                cmdclass=cmdclass,
-                ext_modules=ext_modules,
-            )
-            """
-        ),
-        encoding="ascii",
-    )
-
-    (tmpdir / "main.cpp").write_text(
-        dedent(
-            """\
-            #include <pybind11/pybind11.h>
-
-            int f(int x) {
-                return x * 3;
-            }
-            PYBIND11_MODULE(simple_setup, m) {
-                m.def("f", &f);
-            }
-            """
-        ),
-        encoding="ascii",
-    )
-
-    out = subprocess.check_output(
-        [sys.executable, "setup.py", "build_ext", "--inplace"],
-    )
-    if not WIN:
-        assert b"-g0" in out
-    out = subprocess.check_output(
-        [sys.executable, "setup.py", "build_ext", "--inplace", "--force"],
-        env=dict(os.environ, CFLAGS="-g"),
-    )
-    if not WIN:
-        assert b"-g0" not in out
-
-    # Debug helper printout, normally hidden
-    print(out)
-    for item in tmpdir.listdir():
-        print(item.basename)
-
-    assert (
-        len([f for f in tmpdir.listdir() if f.basename.startswith("simple_setup")]) == 1
-    )
-    assert len(list(tmpdir.listdir())) == 4  # two files + output + build_dir
-
-    (tmpdir / "test.py").write_text(
-        dedent(
-            """\
-            import simple_setup
-            assert simple_setup.f(3) == 9
-            """
-        ),
-        encoding="ascii",
-    )
-
-    subprocess.check_call(
-        [sys.executable, "test.py"], stdout=sys.stdout, stderr=sys.stderr
-    )
-
-
-def test_intree_extensions(monkeypatch, tmpdir):
-    monkeypatch.syspath_prepend(MAIN_DIR)
-
-    from pybind11.setup_helpers import intree_extensions
-
-    monkeypatch.chdir(tmpdir)
-    root = tmpdir
-    root.ensure_dir()
-    subdir = root / "dir"
-    subdir.ensure_dir()
-    src = subdir / "ext.cpp"
-    src.ensure()
-    relpath = src.relto(tmpdir)
-    (ext,) = intree_extensions([relpath])
-    assert ext.name == "ext"
-    subdir.ensure("__init__.py")
-    (ext,) = intree_extensions([relpath])
-    assert ext.name == "dir.ext"
-
-
-def test_intree_extensions_package_dir(monkeypatch, tmpdir):
-    monkeypatch.syspath_prepend(MAIN_DIR)
-
-    from pybind11.setup_helpers import intree_extensions
-
-    monkeypatch.chdir(tmpdir)
-    root = tmpdir / "src"
-    root.ensure_dir()
-    subdir = root / "dir"
-    subdir.ensure_dir()
-    src = subdir / "ext.cpp"
-    src.ensure()
-    (ext,) = intree_extensions([src.relto(tmpdir)], package_dir={"": "src"})
-    assert ext.name == "dir.ext"
-    (ext,) = intree_extensions([src.relto(tmpdir)], package_dir={"foo": "src"})
-    assert ext.name == "foo.dir.ext"
-    subdir.ensure("__init__.py")
-    (ext,) = intree_extensions([src.relto(tmpdir)], package_dir={"": "src"})
-    assert ext.name == "dir.ext"
-    (ext,) = intree_extensions([src.relto(tmpdir)], package_dir={"foo": "src"})
-    assert ext.name == "foo.dir.ext"
+import os
+import subprocess
+import sys
+from textwrap import dedent
+
+import pytest
+
+DIR = os.path.abspath(os.path.dirname(__file__))
+MAIN_DIR = os.path.dirname(os.path.dirname(DIR))
+WIN = sys.platform.startswith("win32") or sys.platform.startswith("cygwin")
+
+
+@pytest.mark.parametrize("parallel", [False, True])
+@pytest.mark.parametrize("std", [11, 0])
+def test_simple_setup_py(monkeypatch, tmpdir, parallel, std):
+    monkeypatch.chdir(tmpdir)
+    monkeypatch.syspath_prepend(MAIN_DIR)
+
+    (tmpdir / "setup.py").write_text(
+        dedent(
+            f"""\
+            import sys
+            sys.path.append({MAIN_DIR!r})
+
+            from setuptools import setup, Extension
+            from pybind11.setup_helpers import build_ext, Pybind11Extension
+
+            std = {std}
+
+            ext_modules = [
+                Pybind11Extension(
+                    "simple_setup",
+                    sorted(["main.cpp"]),
+                    cxx_std=std,
+                ),
+            ]
+
+            cmdclass = dict()
+            if std == 0:
+                cmdclass["build_ext"] = build_ext
+
+
+            parallel = {parallel}
+            if parallel:
+                from pybind11.setup_helpers import ParallelCompile
+                ParallelCompile().install()
+
+            setup(
+                name="simple_setup_package",
+                cmdclass=cmdclass,
+                ext_modules=ext_modules,
+            )
+            """
+        ),
+        encoding="ascii",
+    )
+
+    (tmpdir / "main.cpp").write_text(
+        dedent(
+            """\
+            #include <pybind11/pybind11.h>
+
+            int f(int x) {
+                return x * 3;
+            }
+            PYBIND11_MODULE(simple_setup, m) {
+                m.def("f", &f);
+            }
+            """
+        ),
+        encoding="ascii",
+    )
+
+    out = subprocess.check_output(
+        [sys.executable, "setup.py", "build_ext", "--inplace"],
+    )
+    if not WIN:
+        assert b"-g0" in out
+    out = subprocess.check_output(
+        [sys.executable, "setup.py", "build_ext", "--inplace", "--force"],
+        env=dict(os.environ, CFLAGS="-g"),
+    )
+    if not WIN:
+        assert b"-g0" not in out
+
+    # Debug helper printout, normally hidden
+    print(out)
+    for item in tmpdir.listdir():
+        print(item.basename)
+
+    assert (
+        len([f for f in tmpdir.listdir() if f.basename.startswith("simple_setup")]) == 1
+    )
+    assert len(list(tmpdir.listdir())) == 4  # two files + output + build_dir
+
+    (tmpdir / "test.py").write_text(
+        dedent(
+            """\
+            import simple_setup
+            assert simple_setup.f(3) == 9
+            """
+        ),
+        encoding="ascii",
+    )
+
+    subprocess.check_call(
+        [sys.executable, "test.py"], stdout=sys.stdout, stderr=sys.stderr
+    )
+
+
+def test_intree_extensions(monkeypatch, tmpdir):
+    monkeypatch.syspath_prepend(MAIN_DIR)
+
+    from pybind11.setup_helpers import intree_extensions
+
+    monkeypatch.chdir(tmpdir)
+    root = tmpdir
+    root.ensure_dir()
+    subdir = root / "dir"
+    subdir.ensure_dir()
+    src = subdir / "ext.cpp"
+    src.ensure()
+    relpath = src.relto(tmpdir)
+    (ext,) = intree_extensions([relpath])
+    assert ext.name == "ext"
+    subdir.ensure("__init__.py")
+    (ext,) = intree_extensions([relpath])
+    assert ext.name == "dir.ext"
+
+
+def test_intree_extensions_package_dir(monkeypatch, tmpdir):
+    monkeypatch.syspath_prepend(MAIN_DIR)
+
+    from pybind11.setup_helpers import intree_extensions
+
+    monkeypatch.chdir(tmpdir)
+    root = tmpdir / "src"
+    root.ensure_dir()
+    subdir = root / "dir"
+    subdir.ensure_dir()
+    src = subdir / "ext.cpp"
+    src.ensure()
+    (ext,) = intree_extensions([src.relto(tmpdir)], package_dir={"": "src"})
+    assert ext.name == "dir.ext"
+    (ext,) = intree_extensions([src.relto(tmpdir)], package_dir={"foo": "src"})
+    assert ext.name == "foo.dir.ext"
+    subdir.ensure("__init__.py")
+    (ext,) = intree_extensions([src.relto(tmpdir)], package_dir={"": "src"})
+    assert ext.name == "dir.ext"
+    (ext,) = intree_extensions([src.relto(tmpdir)], package_dir={"foo": "src"})
+    assert ext.name == "foo.dir.ext"
```

## extern/pybind11/tests/test_cmake_build/test.py

 * *Ordering differences only*

```diff
@@ -1,8 +1,8 @@
-import sys
-
-import test_cmake_build
-
-assert isinstance(__file__, str)  # Test this is properly set
-
-assert test_cmake_build.add(1, 2) == 3
-print(f"{sys.argv[1]} imports, runs, and adds: 1 + 2 = 3")
+import sys
+
+import test_cmake_build
+
+assert isinstance(__file__, str)  # Test this is properly set
+
+assert test_cmake_build.add(1, 2) == 3
+print(f"{sys.argv[1]} imports, runs, and adds: 1 + 2 = 3")
```

## extern/pybind11/tests/test_embed/test_interpreter.py

 * *Ordering differences only*

```diff
@@ -1,14 +1,14 @@
-import sys
-
-from widget_module import Widget
-
-
-class DerivedWidget(Widget):
-    def __init__(self, message):
-        super().__init__(message)
-
-    def the_answer(self):
-        return 42
-
-    def argv0(self):
-        return sys.argv[0]
+import sys
+
+from widget_module import Widget
+
+
+class DerivedWidget(Widget):
+    def __init__(self, message):
+        super().__init__(message)
+
+    def the_answer(self):
+        return 42
+
+    def argv0(self):
+        return sys.argv[0]
```

## extern/pybind11/tests/test_embed/test_trampoline.py

 * *Ordering differences only*

```diff
@@ -1,16 +1,16 @@
-import trampoline_module
-
-
-def func():
-    class Test(trampoline_module.test_override_cache_helper):
-        def func(self):
-            return 42
-
-    return Test()
-
-
-def func2():
-    class Test(trampoline_module.test_override_cache_helper):
-        pass
-
-    return Test()
+import trampoline_module
+
+
+def func():
+    class Test(trampoline_module.test_override_cache_helper):
+        def func(self):
+            return 42
+
+    return Test()
+
+
+def func2():
+    class Test(trampoline_module.test_override_cache_helper):
+        pass
+
+    return Test()
```

## extern/pybind11/tools/codespell_ignore_lines_from_errors.py

 * *Ordering differences only*

```diff
@@ -1,35 +1,35 @@
-"""Simple script for rebuilding .codespell-ignore-lines
-
-Usage:
-
-cat < /dev/null > .codespell-ignore-lines
-pre-commit run --all-files codespell >& /tmp/codespell_errors.txt
-python3 tools/codespell_ignore_lines_from_errors.py /tmp/codespell_errors.txt > .codespell-ignore-lines
-
-git diff to review changes, then commit, push.
-"""
-
-import sys
-from typing import List
-
-
-def run(args: List[str]) -> None:
-    assert len(args) == 1, "codespell_errors.txt"
-    cache = {}
-    done = set()
-    for line in sorted(open(args[0]).read().splitlines()):
-        i = line.find(" ==> ")
-        if i > 0:
-            flds = line[:i].split(":")
-            if len(flds) >= 2:
-                filename, line_num = flds[:2]
-                if filename not in cache:
-                    cache[filename] = open(filename).read().splitlines()
-                supp = cache[filename][int(line_num) - 1]
-                if supp not in done:
-                    print(supp)
-                    done.add(supp)
-
-
-if __name__ == "__main__":
-    run(args=sys.argv[1:])
+"""Simple script for rebuilding .codespell-ignore-lines
+
+Usage:
+
+cat < /dev/null > .codespell-ignore-lines
+pre-commit run --all-files codespell >& /tmp/codespell_errors.txt
+python3 tools/codespell_ignore_lines_from_errors.py /tmp/codespell_errors.txt > .codespell-ignore-lines
+
+git diff to review changes, then commit, push.
+"""
+
+import sys
+from typing import List
+
+
+def run(args: List[str]) -> None:
+    assert len(args) == 1, "codespell_errors.txt"
+    cache = {}
+    done = set()
+    for line in sorted(open(args[0]).read().splitlines()):
+        i = line.find(" ==> ")
+        if i > 0:
+            flds = line[:i].split(":")
+            if len(flds) >= 2:
+                filename, line_num = flds[:2]
+                if filename not in cache:
+                    cache[filename] = open(filename).read().splitlines()
+                supp = cache[filename][int(line_num) - 1]
+                if supp not in done:
+                    print(supp)
+                    done.add(supp)
+
+
+if __name__ == "__main__":
+    run(args=sys.argv[1:])
```

## extern/pybind11/tools/libsize.py

 * *Ordering differences only*

```diff
@@ -1,36 +1,36 @@
-import os
-import sys
-
-# Internal build script for generating debugging test .so size.
-# Usage:
-#     python libsize.py file.so save.txt -- displays the size of file.so and, if save.txt exists, compares it to the
-#                                           size in it, then overwrites save.txt with the new size for future runs.
-
-if len(sys.argv) != 3:
-    sys.exit("Invalid arguments: usage: python libsize.py file.so save.txt")
-
-lib = sys.argv[1]
-save = sys.argv[2]
-
-if not os.path.exists(lib):
-    sys.exit(f"Error: requested file ({lib}) does not exist")
-
-libsize = os.path.getsize(lib)
-
-print("------", os.path.basename(lib), "file size:", libsize, end="")
-
-if os.path.exists(save):
-    with open(save) as sf:
-        oldsize = int(sf.readline())
-
-    if oldsize > 0:
-        change = libsize - oldsize
-        if change == 0:
-            print(" (no change)")
-        else:
-            print(f" (change of {change:+} bytes = {change / oldsize:+.2%})")
-else:
-    print()
-
-with open(save, "w") as sf:
-    sf.write(str(libsize))
+import os
+import sys
+
+# Internal build script for generating debugging test .so size.
+# Usage:
+#     python libsize.py file.so save.txt -- displays the size of file.so and, if save.txt exists, compares it to the
+#                                           size in it, then overwrites save.txt with the new size for future runs.
+
+if len(sys.argv) != 3:
+    sys.exit("Invalid arguments: usage: python libsize.py file.so save.txt")
+
+lib = sys.argv[1]
+save = sys.argv[2]
+
+if not os.path.exists(lib):
+    sys.exit(f"Error: requested file ({lib}) does not exist")
+
+libsize = os.path.getsize(lib)
+
+print("------", os.path.basename(lib), "file size:", libsize, end="")
+
+if os.path.exists(save):
+    with open(save) as sf:
+        oldsize = int(sf.readline())
+
+    if oldsize > 0:
+        change = libsize - oldsize
+        if change == 0:
+            print(" (no change)")
+        else:
+            print(f" (change of {change:+} bytes = {change / oldsize:+.2%})")
+else:
+    print()
+
+with open(save, "w") as sf:
+    sf.write(str(libsize))
```

## extern/pybind11/tools/make_changelog.py

 * *Ordering differences only*

```diff
@@ -1,62 +1,62 @@
-#!/usr/bin/env python3
-
-import re
-
-import ghapi.all
-from rich import print
-from rich.syntax import Syntax
-
-ENTRY = re.compile(
-    r"""
-    Suggested \s changelog \s entry:
-    .*
-    ```rst
-    \s*
-    (.*?)
-    \s*
-    ```
-""",
-    re.DOTALL | re.VERBOSE,
-)
-
-print()
-
-
-api = ghapi.all.GhApi(owner="pybind", repo="pybind11")
-
-issues_pages = ghapi.page.paged(
-    api.issues.list_for_repo, labels="needs changelog", state="closed"
-)
-issues = (issue for page in issues_pages for issue in page)
-missing = []
-
-for issue in issues:
-    changelog = ENTRY.findall(issue.body or "")
-    if not changelog or not changelog[0]:
-        missing.append(issue)
-    else:
-        (msg,) = changelog
-        if not msg.startswith("* "):
-            msg = "* " + msg
-        if not msg.endswith("."):
-            msg += "."
-
-        msg += f"\n  `#{issue.number} <{issue.html_url}>`_"
-
-        print(Syntax(msg, "rst", theme="ansi_light", word_wrap=True))
-        print()
-
-if missing:
-    print()
-    print("[blue]" + "-" * 30)
-    print()
-
-    for issue in missing:
-        print(f"[red bold]Missing:[/red bold][red] {issue.title}")
-        print(f"[red]  {issue.html_url}\n")
-
-    print("[bold]Template:\n")
-    msg = "## Suggested changelog entry:\n\n```rst\n\n```"
-    print(Syntax(msg, "md", theme="ansi_light"))
-
-print()
+#!/usr/bin/env python3
+
+import re
+
+import ghapi.all
+from rich import print
+from rich.syntax import Syntax
+
+ENTRY = re.compile(
+    r"""
+    Suggested \s changelog \s entry:
+    .*
+    ```rst
+    \s*
+    (.*?)
+    \s*
+    ```
+""",
+    re.DOTALL | re.VERBOSE,
+)
+
+print()
+
+
+api = ghapi.all.GhApi(owner="pybind", repo="pybind11")
+
+issues_pages = ghapi.page.paged(
+    api.issues.list_for_repo, labels="needs changelog", state="closed"
+)
+issues = (issue for page in issues_pages for issue in page)
+missing = []
+
+for issue in issues:
+    changelog = ENTRY.findall(issue.body or "")
+    if not changelog or not changelog[0]:
+        missing.append(issue)
+    else:
+        (msg,) = changelog
+        if not msg.startswith("* "):
+            msg = "* " + msg
+        if not msg.endswith("."):
+            msg += "."
+
+        msg += f"\n  `#{issue.number} <{issue.html_url}>`_"
+
+        print(Syntax(msg, "rst", theme="ansi_light", word_wrap=True))
+        print()
+
+if missing:
+    print()
+    print("[blue]" + "-" * 30)
+    print()
+
+    for issue in missing:
+        print(f"[red bold]Missing:[/red bold][red] {issue.title}")
+        print(f"[red]  {issue.html_url}\n")
+
+    print("[bold]Template:\n")
+    msg = "## Suggested changelog entry:\n\n```rst\n\n```"
+    print(Syntax(msg, "md", theme="ansi_light"))
+
+print()
```

## tests/detectors/test_coherent_mode.py

 * *Ordering differences only*

```diff
@@ -1,59 +1,59 @@
-import pytest
-from PyMieSim.single.scatterer import Sphere
-from PyMieSim.single.source import Gaussian
-from PyMieSim.single.detector import CoherentMode
-
-# Define a list of mode numbers and rotation angles to be tested
-mode_numbers = [
-    "LP01", "LP11", "LP21",
-    "LG01", "LG11", "LG21",
-    "HG01", "HG11", "HG21"
-]
-
-rotations = [0, 90]
-
-
-@pytest.fixture
-def setup_source():
-    """Fixture to create a Gaussian source used across multiple tests."""
-
-    return Gaussian(
-        wavelength=750e-9,  # Wavelength of the source in meters
-        polarization_value=0,  # Polarization value
-        polarization_type='linear',  # Type of polarization
-        optical_power=1,  # Optical power in watts
-        NA=0.3  # Numerical aperture
-    )
-
-
-@pytest.fixture
-def scatterer(setup_source):
-    """Fixture to create a scatterer with a provided source."""
-
-    return Sphere(
-        diameter=100e-9,  # Diameter in meters
-        source=setup_source,  # Source defined in the setup_source fixture
-        index=1.4,  # Refractive index of the scatterer
-        medium_index=1.0  # Refractive index of the medium
-    )
-
-
-@pytest.mark.parametrize('mode_number', mode_numbers)
-@pytest.mark.parametrize('rotation', rotations)
-def test_lp_modes(mode_number, rotation, scatterer):
-    """Test different LP, LG, and HG modes with varying rotations."""
-
-    detector = CoherentMode(
-        mode_number=mode_number,
-        NA=0.2,  # Numerical aperture for the detector
-        sampling=100,  # Field sampling
-        gamma_offset=0,  # Gamma offset
-        phi_offset=0,  # Phi offset
-        rotation=rotation  # Rotation angle
-    )
-
-    footprint = detector.get_footprint(scatterer=scatterer)
-
-    assert footprint is not None, "Expected a valid footprint but got None."
-
-# -
+import pytest
+from PyMieSim.single.scatterer import Sphere
+from PyMieSim.single.source import Gaussian
+from PyMieSim.single.detector import CoherentMode
+
+# Define a list of mode numbers and rotation angles to be tested
+mode_numbers = [
+    "LP01", "LP11", "LP21",
+    "LG01", "LG11", "LG21",
+    "HG01", "HG11", "HG21"
+]
+
+rotations = [0, 90]
+
+
+@pytest.fixture
+def setup_source():
+    """Fixture to create a Gaussian source used across multiple tests."""
+
+    return Gaussian(
+        wavelength=750e-9,  # Wavelength of the source in meters
+        polarization_value=0,  # Polarization value
+        polarization_type='linear',  # Type of polarization
+        optical_power=1,  # Optical power in watts
+        NA=0.3  # Numerical aperture
+    )
+
+
+@pytest.fixture
+def scatterer(setup_source):
+    """Fixture to create a scatterer with a provided source."""
+
+    return Sphere(
+        diameter=100e-9,  # Diameter in meters
+        source=setup_source,  # Source defined in the setup_source fixture
+        index=1.4,  # Refractive index of the scatterer
+        medium_index=1.0  # Refractive index of the medium
+    )
+
+
+@pytest.mark.parametrize('mode_number', mode_numbers)
+@pytest.mark.parametrize('rotation', rotations)
+def test_lp_modes(mode_number, rotation, scatterer):
+    """Test different LP, LG, and HG modes with varying rotations."""
+
+    detector = CoherentMode(
+        mode_number=mode_number,
+        NA=0.2,  # Numerical aperture for the detector
+        sampling=100,  # Field sampling
+        gamma_offset=0,  # Gamma offset
+        phi_offset=0,  # Phi offset
+        rotation=rotation  # Rotation angle
+    )
+
+    footprint = detector.get_footprint(scatterer=scatterer)
+
+    assert footprint is not None, "Expected a valid footprint but got None."
+
+# -
```

## tests/detectors/test_integration_sphere.py

 * *Ordering differences only*

```diff
@@ -1,46 +1,46 @@
-import pytest
-from PyMieSim.single.scatterer import Sphere
-from PyMieSim.single.source import Gaussian
-from PyMieSim.single.detector import IntegratingSphere
-
-# Define sampling to be tested
-samplings = [100, 200]
-
-
-@pytest.fixture
-def setup_source():
-    """Fixture to create a Gaussian source used across multiple tests."""
-
-    return Gaussian(
-        wavelength=750e-9,  # Wavelength of the source in meters
-        polarization_value=0,  # Polarization value
-        polarization_type='linear',  # Type of polarization
-        optical_power=1,  # Optical power in watts
-        NA=0.3  # Numerical aperture
-    )
-
-
-@pytest.fixture
-def setup_scatterer(setup_source):
-    """Fixture to create a scatterer with a provided source."""
-
-    return Sphere(
-        diameter=100e-9,  # Diameter of the scatterer in meters
-        source=setup_source,  # Gaussian source from setup_source fixture
-        index=1.4,  # Refractive index of the scatterer
-        medium_index=1.0  # Refractive index of the surrounding medium
-    )
-
-
-@pytest.mark.parametrize('sampling', samplings)
-def test_photodiode_with_sampling(sampling, setup_scatterer):
-    """Test the Integrating Sphere detector with different sampling rates."""
-
-    detector = IntegratingSphere(sampling=sampling)
-
-    footprint = detector.get_footprint(scatterer=setup_scatterer)
-
-    # Example verification step (not operational as we're not evaluating the output here)
-    assert footprint is not None, "Expected a valid footprint but got None."
-
-# -
+import pytest
+from PyMieSim.single.scatterer import Sphere
+from PyMieSim.single.source import Gaussian
+from PyMieSim.single.detector import IntegratingSphere
+
+# Define sampling to be tested
+samplings = [100, 200]
+
+
+@pytest.fixture
+def setup_source():
+    """Fixture to create a Gaussian source used across multiple tests."""
+
+    return Gaussian(
+        wavelength=750e-9,  # Wavelength of the source in meters
+        polarization_value=0,  # Polarization value
+        polarization_type='linear',  # Type of polarization
+        optical_power=1,  # Optical power in watts
+        NA=0.3  # Numerical aperture
+    )
+
+
+@pytest.fixture
+def setup_scatterer(setup_source):
+    """Fixture to create a scatterer with a provided source."""
+
+    return Sphere(
+        diameter=100e-9,  # Diameter of the scatterer in meters
+        source=setup_source,  # Gaussian source from setup_source fixture
+        index=1.4,  # Refractive index of the scatterer
+        medium_index=1.0  # Refractive index of the surrounding medium
+    )
+
+
+@pytest.mark.parametrize('sampling', samplings)
+def test_photodiode_with_sampling(sampling, setup_scatterer):
+    """Test the Integrating Sphere detector with different sampling rates."""
+
+    detector = IntegratingSphere(sampling=sampling)
+
+    footprint = detector.get_footprint(scatterer=setup_scatterer)
+
+    # Example verification step (not operational as we're not evaluating the output here)
+    assert footprint is not None, "Expected a valid footprint but got None."
+
+# -
```

## tests/detectors/test_photodiode.py

 * *Ordering differences only*

```diff
@@ -1,50 +1,50 @@
-import pytest
-from PyMieSim.single.scatterer import Sphere
-from PyMieSim.single.source import Gaussian
-from PyMieSim.single.detector import Photodiode
-
-# Define different sampling for testing
-samplings = [100, 200, 300, 400]
-
-
-@pytest.fixture
-def setup_source():
-    """Fixture to create a Gaussian source that can be reused in different tests."""
-
-    return Gaussian(
-        wavelength=750e-9,  # Wavelength of the source in meters
-        polarization_value=0,  # Polarization value
-        polarization_type='linear',  # Polarization type
-        optical_power=1,  # Optical power in watts
-        NA=0.3  # Numerical aperture
-    )
-
-
-@pytest.fixture
-def setup_scatterer(setup_source):
-    """Fixture to create a scatterer using the Gaussian source defined above."""
-
-    return Sphere(
-        diameter=100e-9,  # Diameter of the scatterer in meters
-        source=setup_source,  # Source from setup_source fixture
-        index=1.4,  # Refractive index of the scatterer
-        medium_index=1.0  # Refractive index of the surrounding medium
-    )
-
-
-@pytest.mark.parametrize('sampling', samplings)
-def test_photodiode_sampling(sampling, setup_scatterer):
-    """Test the Photodiode detector with various sampling rates."""
-
-    detector = Photodiode(
-        NA=0.2,  # Numerical aperture of the detector
-        sampling=sampling,  # Field sampling
-        gamma_offset=0,  # Gamma offset
-        phi_offset=0  # Phi offset
-    )
-
-    # Perform the operation to be tested
-    footprint = detector.get_footprint(scatterer=setup_scatterer)
-
-    # Example verification step (not operational as we're not evaluating the output here)
-    assert footprint is not None, "Expected a valid footprint but got None."
+import pytest
+from PyMieSim.single.scatterer import Sphere
+from PyMieSim.single.source import Gaussian
+from PyMieSim.single.detector import Photodiode
+
+# Define different sampling for testing
+samplings = [100, 200, 300, 400]
+
+
+@pytest.fixture
+def setup_source():
+    """Fixture to create a Gaussian source that can be reused in different tests."""
+
+    return Gaussian(
+        wavelength=750e-9,  # Wavelength of the source in meters
+        polarization_value=0,  # Polarization value
+        polarization_type='linear',  # Polarization type
+        optical_power=1,  # Optical power in watts
+        NA=0.3  # Numerical aperture
+    )
+
+
+@pytest.fixture
+def setup_scatterer(setup_source):
+    """Fixture to create a scatterer using the Gaussian source defined above."""
+
+    return Sphere(
+        diameter=100e-9,  # Diameter of the scatterer in meters
+        source=setup_source,  # Source from setup_source fixture
+        index=1.4,  # Refractive index of the scatterer
+        medium_index=1.0  # Refractive index of the surrounding medium
+    )
+
+
+@pytest.mark.parametrize('sampling', samplings)
+def test_photodiode_sampling(sampling, setup_scatterer):
+    """Test the Photodiode detector with various sampling rates."""
+
+    detector = Photodiode(
+        NA=0.2,  # Numerical aperture of the detector
+        sampling=sampling,  # Field sampling
+        gamma_offset=0,  # Gamma offset
+        phi_offset=0  # Phi offset
+    )
+
+    # Perform the operation to be tested
+    footprint = detector.get_footprint(scatterer=setup_scatterer)
+
+    # Example verification step (not operational as we're not evaluating the output here)
+    assert footprint is not None, "Expected a valid footprint but got None."
```

## tests/experiments/test_coreshell.py

 * *Ordering differences only*

```diff
@@ -1,87 +1,87 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-import pytest
-import numpy as np
-
-from PyMieSim.experiment.detector import Photodiode
-from PyMieSim.experiment.scatterer import CoreShell
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-import PyMieSim.measure as pms_measure
-from PyOptik import UsualMaterial
-
-# Define core materials and properties
-core_options = [
-    {'name': 'BK7', 'properties': {'core_material': UsualMaterial.BK7}},
-    {'name': 'Silver', 'properties': {'core_material': UsualMaterial.Silver}},
-    {'name': 'Aluminium', 'properties': {'core_material': UsualMaterial.Aluminium}},
-    {'name': 'Index', 'properties': {'core_index': 1.4}}
-]
-
-# Define shell materials and properties
-shell_options = [
-    {'name': 'BK7', 'properties': {'shell_material': UsualMaterial.BK7}},
-    {'name': 'Silver', 'properties': {'shell_material': UsualMaterial.Silver}},
-    {'name': 'Aluminium', 'properties': {'shell_material': UsualMaterial.Aluminium}},
-    {'name': 'Index', 'properties': {'shell_index': 1.4}}
-]
-
-# Define medium materials and properties
-medium_options = [
-    {'name': 'BK7', 'properties': {'medium_material': UsualMaterial.Water}},
-    {'name': 'BK7', 'properties': {'medium_material': UsualMaterial.Water}},
-    {'name': 'Index', 'properties': {'medium_index': 1.1}}
-]
-
-# Define measures to test
-measures = [
-    pms_measure.Qsca, pms_measure.Qabs, pms_measure.Qback,
-    pms_measure.g, pms_measure.a1, pms_measure.b1, pms_measure.coupling
-]
-
-
-@pytest.mark.parametrize('medium_config', [m['properties'] for m in medium_options], ids=[m['name'] for m in medium_options])
-@pytest.mark.parametrize('shell_config', [s['properties'] for s in shell_options], ids=[s['name'] for s in shell_options])
-@pytest.mark.parametrize('core_config', [c['properties'] for c in core_options], ids=[c['name'] for c in core_options])
-@pytest.mark.parametrize('measure', measures, ids=[m.short_label for m in measures])
-def test_coreshell_scattering_properties(measure, medium_config, core_config, shell_config):
-    # Setup Gaussian source
-    source = Gaussian(
-        wavelength=np.linspace(400e-9, 1800e-9, 50),
-        polarization_value=0,
-        polarization_type='linear',
-        optical_power=1e-3,
-        NA=0.2
-    )
-
-    # Setup core-shell scatterer
-    scatterer = CoreShell(
-        core_diameter=np.linspace(400e-9, 1400e-9, 10),
-        shell_width=300e-9,
-        source=source,
-        **medium_config,
-        **core_config,
-        **shell_config
-    )
-
-    # Setup detector
-    detector = Photodiode(
-        NA=0.2,
-        polarization_filter=None,
-        gamma_offset=0,
-        phi_offset=0,
-        sampling=100
-    )
-
-    # Configure and run the experiment
-    experiment = Setup(
-        scatterer=scatterer,
-        source=source,
-        detector=detector
-    )
-
-    # Execute measurement
-    experiment.get(measure)
-
-# -
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import pytest
+import numpy as np
+
+from PyMieSim.experiment.detector import Photodiode
+from PyMieSim.experiment.scatterer import CoreShell
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+import PyMieSim.measure as pms_measure
+from PyOptik import UsualMaterial
+
+# Define core materials and properties
+core_options = [
+    {'name': 'BK7', 'properties': {'core_material': UsualMaterial.BK7}},
+    {'name': 'Silver', 'properties': {'core_material': UsualMaterial.Silver}},
+    {'name': 'Aluminium', 'properties': {'core_material': UsualMaterial.Aluminium}},
+    {'name': 'Index', 'properties': {'core_index': 1.4}}
+]
+
+# Define shell materials and properties
+shell_options = [
+    {'name': 'BK7', 'properties': {'shell_material': UsualMaterial.BK7}},
+    {'name': 'Silver', 'properties': {'shell_material': UsualMaterial.Silver}},
+    {'name': 'Aluminium', 'properties': {'shell_material': UsualMaterial.Aluminium}},
+    {'name': 'Index', 'properties': {'shell_index': 1.4}}
+]
+
+# Define medium materials and properties
+medium_options = [
+    {'name': 'BK7', 'properties': {'medium_material': UsualMaterial.Water}},
+    {'name': 'BK7', 'properties': {'medium_material': UsualMaterial.Water}},
+    {'name': 'Index', 'properties': {'medium_index': 1.1}}
+]
+
+# Define measures to test
+measures = [
+    pms_measure.Qsca, pms_measure.Qabs, pms_measure.Qback,
+    pms_measure.g, pms_measure.a1, pms_measure.b1, pms_measure.coupling
+]
+
+
+@pytest.mark.parametrize('medium_config', [m['properties'] for m in medium_options], ids=[m['name'] for m in medium_options])
+@pytest.mark.parametrize('shell_config', [s['properties'] for s in shell_options], ids=[s['name'] for s in shell_options])
+@pytest.mark.parametrize('core_config', [c['properties'] for c in core_options], ids=[c['name'] for c in core_options])
+@pytest.mark.parametrize('measure', measures, ids=[m.short_label for m in measures])
+def test_coreshell_scattering_properties(measure, medium_config, core_config, shell_config):
+    # Setup Gaussian source
+    source = Gaussian(
+        wavelength=np.linspace(400e-9, 1800e-9, 50),
+        polarization_value=0,
+        polarization_type='linear',
+        optical_power=1e-3,
+        NA=0.2
+    )
+
+    # Setup core-shell scatterer
+    scatterer = CoreShell(
+        core_diameter=np.linspace(400e-9, 1400e-9, 10),
+        shell_width=300e-9,
+        source=source,
+        **medium_config,
+        **core_config,
+        **shell_config
+    )
+
+    # Setup detector
+    detector = Photodiode(
+        NA=0.2,
+        polarization_filter=None,
+        gamma_offset=0,
+        phi_offset=0,
+        sampling=100
+    )
+
+    # Configure and run the experiment
+    experiment = Setup(
+        scatterer=scatterer,
+        source=source,
+        detector=detector
+    )
+
+    # Execute measurement
+    experiment.get(measure)
+
+# -
```

## tests/experiments/test_cylinder.py

 * *Ordering differences only*

```diff
@@ -1,76 +1,76 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-import pytest
-import numpy as np
-
-from PyMieSim.experiment.detector import Photodiode
-from PyMieSim.experiment.scatterer import Cylinder
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-import PyMieSim.measure as pms_measure
-from PyOptik import UsualMaterial
-
-# Material configurations for the cylinder core
-core_options = [
-    {'name': 'BK7', 'properties': {'material': UsualMaterial.BK7}},
-    {'name': 'Silver', 'properties': {'material': UsualMaterial.Silver}},
-    {'name': 'Aluminium', 'properties': {'material': UsualMaterial.Aluminium}},
-    {'name': 'Index', 'properties': {'index': 1.4}}
-]
-
-# Medium configurations
-medium_options = [
-    {'name': 'BK7', 'properties': {'medium_material': UsualMaterial.BK7}},
-    {'name': 'Index', 'properties': {'medium_index': 1.1}}
-]
-
-# Measures to be tested
-measures = [
-    pms_measure.Qsca,
-    pms_measure.Qabs,
-    pms_measure.coupling
-]
-
-
-@pytest.mark.parametrize('medium_config', [m['properties'] for m in medium_options], ids=[m['name'] for m in medium_options])
-@pytest.mark.parametrize('core_config', [c['properties'] for c in core_options], ids=[c['name'] for c in core_options])
-@pytest.mark.parametrize('measure', measures, ids=[m.short_label for m in measures])
-def test_cylinder_scattering_properties(measure, medium_config, core_config):
-    # Setup Gaussian source
-    source = Gaussian(
-        wavelength=np.linspace(400e-9, 1800e-9, 50),
-        polarization_value=0,
-        polarization_type='linear',
-        optical_power=1e-3,
-        NA=0.2
-    )
-
-    # Setup cylindrical scatterer
-    scatterer = Cylinder(
-        diameter=np.linspace(400e-9, 1400e-9, 10),
-        source=source,
-        **medium_config,
-        **core_config
-    )
-
-    # Setup detector
-    detector = Photodiode(
-        NA=0.2,
-        polarization_filter=None,
-        gamma_offset=0,
-        phi_offset=0,
-        sampling=100
-    )
-
-    # Configure and run the experiment
-    experiment = Setup(
-        scatterer=scatterer,
-        source=source,
-        detector=detector
-    )
-
-    # Execute measurement
-    experiment.get(measure)
-
-# -
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import pytest
+import numpy as np
+
+from PyMieSim.experiment.detector import Photodiode
+from PyMieSim.experiment.scatterer import Cylinder
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+import PyMieSim.measure as pms_measure
+from PyOptik import UsualMaterial
+
+# Material configurations for the cylinder core
+core_options = [
+    {'name': 'BK7', 'properties': {'material': UsualMaterial.BK7}},
+    {'name': 'Silver', 'properties': {'material': UsualMaterial.Silver}},
+    {'name': 'Aluminium', 'properties': {'material': UsualMaterial.Aluminium}},
+    {'name': 'Index', 'properties': {'index': 1.4}}
+]
+
+# Medium configurations
+medium_options = [
+    {'name': 'BK7', 'properties': {'medium_material': UsualMaterial.BK7}},
+    {'name': 'Index', 'properties': {'medium_index': 1.1}}
+]
+
+# Measures to be tested
+measures = [
+    pms_measure.Qsca,
+    pms_measure.Qabs,
+    pms_measure.coupling
+]
+
+
+@pytest.mark.parametrize('medium_config', [m['properties'] for m in medium_options], ids=[m['name'] for m in medium_options])
+@pytest.mark.parametrize('core_config', [c['properties'] for c in core_options], ids=[c['name'] for c in core_options])
+@pytest.mark.parametrize('measure', measures, ids=[m.short_label for m in measures])
+def test_cylinder_scattering_properties(measure, medium_config, core_config):
+    # Setup Gaussian source
+    source = Gaussian(
+        wavelength=np.linspace(400e-9, 1800e-9, 50),
+        polarization_value=0,
+        polarization_type='linear',
+        optical_power=1e-3,
+        NA=0.2
+    )
+
+    # Setup cylindrical scatterer
+    scatterer = Cylinder(
+        diameter=np.linspace(400e-9, 1400e-9, 10),
+        source=source,
+        **medium_config,
+        **core_config
+    )
+
+    # Setup detector
+    detector = Photodiode(
+        NA=0.2,
+        polarization_filter=None,
+        gamma_offset=0,
+        phi_offset=0,
+        sampling=100
+    )
+
+    # Configure and run the experiment
+    experiment = Setup(
+        scatterer=scatterer,
+        source=source,
+        detector=detector
+    )
+
+    # Execute measurement
+    experiment.get(measure)
+
+# -
```

## tests/experiments/test_sphere.py

 * *Ordering differences only*

```diff
@@ -1,75 +1,75 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-import pytest
-import numpy as np
-
-from PyMieSim.experiment.detector import Photodiode
-from PyMieSim.experiment.scatterer import Sphere
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-import PyMieSim.measure as pms_measure
-from PyOptik import UsualMaterial
-
-# Configure the core materials for the sphere
-core_options = [
-    {'name': 'BK7', 'properties': {'material': UsualMaterial.BK7}},
-    {'name': 'Silver', 'properties': {'material': UsualMaterial.Silver}},
-    {'name': 'Aluminium', 'properties': {'material': UsualMaterial.Aluminium}},
-    {'name': 'Index', 'properties': {'index': 1.4}}
-]
-
-# Define medium options
-medium_options = [
-    {'name': 'BK7', 'properties': {'medium_material': UsualMaterial.BK7}},
-    {'name': 'Index', 'properties': {'medium_index': 1.1}}
-]
-
-# List of measures to be tested
-measures = [
-    pms_measure.Qsca, pms_measure.Qabs, pms_measure.Qback,
-    pms_measure.g, pms_measure.a1, pms_measure.b1, pms_measure.coupling
-]
-
-
-@pytest.mark.parametrize('medium_config', [m['properties'] for m in medium_options], ids=[m['name'] for m in medium_options])
-@pytest.mark.parametrize('core_config', [c['properties'] for c in core_options], ids=[c['name'] for c in core_options])
-@pytest.mark.parametrize('measure', measures, ids=[m.short_label for m in measures])
-def test_sphere_scattering_properties(measure, core_config, medium_config):
-    # Set up the Gaussian source
-    source = Gaussian(
-        wavelength=np.linspace(400e-9, 1800e-9, 50),
-        polarization_value=0,
-        polarization_type='linear',
-        optical_power=1e-3,
-        NA=0.2
-    )
-
-    # Configure the spherical scatterer
-    scatterer = Sphere(
-        diameter=np.linspace(400e-9, 1400e-9, 10),
-        source=source,
-        **medium_config,
-        **core_config
-    )
-
-    # Configure the detector
-    detector = Photodiode(
-        NA=0.2,
-        polarization_filter=None,
-        gamma_offset=0,
-        phi_offset=0,
-        sampling=100
-    )
-
-    # Set up and run the experiment
-    experiment = Setup(
-        scatterer=scatterer,
-        source=source,
-        detector=detector
-    )
-
-    # Perform the measurement
-    experiment.get(measure)
-
-# -
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import pytest
+import numpy as np
+
+from PyMieSim.experiment.detector import Photodiode
+from PyMieSim.experiment.scatterer import Sphere
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+import PyMieSim.measure as pms_measure
+from PyOptik import UsualMaterial
+
+# Configure the core materials for the sphere
+core_options = [
+    {'name': 'BK7', 'properties': {'material': UsualMaterial.BK7}},
+    {'name': 'Silver', 'properties': {'material': UsualMaterial.Silver}},
+    {'name': 'Aluminium', 'properties': {'material': UsualMaterial.Aluminium}},
+    {'name': 'Index', 'properties': {'index': 1.4}}
+]
+
+# Define medium options
+medium_options = [
+    {'name': 'BK7', 'properties': {'medium_material': UsualMaterial.BK7}},
+    {'name': 'Index', 'properties': {'medium_index': 1.1}}
+]
+
+# List of measures to be tested
+measures = [
+    pms_measure.Qsca, pms_measure.Qabs, pms_measure.Qback,
+    pms_measure.g, pms_measure.a1, pms_measure.b1, pms_measure.coupling
+]
+
+
+@pytest.mark.parametrize('medium_config', [m['properties'] for m in medium_options], ids=[m['name'] for m in medium_options])
+@pytest.mark.parametrize('core_config', [c['properties'] for c in core_options], ids=[c['name'] for c in core_options])
+@pytest.mark.parametrize('measure', measures, ids=[m.short_label for m in measures])
+def test_sphere_scattering_properties(measure, core_config, medium_config):
+    # Set up the Gaussian source
+    source = Gaussian(
+        wavelength=np.linspace(400e-9, 1800e-9, 50),
+        polarization_value=0,
+        polarization_type='linear',
+        optical_power=1e-3,
+        NA=0.2
+    )
+
+    # Configure the spherical scatterer
+    scatterer = Sphere(
+        diameter=np.linspace(400e-9, 1400e-9, 10),
+        source=source,
+        **medium_config,
+        **core_config
+    )
+
+    # Configure the detector
+    detector = Photodiode(
+        NA=0.2,
+        polarization_filter=None,
+        gamma_offset=0,
+        phi_offset=0,
+        sampling=100
+    )
+
+    # Set up and run the experiment
+    experiment = Setup(
+        scatterer=scatterer,
+        source=source,
+        detector=detector
+    )
+
+    # Perform the measurement
+    experiment.get(measure)
+
+# -
```

## tests/extra/test_mesh.py

 * *Ordering differences only*

```diff
@@ -1,13 +1,13 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-from PyMieSim.mesh import FibonacciMesh
-
-
-def test_fibonacci_mesh():
-    mesh = FibonacciMesh(
-        max_angle=1.3,
-        sampling=100
-    )
-
-    mesh.plot()
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+from PyMieSim.mesh import FibonacciMesh
+
+
+def test_fibonacci_mesh():
+    mesh = FibonacciMesh(
+        max_angle=1.3,
+        sampling=100
+    )
+
+    mesh.plot()
```

## tests/scatterers/test_coreshell.py

 * *Ordering differences only*

```diff
@@ -1,125 +1,125 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-import pytest
-from PyMieSim.single.scatterer import CoreShell
-from PyMieSim.single.source import Gaussian
-from PyMieSim.single.detector import Photodiode
-from PyOptik import UsualMaterial
-
-# Core and shell configurations with clear separation of test ids and parameters
-core_configs = [
-    {'config': {'core_material': UsualMaterial.BK7}, 'id': 'BK7'},
-    {'config': {'core_material': UsualMaterial.Silver}, 'id': 'Silver'},
-    {'config': {'core_index': 1.4}, 'id': 'Index 1.4'}
-]
-
-shell_configs = [
-    {'config': {'shell_material': UsualMaterial.BK7}, 'id': 'BK7'},
-    {'config': {'shell_material': UsualMaterial.Silver}, 'id': 'Silver'},
-    {'config': {'shell_material': UsualMaterial.Aluminium}, 'id': 'Aluminium'},
-    {'config': {'shell_index': 1.4}, 'id': 'Index 1.4'}
-]
-
-# Methods and attributes to test
-methods = [
-    "get_far_field",
-    "get_stokes",
-    "get_spf",
-    "get_s1s2",
-    "an",
-    "bn",
-]
-
-attributes = [
-    "size_parameter",
-    "area",
-    "Qsca",
-    "Qext",
-    "Qback",
-    "Qratio",
-    "Qpr",
-    "Csca",
-    "Cext",
-    "Cback",
-    "Cratio",
-    "Cpr",
-]
-
-
-@pytest.mark.parametrize('shell_config', shell_configs, ids=[config['id'] for config in shell_configs])
-@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
-@pytest.mark.parametrize('method', methods)
-def test_coreshell_method(method, core_config, shell_config):
-    source = Gaussian(
-        wavelength=750e-9,
-        polarization_value=0,
-        polarization_type='linear',
-        optical_power=1,
-        NA=0.3
-    )
-    scatterer = CoreShell(
-        core_diameter=100e-9,
-        shell_width=200e-9,
-        source=source,
-        medium_index=1.0,
-        **core_config['config'],
-        **shell_config['config']
-    )
-
-    # Execute the method
-    _ = getattr(scatterer, method)()
-
-
-@pytest.mark.parametrize('shell_config', shell_configs, ids=[config['id'] for config in shell_configs])
-@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
-def test_coreshell_coupling(core_config, shell_config):
-    detector = Photodiode(
-        NA=0.2,
-        gamma_offset=0,
-        phi_offset=0,
-    )
-    source = Gaussian(
-        wavelength=750e-9,
-        polarization_value=0,
-        polarization_type='linear',
-        optical_power=1,
-        NA=0.3
-    )
-    scatterer = CoreShell(
-        core_diameter=100e-9,
-        shell_width=200e-9,
-        source=source,
-        medium_index=1.0,
-        **core_config['config'],
-        **shell_config['config']
-    )
-
-    # Calculate optical coupling
-    _ = detector.coupling(scatterer)
-
-
-@pytest.mark.parametrize('shell_config', shell_configs, ids=[config['id'] for config in shell_configs])
-@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
-@pytest.mark.parametrize('attribute', attributes)
-def test_coreshell_attribute(attribute, core_config, shell_config):
-    source = Gaussian(
-        wavelength=750e-9,
-        polarization_value=0,
-        polarization_type='linear',
-        optical_power=1,
-        NA=0.3
-    )
-    scatterer = CoreShell(
-        core_diameter=100e-9,
-        shell_width=200e-9,
-        source=source,
-        medium_index=1.0,
-        **core_config['config'],
-        **shell_config['config']
-    )
-
-    # Access and verify the attribute
-    _ = getattr(scatterer, attribute)
-
-# -
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import pytest
+from PyMieSim.single.scatterer import CoreShell
+from PyMieSim.single.source import Gaussian
+from PyMieSim.single.detector import Photodiode
+from PyOptik import UsualMaterial
+
+# Core and shell configurations with clear separation of test ids and parameters
+core_configs = [
+    {'config': {'core_material': UsualMaterial.BK7}, 'id': 'BK7'},
+    {'config': {'core_material': UsualMaterial.Silver}, 'id': 'Silver'},
+    {'config': {'core_index': 1.4}, 'id': 'Index 1.4'}
+]
+
+shell_configs = [
+    {'config': {'shell_material': UsualMaterial.BK7}, 'id': 'BK7'},
+    {'config': {'shell_material': UsualMaterial.Silver}, 'id': 'Silver'},
+    {'config': {'shell_material': UsualMaterial.Aluminium}, 'id': 'Aluminium'},
+    {'config': {'shell_index': 1.4}, 'id': 'Index 1.4'}
+]
+
+# Methods and attributes to test
+methods = [
+    "get_far_field",
+    "get_stokes",
+    "get_spf",
+    "get_s1s2",
+    "an",
+    "bn",
+]
+
+attributes = [
+    "size_parameter",
+    "area",
+    "Qsca",
+    "Qext",
+    "Qback",
+    "Qratio",
+    "Qpr",
+    "Csca",
+    "Cext",
+    "Cback",
+    "Cratio",
+    "Cpr",
+]
+
+
+@pytest.mark.parametrize('shell_config', shell_configs, ids=[config['id'] for config in shell_configs])
+@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
+@pytest.mark.parametrize('method', methods)
+def test_coreshell_method(method, core_config, shell_config):
+    source = Gaussian(
+        wavelength=750e-9,
+        polarization_value=0,
+        polarization_type='linear',
+        optical_power=1,
+        NA=0.3
+    )
+    scatterer = CoreShell(
+        core_diameter=100e-9,
+        shell_width=200e-9,
+        source=source,
+        medium_index=1.0,
+        **core_config['config'],
+        **shell_config['config']
+    )
+
+    # Execute the method
+    _ = getattr(scatterer, method)()
+
+
+@pytest.mark.parametrize('shell_config', shell_configs, ids=[config['id'] for config in shell_configs])
+@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
+def test_coreshell_coupling(core_config, shell_config):
+    detector = Photodiode(
+        NA=0.2,
+        gamma_offset=0,
+        phi_offset=0,
+    )
+    source = Gaussian(
+        wavelength=750e-9,
+        polarization_value=0,
+        polarization_type='linear',
+        optical_power=1,
+        NA=0.3
+    )
+    scatterer = CoreShell(
+        core_diameter=100e-9,
+        shell_width=200e-9,
+        source=source,
+        medium_index=1.0,
+        **core_config['config'],
+        **shell_config['config']
+    )
+
+    # Calculate optical coupling
+    _ = detector.coupling(scatterer)
+
+
+@pytest.mark.parametrize('shell_config', shell_configs, ids=[config['id'] for config in shell_configs])
+@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
+@pytest.mark.parametrize('attribute', attributes)
+def test_coreshell_attribute(attribute, core_config, shell_config):
+    source = Gaussian(
+        wavelength=750e-9,
+        polarization_value=0,
+        polarization_type='linear',
+        optical_power=1,
+        NA=0.3
+    )
+    scatterer = CoreShell(
+        core_diameter=100e-9,
+        shell_width=200e-9,
+        source=source,
+        medium_index=1.0,
+        **core_config['config'],
+        **shell_config['config']
+    )
+
+    # Access and verify the attribute
+    _ = getattr(scatterer, attribute)
+
+# -
```

## tests/scatterers/test_cylinder.py

 * *Ordering differences only*

```diff
@@ -1,109 +1,109 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-import pytest
-from PyMieSim.single.scatterer import Cylinder
-from PyMieSim.single.source import Gaussian
-from PyMieSim.single.detector import Photodiode
-from PyOptik import UsualMaterial
-
-# Core configurations separated for clarity and functionality
-core_configs = [
-    {'config': {'material': UsualMaterial.BK7}, 'id': 'BK7'},
-    {'config': {'material': UsualMaterial.Silver}, 'id': 'Silver'},
-    {'config': {'index': 1.4}, 'id': 'Index 1.4'}
-]
-
-# Methods to be tested
-methods = [
-    "get_far_field",
-    "get_stokes",
-    "get_spf",
-    "get_s1s2",
-    "a1n",
-    "a2n",
-    "b1n",
-    "b2n",
-]
-
-# Attributes to check
-attributes = [
-    "size_parameter",
-    "area",
-    "Qsca",
-    "Qext",
-    "Qabs",
-    "Csca",
-    "Cext",
-    "Cabs",
-    "g",
-]
-
-
-@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
-@pytest.mark.parametrize('method', methods)
-def test_cylinder_methods(method, core_config):
-    source = Gaussian(
-        wavelength=750e-9,
-        polarization_value=0,
-        polarization_type='linear',
-        optical_power=1,
-        NA=0.3
-    )
-    scatterer = Cylinder(
-        diameter=100e-9,
-        source=source,
-        medium_index=1.0,
-        **core_config['config']
-    )
-
-    # Execute method
-    _ = getattr(scatterer, method)()
-
-
-@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
-def test_cylinder_coupling(core_config):
-    detector = Photodiode(
-        NA=0.2,
-        gamma_offset=0,
-        phi_offset=0,
-    )
-    source = Gaussian(
-        wavelength=750e-9,
-        polarization_value=0,
-        polarization_type='linear',
-        optical_power=1,
-        NA=0.3
-    )
-    scatterer = Cylinder(
-        diameter=100e-9,
-        source=source,
-        medium_index=1.0,
-        **core_config['config']
-    )
-
-    # Calculate optical coupling
-    _ = detector.coupling(scatterer)
-
-
-@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
-@pytest.mark.parametrize('attribute', attributes)
-def test_cylinder_attributes(attribute, core_config):
-    source = Gaussian(
-        wavelength=750e-9,
-        polarization_value=0,
-        polarization_type='linear',
-        optical_power=1,
-        NA=0.3
-    )
-    scatterer = Cylinder(
-        diameter=100e-9,
-        source=source,
-        medium_index=1.0,
-        **core_config['config']
-    )
-
-    # Access and validate the specified attribute
-    _ = getattr(scatterer, attribute)
-
-# -
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import pytest
+from PyMieSim.single.scatterer import Cylinder
+from PyMieSim.single.source import Gaussian
+from PyMieSim.single.detector import Photodiode
+from PyOptik import UsualMaterial
+
+# Core configurations separated for clarity and functionality
+core_configs = [
+    {'config': {'material': UsualMaterial.BK7}, 'id': 'BK7'},
+    {'config': {'material': UsualMaterial.Silver}, 'id': 'Silver'},
+    {'config': {'index': 1.4}, 'id': 'Index 1.4'}
+]
+
+# Methods to be tested
+methods = [
+    "get_far_field",
+    "get_stokes",
+    "get_spf",
+    "get_s1s2",
+    "a1n",
+    "a2n",
+    "b1n",
+    "b2n",
+]
+
+# Attributes to check
+attributes = [
+    "size_parameter",
+    "area",
+    "Qsca",
+    "Qext",
+    "Qabs",
+    "Csca",
+    "Cext",
+    "Cabs",
+    "g",
+]
+
+
+@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
+@pytest.mark.parametrize('method', methods)
+def test_cylinder_methods(method, core_config):
+    source = Gaussian(
+        wavelength=750e-9,
+        polarization_value=0,
+        polarization_type='linear',
+        optical_power=1,
+        NA=0.3
+    )
+    scatterer = Cylinder(
+        diameter=100e-9,
+        source=source,
+        medium_index=1.0,
+        **core_config['config']
+    )
+
+    # Execute method
+    _ = getattr(scatterer, method)()
+
+
+@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
+def test_cylinder_coupling(core_config):
+    detector = Photodiode(
+        NA=0.2,
+        gamma_offset=0,
+        phi_offset=0,
+    )
+    source = Gaussian(
+        wavelength=750e-9,
+        polarization_value=0,
+        polarization_type='linear',
+        optical_power=1,
+        NA=0.3
+    )
+    scatterer = Cylinder(
+        diameter=100e-9,
+        source=source,
+        medium_index=1.0,
+        **core_config['config']
+    )
+
+    # Calculate optical coupling
+    _ = detector.coupling(scatterer)
+
+
+@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
+@pytest.mark.parametrize('attribute', attributes)
+def test_cylinder_attributes(attribute, core_config):
+    source = Gaussian(
+        wavelength=750e-9,
+        polarization_value=0,
+        polarization_type='linear',
+        optical_power=1,
+        NA=0.3
+    )
+    scatterer = Cylinder(
+        diameter=100e-9,
+        source=source,
+        medium_index=1.0,
+        **core_config['config']
+    )
+
+    # Access and validate the specified attribute
+    _ = getattr(scatterer, attribute)
+
+# -
```

## tests/scatterers/test_sphere.py

 * *Ordering differences only*

```diff
@@ -1,105 +1,105 @@
-import pytest
-from PyMieSim.single.scatterer import Sphere
-from PyMieSim.single.source import Gaussian
-from PyMieSim.single.detector import Photodiode
-from PyOptik import UsualMaterial
-
-# Define the core configurations for testing, now separated 'id' for clarity in tests
-core_configs = [
-    {'config': {'material': UsualMaterial.BK7}, 'id': 'BK7'},
-    {'config': {'material': UsualMaterial.Silver}, 'id': 'Silver'},
-    {'config': {'index': 1.4}, 'id': 'Index 1.4'}
-]
-
-methods = ["an", "bn"]
-
-attributes = [
-    "size_parameter", "area", "Qsca", "Qext", "Qback", "Qratio",
-    "Qpr", "Csca", "Cext", "Cback", "Cratio", "Cpr",
-]
-
-plottings = [
-    "get_far_field", "get_stokes", "get_spf", "get_s1s2",
-]
-
-
-@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
-@pytest.mark.parametrize('method', methods)
-def test_sphere_method(method, core_config):
-    source = Gaussian(
-        wavelength=750e-9,
-        polarization_value=0,
-        polarization_type='linear',
-        optical_power=1,
-        NA=0.3
-    )
-    # Pass only the actual configuration dictionary to the constructor
-    scatterer = Sphere(
-        diameter=100e-9,
-        source=source,
-        medium_index=1.0,
-        **core_config['config']
-    )
-    _ = getattr(scatterer, method)()
-
-
-@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
-@pytest.mark.parametrize('attribute', attributes)
-def test_sphere_attribute(attribute, core_config):
-    source = Gaussian(
-        wavelength=750e-9,
-        polarization_value=0,
-        polarization_type='linear',
-        optical_power=1,
-        NA=0.3
-    )
-    scatterer = Sphere(
-        diameter=100e-9,
-        source=source,
-        medium_index=1.0,
-        **core_config['config']
-    )
-    _ = getattr(scatterer, attribute)
-
-
-@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
-def test_sphere_coupling(core_config):
-    detector = Photodiode(
-        NA=0.2,
-        gamma_offset=0,
-        phi_offset=0,
-    )
-    source = Gaussian(
-        wavelength=750e-9,
-        polarization_value=0,
-        polarization_type='linear',
-        optical_power=1,
-        NA=0.3
-    )
-    scatterer = Sphere(
-        diameter=100e-9,
-        source=source,
-        medium_index=1.0,
-        **core_config['config']
-    )
-    _ = detector.coupling(scatterer)
-
-
-@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
-@pytest.mark.parametrize('plotting', plottings)
-def test_sphere_plottings(plotting, core_config):
-    source = Gaussian(
-        wavelength=750e-9,
-        polarization_value=0,
-        polarization_type='linear',
-        optical_power=1,
-        NA=0.3
-    )
-    scatterer = Sphere(
-        diameter=100e-9,
-        source=source,
-        medium_index=1.0,
-        **core_config['config']
-    )
-    data = getattr(scatterer, plotting)()
-    assert data is not None, "Plotting data should not be None"
+import pytest
+from PyMieSim.single.scatterer import Sphere
+from PyMieSim.single.source import Gaussian
+from PyMieSim.single.detector import Photodiode
+from PyOptik import UsualMaterial
+
+# Define the core configurations for testing, now separated 'id' for clarity in tests
+core_configs = [
+    {'config': {'material': UsualMaterial.BK7}, 'id': 'BK7'},
+    {'config': {'material': UsualMaterial.Silver}, 'id': 'Silver'},
+    {'config': {'index': 1.4}, 'id': 'Index 1.4'}
+]
+
+methods = ["an", "bn"]
+
+attributes = [
+    "size_parameter", "area", "Qsca", "Qext", "Qback", "Qratio",
+    "Qpr", "Csca", "Cext", "Cback", "Cratio", "Cpr",
+]
+
+plottings = [
+    "get_far_field", "get_stokes", "get_spf", "get_s1s2",
+]
+
+
+@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
+@pytest.mark.parametrize('method', methods)
+def test_sphere_method(method, core_config):
+    source = Gaussian(
+        wavelength=750e-9,
+        polarization_value=0,
+        polarization_type='linear',
+        optical_power=1,
+        NA=0.3
+    )
+    # Pass only the actual configuration dictionary to the constructor
+    scatterer = Sphere(
+        diameter=100e-9,
+        source=source,
+        medium_index=1.0,
+        **core_config['config']
+    )
+    _ = getattr(scatterer, method)()
+
+
+@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
+@pytest.mark.parametrize('attribute', attributes)
+def test_sphere_attribute(attribute, core_config):
+    source = Gaussian(
+        wavelength=750e-9,
+        polarization_value=0,
+        polarization_type='linear',
+        optical_power=1,
+        NA=0.3
+    )
+    scatterer = Sphere(
+        diameter=100e-9,
+        source=source,
+        medium_index=1.0,
+        **core_config['config']
+    )
+    _ = getattr(scatterer, attribute)
+
+
+@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
+def test_sphere_coupling(core_config):
+    detector = Photodiode(
+        NA=0.2,
+        gamma_offset=0,
+        phi_offset=0,
+    )
+    source = Gaussian(
+        wavelength=750e-9,
+        polarization_value=0,
+        polarization_type='linear',
+        optical_power=1,
+        NA=0.3
+    )
+    scatterer = Sphere(
+        diameter=100e-9,
+        source=source,
+        medium_index=1.0,
+        **core_config['config']
+    )
+    _ = detector.coupling(scatterer)
+
+
+@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
+@pytest.mark.parametrize('plotting', plottings)
+def test_sphere_plottings(plotting, core_config):
+    source = Gaussian(
+        wavelength=750e-9,
+        polarization_value=0,
+        polarization_type='linear',
+        optical_power=1,
+        NA=0.3
+    )
+    scatterer = Sphere(
+        diameter=100e-9,
+        source=source,
+        medium_index=1.0,
+        **core_config['config']
+    )
+    data = getattr(scatterer, plotting)()
+    assert data is not None, "Plotting data should not be None"
```

## tests/validation/test_coreshell_pymiescatt.py

 * *Ordering differences only*

```diff
@@ -1,110 +1,110 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-import pytest
-import numpy
-
-from PyMieSim.experiment.scatterer import CoreShell
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-
-from PyMieSim import measure
-
-import PyMieScatt as ps
-PyMieScatt_measures = {
-    'Qext': 0,
-    'Qsca': 1,
-    'Qabs': 2,
-    'g': 3,
-    'Qpr': 4,
-    'Qback': 5,
-    'Qratio': 6
-}
-
-
-def get_PyMieSim_data(source, core_index, shell_index, core_diameters, shell_width, measure_string: str):
-    scatterer = CoreShell(
-        core_diameter=core_diameters,
-        shell_width=shell_width,
-        core_index=core_index,
-        shell_index=shell_index,
-        medium_index=1.,
-        source=source
-    )
-
-    experiment = Setup(
-        scatterer=scatterer,
-        source=source,
-        detector=None
-    )
-
-    data = experiment.get(getattr(measure, measure_string), export_as_numpy=True)
-
-    return data.squeeze()
-
-
-def get_PyMieScatt_data(source, core_index, shell_index, core_diameters, shell_width, measure_string: str):
-    PyMieScatt_data = []
-    for core_diameter in core_diameters:
-        efficiencies = ps.MieQCoreShell(
-            mCore=core_index,
-            mShell=shell_index,
-            wavelength=source.wavelength[0],
-            dCore=core_diameter,
-            dShell=core_diameter + shell_width
-        )
-
-        measure_idx = PyMieScatt_measures.get(measure_string)
-        data = efficiencies[measure_idx]
-        PyMieScatt_data.append(float(data))
-
-    return numpy.asarray(PyMieScatt_data).squeeze()
-
-
-def get_comparison(wavelength, core_index, shell_index, core_diameters, shell_width, measure_string: str):
-    source = Gaussian(
-        wavelength=wavelength,
-        polarization_value=0,
-        polarization_type='linear',
-        optical_power=1e-3,
-        NA=0.2
-    )
-
-    PyMieScatt_data = get_PyMieScatt_data(
-        source=source,
-        core_index=core_index,
-        shell_index=shell_index,
-        core_diameters=core_diameters,
-        shell_width=shell_width,
-        measure_string=measure_string
-    )
-
-    PyMieSim_data = get_PyMieSim_data(
-        source=source,
-        core_index=core_index,
-        shell_index=shell_index,
-        core_diameters=core_diameters,
-        shell_width=shell_width,
-        measure_string=measure_string
-    )
-
-    return PyMieSim_data, PyMieScatt_data
-
-
-@pytest.mark.parametrize('measure_string', ['Qext', 'Qsca', 'Qabs', 'g', 'Qpr'])
-def test_comparison(measure_string: str):
-    PyMieSim_data, PyMieScatt_data = get_comparison(
-        wavelength=632e-9,
-        core_index=1.4 + 0.3j,
-        shell_index=1.3,
-        core_diameters=numpy.geomspace(10e-9, 6000e-9, 800),
-        shell_width=600e-9,
-        measure_string=measure_string
-    )
-
-    discrepency = numpy.isclose(PyMieSim_data, PyMieScatt_data, atol=0, rtol=1e-4)
-
-    if not discrepency.astype(int).mean() > 0.5:
-        raise ValueError('Error: mismatch on PyMieScatt calculation occuring')
-
-# -
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import pytest
+import numpy
+
+from PyMieSim.experiment.scatterer import CoreShell
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+
+from PyMieSim import measure
+
+import PyMieScatt as ps
+PyMieScatt_measures = {
+    'Qext': 0,
+    'Qsca': 1,
+    'Qabs': 2,
+    'g': 3,
+    'Qpr': 4,
+    'Qback': 5,
+    'Qratio': 6
+}
+
+
+def get_PyMieSim_data(source, core_index, shell_index, core_diameters, shell_width, measure_string: str):
+    scatterer = CoreShell(
+        core_diameter=core_diameters,
+        shell_width=shell_width,
+        core_index=core_index,
+        shell_index=shell_index,
+        medium_index=1.,
+        source=source
+    )
+
+    experiment = Setup(
+        scatterer=scatterer,
+        source=source,
+        detector=None
+    )
+
+    data = experiment.get(getattr(measure, measure_string), export_as_numpy=True)
+
+    return data.squeeze()
+
+
+def get_PyMieScatt_data(source, core_index, shell_index, core_diameters, shell_width, measure_string: str):
+    PyMieScatt_data = []
+    for core_diameter in core_diameters:
+        efficiencies = ps.MieQCoreShell(
+            mCore=core_index,
+            mShell=shell_index,
+            wavelength=source.wavelength[0],
+            dCore=core_diameter,
+            dShell=core_diameter + shell_width
+        )
+
+        measure_idx = PyMieScatt_measures.get(measure_string)
+        data = efficiencies[measure_idx]
+        PyMieScatt_data.append(float(data))
+
+    return numpy.asarray(PyMieScatt_data).squeeze()
+
+
+def get_comparison(wavelength, core_index, shell_index, core_diameters, shell_width, measure_string: str):
+    source = Gaussian(
+        wavelength=wavelength,
+        polarization_value=0,
+        polarization_type='linear',
+        optical_power=1e-3,
+        NA=0.2
+    )
+
+    PyMieScatt_data = get_PyMieScatt_data(
+        source=source,
+        core_index=core_index,
+        shell_index=shell_index,
+        core_diameters=core_diameters,
+        shell_width=shell_width,
+        measure_string=measure_string
+    )
+
+    PyMieSim_data = get_PyMieSim_data(
+        source=source,
+        core_index=core_index,
+        shell_index=shell_index,
+        core_diameters=core_diameters,
+        shell_width=shell_width,
+        measure_string=measure_string
+    )
+
+    return PyMieSim_data, PyMieScatt_data
+
+
+@pytest.mark.parametrize('measure_string', ['Qext', 'Qsca', 'Qabs', 'g', 'Qpr'])
+def test_comparison(measure_string: str):
+    PyMieSim_data, PyMieScatt_data = get_comparison(
+        wavelength=632e-9,
+        core_index=1.4 + 0.3j,
+        shell_index=1.3,
+        core_diameters=numpy.geomspace(10e-9, 6000e-9, 800),
+        shell_width=600e-9,
+        measure_string=measure_string
+    )
+
+    discrepency = numpy.isclose(PyMieSim_data, PyMieScatt_data, atol=0, rtol=1e-4)
+
+    if not discrepency.astype(int).mean() > 0.5:
+        raise ValueError('Error: mismatch on PyMieScatt calculation occuring')
+
+# -
```

## tests/validation/test_detector.py

 * *Ordering differences only*

```diff
@@ -1,121 +1,121 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-import numpy
-import pytest
-from PyMieSim import single
-from PyMieSim import experiment, measure
-
-
-@pytest.fixture
-def source_single():
-    """Fixture for creating a Gaussian source reused across tests."""
-    return single.source.Gaussian(
-        wavelength=1e-6,
-        polarization_value=0,
-        polarization_type='linear',
-        optical_power=1,
-        NA=0.3
-    )
-
-
-@pytest.fixture
-def source_experiment():
-    """Fixture for creating a Gaussian source reused across tests."""
-    return experiment.source.Gaussian(
-        wavelength=1e-6,
-        polarization_value=0,
-        polarization_type='linear',
-        optical_power=1,
-        NA=0.3
-    )
-
-
-@pytest.fixture
-def scatterer_single(source_single):
-    """Fixture for creating a Gaussian source reused across tests."""
-    return single.scatterer.Sphere(
-        diameter=1e-6,
-        index=1.5 + 0.5j,
-        source=source_single,
-        medium_index=1
-    )
-
-
-@pytest.fixture
-def scatterer_experiment(source_experiment):
-    """Fixture for creating a Gaussian source reused across tests."""
-    return experiment.scatterer.Sphere(
-        diameter=1e-6,
-        index=1.5 + 0.5j,
-        source=source_experiment,
-        medium_index=1
-    )
-
-
-def test_detector_single_polarization_filter(source_single, scatterer_single):
-    detector_0 = single.detector.Photodiode(
-        NA=0.1,
-        gamma_offset=0,
-        phi_offset=90,
-        polarization_filter=0
-    )
-
-    detector_180 = single.detector.Photodiode(
-        NA=0.1,
-        gamma_offset=0,
-        phi_offset=90,
-        polarization_filter=180
-    )
-
-    coupling_0 = detector_0.coupling(scatterer_single)
-    coupling_180 = detector_180.coupling(scatterer_single)
-    if not numpy.isclose(coupling_0, coupling_180, atol=1e-5):
-        raise ValueError(f'Mismatch with coupling value for detector with rotation of 0 and 180 degrees. [{coupling_0} vs {coupling_180}]')
-
-
-def test_detector_single_rotation(source_single, scatterer_single):
-    detector_0 = single.detector.CoherentMode(
-        mode_number='LP11',
-        NA=0.1,
-        gamma_offset=0,
-        phi_offset=40,
-        polarization_filter=None,
-        rotation=0
-    )
-
-    detector_180 = single.detector.CoherentMode(
-        mode_number='LP11',
-        NA=0.1,
-        gamma_offset=0,
-        phi_offset=40,
-        polarization_filter=None,
-        rotation=180
-    )
-
-    coupling_0 = detector_0.coupling(scatterer_single)
-    coupling_180 = detector_180.coupling(scatterer_single)
-    if not numpy.isclose(coupling_0, coupling_180, atol=1e-5):
-        raise ValueError(f'Mismatch with coupling value for detector with rotation of 0 and 180 degrees. [{coupling_0} vs {coupling_180}]')
-
-
-def test_detector_experiment_polarization_filter(source_experiment, scatterer_experiment):
-    detector = experiment.detector.Photodiode(
-        NA=0.1,
-        gamma_offset=0,
-        phi_offset=90,
-        polarization_filter=[0, 180],
-        sampling=100
-    )
-
-    setup = experiment.Setup(
-        scatterer=scatterer_experiment,
-        detector=detector,
-        source=source_experiment
-    )
-
-    coupling_values = setup.get(measure=measure.coupling, export_as_numpy=True).squeeze()
-
-    if not coupling_values[0] == coupling_values[-1]:
-        raise ValueError('Mismatch with coupling value for detector with polarization filter of 0 and 180 degrees')
-# -
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import numpy
+import pytest
+from PyMieSim import single
+from PyMieSim import experiment, measure
+
+
+@pytest.fixture
+def source_single():
+    """Fixture for creating a Gaussian source reused across tests."""
+    return single.source.Gaussian(
+        wavelength=1e-6,
+        polarization_value=0,
+        polarization_type='linear',
+        optical_power=1,
+        NA=0.3
+    )
+
+
+@pytest.fixture
+def source_experiment():
+    """Fixture for creating a Gaussian source reused across tests."""
+    return experiment.source.Gaussian(
+        wavelength=1e-6,
+        polarization_value=0,
+        polarization_type='linear',
+        optical_power=1,
+        NA=0.3
+    )
+
+
+@pytest.fixture
+def scatterer_single(source_single):
+    """Fixture for creating a Gaussian source reused across tests."""
+    return single.scatterer.Sphere(
+        diameter=1e-6,
+        index=1.5 + 0.5j,
+        source=source_single,
+        medium_index=1
+    )
+
+
+@pytest.fixture
+def scatterer_experiment(source_experiment):
+    """Fixture for creating a Gaussian source reused across tests."""
+    return experiment.scatterer.Sphere(
+        diameter=1e-6,
+        index=1.5 + 0.5j,
+        source=source_experiment,
+        medium_index=1
+    )
+
+
+def test_detector_single_polarization_filter(source_single, scatterer_single):
+    detector_0 = single.detector.Photodiode(
+        NA=0.1,
+        gamma_offset=0,
+        phi_offset=90,
+        polarization_filter=0
+    )
+
+    detector_180 = single.detector.Photodiode(
+        NA=0.1,
+        gamma_offset=0,
+        phi_offset=90,
+        polarization_filter=180
+    )
+
+    coupling_0 = detector_0.coupling(scatterer_single)
+    coupling_180 = detector_180.coupling(scatterer_single)
+    if not numpy.isclose(coupling_0, coupling_180, atol=1e-5):
+        raise ValueError(f'Mismatch with coupling value for detector with rotation of 0 and 180 degrees. [{coupling_0} vs {coupling_180}]')
+
+
+def test_detector_single_rotation(source_single, scatterer_single):
+    detector_0 = single.detector.CoherentMode(
+        mode_number='LP11',
+        NA=0.1,
+        gamma_offset=0,
+        phi_offset=40,
+        polarization_filter=None,
+        rotation=0
+    )
+
+    detector_180 = single.detector.CoherentMode(
+        mode_number='LP11',
+        NA=0.1,
+        gamma_offset=0,
+        phi_offset=40,
+        polarization_filter=None,
+        rotation=180
+    )
+
+    coupling_0 = detector_0.coupling(scatterer_single)
+    coupling_180 = detector_180.coupling(scatterer_single)
+    if not numpy.isclose(coupling_0, coupling_180, atol=1e-5):
+        raise ValueError(f'Mismatch with coupling value for detector with rotation of 0 and 180 degrees. [{coupling_0} vs {coupling_180}]')
+
+
+def test_detector_experiment_polarization_filter(source_experiment, scatterer_experiment):
+    detector = experiment.detector.Photodiode(
+        NA=0.1,
+        gamma_offset=0,
+        phi_offset=90,
+        polarization_filter=[0, 180],
+        sampling=100
+    )
+
+    setup = experiment.Setup(
+        scatterer=scatterer_experiment,
+        detector=detector,
+        source=source_experiment
+    )
+
+    coupling_values = setup.get(measure=measure.coupling, export_as_numpy=True).squeeze()
+
+    if not coupling_values[0] == coupling_values[-1]:
+        raise ValueError('Mismatch with coupling value for detector with polarization filter of 0 and 180 degrees')
+# -
```

## tests/validation/test_sphere_internal.py

 * *Ordering differences only*

```diff
@@ -1,83 +1,83 @@
-import numpy
-
-from PyMieSim.single.scatterer import Sphere, CoreShell
-from PyMieSim.single.source import Gaussian
-from PyMieSim.single.detector import Photodiode
-from PyMieSim.mesh import FibonacciMesh  # noqa: F401
-
-
-def test_Qsca_cross_section():
-    source = Gaussian(
-        wavelength=1e-6,
-        polarization_value=0,
-        polarization_type='linear',
-        optical_power=1,
-        NA=0.3
-    )
-    sphere = Sphere(diameter=300e-9, index=1.4, source=source)
-    val0 = sphere.get_cross_section()
-    val1 = sphere.Qsca * sphere.area
-
-    if not numpy.isclose(val0, val1, atol=0, rtol=1e-5):
-        raise ValueError('Mismatch with testing values')
-
-
-def test_energy_flow_coupling():
-    source = Gaussian(
-        wavelength=1e-6,
-        polarization_value=0,
-        polarization_type='linear',
-        optical_power=1,
-        NA=0.3
-    )
-    sphere = Sphere(
-        diameter=300e-9,
-        index=1.4,
-        source=source
-    )
-
-    detector = Photodiode(
-        sampling=500,
-        NA=2.0,
-        gamma_offset=0,
-        phi_offset=0
-    )
-
-    val0 = sphere.get_energy_flow(detector.cpp_binding.mesh)
-    val1 = detector.coupling(sphere)
-
-    if not numpy.isclose(val0, val1, atol=0, rtol=1e-5):
-        raise ValueError('Mismatch with testing values')
-
-
-def test_compare_sphere_coreshell_0():
-    source = Gaussian(
-        wavelength=1e-6,
-        polarization_value=0,
-        polarization_type='linear',
-        optical_power=1,
-        NA=0.3
-    )
-
-    sphere = Sphere(
-        diameter=1e-6,
-        index=1.5,
-        source=source
-    )
-
-    coreshell = CoreShell(
-        core_diameter=1e-6,
-        shell_width=0,
-        core_index=1.5,
-        shell_index=1.8,
-        source=source
-    )
-
-    for parameter in ['Qsca', 'Qext', 'Qabs']:
-        value_sphere = getattr(sphere, parameter)
-        value_coreshell = getattr(coreshell, parameter)
-
-        if not numpy.isclose(value_sphere, value_coreshell, atol=1e-12, rtol=1e-5):
-            raise ValueError(f'Mismatch with juxtaposing CoreShell with zero shell and Sphere for parameter: {parameter}')
-
-# -
+import numpy
+
+from PyMieSim.single.scatterer import Sphere, CoreShell
+from PyMieSim.single.source import Gaussian
+from PyMieSim.single.detector import Photodiode
+from PyMieSim.mesh import FibonacciMesh  # noqa: F401
+
+
+def test_Qsca_cross_section():
+    source = Gaussian(
+        wavelength=1e-6,
+        polarization_value=0,
+        polarization_type='linear',
+        optical_power=1,
+        NA=0.3
+    )
+    sphere = Sphere(diameter=300e-9, index=1.4, source=source)
+    val0 = sphere.get_cross_section()
+    val1 = sphere.Qsca * sphere.area
+
+    if not numpy.isclose(val0, val1, atol=0, rtol=1e-5):
+        raise ValueError('Mismatch with testing values')
+
+
+def test_energy_flow_coupling():
+    source = Gaussian(
+        wavelength=1e-6,
+        polarization_value=0,
+        polarization_type='linear',
+        optical_power=1,
+        NA=0.3
+    )
+    sphere = Sphere(
+        diameter=300e-9,
+        index=1.4,
+        source=source
+    )
+
+    detector = Photodiode(
+        sampling=500,
+        NA=2.0,
+        gamma_offset=0,
+        phi_offset=0
+    )
+
+    val0 = sphere.get_energy_flow(detector.cpp_binding.mesh)
+    val1 = detector.coupling(sphere)
+
+    if not numpy.isclose(val0, val1, atol=0, rtol=1e-5):
+        raise ValueError('Mismatch with testing values')
+
+
+def test_compare_sphere_coreshell_0():
+    source = Gaussian(
+        wavelength=1e-6,
+        polarization_value=0,
+        polarization_type='linear',
+        optical_power=1,
+        NA=0.3
+    )
+
+    sphere = Sphere(
+        diameter=1e-6,
+        index=1.5,
+        source=source
+    )
+
+    coreshell = CoreShell(
+        core_diameter=1e-6,
+        shell_width=0,
+        core_index=1.5,
+        shell_index=1.8,
+        source=source
+    )
+
+    for parameter in ['Qsca', 'Qext', 'Qabs']:
+        value_sphere = getattr(sphere, parameter)
+        value_coreshell = getattr(coreshell, parameter)
+
+        if not numpy.isclose(value_sphere, value_coreshell, atol=1e-12, rtol=1e-5):
+            raise ValueError(f'Mismatch with juxtaposing CoreShell with zero shell and Sphere for parameter: {parameter}')
+
+# -
```

## tests/validation/test_sphere_pymiescatt.py

 * *Ordering differences only*

```diff
@@ -1,100 +1,100 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-import pytest
-import numpy
-
-from PyMieSim.experiment.scatterer import Sphere
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
-
-from PyMieSim import measure
-
-import PyMieScatt as ps
-PyMieScatt_measures = {
-    'Qext': 0,
-    'Qsca': 1,
-    'Qabs': 2,
-    'g': 3,
-    'Qpr': 4,
-    'Qback': 5,
-    'Qratio': 6
-}
-
-
-def get_PyMieSim_data(source, index, diameters, measure_string: str):
-    scatterer = Sphere(
-        diameter=diameters,
-        index=index,
-        medium_index=1.,
-        source=source
-    )
-
-    experiment = Setup(
-        scatterer=scatterer,
-        source=source,
-        detector=None
-    )
-
-    data = experiment.get(getattr(measure, measure_string), export_as_numpy=True)
-
-    return data.squeeze()
-
-
-def get_PyMieScatt_data(source, index, diameters, measure_string: str):
-    PyMieScatt_data = []
-    for diameter in diameters:
-        efficiencies = ps.MieQ(
-            m=index,
-            wavelength=source.wavelength[0],
-            diameter=diameter,
-        )
-
-        measure_idx = PyMieScatt_measures.get(measure_string)
-        data = efficiencies[measure_idx]
-        PyMieScatt_data.append(float(data))
-
-    return numpy.asarray(PyMieScatt_data).squeeze()
-
-
-def get_comparison(wavelength, index, diameters, measure_string: str):
-    source = Gaussian(
-        wavelength=wavelength,
-        polarization_value=0,
-        polarization_type='linear',
-        optical_power=1e-3,
-        NA=0.2
-    )
-
-    PyMieScatt_data = get_PyMieScatt_data(
-        source=source,
-        index=index,
-        diameters=diameters,
-        measure_string=measure_string
-    )
-
-    PyMieSim_data = get_PyMieSim_data(
-        source=source,
-        index=index,
-        diameters=diameters,
-        measure_string=measure_string
-    )
-
-    return PyMieSim_data, PyMieScatt_data
-
-
-@pytest.mark.parametrize('measure_string', ['Qext', 'Qsca', 'Qabs', 'g', 'Qpr'])
-def test_comparison(measure_string: str):
-    PyMieSim_data, PyMieScatt_data = get_comparison(
-        wavelength=632e-9,
-        index=1.4 + 0.3j,
-        diameters=numpy.geomspace(10e-9, 6000e-9, 800),
-        measure_string=measure_string
-    )
-
-    discrepency = numpy.isclose(PyMieSim_data, PyMieScatt_data, atol=0, rtol=1e-3)
-
-    if not discrepency.mean() > 0.9:
-        raise ValueError('Error: mismatch on PyMieScatt calculation occuring')
-
-# -
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import pytest
+import numpy
+
+from PyMieSim.experiment.scatterer import Sphere
+from PyMieSim.experiment.source import Gaussian
+from PyMieSim.experiment import Setup
+
+from PyMieSim import measure
+
+import PyMieScatt as ps
+PyMieScatt_measures = {
+    'Qext': 0,
+    'Qsca': 1,
+    'Qabs': 2,
+    'g': 3,
+    'Qpr': 4,
+    'Qback': 5,
+    'Qratio': 6
+}
+
+
+def get_PyMieSim_data(source, index, diameters, measure_string: str):
+    scatterer = Sphere(
+        diameter=diameters,
+        index=index,
+        medium_index=1.,
+        source=source
+    )
+
+    experiment = Setup(
+        scatterer=scatterer,
+        source=source,
+        detector=None
+    )
+
+    data = experiment.get(getattr(measure, measure_string), export_as_numpy=True)
+
+    return data.squeeze()
+
+
+def get_PyMieScatt_data(source, index, diameters, measure_string: str):
+    PyMieScatt_data = []
+    for diameter in diameters:
+        efficiencies = ps.MieQ(
+            m=index,
+            wavelength=source.wavelength[0],
+            diameter=diameter,
+        )
+
+        measure_idx = PyMieScatt_measures.get(measure_string)
+        data = efficiencies[measure_idx]
+        PyMieScatt_data.append(float(data))
+
+    return numpy.asarray(PyMieScatt_data).squeeze()
+
+
+def get_comparison(wavelength, index, diameters, measure_string: str):
+    source = Gaussian(
+        wavelength=wavelength,
+        polarization_value=0,
+        polarization_type='linear',
+        optical_power=1e-3,
+        NA=0.2
+    )
+
+    PyMieScatt_data = get_PyMieScatt_data(
+        source=source,
+        index=index,
+        diameters=diameters,
+        measure_string=measure_string
+    )
+
+    PyMieSim_data = get_PyMieSim_data(
+        source=source,
+        index=index,
+        diameters=diameters,
+        measure_string=measure_string
+    )
+
+    return PyMieSim_data, PyMieScatt_data
+
+
+@pytest.mark.parametrize('measure_string', ['Qext', 'Qsca', 'Qabs', 'g', 'Qpr'])
+def test_comparison(measure_string: str):
+    PyMieSim_data, PyMieScatt_data = get_comparison(
+        wavelength=632e-9,
+        index=1.4 + 0.3j,
+        diameters=numpy.geomspace(10e-9, 6000e-9, 800),
+        measure_string=measure_string
+    )
+
+    discrepency = numpy.isclose(PyMieSim_data, PyMieScatt_data, atol=0, rtol=1e-3)
+
+    if not discrepency.mean() > 0.9:
+        raise ValueError('Error: mismatch on PyMieScatt calculation occuring')
+
+# -
```

## tests/validation/test_sphere_scott_prahl.py

 * *Ordering differences only*

```diff
@@ -1,40 +1,40 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-import pytest
-import numpy
-
-from PyMieSim.single.scatterer import Sphere
-from PyMieSim.single.source import Gaussian
-
-
-scott_prahl_values = {
-    'Qsca': 1.1759,
-    'Qext': 2.6257,
-    'g': 0.80335,
-}
-
-
-@pytest.mark.parametrize('measure_str', scott_prahl_values.keys(), ids=scott_prahl_values.keys())
-def test_validation_scott_prahl(measure_str):
-    source = Gaussian(
-        wavelength=1e-6,
-        polarization_value=0,
-        polarization_type='linear',
-        optical_power=1,
-        NA=0.3
-    )
-
-    scatterer = Sphere(
-        diameter=1e-6,
-        index=1.5 + 0.5j,
-        source=source
-    )
-
-    scott_prahl_value = scott_prahl_values.get(measure_str)
-    pymiesim_value = getattr(scatterer, measure_str)
-
-    if not numpy.isclose(pymiesim_value, scott_prahl_value, atol=0, rtol=1e-3):
-        raise ValueError('Mismatch with testing values')
-
-# -
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import pytest
+import numpy
+
+from PyMieSim.single.scatterer import Sphere
+from PyMieSim.single.source import Gaussian
+
+
+scott_prahl_values = {
+    'Qsca': 1.1759,
+    'Qext': 2.6257,
+    'g': 0.80335,
+}
+
+
+@pytest.mark.parametrize('measure_str', scott_prahl_values.keys(), ids=scott_prahl_values.keys())
+def test_validation_scott_prahl(measure_str):
+    source = Gaussian(
+        wavelength=1e-6,
+        polarization_value=0,
+        polarization_type='linear',
+        optical_power=1,
+        NA=0.3
+    )
+
+    scatterer = Sphere(
+        diameter=1e-6,
+        index=1.5 + 0.5j,
+        source=source
+    )
+
+    scott_prahl_value = scott_prahl_values.get(measure_str)
+    pymiesim_value = getattr(scatterer, measure_str)
+
+    if not numpy.isclose(pymiesim_value, scott_prahl_value, atol=0, rtol=1e-3):
+        raise ValueError('Mismatch with testing values')
+
+# -
```

## Comparing `PyMieSim-1.9.1.dist-info/LICENSE` & `PyMieSim-1.9.3.dist-info/LICENSE`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-MIT License
-
-Copyright (c) 2020 Martin Poinsinet de Sivry-Houle
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
+MIT License
+
+Copyright (c) 2020 Martin Poinsinet de Sivry-Houle
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
```

## Comparing `PyMieSim-1.9.1.dist-info/METADATA` & `PyMieSim-1.9.3.dist-info/METADATA`

 * *Files 17% similar despite different names*

```diff
@@ -1,258 +1,314 @@
-Metadata-Version: 2.1
-Name: PyMieSim
-Version: 1.9.1
-Summary: A package for light scattering computation.
-Home-page: https://github.com/MartinPdeS/PyMieSim
-Author: Martin Poinsinet de Sivry
-Author-email: Martin.poinsinet.de.sivry@gmail.com
-License: MIT
-Keywords: mie,scattering,backscatter,sphere,cylinder,nanoparticle,phase function,efficiency,rayleigh,backscattering
-Platform: unix
-Platform: linux
-Platform: osx
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.7
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
-Classifier: Programming Language :: Python :: 3.12
-Classifier: Programming Language :: Python :: Implementation :: CPython
-Classifier: Development Status :: 4 - Beta
-Classifier: Topic :: Scientific/Engineering :: Physics
-Classifier: License :: OSI Approved :: MIT License
-Classifier: Intended Audience :: Science/Research
-Description-Content-Type: text/x-rst
-License-File: LICENSE
-Requires-Dist: numpy >=1.26.0
-Requires-Dist: scipy ==1.11.3
-Requires-Dist: matplotlib ==3.8.2
-Requires-Dist: DataVisual ==1.4.*
-Requires-Dist: PyOptik >=0.7.8
-Requires-Dist: tabulate ==0.9.0
-Provides-Extra: documentation
-Requires-Dist: numpydoc ==1.6.0 ; extra == 'documentation'
-Requires-Dist: sphinx >=5.1.1 ; extra == 'documentation'
-Requires-Dist: sphinx-gallery ==0.15.0 ; extra == 'documentation'
-Requires-Dist: sphinx-rtd-theme ==2.0.0 ; extra == 'documentation'
-Requires-Dist: pydata-sphinx-theme ==0.14.1 ; extra == 'documentation'
-Requires-Dist: PyMieScatt ==1.8.1.1 ; extra == 'documentation'
-Provides-Extra: testing
-Requires-Dist: pytest >=0.6 ; extra == 'testing'
-Requires-Dist: pytest-cov >=2.0 ; extra == 'testing'
-Requires-Dist: pytest-json-report ==1.5.0 ; extra == 'testing'
-Requires-Dist: mypy >=0.910 ; extra == 'testing'
-Requires-Dist: flake8 >=3.9 ; extra == 'testing'
-Requires-Dist: tox >=3.24 ; extra == 'testing'
-Requires-Dist: coverage ==6.5.0 ; extra == 'testing'
-Requires-Dist: PyMieScatt ==1.8.1.1 ; extra == 'testing'
-
-|Logo|
-
-|python|
-|zenodo|
-|colab|
-|unittest|
-|docs|
-|PyPi|
-|PyPi_download|
-
-
-PyMieSim
-========
-
-PyMieSim is a software designed for comprehensive Mie scattering analysis, featuring a user-friendly installation and operation process. The characterization of the scattering event within PyMieSim is determined by a set of specific properties, as illustrated in the subsequent figure.
-
-Currently, PyMieSim integrates three distinct solvers tailored to three different types of scatterers: spherical particles, infinite cylindrical particles, and core-shell spherical particles. Additional parameters governing the scattering event are contingent upon the attributes of the light source and the detector (when applicable). The attributes pertinent to each of these components are delineated in the ensuing figure.
-
-
-.. image:: https://github.com/MartinPdeS/PyMieSim/raw/master/docs/images/code_structure.png
-  :width: 800
-  :alt: Structure of the library
-
-The package also lets you construct an **Experiment** using **SphereSet**/**CoreShellSet**/**CylinderSet**, **SourceSet** and **DetectorSet**.
-Those class define the type of scatterers, light sources and detectors you want to study.
-
-
-----
-
-Getting started
-****************
-
-PyMieSim was developed to be a used in Python script as shown in the documentation section. Although, since version 1.7.0 it is possible to use the new graphical user interface. To use is, you first need to install it:
-
-.. code-block:: python
-
-   >>> pip install PyMieSim
-
-Once this is done you can run the graphic interface as follows:
-
-.. code-block:: python
-
-   >>> python -m PyMieSim
-
-Clicking the "Calculate" button should render the following:
-
-|example_gui|
-
-----
-
-Documentation
-**************
-All the latest available documentation is available `here <https://pymiesim.readthedocs.io/en/latest/>`_ or you can click the following badge:
-
-|docs|
-
-----
-
-Google Colab
-**************
-It's 2024, you don't need to run all your code on you computer anymore. Google Colab is a platform which allows to write/use python scripts remotely.
-You can open the PyMieSim.ipynb in the file to access it or click on the following "Open in Colab" badge:
-
-|colab|
-
-----
-
-
-Installation
-************
-
-For common version of Windows, Linux and MacOS, (on x86_64 architecture), the package can readily be installed using pip;
-
-.. code-block:: python
-
-   >>> pip install PyMieSim
-
-The ready to install wheel is not available for arm chip of the newer mac M1, M2 product. You can however install manually the package.
-
-
-If, however, this fail you can build the package from scratch following the steps on the **Manual building** section.
-
-**Note:** Wheel support now extended to `manylinux2014 <https://www.python.org/dev/peps/pep-0599/>`_.
-
-
-----
-
-
-
-Manual building
-***************
-
-To manually buld the project on your computer make sure that you do have gcc installed (c++ and fortran compiler), plus python version 3.7+.
-For windows system I recommend install MingGW with g++ and fortran compiler.
-
-This being done, the following commands should do the trick.
-
-Linux / MacOs
-~~~~~~~~~~~~~
-
-.. code-block:: python
-
-   >>> git clone https://github.com/MartinPdeS/PyMieSim.git
-   >>> cd PyMieSim
-   >>> git submodule init && git submodule update
-   >>> mkdir build
-   >>> cd build
-   >>> cmake ../ -G"Unix Makefiles" (macOS, Linux)
-   >>> cmake ../ -G"MinGW Makefiles" (Windows)
-   >>> sudo make install
-   >>> cd ..
-   >>> python -m pip install .
-
-----
-
-Testing
-*******
-
-To test localy (with cloning the GitHub repository) you'll need to install the dependencies and run the coverage command as
-
-.. code:: python
-
-   >>> git clone https://github.com/MartinPdeS/PyMieSim.git
-   >>> cd PyMieSim
-   >>> pip install -r requirements/requirements.txt
-   >>> coverage run --source=PyMieSim --module pytest --verbose tests
-   >>> coverage report --show-missing
-
-----
-
-
-
-Coding examples
-***************
-Plenty of examples are available online, I invite you to check the `examples <https://pymiesim.readthedocs.io/en/master/gallery/index.html>`_
-section of the documentation.
-
-
-----
-
-Scientific article
-******************
-The associated article is free of access on this link `article <https://opg.optica.org/optcon/fulltext.cfm?uri=optcon-2-3-520&id=526697>`_
-
-
-Citing this work?
-******************
-I spent a full year to develop this tool for you to use so if it helped you in your research, I would greatly appreciate you citing the article associated to my work. Many thanks!
-
-.. code-block:: none
-
-   @article{PoinsinetdeSivry-Houle:23,
-       author = {Martin Poinsinet de Sivry-Houle and Nicolas Godbout and Caroline Boudoux},
-       journal = {Opt. Continuum},
-       keywords = {Light scattering; Mie theory; Optical coherence tomography; Radiation pressure; Scattering theory; Surface plasmon resonance},
-       number = {3},
-       pages = {520--534},
-       publisher = {Optica Publishing Group},
-       title = {PyMieSim: an open-source library for fast and flexible far-field Mie scattering simulations},
-       volume = {2},
-       month = {Mar},
-       year = {2023},
-       url = {https://opg.optica.org/optcon/abstract.cfm?URI=optcon-2-3-520},
-       doi = {10.1364/OPTCON.473102},
-       abstract = {},
-   }
-
-----
-
-
-
-Contact Information
-************************
-As of 2024, the project is still under development. If you want to collaborate, it would be a pleasure! I encourage you to contact me.
-
-PyMieSim was written by `Martin Poinsinet de Sivry-Houle <https://github.com/MartinPdS>`_  .
-
-Email:`martin.poinsinet-de-sivry@polymtl.ca <mailto:martin.poinsinet-de-sivry@polymtl.ca?subject=PyMieSim>`_ .
-
-.. |python| image:: https://img.shields.io/pypi/pyversions/pymiesim.svg
-   :target: https://www.python.org/
-
-.. |zenodo| image:: https://zenodo.org/badge/DOI/10.5281/zenodo.5593704.svg
-   :target: https://doi.org/10.5281/zenodo.4556074
-
-.. |colab| image:: https://colab.research.google.com/assets/colab-badge.svg
-   :target: https://colab.research.google.com/drive/1FUi_hRUXxCVvkHBY10YE1yR-nTATcDei?usp=sharing
-
-.. |docs| image:: https://readthedocs.org/projects/pymiesim/badge/?version=latest
-   :target: https://pymiesim.readthedocs.io/en/latest/
-
-.. |PyPi| image:: https://badge.fury.io/py/PyMieSim.svg
-    :target: https://badge.fury.io/py/PyMieSim
-
-.. |Logo| image:: https://github.com/MartinPdeS/PyMieSim/raw/master/docs/images/logo.png
-
-.. |PyPi_download| image:: https://img.shields.io/pypi/dm/PyMieSim.svg
-   :target: https://pypistats.org/packages/pymiesim
-
-.. |unittest| image:: https://img.shields.io/endpoint?url=https://gist.githubusercontent.com/MartinPdeS/f0955be398d59efac69042c1b0fbece2/raw/a3b36ca9f6bebaab5180686bef481ed0d2ebfb71/PyMieSimcoverage_badge.json
-
-.. |code_structure| image:: https://github.com/MartinPdeS/PyMieSim/raw/master/docs/images/code_structure.png
-  :width: 800
-  :alt: Structure of the library
-
-.. |example_gui| image:: https://github.com/MartinPdeS/PyMieSim/raw/master/docs/images/example_gui.png
-  :width: 800
-  :alt: Structure of the library
+Metadata-Version: 2.1
+Name: PyMieSim
+Version: 1.9.3
+Summary: A package for light scattering computation.
+Home-page: https://github.com/MartinPdeS/PyMieSim
+Author: Martin Poinsinet de Sivry
+Author-email: Martin.poinsinet.de.sivry@gmail.com
+License: MIT
+Keywords: mie,scattering,backscatter,sphere,cylinder,nanoparticle,phase function,efficiency,rayleigh,backscattering
+Platform: unix
+Platform: linux
+Platform: osx
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.7
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: 3.12
+Classifier: Programming Language :: Python :: Implementation :: CPython
+Classifier: Development Status :: 4 - Beta
+Classifier: Topic :: Scientific/Engineering :: Physics
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Intended Audience :: Science/Research
+Description-Content-Type: text/x-rst
+License-File: LICENSE
+Requires-Dist: numpy >=1.26.0
+Requires-Dist: pydantic ==2.6.3
+Requires-Dist: scipy ==1.11.3
+Requires-Dist: matplotlib ==3.8.2
+Requires-Dist: DataVisual ==1.4.1
+Requires-Dist: PyOptik >=0.7.10
+Requires-Dist: tabulate ==0.9.0
+Provides-Extra: documentation
+Requires-Dist: numpydoc ==1.6.0 ; extra == 'documentation'
+Requires-Dist: sphinx >=5.1.1 ; extra == 'documentation'
+Requires-Dist: sphinx-gallery ==0.15.0 ; extra == 'documentation'
+Requires-Dist: sphinx-rtd-theme ==2.0.0 ; extra == 'documentation'
+Requires-Dist: pydata-sphinx-theme ==0.14.1 ; extra == 'documentation'
+Requires-Dist: PyMieScatt ==1.8.1.1 ; extra == 'documentation'
+Provides-Extra: testing
+Requires-Dist: pytest >=0.6 ; extra == 'testing'
+Requires-Dist: pytest-cov >=2.0 ; extra == 'testing'
+Requires-Dist: pytest-json-report ==1.5.0 ; extra == 'testing'
+Requires-Dist: mypy >=0.910 ; extra == 'testing'
+Requires-Dist: flake8 >=3.9 ; extra == 'testing'
+Requires-Dist: tox >=3.24 ; extra == 'testing'
+Requires-Dist: coverage ==6.5.0 ; extra == 'testing'
+Requires-Dist: PyMieScatt ==1.8.1.1 ; extra == 'testing'
+
+|Logo|
+
+|python|
+|zenodo|
+|colab|
+|unittest|
+|docs|
+|PyPi|
+|PyPi_download|
+
+
+PyMieSim
+========
+
+PyMieSim is a software designed for comprehensive Mie scattering analysis, featuring a user-friendly installation and operation process. The characterization of the scattering event within PyMieSim is determined by a set of specific properties, as illustrated in the subsequent figure.
+
+Currently, PyMieSim integrates three distinct solvers tailored to three different types of scatterers: spherical particles, infinite cylindrical particles, and core-shell spherical particles. Additional parameters governing the scattering event are contingent upon the attributes of the light source and the detector (when applicable). The attributes pertinent to each of these components are delineated in the ensuing figure.
+
+
+.. image:: https://github.com/MartinPdeS/PyMieSim/raw/master/docs/images/code_structure.png
+  :width: 800
+  :alt: Structure of the library
+
+The package also lets you construct an **Experiment** using **SphereSet**/**CoreShellSet**/**CylinderSet**, **SourceSet** and **DetectorSet**.
+Those class define the type of scatterers, light sources and detectors you want to study.
+
+
+----
+
+Getting started
+****************
+
+PyMieSim was developed to be a used in Python script as shown in the documentation section. Although, since version 1.7.0 it is possible to use the new graphical user interface. To use is, you first need to install it:
+
+.. code-block:: python
+
+   >>> pip install PyMieSim
+
+Once this is done you can run the graphic interface as follows:
+
+.. code-block:: python
+
+   >>> python -m PyMieSim
+
+Clicking the "Calculate" button should render the following:
+
+|example_gui|
+
+----
+
+Documentation
+**************
+All the latest available documentation is available `here <https://pymiesim.readthedocs.io/en/latest/>`_ or you can click the following badge:
+
+|docs|
+
+----
+
+Google Colab
+**************
+It's 2024, you don't need to run all your code on you computer anymore. Google Colab is a platform which allows to write/use python scripts remotely.
+You can open the PyMieSim.ipynb in the file to access it or click on the following "Open in Colab" badge:
+
+|colab|
+
+----
+
+
+Installation
+************
+
+For common version of Windows, Linux and MacOS, (on x86_64 architecture), the package can readily be installed using pip;
+
+.. code-block:: python
+
+   >>> pip install PyMieSim
+
+The ready to install wheel is not available for arm chip of the newer mac M1, M2 product. You can however install manually the package.
+
+
+If, however, this fail you can build the package from scratch following the steps on the **Manual building** section.
+
+**Note:** Wheel support now extended to `manylinux2014 <https://www.python.org/dev/peps/pep-0599/>`_.
+
+
+----
+
+
+
+Manual building
+***************
+
+To manually buld the project on your computer make sure that you do have gcc installed (c++ and fortran compiler), plus python version 3.7+.
+For windows system I recommend install MingGW with g++ and fortran compiler.
+
+This being done, the following commands should do the trick.
+
+Linux / MacOs
+~~~~~~~~~~~~~
+
+.. code-block:: python
+
+   >>> git clone https://github.com/MartinPdeS/PyMieSim.git
+   >>> cd PyMieSim
+   >>> git submodule init && git submodule update
+   >>> mkdir build
+   >>> cd build
+   >>> cmake ../ -G"Unix Makefiles" (macOS, Linux)
+   >>> cmake ../ -G"MinGW Makefiles" (Windows)
+   >>> sudo make install
+   >>> cd ..
+   >>> python -m pip install .
+
+----
+
+Testing
+*******
+
+To test localy (with cloning the GitHub repository) you'll need to install the dependencies and run the coverage command as
+
+.. code:: python
+
+   >>> git clone https://github.com/MartinPdeS/PyMieSim.git
+   >>> cd PyMieSim
+   >>> pip install -r requirements/requirements.txt
+   >>> coverage run --source=PyMieSim --module pytest --verbose tests
+   >>> coverage report --show-missing
+
+----
+
+
+
+Coding examples
+***************
+
+PyMieSim was developed with the aim of being an intuitive and easy to use tool.
+Below is and example that illustrate this:
+
+.. code:: python
+
+   import numpy
+   from PyMieSim.experiment.detector import Photodiode
+   from PyMieSim.experiment.scatterer import Sphere
+   from PyMieSim.experiment.source import Gaussian
+   from PyMieSim.experiment import Setup
+
+   from PyMieSim import measure
+   from PyOptik import UsualMaterial
+
+   source = Gaussian(
+       wavelength=1200e-9,
+       polarization_value=90,
+       polarization_type='linear',
+       optical_power=1e-3,
+       NA=0.2
+   )
+
+   scatterer = Sphere(
+       diameter=numpy.linspace(100e-9, 3000e-9, 600),
+       material=UsualMaterial.BK7,
+       medium_index=1.0,
+       source=source
+   )
+
+   detector = Photodiode(
+       NA=[0.15, 0.1, 0.05],
+       phi_offset=-180.0,
+       gamma_offset=0.0,
+       sampling=600,
+       polarization_filter=None
+   )
+
+   experiment = Setup(
+       scatterer=scatterer,
+       source=source,
+       detector=detector
+   )
+
+   data = experiment.get(measure.coupling)
+
+   figure = data.plot(
+       x=experiment.diameter,
+       y_scale='linear',
+       normalize=True
+   )
+
+   figure.show()
+
+
+Plenty of other examples are available online, I invite you to check the `examples <https://pymiesim.readthedocs.io/en/master/gallery/index.html>`_
+section of the documentation.
+
+
+----
+
+Scientific article
+******************
+The associated article is free of access on this link `article <https://opg.optica.org/optcon/fulltext.cfm?uri=optcon-2-3-520&id=526697>`_
+
+
+Citing this work?
+******************
+I spent a full year to develop this tool for you to use so if it helped you in your research, I would greatly appreciate you citing the article associated to my work. Many thanks!
+
+.. code-block:: none
+
+   @article{PoinsinetdeSivry-Houle:23,
+       author = {Martin Poinsinet de Sivry-Houle and Nicolas Godbout and Caroline Boudoux},
+       journal = {Opt. Continuum},
+       keywords = {Light scattering; Mie theory; Optical coherence tomography; Radiation pressure; Scattering theory; Surface plasmon resonance},
+       number = {3},
+       pages = {520--534},
+       publisher = {Optica Publishing Group},
+       title = {PyMieSim: an open-source library for fast and flexible far-field Mie scattering simulations},
+       volume = {2},
+       month = {Mar},
+       year = {2023},
+       url = {https://opg.optica.org/optcon/abstract.cfm?URI=optcon-2-3-520},
+       doi = {10.1364/OPTCON.473102},
+       abstract = {},
+   }
+
+----
+
+
+
+Contact Information
+************************
+As of 2024, the project is still under development. If you want to collaborate, it would be a pleasure! I encourage you to contact me.
+
+PyMieSim was written by `Martin Poinsinet de Sivry-Houle <https://github.com/MartinPdS>`_  .
+
+Email:`martin.poinsinet-de-sivry@polymtl.ca <mailto:martin.poinsinet-de-sivry@polymtl.ca?subject=PyMieSim>`_ .
+
+.. |python| image:: https://img.shields.io/pypi/pyversions/pymiesim.svg
+   :target: https://www.python.org/
+
+.. |zenodo| image:: https://zenodo.org/badge/DOI/10.5281/zenodo.5593704.svg
+   :target: https://doi.org/10.5281/zenodo.4556074
+
+.. |colab| image:: https://colab.research.google.com/assets/colab-badge.svg
+   :target: https://colab.research.google.com/drive/1FUi_hRUXxCVvkHBY10YE1yR-nTATcDei?usp=sharing
+
+.. |docs| image:: https://readthedocs.org/projects/pymiesim/badge/?version=latest
+   :target: https://pymiesim.readthedocs.io/en/latest/
+
+.. |PyPi| image:: https://badge.fury.io/py/PyMieSim.svg
+    :target: https://badge.fury.io/py/PyMieSim
+
+.. |Logo| image:: https://github.com/MartinPdeS/PyMieSim/raw/master/docs/images/logo.png
+
+.. |PyPi_download| image:: https://img.shields.io/pypi/dm/PyMieSim.svg
+   :target: https://pypistats.org/packages/pymiesim
+
+.. |unittest| image:: https://img.shields.io/endpoint?url=https://gist.githubusercontent.com/MartinPdeS/f0955be398d59efac69042c1b0fbece2/raw/a3b36ca9f6bebaab5180686bef481ed0d2ebfb71/PyMieSimcoverage_badge.json
+
+.. |code_structure| image:: https://github.com/MartinPdeS/PyMieSim/raw/master/docs/images/code_structure.png
+  :width: 800
+  :alt: Structure of the library
+
+.. |example_gui| image:: https://github.com/MartinPdeS/PyMieSim/raw/master/docs/images/example_gui.png
+  :width: 800
+  :alt: Structure of the library
```

## Comparing `PyMieSim-1.9.1.dist-info/RECORD` & `PyMieSim-1.9.3.dist-info/RECORD`

 * *Files 20% similar despite different names*

```diff
@@ -1,207 +1,208 @@
-PyMieSim/VERSION,sha256=JPccUmy-09WkD7Vih_rgW2GhpzqNduUjziOSra0CCaw,7
-PyMieSim/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-PyMieSim/__main__.py,sha256=gyDuEzcfopHfNbkK0mI9UALzu2aG9uctC6gPXQdYLd4,230
-PyMieSim/measure.py,sha256=sQQhwAZIRDH73-HDG58mX8GHXa0ibywmbEUk4vnOWVs,3780
-PyMieSim/mesh.py,sha256=-Bkdz6ZAsNkdceLguXiS-tiA1Rdj8DjTkfU78hkm_ms,7864
-PyMieSim/physics.py,sha256=1AT6Ke_FxsUB-oAV1tzt34LzXqoPK1yOdtsBdzo0XQs,1988
-PyMieSim/polarization.py,sha256=ZQj4x5465pqfopu9TgKdqMIuJtk1jNIypA4fO5QP5-k,2084
-PyMieSim/binary/CoreShellInterface.cp310-win_amd64.pyd,sha256=e9lQTKCERGRGgT_PGTEqJYEqfkGdJslJIycdApgzrxE,814592
-PyMieSim/binary/CoreShellInterface.cp311-win_amd64.pyd,sha256=26DkVGN_rjG9HYbx1onh2DuXthDvomV89imSUDrLcxU,814592
-PyMieSim/binary/CoreShellInterface.cp312-win_amd64.pyd,sha256=OgU5zpWkVdApu78s4AttO-jS1768ry7zMxgykC77qBY,814592
-PyMieSim/binary/CylinderInterface.cp310-win_amd64.pyd,sha256=ol0_sRB7i58cqQ-a10CDjzZKEXh6sJyp8V5s603fib8,796672
-PyMieSim/binary/CylinderInterface.cp311-win_amd64.pyd,sha256=r8RKBIrt98OGRFv1RZFyEjgVnEKPgukeoxIOy7xlfrY,797184
-PyMieSim/binary/CylinderInterface.cp312-win_amd64.pyd,sha256=5mMYPgG5ZOLA-3vPdy0JC6Xe7yxtT7rP5qzOFwz8eCM,797696
-PyMieSim/binary/DetectorInterface.cp310-win_amd64.pyd,sha256=7FaqHpVE5Fwz0zI6nGzruwIY7W-PLugm4qVJ4SfH8rg,853504
-PyMieSim/binary/DetectorInterface.cp311-win_amd64.pyd,sha256=EfY2JI_8jIed1ImA9gcY3ytMTyRHVAitezCHMCyoQQ8,853504
-PyMieSim/binary/DetectorInterface.cp312-win_amd64.pyd,sha256=S6UCxRZ_4P_YDF26xwLkq6hrmZ7YvJJYUz6k1RBcbtE,852992
-PyMieSim/binary/Experiment.cp310-win_amd64.pyd,sha256=r2SfzEhfMRmLSatPrubXbO7mO-ynXR02zP35kXXxhxA,966144
-PyMieSim/binary/Experiment.cp311-win_amd64.pyd,sha256=jZRQ09ompRTuDfYeuwdxIzl1xLNdRZzBQlVKBAtJWOE,966144
-PyMieSim/binary/Experiment.cp312-win_amd64.pyd,sha256=YzA015v-qpRBTYmAjcvGV4GT_PpHBQ8RohAxzHg04MM,967680
-PyMieSim/binary/Fibonacci.cp310-win_amd64.pyd,sha256=EOzUX7qOdawTs-1ZG_vVgwbJ_rkN-heOzSbr1FPDflE,351744
-PyMieSim/binary/Fibonacci.cp311-win_amd64.pyd,sha256=xFPD21aZ6W3_lqVXITQhFAuqNeGCsDrYOuuyiz8wRVg,351744
-PyMieSim/binary/Fibonacci.cp312-win_amd64.pyd,sha256=nBw6b_e8n0awXs_IpiNybIDtrLnBfmvqyc4TuhtK06s,351744
-PyMieSim/binary/ModeField.cp310-win_amd64.pyd,sha256=eeblohLEr3eQIec8jpxY-3cjj16IzIZkvq6rDp4xP7c,301568
-PyMieSim/binary/ModeField.cp311-win_amd64.pyd,sha256=86UzMjkBjQiKJ5fBwK24dfWV8x-LOkip0wnS949pJvs,301568
-PyMieSim/binary/ModeField.cp312-win_amd64.pyd,sha256=tV2p8oiYFAFKzXTTIZ_kyb_1rcC7bX4OcOLPgz7GuYg,301568
-PyMieSim/binary/Sets.cp310-win_amd64.pyd,sha256=2EF77kYCuggiVVVPF7UqqNADqKirKQl51ZEfNV5Orng,873984
-PyMieSim/binary/Sets.cp311-win_amd64.pyd,sha256=NrLJlbR4DlO-BE6G9OLZiUp4fI8NofAcgM-JTzSSYIQ,873984
-PyMieSim/binary/Sets.cp312-win_amd64.pyd,sha256=AZsJhmaMxidByn9fkmiS3oxic9BPuNK-mLFu6nNTr_k,872960
-PyMieSim/binary/SphereInterface.cp310-win_amd64.pyd,sha256=T2o-N6sZdpE3AoiUCpT-UmEe0PIX31A3seZoLykKvGw,814592
-PyMieSim/binary/SphereInterface.cp311-win_amd64.pyd,sha256=rpESgNwUV8cDWCiF8E6uAa97wuQGMlt9wBUvY64nHvg,815104
-PyMieSim/binary/SphereInterface.cp312-win_amd64.pyd,sha256=rZ15pszWDKZvmgriRZwolLUwNLuRwjtFeXSKROCZQLk,815616
-PyMieSim/binary/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-PyMieSim/binary/libZBessel.a,sha256=guBXqBM6Hnzkvk-eDz5oJ9fxpGMige9GMziQ-BTdGu8,133174
-PyMieSim/experiment/__init__.py,sha256=-vnICKYVqY7jaJFO1uKEOXNhIBOE9x5r6pIHXwNwbDY,165
-PyMieSim/experiment/detector.py,sha256=QZhxm5s_utucRzp439Fdb_1Hjhwhf3mdhstSf34qZD8,8444
-PyMieSim/experiment/scatterer.py,sha256=4KMQmGoJF4127fIYaK0Q6JdsXFQYFzz_AOcOsk15N5k,16834
-PyMieSim/experiment/setup.py,sha256=2R6qVA0ECZDvaXkBZZoP97gfrH_guD-NYIBp616cins,5170
-PyMieSim/experiment/source.py,sha256=uRxu0OTIkdSHQyOD0Fa52KbzalXy7D95KeSXYVJqJ2U,5540
-PyMieSim/gui/__init__.py,sha256=zZXn-a_mnzBG2TSrP4z9VRMkvDa-55jz058uYZ6KRx0,209
-PyMieSim/gui/axis_tab.py,sha256=eD9VEN4uobvvZGaN1VmsW4vOvkXRt2nwdajBaSWT57Y,3291
-PyMieSim/gui/base_tab.py,sha256=xhL9_V7PTzA55xv9EkKcqXjeUe8RmZI7A5u5gL00wF0,3382
-PyMieSim/gui/detector_tab.py,sha256=Qo3XaMCgZZgJv8IIS1kKT7RUId07CaRLJiInaREpiKw,6388
-PyMieSim/gui/main_window.py,sha256=Umg3PSKIaoA1QPJ1ChkzChCfr8eLwFZIxRVldSJxmkw,7703
-PyMieSim/gui/scatterer_tab.py,sha256=9xXVdCn9NQt-0SMa-O1BqfuVbKkQLBY3v2QNDUnDKhU,7070
-PyMieSim/gui/source_tab.py,sha256=V-iDBDqy6k3Wx9x_KV_MsFwCUZi1Mk7wCinN2rO_wss,2633
-PyMieSim/gui/widget_collection.py,sha256=nv9Kxdoszv0ZYVAehPwPqzf4nR9tLNwMjvmQbpOcJVo,3122
-PyMieSim/gui/widgets.py,sha256=4Bh70NWGL8A7WTlN6mqrPaRMf79IT13YaBW8ULR01Kk,6658
-PyMieSim/single/__init__.py,sha256=mzpMGNZTXEjpnq5cH0by4gM3TRmdJbtBdIe-H9ELxG0,139
-PyMieSim/single/detector.py,sha256=_ZXo1vjQ0ut-zej3OmQ3ePc2JzF1qkQLAqt29T572wU,10529
-PyMieSim/single/representations.py,sha256=aBZo4mZMLXX3xK-wUezDWUOsO9KaI-NDTrKem-bKZ0A,19667
-PyMieSim/single/scatterer.py,sha256=iSbE7N5SkIc-VcPj-Wo2tyBnaGZ9KWzuFxqjfOaYHIU,20055
-PyMieSim/single/source.py,sha256=RhrVyBlQJSpu-WjoDDDMYZFNFF7tvC2kfBbksE_AzQw,5579
-PyMieSim/tools/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-PyMieSim/tools/directories.py,sha256=Lc7ScDTwxX5DFGkWnWxd-cidPr3tFwBugiSixXMOH-s,1184
-PyMieSim/tools/special_functions.py,sha256=V5r6kenbGsDtL4C94mWEutKoX7mCgQFmbJKahgnWen8,6229
-PyMieSim/validation_data/Figure810BH.csv,sha256=a16WSB7y7_TuGcboXUINj7y-mX0mkG_Vo0CFtE-pfF8,10073
-PyMieSim/validation_data/Figure87BH.csv,sha256=6vf5uPxzYP7N1rD8GgQJxi4-Yme8Q3ycPpsavXlQQZY,40002
-PyMieSim/validation_data/Figure88BH.csv,sha256=c30NQRjxlPz6plBcuG3kMVdTYQ0sHmRXRnzS67gyFnQ,40002
-PyMieSim/validation_data/PyMieScattQsca.csv,sha256=1TqB7ky435UxeNJSAn6YR3_qUuUKZNLxVAbCLmrnLDk,20800
-PyMieSim/validation_data/PyMieScattQscaCoreShell.csv,sha256=khOJo3N54CqvrG9sxpuvvv5mZlcF3awOk738WHLougI,10400
-PyMieSim/validation_data/PyMieScattQscaCoreShellMedium.csv,sha256=fW1paOgE4ez_26Er4sfqoXujcMtuooj9I6RO6qRCXPo,10400
-PyMieSim/validation_data/PyMieScattQscaMedium.csv,sha256=7PE_F3sLIKmKPhcoMUxeByZHw3lzDfc3TH9g9bh3Noo,20800
-development/debugging.py,sha256=rxDeIadCtMJjYMIYh8uRIwk0tPVH6bTMJasRecp6iyY,765
-development/fcm.py,sha256=wQvDcT6G8vhHQ0zE2jmYnc3ZJ6irlIWNdKrkUG9N28M,1051
-development/gui.py,sha256=LYma4E1_T8xOqXzy4g-wnDhacH4MzSpNaZvje6onyC0,13670
-development/matthew_singe-2.py,sha256=sF_qSo2FVFXlZc9I4uGYMbTwv79lKzg5JqSQIk5HPbI,1161
-development/matthew_singer.py,sha256=k1rjZs42RXc9Llo_E51LFzQzASk8iBqJF4_Y6dSLIao,1501
-docs/examples/detector/plot_HG01.py,sha256=QGDnAf35KvGjyu8644MJFbJ1FjOE0ELfHASMZGVEjZg,847
-docs/examples/detector/plot_HG11.py,sha256=0RDUbocl8i4QUZouRGJlx7PNDCOcE2v0MYtAza9933E,864
-docs/examples/detector/plot_LG11.py,sha256=QEJXCm2XHIMCSOOJNRjUNVivjgDzi5hyG9NHu_p8qaA,851
-docs/examples/detector/plot_LP01.py,sha256=MdsDk0aNhY6O79ApHs_fXNmO01QED4xcSVY9Il3Piv4,826
-docs/examples/detector/plot_LP02.py,sha256=5o3KFURBQ-CbKFvOHH0gFb4_MZB_w3GO03t3ONZKYT0,640
-docs/examples/detector/plot_LP11.py,sha256=8cjA3hd5SeQT8-On1qdZo9P0yilaBa43saZmmT7pnus,640
-docs/examples/detector/plot_integrating_sphere.py,sha256=iW_FFeKuEQAv0iRwP8IYK_AYj54-ifODOuj5gPuCB-E,559
-docs/examples/detector/plot_photodiode.py,sha256=lueGQSTcQwfiX7qGJAAur3UFjEe9QQbJ3AWo_e0ZZ-8,666
-docs/examples/experiment/plot_coreshell_Qback_vs_corediameter.py,sha256=3gcx_-UEeUBeAgsSgXbaxLilrNv6FjqcdLs9xm6lVbs,1897
-docs/examples/experiment/plot_coreshell_a1_vs_corediameter.py,sha256=ZQmsjosZ8iUQWV6XdUBhzj19kbelLF61numAHCF9HeA,2125
-docs/examples/experiment/plot_coreshell_b1_vs_corediameter.py,sha256=JfAqtigwvAjqJ-jxHxldu3cTQO2mMXYFolNxe9aynRA,2033
-docs/examples/experiment/plot_coreshell_coupling_vs_corediameter.py,sha256=mzFXmHmNZMsUBzzyPKEtEsNNWvfI-BjZEpXanrXYIUc,2126
-docs/examples/experiment/plot_cylinder_Qabs_vs_diameter.py,sha256=Xwzs9jtarrqQcXwU5ay6OG5MR5o5xTroOPVmFxkcIvc,1869
-docs/examples/experiment/plot_cylinder_Qsca_vs_diameter.py,sha256=lmNeEu7WxoDACRyGrY6SazxEw22TDVLPF_eIZ-K2bbY,1624
-docs/examples/experiment/plot_cylinder_Qsca_vs_index.py,sha256=k6Cet19MoB0mCyCskLxOjTvreB3D_RxFrzKafuxHDaw,1617
-docs/examples/experiment/plot_cylinder_Qsca_vs_wavelength.py,sha256=hczLnthxcCklVJwySrismD6iSOxG9pMb4z7U_ehvNzM,1948
-docs/examples/experiment/plot_cylinder_Qsca_vs_wavelength_std.py,sha256=2vFQQIVI8CE5xl6DZHrc_lWkQwFepvkSuYq_IgJI21Y,1155
-docs/examples/experiment/plot_cylinder_a11_vs_diameter.py,sha256=5ZlIv2N6RUccTy-dlGrtNpOJCKWkwf2ScLxt5Ouak6k,1594
-docs/examples/experiment/plot_cylinder_b11_vs_diameter.py,sha256=qBAfu2WGNrFKt7dBSIUHHwjWlUTPQwn-IqzTkk8WThQ,1507
-docs/examples/experiment/plot_cylinder_coupling_vs_diameter.py,sha256=9QJu8ljF8uG24sNBocADjqBZt42oRDbEXAOfMa_rwTg,2026
-docs/examples/experiment/plot_cylinder_coupling_vs_phioffset.py,sha256=Sl3clcvtuQB4raxtwSYMfxYQMX3HwBFePDA-JhivcV0,2048
-docs/examples/experiment/plot_cylinder_coupling_vs_wavelength.py,sha256=-8nN-yp69S3I926a2Pgj7AHFrcvxEL_30eSi5Y6VrlE,2259
-docs/examples/experiment/plot_sphere_Qabs_vs_diameter.py,sha256=9A7ZE6dk50ZlfWzFtBtTMTE1OBxA77-Q7ldvHdvaaGI,1116
-docs/examples/experiment/plot_sphere_Qsca_vs_diameter.py,sha256=xupVg6DgXcrWQQ9lALlOBz-YWWX1C9_yQSYZGKBJnZo,1022
-docs/examples/experiment/plot_sphere_Qsca_vs_index.py,sha256=kju_K7V-zYNsSVOq93T_Zof0SX6YBjd4P6em2mCDK3U,1005
-docs/examples/experiment/plot_sphere_Qsca_vs_wavelength.py,sha256=9F5qYFoWH1fq03KiG-6Fukyp-OTa1v-BpcheiMBA3ps,1033
-docs/examples/experiment/plot_sphere_Qsca_vs_wavelength_std.py,sha256=sNt0GMnReQiyg1OipTCG1_wWDSkJVgaKhPL3GTVruU8,1150
-docs/examples/experiment/plot_sphere_a1_vs_diameter.py,sha256=LFSlxjneSLuUex-hPJ1zNaj0fqVjTd-tLa3FujQS2Ak,1020
-docs/examples/experiment/plot_sphere_b1_vs_diameter.py,sha256=V22NliGusP4jrBEBI1cckQpsv9fTsOMt5_IVYA2DhaI,1017
-docs/examples/experiment/plot_sphere_coherent_coupling_vs_phioffset.py,sha256=QLgsChUBsuchudgzAA1Qd0OzEotZuIzwTZvI-HqgtRc,1450
-docs/examples/experiment/plot_sphere_coherent_coupling_vs_rotation.py,sha256=zew2KZifEwcDSY2uVzcayoOQm8v7iw8SULFX87x7PBQ,1380
-docs/examples/experiment/plot_sphere_coupling_vs_diameter.py,sha256=Edivh3u1QiubhbJ3BaDURFbOdl9iB1zDnURly9m_OPA,1381
-docs/examples/experiment/plot_sphere_coupling_vs_filter.py,sha256=svCwT91zvmstBARxl9H0cC201GZG5KW5dG8cldwz1Ss,1489
-docs/examples/experiment/plot_sphere_coupling_vs_phioffset.py,sha256=nXxf64bYnF3LlJf4wkmB8I60O6TxMr_MvYRJwcarIuc,1355
-docs/examples/experiment/plot_sphere_coupling_vs_wavelength.py,sha256=f2SeHBf21KQ9CrTQlZzmCF60NU6rBSNGaB8mA2r1-ws,1441
-docs/examples/extras/SphereProperties.py,sha256=fNAHB4Xsyon5EaCZByureltLWqMHzszPXPzbwDE0HkM,1033
-docs/examples/extras/plot_Qsca_vs_permittivity_vs_size_parameter.py,sha256=pqp20zakQb9BFRmzuAfpHVAP67m3NtrKZNqnVpQ5eIg,1600
-docs/examples/extras/plot_coupling_heatmap.py,sha256=f24GX0qI7Luy60enCIkG498JV_pvFsGXm3RXX-brxYk,1748
-docs/examples/scatterer/plot_farfield.py,sha256=wslJbnqYBLOyKv07aGLjlJWLOA6ozBmWqaKcqwMvLjA,1054
-docs/examples/scatterer/plot_footprint.py,sha256=F3VlKaUpDn5hIPtasPHiwga4NBmhO8oh9KggRW2YFbA,1336
-docs/examples/scatterer/plot_s1s2.py,sha256=j2aD457_aXyDhNq66FZr4QCAEx2cLgW17XOsrN2wclU,940
-docs/examples/scatterer/plot_source.py,sha256=BAw8KjynsrsUdL3Q8_Ko6i08HPv6ZCO84oZYay6yqJw,593
-docs/examples/scatterer/plot_spf.py,sha256=D8pSUoekXsa9ZJfr-YwkmtG0hXX8T9pMbPmVI_ocRRk,1003
-docs/examples/scatterer/plot_stokes.py,sha256=bQ_xJi-kK-hcsqzwI97TQM-Fay5Ghvnhhn1TzOlOcfk,946
-docs/examples/validation/plot_BH810.py,sha256=6afBvXME0vWbt-nQNhYQdUzZEuTq55m4saVa7Lle6s8,1207
-docs/examples/validation/plot_BH87.py,sha256=esRVykHoLsExTB0Ab9_yReNu2lJpMJulnlLx1VMsosM,1634
-docs/examples/validation/plot_BH88.py,sha256=-p8cMEm4_FPujO70Ntxo7wkiRKc5bft1DTKgqzxNVhk,2676
-docs/examples/validation/plot_phase_function_detector.py,sha256=1c7SIE9g7d1aB5_pr6Q8MSNsetsk58QjQHXaYrMIsRM,2747
-docs/examples/validation/plot_pymiescatt_0.py,sha256=a664WU9_0GbKmHqXpIrlqJuqms3XSqAsLmjPr7L-Bkw,1950
-docs/examples/validation/plot_pymiescatt_1.py,sha256=gsZyf18NUP5bP51kztlbVP-X9yW12IWVxbCtSdz8soA,2030
-docs/examples/validation/plot_pymiescatt_2.py,sha256=_izpLM5uwyPtH0CQb2Bi4k9eAyOMRdjyIQKIz_0xHtc,2226
-docs/examples/validation/plot_pymiescatt_3.py,sha256=sPkA1N8ZWllUCj7YIyJRE1bsASLPvtnvIC4VV9H1ue0,2328
-docs/source/conf.py,sha256=kQcXsOr9ovBFf86xxo9KU0SpglPQLrtOxDrp9ilGwRs,4717
-extern/pybind11/noxfile.py,sha256=GBm2vlcsgIEW_M3UnfIc4QSb-fe4Pg0vsAObCb8U3qU,2872
-extern/pybind11/setup.py,sha256=-Xpv99Fm-Y4cEU6fwadbPh4RptQ5WyTrJUQOp88ajVs,5027
-extern/pybind11/docs/benchmark.py,sha256=tYlMVW_GtxknuS-C3wC5fLP69K-64No0-h2J2rcQUWs,2943
-extern/pybind11/docs/conf.py,sha256=ZcIspTTuCcZJZ5QF5T7WoppxB5rFs21PgOKKDSnWbW8,11926
-extern/pybind11/pybind11/__init__.py,sha256=BcyFxL5hmgiWCK5n2wGwaAFbonTPPRWEtqr-_7cL-ys,431
-extern/pybind11/pybind11/__main__.py,sha256=14R-y51seeb0de65x1CZt2picXBvL-N96jdtzUCC5CU,1606
-extern/pybind11/pybind11/_version.py,sha256=thkwrA9N4ngLuELUfitvdEdv9IK3m0gI44CouznBe3c,240
-extern/pybind11/pybind11/commands.py,sha256=nEFUE_pbCW4DGM9U3tQ0RT_7njQCru2iz2sjUdpNXRQ,1263
-extern/pybind11/pybind11/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-extern/pybind11/pybind11/setup_helpers.py,sha256=Byol9vJqykTfZf0V8yQQGLXMa5C2ZJaPkDqESgN7m28,18153
-extern/pybind11/tests/conftest.py,sha256=Wavq1-Fn14hX_1Op_R7YFlah4_G23ys0ouC5r23ojek,6114
-extern/pybind11/tests/env.py,sha256=NvjxtMaRuKNeEAzjK7xx2boRxnf7h1dHhyf1CxDoH08,968
-extern/pybind11/tests/test_async.py,sha256=Koef0HuASvyUDXCsAb2QwzayEE_dpuCXNv1oDJTdBiA,558
-extern/pybind11/tests/test_buffers.py,sha256=orE_UqjLg2lTBIP2dvQSeEqURR41iZESaEwrYPBK2_0,5004
-extern/pybind11/tests/test_builtin_casters.py,sha256=nXCUYNA1L5eGPTlo2hgf40pumYJR4nIScPG7Yac6R1k,17771
-extern/pybind11/tests/test_call_policies.py,sha256=Thh9Q_wck4D9tvvP7wl1S_rLXsKijl8mkfq6RQ0AwR8,6796
-extern/pybind11/tests/test_callbacks.py,sha256=MBUVYOEJj5yK_JZgrFlABQSTwXqM8S_-QDO9kGrFWIA,6454
-extern/pybind11/tests/test_chrono.py,sha256=mLKoPUYSSuEwgcUVZz-fZwR_xEj80SZVAZpEPChNgWM,5896
-extern/pybind11/tests/test_class.py,sha256=gno1707lZaTUBJlVTVs3LYKmgCrWSSMfpn3Fe_YCHu0,15302
-extern/pybind11/tests/test_const_name.py,sha256=rS7uKYBrQw3CdMNgvORVlJzYIPhcpINruDeBdUVL6j4,618
-extern/pybind11/tests/test_constants_and_functions.py,sha256=P5VTHBS3FARAjdx0PGM-VAWcRzxHhYhMunwdQXDoYZI,1550
-extern/pybind11/tests/test_copy_move.py,sha256=uMh4eQn7oDQl-PHaWzq-SLKaQvyNEaZjeMtIoqie5ek,4928
-extern/pybind11/tests/test_custom_type_casters.py,sha256=13pwI-AcQHEzrIqX532ueF8lxRdHYnA1-O5d_miOJnQ,4106
-extern/pybind11/tests/test_custom_type_setup.py,sha256=lH3zZm9sLlv1o6__8ZSWxZPjkA5aIrU0zhbpQoSEBrs,1137
-extern/pybind11/tests/test_docstring_options.py,sha256=e2p8DRsIXyR9_1yeONGV3oVOeeYhTASsiIQQJEr1_dk,2487
-extern/pybind11/tests/test_eigen_matrix.py,sha256=ULmnxkEmyt7rMdRp6k6lYQwlBIQmqKTL36pcDP2TQjo,29651
-extern/pybind11/tests/test_eigen_tensor.py,sha256=-_ikkQSyZpi9WP4jhGs34PWPtzqi4RJvYBcaG0iVLdo,9740
-extern/pybind11/tests/test_enum.py,sha256=PyuqQZfYxhRcRjE14SrGQ8rOhe-e1KLMNYDa3oln_gM,9167
-extern/pybind11/tests/test_eval.py,sha256=uhk8ZP_UXyXbFVhTuISqhvDI9GTSu0cGfNuucdQcheE,1193
-extern/pybind11/tests/test_eval_call.py,sha256=u7UlNV-aeggzw6AKA3847r6EWmPXTV9v17DJXJRGY0U,123
-extern/pybind11/tests/test_exceptions.py,sha256=ZnWODU99ki4siXfCkLQ07huU27mV8FYZKni37_qpC14,13157
-extern/pybind11/tests/test_factory_constructors.py,sha256=djli5YDdhpgdsPs5M951lJFwZWLYBzLDdIp4u0JVYb0,17035
-extern/pybind11/tests/test_gil_scoped.py,sha256=VfXbqUT3zICFXKrZpJXBsnUiRa2yXPeRLwrSAGDSKoY,8784
-extern/pybind11/tests/test_iostream.py,sha256=81QB2pHwKjmn03l0cr1SZh8s18EA5R4rd51JeluBmw0,7581
-extern/pybind11/tests/test_kwargs_and_defaults.py,sha256=gAIoiEXLR21Nh2EQSbhtGuCx23Bw-1_2sCJAKd9aa9A,14147
-extern/pybind11/tests/test_local_bindings.py,sha256=H-grO_Kz_byDZL34o2m_GSUkxxWgAQN8HJ-T6UgU0tc,8311
-extern/pybind11/tests/test_methods_and_attributes.py,sha256=xZHfqjKEsNd_eir_ovsEMCQ32wj09fpLGvxXLpF4dp8,18661
-extern/pybind11/tests/test_modules.py,sha256=MX2_A7n_NuKd9rp1lpOsh2l0g0LJEZ-D1aR9DkDrS5U,4329
-extern/pybind11/tests/test_multiple_inheritance.py,sha256=aidGjgyDdHlLIpyBXt-KKG8fSHDdQczuz-di4i8q34o,12367
-extern/pybind11/tests/test_numpy_array.py,sha256=beHIrrG8rAZnLTt3M0upfQGZoye4oWYSl6WL8ezQuA0,20949
-extern/pybind11/tests/test_numpy_dtypes.py,sha256=Yo-sC1ThnQlHw-SNtupukykb8kpK9cRwC8Q_3tN6SZo,14840
-extern/pybind11/tests/test_numpy_vectorize.py,sha256=_6jgbDjfzVRgMKGqBTUgwsT94v1IcKlVsVjNcMn0qtU,9952
-extern/pybind11/tests/test_opaque_types.py,sha256=VQkfjmjOQrIAqGohE0Jc82Q3nyWOt1OMahw9RHlJ7VQ,1905
-extern/pybind11/tests/test_operator_overloading.py,sha256=8fX_td5nXACSzh-B5BUA8H7pO4WSjd-hWKrjwioId9I,4483
-extern/pybind11/tests/test_pickling.py,sha256=ak4g7rDTDrUaK0JZ__f_FTn54GR9tNPV1yY3njnNaDM,2813
-extern/pybind11/tests/test_pytypes.py,sha256=DRVusN7Lhhx5TQuA9JTmn4rmHGuJOy-6zVtsbXZbL8s,24515
-extern/pybind11/tests/test_sequences_and_iterators.py,sha256=iJK3WXeFr5UNUTr2GiMTgSkghcxUCEDgTvV4P_0NZAY,8272
-extern/pybind11/tests/test_smart_ptr.py,sha256=1HLW1_YNMdMPYrxYOavNlqu2ymDt5AjFYoC9pZPiqxY,9845
-extern/pybind11/tests/test_stl.py,sha256=fS_Ne9BDQ-wyiHlE61kSmJhD1l0G7nv8OVdF6nZBVOA,12612
-extern/pybind11/tests/test_stl_binders.py,sha256=vCWNtbWDVpsPxvPa-HL3r6DkEycfaLcdDftdHOXZU0U,9511
-extern/pybind11/tests/test_tagbased_polymorphic.py,sha256=hAqyR1IXoNmJUUZ-H0Ot2hteaex9VGE1QymWDTN3tJ4,769
-extern/pybind11/tests/test_thread.py,sha256=xpgsriDrcCnLpsRud873ktQL7RZWB3nTvTxTWEOoBI8,868
-extern/pybind11/tests/test_union.py,sha256=BLIsmhBn9GX2LDn9hBhjDD03vE_9m7FdFIrhai_opL8,156
-extern/pybind11/tests/test_virtual_functions.py,sha256=M2lhv4fWJ7tNy3HLx_9aYohsaxiYx78shkIQ-f2XxrY,13378
-extern/pybind11/tests/extra_python_package/test_files.py,sha256=yPakMoEOHb6fQjs1pQzXJ-UMI7vMawRkBs6vNembMJc,8582
-extern/pybind11/tests/extra_setuptools/test_setuphelper.py,sha256=wkDPeVFCh0UYxKQqr5g4917_15SzbFvmgDMbX0fN_3A,4304
-extern/pybind11/tests/test_cmake_build/test.py,sha256=FIAyjOQkxy8mScsPccANS8lIkxEHMXucr2D0IzjxY2Q,206
-extern/pybind11/tests/test_embed/test_interpreter.py,sha256=unuIU5dE-Ie8L2l6UkUuFfE2s_dTyboWkITp2TrjzuA,251
-extern/pybind11/tests/test_embed/test_trampoline.py,sha256=fa6Pm_kP3TZFriK4zGkJT98JF6GDWFoFGZ5fUAoP9zw,291
-extern/pybind11/tools/codespell_ignore_lines_from_errors.py,sha256=YYO_A0K8DbXNqNbTJAt5l0zrkF9deOOSgM1Awe53a0g,1075
-extern/pybind11/tools/libsize.py,sha256=xp1nJIl4vHGMbSpYOydVV9kzcraSNRXNS52eImM7a94,1067
-extern/pybind11/tools/make_changelog.py,sha256=8s1y9yPnWxYuX7-RjQKuIdZq3qpFCfLn_0g6kfxxU5s,1373
-tests/detectors/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-tests/detectors/test_coherent_mode.py,sha256=7HLToi0_avGAEGqcyHNWq9fFmNFwSgtQY55IXDXUIzY,1835
-tests/detectors/test_integration_sphere.py,sha256=hZ17uq4HFgj0p_NnZxNb_OXWroLIbz1DncT6WAFH5vY,1555
-tests/detectors/test_photodiode.py,sha256=z2AO_DFKmeb_aVQtVizdVH-h9cHVWRuqU9lG7AoKq0s,1763
-tests/experiments/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-tests/experiments/test_coreshell.py,sha256=lpNtoNKOaWXWVm7fTHp1awalO50LrtyvVJPDifvTHrY,2985
-tests/experiments/test_cylinder.py,sha256=ZU4PwktPdY15t8IWiu9388c0OovfCGmw6z9h41HuvCs,2248
-tests/experiments/test_sphere.py,sha256=RwkA_BzeFwVuPEeKYLa9CDips4_yqH5GUjfmI01J2_U,2329
-tests/extra/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-tests/extra/test_mesh.py,sha256=6L5tCwlC3m5uY9UbibX1mwoW3knyzqlVFztnOWIVjqU,222
-tests/scatterers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-tests/scatterers/test_coreshell.py,sha256=gSVOYufH83GobHytD50SDrqOOdf8Jub9pb4cWSMHF0s,3585
-tests/scatterers/test_cylinder.py,sha256=4gf5AK5lMVIiqHLeMdxX-f3Xds2gjM-xsfgZ0zuO9JU,2677
-tests/scatterers/test_sphere.py,sha256=HVekgJwdcCgH_HrMByrIYAhEHarnFPqgsJw7kklo1p8,3126
-tests/validation/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-tests/validation/test_coreshell_pymiescatt.py,sha256=fzy5pNFDlsW7Gku2Bv5xXpaW1a-1mcZX_2WdCOfqBbI,3083
-tests/validation/test_detector.py,sha256=fGLJP9P4EspDhXc1z1h-Qrpa7uIhk2ZX479KO6LGU-0,3538
-tests/validation/test_sphere_internal.py,sha256=mc2vgvqGjSvbsA3Wknfew_k_yxkoUSEPZ3YINqfQmHA,2180
-tests/validation/test_sphere_pymiescatt.py,sha256=iKd3ySCTpgbE6R_SMwjIOHnUWLDjwP6AkBhwLT_tfbY,2517
-tests/validation/test_sphere_scott_prahl.py,sha256=74T6lgF9yyeGfSM5R88J9EpCSew3vSYDCQrSZwnueEA,954
-PyMieSim-1.9.1.dist-info/LICENSE,sha256=Iiz1zBIAocPfqqVpPTakp8OKXY9K5j4bIRbgaXy2iAE,1109
-PyMieSim-1.9.1.dist-info/METADATA,sha256=7hvglHh_DlcJmEs8y8Txg_sunY6nWvgiggyN68VJuyQ,9453
-PyMieSim-1.9.1.dist-info/WHEEL,sha256=fZWyj_84lK0cA-ZNCsdwhbJl0OTrpWkxInEn424qrSs,102
-PyMieSim-1.9.1.dist-info/top_level.txt,sha256=QC3b6aFV2qIGEOt4YzIHvFOTfelhUO2SFy-2gt4UcGY,72
-PyMieSim-1.9.1.dist-info/RECORD,,
+development/debugging.py,sha256=YUi2aaYwvH4ajawSPtyEH296rW_ADEqGgwF4A68LjOI,148
+development/matthew_singer.py,sha256=larHhrqPlRoyz7BnGVjCs7H8VWzj42VDK_yfN39fiP0,1434
+development/fcm.py,sha256=rMNpkIvT7-mHL67mk5r74z1V_u_Pxp-t9C2J6gkw8Y4,1003
+development/matthew_singe-2.py,sha256=BTu-sDa1OeOexE2G1e7lEhlOMrvxP-SZSM6z5-frw-Q,1106
+development/gui.py,sha256=O06rk8eArzF4BUnWK24DMJAZG-jSuBv6bluY1wW5PjE,13307
+tests/experiments/test_coreshell.py,sha256=4EW6u0Ehufd4ncCxe6_Dztoe-zW8VAbnjolbbt1JWGU,2898
+tests/experiments/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+tests/experiments/test_sphere.py,sha256=22z1eLyuaZJFp8VhrlPhJaDgNf17wtkZyDItJFmrnjQ,2254
+tests/experiments/test_cylinder.py,sha256=3IMrVyWqhGurMg_K-jSgK6z1dqN1K7piJpM8UlsCwZg,2172
+tests/scatterers/test_coreshell.py,sha256=4e4pi6NpUI68mC8ui3aFmBiv6JEDeoXYo_EF1sMYjfc,3460
+tests/scatterers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+tests/scatterers/test_sphere.py,sha256=-hYi2YnczR1f_rj4ft477ed4wQRM54fQNzVNzSiLNH0,3021
+tests/scatterers/test_cylinder.py,sha256=z45rwRDnfdCezwfqJRh2bkZ4lE6_adtiJFs6vVevSf4,2568
+tests/extra/test_mesh.py,sha256=ppYBnDjLpo_QwzvdmEsPqdlG1RptXVIYtHyZpZWBAGw,209
+tests/extra/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+tests/detectors/test_integration_sphere.py,sha256=AUocm9eaTZJO3gzseb2jqjM6isEv7HdpQfZLPqkMsJ8,1509
+tests/detectors/test_coherent_mode.py,sha256=hCcEQr2TcTIXN0ykr_Y2_lmalBQzBO0NxB0XPMHhqKk,1776
+tests/detectors/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+tests/detectors/test_photodiode.py,sha256=yDzq5rzL7LNrJRgxaNNorbOlbpeSf_ce8ll0VQYk7Xc,1713
+tests/validation/test_detector.py,sha256=zZxfXNYM17zJiYOaI4xWsDYwaSn8KFoohlh8tTd8C4o,3417
+tests/validation/test_sphere_internal.py,sha256=A27SZD9c-eIMf_y2k-tPesnoDfKjZYDwIPZf9ccNVa8,2097
+tests/validation/test_sphere_scott_prahl.py,sha256=N3e8dNMuYuM_tUcSZsECSuGQigEt3vpTU49fCnyIW4A,914
+tests/validation/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+tests/validation/test_sphere_pymiescatt.py,sha256=SuWWVZH7KA2To8ZTshH0AHFlDL7wk3k6m4ULluLlFaI,2417
+tests/validation/test_coreshell_pymiescatt.py,sha256=HvQKGvBpSj2HFBdQov_iVTnSkkXa5oq44YGJM5QUBew,2973
+docs/source/conf.py,sha256=JgLEe9HbERRDR4YQPCBW9scrkNbyyRJDWkTS0n8hpk4,4528
+docs/examples/scatterer/plot_stokes.py,sha256=FvTwONETWNO42HQbKVqglI56VJ_znzqLYDIn_Y7mD00,905
+docs/examples/scatterer/plot_footprint.py,sha256=wJM-WTzZoNa_-2a-4kbRprXwiT9eK-yMoJSFPqxELtk,1289
+docs/examples/scatterer/plot_farfield.py,sha256=094qHbslIFFBcGc8q4x-wa49_w0EFzugLPNrw6D6xYw,1012
+docs/examples/scatterer/plot_s1s2.py,sha256=A3mXkcrG93P3e_SRvJbWWAJbeWAD3DJjoLRmMdEvkRY,899
+docs/examples/scatterer/plot_spf.py,sha256=rHkExmdGQd_hjrwvrZ9w7tsrTzuS-2WA1O_IsrLHV_U,961
+docs/examples/scatterer/plot_source.py,sha256=jGIS4CTvl7UFygQ-F2LCEl7xb_9KSH3j1-7GyQoA4Xo,565
+docs/examples/detector/plot_HG11.py,sha256=a-PU2kMhwH1WThshUvPhy2DgJUdDDf3OqD4AeknhPwg,830
+docs/examples/detector/plot_HG01.py,sha256=16tdjmu9aHpNQ8DREqpivbBPvcM27qhcDjs2Mn4BTbc,814
+docs/examples/detector/plot_LP02.py,sha256=VF_xOg70c5chrLdsFJ8Kbun3vR7xOxYzIlH9yHILrQ4,612
+docs/examples/detector/plot_integrating_sphere.py,sha256=o4yloxvZkrv1QxqGL8CMgRKhn1114AUAe6emterfRj0,534
+docs/examples/detector/plot_LG11.py,sha256=pt1vSTy9nDviBGSLk_H3588L_DiekxkIDTZygkHebI4,818
+docs/examples/detector/plot_photodiode.py,sha256=a8Hjwc_jjCnKFm2RxcLN6YQw9297ppy8AyQC7389vzI,638
+docs/examples/detector/plot_LP01.py,sha256=EmPx5OkfU_famJ_9i1A6PQFF195DRZqVXx0aZBa2j7g,793
+docs/examples/detector/plot_LP11.py,sha256=04xaLSkrt--ma78k06z27HfO_tt__IVJfDEzt_gybb4,612
+docs/examples/experiment/plot_cylinder_a11_vs_diameter.py,sha256=OmMrp4Hnvi8qzP7LU3tBZbz7OCozCDJwfyknv1mUFqI,1538
+docs/examples/experiment/plot_cylinder_coupling_vs_phioffset.py,sha256=ymxV7iKAEKMt8UKCISlTm_92mzrxkvqU_Rdp9ZvMuyA,1978
+docs/examples/experiment/plot_sphere_coupling_vs_phioffset.py,sha256=DjzxpvD8jhFkgQ8fYPgeIXx5o6fskXlAJrNQiAYvr1M,1289
+docs/examples/experiment/plot_cylinder_Qsca_vs_index.py,sha256=JAov3yJj70dQIEB2zpmGQDIrhlgrPDnjFRBQcA6g1DU,1561
+docs/examples/experiment/plot_coreshell_Qback_vs_corediameter.py,sha256=CLTMWqlsZDPECDAS2Pnab0YWP4XQGnSjdhmekqmmKMk,1836
+docs/examples/experiment/plot_sphere_a1_vs_diameter.py,sha256=wqywLkvu3OPh5DA3buJ57WCQW-vzRZNtXd1j-VzXfO4,967
+docs/examples/experiment/plot_sphere_coupling_vs_diameter.py,sha256=2OPPo9LHTIeCP4-KLW81YsTZXySmwi_17B1YhLyjLmE,1333
+docs/examples/experiment/plot_cylinder_Qabs_vs_diameter.py,sha256=7sFmrPPeRjQ8lfMdLJrfv80jTDt99cag6Y-A6drWpaU,1810
+docs/examples/experiment/plot_cylinder_Qsca_vs_diameter.py,sha256=NJYwURVA0N0zpY9qtKGhFOUiQPZhMI6u-o_7_wwWt5s,1568
+docs/examples/experiment/plot_cylinder_coupling_vs_diameter.py,sha256=T12a80e9FmJk4rCCwBc_Gn0Anm2963BJJGjdH9rStOw,1956
+docs/examples/experiment/plot_sphere_Qsca_vs_index.py,sha256=z1kfKy9pw1-RQ55eSSgkfskdLsLHlF69805Xwtv7Eow,954
+docs/examples/experiment/plot_sphere_b1_vs_diameter.py,sha256=o-vlBQpkjm5C1WoWJ4PGOUgw6jZCqcJmmmFiJrKcELQ,964
+docs/examples/experiment/plot_sphere_coherent_coupling_vs_rotation.py,sha256=TtKOo6XpKvkCTgHutPRIeYJLmS7gSIxBv0cKqMmaGa8,1316
+docs/examples/experiment/plot_sphere_Qsca_vs_diameter.py,sha256=1tgH79JeY_ZohnD97XTSe1dP2QvyZfyfwPnZB6RJ30c,971
+docs/examples/experiment/plot_sphere_Qsca_vs_wavelength.py,sha256=cme8a21sCBSEOdKuQoF24GVJRZUjcux7XDUZCumIfBM,982
+docs/examples/experiment/plot_sphere_Qabs_vs_diameter.py,sha256=-KEU7xhz9foEALvy3-q8YurIueN2UKHK9C9mdUKV_Ag,1063
+docs/examples/experiment/plot_sphere_coherent_coupling_vs_phioffset.py,sha256=Aanv90bj6uzV0J7pVV1cC_LpsEPEObt-aJaRzNzLYTs,1382
+docs/examples/experiment/plot_coreshell_a1_vs_corediameter.py,sha256=vg-Jde0SVWMxBEhrspQPeIQ_vVvPs2eM8jh-Fq_7loU,2062
+docs/examples/experiment/plot_coreshell_coupling_vs_corediameter.py,sha256=o_UkZu7MOfNAHOG7A8qfD5lS033ByqW48kSZGyU1fuE,2054
+docs/examples/experiment/plot_cylinder_b11_vs_diameter.py,sha256=eki0LK653_0vtV8l7a8vpHeP7rhCnl1O0KT39FGFL6g,1452
+docs/examples/experiment/plot_coreshell_b1_vs_corediameter.py,sha256=KH1s7Y03fCBVJcXwJs6zWSeY0MixgjVY4C7MS7oxsyA,1969
+docs/examples/experiment/plot_sphere_Qsca_vs_wavelength_std.py,sha256=Sp9d_bYFbNV0ihdPBu1iqlLbqz7VCo6Ehp9zpzsKpd8,1093
+docs/examples/experiment/plot_sphere_coupling_vs_wavelength.py,sha256=SD0wgCL2yy5Fu7E9KmY_IKWyQPSD05s271FC-Y_ovP0,1373
+docs/examples/experiment/plot_cylinder_Qsca_vs_wavelength_std.py,sha256=RFhl6uduyN-dMTMTm_miKGjanJFEtuwpvLcNn3ffpjw,1098
+docs/examples/experiment/plot_cylinder_coupling_vs_wavelength.py,sha256=mJfWQbbB3jbw3v8GtR_ExoJv7Y1l2r_1m5-wfGqJJR4,2187
+docs/examples/experiment/plot_sphere_coupling_vs_filter.py,sha256=Ao5iG6r5zAp18pBlNrwsib9zV4xGLPJnAlTgsKd8R9o,1420
+docs/examples/experiment/plot_cylinder_Qsca_vs_wavelength.py,sha256=WoJN9jp9r4HZu3d6YFwPxwSmakD-fPP9i7cPag5UCVE,1888
+docs/examples/validation/plot_pymiescatt_0.py,sha256=2zTuv5Bhnm4mIA7yQir-yur8BaXQ1UVuMolDK5wXWdY,1878
+docs/examples/validation/plot_phase_function_detector.py,sha256=jYeFe5ZV9niz5oJreftSn3etMNGQ8UYsOJRKghkWW4c,2653
+docs/examples/validation/plot_pymiescatt_1.py,sha256=4Lfxq7egUq1tuWIw1QdlQrlLAAzLHubHZzkzQxmXA4w,1956
+docs/examples/validation/plot_BH87.py,sha256=kbq-dDrAxcuCIVOGPgFlAwp1olgIhUkB1xMGeht8kBk,1569
+docs/examples/validation/plot_BH88.py,sha256=L5-TqFGGJgBqTV3IrdQWdYcxdiGVfDRWBoPe9QY49gk,2599
+docs/examples/validation/plot_BH810.py,sha256=BdXfq_cbsRNfCV5AK2M3FM1FHRCmb1qe3_C8B4V0gCE,1154
+docs/examples/validation/plot_pymiescatt_2.py,sha256=sILJ0UO6rj3GTfV0zBN0eu30U9fHDfnjwNLejhWLatI,2143
+docs/examples/validation/plot_pymiescatt_3.py,sha256=vcgQw_aZ84kBjJMRkua6_y5Axg6c_HXCe5UpTy7jhsg,2246
+docs/examples/extras/SphereProperties.py,sha256=uM27yTtct97eJZqmfY22G40cQzKfCcwqronI1nhwWvs,983
+docs/examples/extras/plot_Qsca_vs_permittivity_vs_size_parameter.py,sha256=7A7VryNHDrZLrw6NUxSVcKUaJh5biR4wyxgtto2EmJE,1528
+docs/examples/extras/plot_coupling_heatmap.py,sha256=KCHzC-J2F8r_QywmcRQXUjwiOoABTD7Lf_PuHZ0R8MM,1663
+PyMieSim/measure.py,sha256=x-JKKDUc46oymAJTs3MfQdeYqVJK5xJ_1kwgeSQB0Yc,3680
+PyMieSim/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+PyMieSim/mesh.py,sha256=EFCa93ZBi1U5SHqPuC7BYnUbwUj8tA_KL_OdYAkoaQg,7626
+PyMieSim/physics.py,sha256=3hSIwyen2eOs91Uj93nRI5QcX1Yrev0NJdwVbUQptjM,1932
+PyMieSim/VERSION,sha256=JyvJHgCQJn-THkr7jL9H-s1Ea2VWcQz-X3BiHK64uxk,6
+PyMieSim/polarization.py,sha256=99o80q5yc-5p7gA_SLM3K8aLL1Q6sjuJxUlsD3O74Hc,2011
+PyMieSim/__main__.py,sha256=xmv24e7pxaAvdnlLmyrKVogv0rtOIlJTm0dyy2gmURg,215
+PyMieSim/tools/directories.py,sha256=m4NOA8BYRO-9gSQvwQSP4y6pxEiCaRBK5j6e7Qs--R0,1133
+PyMieSim/tools/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+PyMieSim/tools/special_functions.py,sha256=XCxMMh9gTnCczbWbSSdgMZw-J3uronmEAIr-aD3jQys,6049
+PyMieSim/single/detector.py,sha256=OoQcmjWGrWfyMxzlPXMJDyXU2vx6aZcSio1JqBT29vY,10357
+PyMieSim/single/scatterer.py,sha256=QOtm26hpmi4oMNzU2xkB9fEVykz-8B1dq5BI9pKItP0,19442
+PyMieSim/single/__init__.py,sha256=XIP4NITB_-I7K4WnLlme9PmNAKqaXlbHdbqiYdknNTg,137
+PyMieSim/single/representations.py,sha256=V1EYolSwvHNGJTf5bzsearmWRIBk9OZD06vDBurDfEY,19167
+PyMieSim/single/source.py,sha256=o-Bnz-ETm2Q2ZHPSMHDIyekgNw8kp3oCa09Grkvi2Rc,5414
+PyMieSim/.dylibs/libgomp.1.dylib,sha256=czG2jGghWnJgVuF3fyoGVy_4Sbu96tmDbZI1Ojbmc88,477504
+PyMieSim/validation_data/Figure87BH.csv,sha256=h4Rk4DSjQSTfq-BYfXYP51MBwBfygfOePqDhrHk6xkY,40000
+PyMieSim/validation_data/PyMieScattQsca.csv,sha256=EH2Nwi8UFRbltHu-ErURw0tJHDthnLD3k8nCcbN6law,20000
+PyMieSim/validation_data/Figure810BH.csv,sha256=KCea8BeVm3LBw8tbKWVQf18EiE6tOtQFKEs4fs4jxDk,9828
+PyMieSim/validation_data/PyMieScattQscaCoreShell.csv,sha256=pHyrVFIEa7NSOQ3OxmgnkrNkajJWW8K3-ioGHfMfMyU,10000
+PyMieSim/validation_data/Figure88BH.csv,sha256=SimTnjZ-13-ovY0MmYKvgjqXuCIwhFE8crjaN_iNrEs,40000
+PyMieSim/validation_data/PyMieScattQscaMedium.csv,sha256=655BTGdcxmA4lBd2V_51YRGjiRzihl2ISxAC_JGRa-M,20000
+PyMieSim/validation_data/PyMieScattQscaCoreShellMedium.csv,sha256=0S5USnRpPkT-3jSFFUh-RvjjrE-8EauLKLvt_r7M0D4,10000
+PyMieSim/gui/main_window.py,sha256=LDDxzkkZ_hzoPyBnK68pccSLJ8QWc6ckltu5lgzoAKo,7483
+PyMieSim/gui/source_tab.py,sha256=h6y2EzeZQORxOYisegYL2z51ds2jtMLzRQh0bE9BOzg,2570
+PyMieSim/gui/__init__.py,sha256=6AInDmiep03bOHlmiutVXBN7WTgxZFhXe4H-h6mF7Q4,203
+PyMieSim/gui/axis_tab.py,sha256=GVvmOcQ9B3SoVUsrilQXzBkzQaqLHO05zM-DxAl-27U,3208
+PyMieSim/gui/base_tab.py,sha256=QG2Y7JLMR8IsvrPEMZonSirZ9b63JLEQtDo-cERZx64,3306
+PyMieSim/gui/widgets.py,sha256=Tg0GhiRURURyjuCZhEcY78jRNX3VQ4Mk507tLQ8papE,6471
+PyMieSim/gui/widget_collection.py,sha256=TbsfMLWbawwrmgnAHqJGHQ7BEH32Fg1pGxB-pI66Tk8,3032
+PyMieSim/gui/detector_tab.py,sha256=n5epTGfE3uosRSNbHnaPxFpZncTGVTYdUN9TOuNTq-M,6245
+PyMieSim/gui/scatterer_tab.py,sha256=fwxZ-97_VK9v-6bWoa5_uZklSZgy2UfKi8DnOXmT45g,6915
+PyMieSim/experiment/detector.py,sha256=AxOhcjHFCdyS_9HgUTt9KliWTrCquauImN93hriyfX8,8281
+PyMieSim/experiment/scatterer.py,sha256=_CnsgsSc4I-cAwPDgsBNfdci6RWjJBpoSz_SfGOYWBE,17033
+PyMieSim/experiment/__init__.py,sha256=ZRc5g124IZ_0FFmR0TyJA_27X8uIbyxmyhganbTYd7M,162
+PyMieSim/experiment/setup.py,sha256=S8Ye4bIMnqIE9cCoWWbdpgfrh14jXSyWdcy2cNBbAbo,4992
+PyMieSim/experiment/source.py,sha256=l3qIT7TUh5sRoayLxLQwGJZPR14SXPqyeojbhdQgnqQ,5493
+PyMieSim/binary/DetectorInterface.cpython-311-darwin.so,sha256=07JhIR4F9O6vnRk72p3Ed-X2GoucU14r7ntnShY4_5g,1006560
+PyMieSim/binary/CoreShellInterface.cpython-310-darwin.so,sha256=7XQK06SPAniVyqaChiTXT_k8MBN8DbAqWGkxLDmEtjU,957560
+PyMieSim/binary/ModeField.cpython-312-darwin.so,sha256=5Kg8brWefFY-TQJ2uLbAAjfOS_rgnO2FPmmnwiSHa58,430144
+PyMieSim/binary/CylinderInterface.cpython-312-darwin.so,sha256=TCxqO6c1tZsXKCA9Z7o0shjX9mNL2IQ7FYCiINfZwA8,941240
+PyMieSim/binary/Fibonacci.cpython-312-darwin.so,sha256=JSYFXa-PzU2PB6CDLuMFFovgwLzwtIWtx5ztJ3Hllzc,467368
+PyMieSim/binary/Sets.cpython-312-darwin.so,sha256=Wq00BcK_EH_CaL2x5tLL-CxYQ-pODqnP_CkvqjO1w6o,1025424
+PyMieSim/binary/DetectorInterface.cpython-310-darwin.so,sha256=mIjgZxx38wUnVWWh8PPr2ASWIowKxS21ofk13u8vmlg,1006560
+PyMieSim/binary/CoreShellInterface.cpython-311-darwin.so,sha256=3bW7oyHbCxpExalytJK0ZzQJE-gj7q3citOO2fd4kQg,957560
+PyMieSim/binary/SphereInterface.cpython-312-darwin.so,sha256=vQyFPYrKLKYejZLuRvh8wt1qgj6QprdN1x3z8PZHJlk,957776
+PyMieSim/binary/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+PyMieSim/binary/Experiment.cpython-312-darwin.so,sha256=p0iD5W8MjcL4O-JuHMibLtrsrg-Cd5FUuUPZzFw8DpU,1117760
+PyMieSim/binary/CylinderInterface.cpython-311-darwin.so,sha256=E6PxYrmFBp9pKQxnCZkMdVyGY357zs0qgKsjd4vBh1I,941120
+PyMieSim/binary/libZBessel.a,sha256=iVzjA3UqiKyiUQOsWeShwoc9WlsH0jGCXGipaxpSeLA,158824
+PyMieSim/binary/CoreShellInterface.cpython-312-darwin.so,sha256=5riZukp2bn90cMlzWlJkZn3gvD3MAnF-J8-nNPCSwe0,957696
+PyMieSim/binary/Sets.cpython-311-darwin.so,sha256=EhLz6TJx3Jo4TAI43oMvWzjhxneigjunn6U5yJKTGU0,1025312
+PyMieSim/binary/Fibonacci.cpython-311-darwin.so,sha256=BF2xbxEYfj75Bkdebr67Bgzn7zTt17FlNAqJc8Q_2LA,467248
+PyMieSim/binary/SphereInterface.cpython-311-darwin.so,sha256=6AFS91T39sEOdbWp9P4-bJpMjZupQhBI1I46KhRHxrs,957640
+PyMieSim/binary/ModeField.cpython-310-darwin.so,sha256=c7VYYaO2GIgpLuC2ojLQzogxlsMKG_1yNuXcCoXrLRo,429872
+PyMieSim/binary/Experiment.cpython-311-darwin.so,sha256=hdZTE296tcz-ClPQJcV8V8OxL2DL8ybT_ERqwGdFuPk,1117648
+PyMieSim/binary/CylinderInterface.cpython-310-darwin.so,sha256=Hcqd3KNV1rQfEt7FtYiUhFWotFyvaV-UtY_kpIDCpnc,941120
+PyMieSim/binary/DetectorInterface.cpython-312-darwin.so,sha256=N-_kuMoGEn1N1CVw4wPkRdPEj6IsT87rxi1yd3yGvHA,1006696
+PyMieSim/binary/Fibonacci.cpython-310-darwin.so,sha256=nn5y5_ZhbX7eNB5vbYZd-SPPZb_PHQgvChmWEtQ48XU,467248
+PyMieSim/binary/Sets.cpython-310-darwin.so,sha256=6qsdpzx2BbeDi0LwRgxpLktCsmP2ID3rLv0PDm8BPPA,1025312
+PyMieSim/binary/SphereInterface.cpython-310-darwin.so,sha256=Twn4Ywtq4LmrEsLjdsf9_gRPkTclHXJzwY5AQ6T74XE,957640
+PyMieSim/binary/ModeField.cpython-311-darwin.so,sha256=dNnsVugMT-Ec7H_dl5fkMgRj_deVvBWhx2UK_oRBza4,429872
+PyMieSim/binary/Experiment.cpython-310-darwin.so,sha256=IdHLtV4YiHDPhLGgZ8KbZ4Py3tPB3b8W3wFUcm_-s6Y,1117648
+extern/pybind11/setup.py,sha256=b4JU_muegBOAidH4nQtGIwaVv-SxpIQTTtH_8YLOZrk,4877
+extern/pybind11/noxfile.py,sha256=ZxT4ijLbSroSevM-BfUi6JtZEPXpAMJXR7F2XobbgUo,2765
+extern/pybind11/tools/libsize.py,sha256=3MBZDCi0-kdKei_6RcTbmVJgtmT4udB-WIF-mOPLBD4,1031
+extern/pybind11/tools/make_changelog.py,sha256=W1WAntnxxI8vWp6JPikaiY6FToN4vpYcXFBSJhP7ZdM,1311
+extern/pybind11/tools/codespell_ignore_lines_from_errors.py,sha256=rf-frzFTrUyfZ9PsnJbbhirTRGOaL48gXDhH-ba68e0,1040
+extern/pybind11/pybind11/setup_helpers.py,sha256=diXZSoqOnN9ecbfA63tjmcCiWxgqk1kJmBiAm7JBoFY,17650
+extern/pybind11/pybind11/_version.py,sha256=iVAGMbN1h-XFnoSwTYnXdV3F67ni09TRUfHu_tppoWs,228
+extern/pybind11/pybind11/__init__.py,sha256=5KKIhY_RgzBRRHCtqsEF0SWrCs4RAcK_GOI-EVIzp7M,414
+extern/pybind11/pybind11/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+extern/pybind11/pybind11/commands.py,sha256=u9TzdwHN7iQD6Zy8gwvOqvU0GLeIT6Hf_PVdkqxLlGY,1226
+extern/pybind11/pybind11/__main__.py,sha256=ATLlhFlhBxDXxxXEfnf2F1RcRhuWN1ziMwbmrGuhif0,1544
+extern/pybind11/tests/test_stl_binders.py,sha256=-sd2D1uiEzD1Q8VrifxlMyiWiOPNkvvXRUsmLpcbNzw,9174
+extern/pybind11/tests/test_methods_and_attributes.py,sha256=-cLl_FwgnqoE15_iSIJN5vnLe7gbUUrLr4obpuVNAX8,18134
+extern/pybind11/tests/test_sequences_and_iterators.py,sha256=VqLfJU7U1JEH2rJKPGnMWwZLkJSOomgQGYY_r1ERJhA,8021
+extern/pybind11/tests/test_numpy_vectorize.py,sha256=xZapScMZl-dM3xeN379WUlrQf0jE_rnxNd2f1Xxz3OA,9686
+extern/pybind11/tests/test_chrono.py,sha256=wWRj4tub996ztvM47I32U3V4Zh4Fyrsts12NWVC6KfE,5691
+extern/pybind11/tests/conftest.py,sha256=ukIIUMdkT32ytGy5CWzwn61u2axWN3Y1CW4GoUYERnM,5876
+extern/pybind11/tests/test_callbacks.py,sha256=fQzWzGGkPjhxxcLohnYDvFcfgn3DJGRuqzxKrbgI_2Q,6246
+extern/pybind11/tests/test_pytypes.py,sha256=rM3Lz2an6IQHFP9HvtW4sNgx3G5AGSktvPBB5ft78JY,23630
+extern/pybind11/tests/test_class.py,sha256=tVYI_AR9qqQ-S6Jc8v6p5f8w9yCVQNuWN0p2c1xOR2Q,14814
+extern/pybind11/tests/env.py,sha256=3XObndTBgxNBvN2mu7ae-SeJrBGrlmGE-79oISP4Dw8,940
+extern/pybind11/tests/test_eigen_tensor.py,sha256=lTEsTH2fHaNQeeWxVelZk6NKfLVEVubk39du8XpMvzg,9450
+extern/pybind11/tests/test_docstring_options.py,sha256=9SIyCr1g7mRKCpL5Y1op_Wvo2Wnyfs1eVDdQjvo2V64,2423
+extern/pybind11/tests/test_async.py,sha256=gBAb1FO_U94Q_7A5PQcz9ZOqGxq5a81nPzcZ6Ed7Nz4,534
+extern/pybind11/tests/test_local_bindings.py,sha256=Z4aupdd8VqwEL_YtqauPisMGDQ96Wq2u0WX7Tlgs3Po,8054
+extern/pybind11/tests/test_smart_ptr.py,sha256=Pg4squkdWXLQbzkPpW_uJwCD8t3C--tXRhkrQaOV6Lo,9530
+extern/pybind11/tests/test_numpy_array.py,sha256=X6rr1vYRD8CvoFdLrAnhxXcBEc2DvhcT88U85goPu2A,20356
+extern/pybind11/tests/test_builtin_casters.py,sha256=h44NPHdMQPapC59PRCo7ZwJfd8d2YFs9-_FUkpLGPq0,17245
+extern/pybind11/tests/test_constants_and_functions.py,sha256=lvquiDGfVq6r2UvsjVemr9GmLWb2G0P0Qkz7c1yGmQ0,1498
+extern/pybind11/tests/test_exceptions.py,sha256=vR6KA9eGUm1s_ymAniAdst4-6xkp-mFFEAZ9U68uLko,12774
+extern/pybind11/tests/test_factory_constructors.py,sha256=bTHcP5Tp_e2IPYRdP9l2rBUlc3Z05Orz214aqaVIY7s,16519
+extern/pybind11/tests/test_iostream.py,sha256=6aIdahmb5aFdfpB8sMDKYseVZPxaOVvDXFD6t3IzNcA,7286
+extern/pybind11/tests/test_operator_overloading.py,sha256=EXYVO-xVcZ7JGqtbf9kr_jSr4z9vWPp9WlzkWdXMLxQ,4332
+extern/pybind11/tests/test_union.py,sha256=k80v8rRTygvDKJ1glA8Pptl1_JWxn2hHSIZUnzJ_M-4,148
+extern/pybind11/tests/test_kwargs_and_defaults.py,sha256=_3vTUNVmMmuK4s2npgUmG5b-lqXB9V6Py0f5_eQlSeg,13757
+extern/pybind11/tests/test_thread.py,sha256=0UOYRTgU4Cn2NyMqKXTCRPvLPV2VZp1tv5g_GCiJVRI,826
+extern/pybind11/tests/test_pickling.py,sha256=YdQB55beQ2jM3chdltDDdDgDFTgafB2p_C-kYRfeyNE,2720
+extern/pybind11/tests/test_copy_move.py,sha256=g3Ko_liPXH1HoGMRF18rK5uCPmZ3VmRM4NZ4NFlzr50,4796
+extern/pybind11/tests/test_eval_call.py,sha256=Sv6xRg8O6PFz9bu4E-SngKmKAJDR-zoraB4DJxiIwsQ,119
+extern/pybind11/tests/test_custom_type_casters.py,sha256=dBjFobEJ35lHHWo2X58iEt7CfZIkGb3QVZ_39VYCezY,3985
+extern/pybind11/tests/test_stl.py,sha256=8Kc8SsWKT9UT2bKEU9dQnoXNVGIXbj9_L7DfPKbyPHM,12235
+extern/pybind11/tests/test_numpy_dtypes.py,sha256=MNgWJxNi0DFJ3ly1NMAd9zhiWaRTSO0RWvYpkthTVGM,14394
+extern/pybind11/tests/test_eigen_matrix.py,sha256=XVheuyaODL76SpAMRKqyLQMtbL6q20h9-IlgdjiO-NA,28867
+extern/pybind11/tests/test_opaque_types.py,sha256=9NC9CVbTICcgHROPDELwp8cAODmEhiAJZorhXJVOsFw,1847
+extern/pybind11/tests/test_virtual_functions.py,sha256=9OjPO76mrpGpO6ytU4zS754cmHvDAo0wsXNtcV65kp4,12919
+extern/pybind11/tests/test_const_name.py,sha256=z8q4xkeQ0xn69buofJ6dNR0RzVkMfB27fAqaZ6C_694,589
+extern/pybind11/tests/test_call_policies.py,sha256=Sh6W8mZl_6WES3wl0Xg37wDRKtwvfTYN4KVrbMjgGCg,6549
+extern/pybind11/tests/test_custom_type_setup.py,sha256=2aNhQbXLT-g3xhY-rpUY7rvvpAWrkN666wwKU5Nbv74,1089
+extern/pybind11/tests/test_buffers.py,sha256=cPZ41-XaAz5BDjmTe7rOdZt46gZ3lnx8YIIokMBfBa0,4841
+extern/pybind11/tests/test_modules.py,sha256=7aZHbYCSvKcsZPYDVHBtrgfDke-kffPtc58t6pALPgc,4209
+extern/pybind11/tests/test_gil_scoped.py,sha256=g9yvKayKFzlycrJAPLdb01ong9mfsHZNlzECX9fvi1o,8540
+extern/pybind11/tests/test_multiple_inheritance.py,sha256=TMfFciBKCWT_HMEiJd4rsM5UAah0vwDO2ce80gmajCU,11874
+extern/pybind11/tests/test_tagbased_polymorphic.py,sha256=SOZRvD7dO-d8yN0rdwdNwuierZ_QSGBxGdHyr8jAg5I,741
+extern/pybind11/tests/test_eval.py,sha256=OWASlmDmIp_YVBWdfJWqQsVnXNNXAf9bbTrbYfXnkts,1143
+extern/pybind11/tests/test_enum.py,sha256=KaWtjctFemc_vEYEzP8pLv_QsCIxQfXV5p_0bdUzup4,8903
+extern/pybind11/tests/test_embed/test_trampoline.py,sha256=Imweq5_SBMVAHq3Z2Zk2BBhdsU051vlQCDTPCN_VHFM,275
+extern/pybind11/tests/test_embed/test_interpreter.py,sha256=9IOkq9zAEvHwSfYphifX44hic0IxULirsSxpOYylePk,237
+extern/pybind11/tests/test_cmake_build/test.py,sha256=U_GX_6p4JTzq-zPzmopNAoD_MuPfE0MLiiJf4-u24O8,198
+extern/pybind11/tests/extra_setuptools/test_setuphelper.py,sha256=msgUx7ZS651vGZ9Jg_f4LBdQ2otkdOb61dLBBpmvC6k,4153
+extern/pybind11/tests/extra_python_package/test_files.py,sha256=QM3ebvWRfMDyDmfuC2SSIe3ZiIRM_DgsI7N73fFQrM4,8294
+extern/pybind11/docs/benchmark.py,sha256=6YUl1vJBLvkk9R5gt1zaPwVpJUelw_Ps3R0e1CJfP0U,2856
+extern/pybind11/docs/conf.py,sha256=f6m9fvBG1NyNzP9k2K7iQg_PRA3C-kj_ltuZ0ahVGEs,11558
+PyMieSim-1.9.3.dist-info/RECORD,,
+PyMieSim-1.9.3.dist-info/LICENSE,sha256=-QSWDJghhVqbAzChmEK86liqPX_eeQFgdwlrKTLLcIA,1088
+PyMieSim-1.9.3.dist-info/WHEEL,sha256=Vo9YTsjXxZ5SWdH4n69oS5jU3YTIi3eHk0n-aUcTtlw,110
+PyMieSim-1.9.3.dist-info/top_level.txt,sha256=LXxvGEpF7Cp4kfne59F3N5PyIbrWpo_9WGmMYe3YyvE,60
+PyMieSim-1.9.3.dist-info/METADATA,sha256=OWZxe8vEybhXz2ibuDto08M1QBxo2jh--9LOgUzYNEM,10426
```


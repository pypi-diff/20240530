# Comparing `tmp/genie.libs.sdk-3.1.8-py3-none-any.whl.zip` & `tmp/genie.libs.sdk-3.1.9-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,479 +1,480 @@
-Zip file size: 453727 bytes, number of entries: 477
--rw-r--r--  2.0 unx     1676 b- defN 18-Dec-06 20:25 genie.libs.sdk-3.1.8-py3.5-nspkg.pth
--rw-r--r--  2.0 unx     1128 b- defN 18-Dec-06 20:24 genie/libs/sdk/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/libs/__init__.py
--rw-r--r--  2.0 unx       26 b- defN 18-May-14 16:03 genie/libs/sdk/libs/abstracted_libs/__init__.py
--rw-r--r--  2.0 unx     1002 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/configure_snapshot_command.py
--rw-r--r--  2.0 unx    10315 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/ha.py
--rw-r--r--  2.0 unx     1019 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/init_exec_commands.py
--rw-r--r--  2.0 unx     1853 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/management_interface.py
--rw-r--r--  2.0 unx    31603 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/processors.py
--rw-r--r--  2.0 unx    12327 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/subsection.py
--rw-r--r--  2.0 unx      256 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/ios/__init__.py
--rw-r--r--  2.0 unx     1016 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/ios/init_exec_commands.py
--rw-r--r--  2.0 unx     1641 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/ios/management_interface.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/libs/abstracted_libs/iosxe/__init__.py
--rw-r--r--  2.0 unx      680 b- defN 18-May-14 16:03 genie/libs/sdk/libs/abstracted_libs/iosxe/ha.py
--rw-r--r--  2.0 unx     1018 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/iosxe/init_exec_commands.py
--rw-r--r--  2.0 unx     1653 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/iosxe/management_interface.py
--rw-r--r--  2.0 unx     5567 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/iosxe/processors.py
--rw-r--r--  2.0 unx    11394 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/iosxe/restore.py
--rw-r--r--  2.0 unx    23667 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/iosxe/subsection.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/libs/abstracted_libs/iosxe/asr1k/__init__.py
--rw-r--r--  2.0 unx    20020 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/iosxe/asr1k/ha.py
--rw-r--r--  2.0 unx     3186 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/iosxe/asr1k/subsection.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/libs/abstracted_libs/iosxe/c3850/__init__.py
--rw-r--r--  2.0 unx     1056 b- defN 18-May-14 16:03 genie/libs/sdk/libs/abstracted_libs/iosxe/c3850/ha.py
--rw-r--r--  2.0 unx     3111 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/iosxe/c3850/subsection.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/libs/abstracted_libs/iosxr/__init__.py
--rw-r--r--  2.0 unx     2594 b- defN 18-May-14 16:03 genie/libs/sdk/libs/abstracted_libs/iosxr/ha.py
--rw-r--r--  2.0 unx     1018 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/iosxr/init_exec_commands.py
--rw-r--r--  2.0 unx     1641 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/iosxr/management_interface.py
--rw-r--r--  2.0 unx     8623 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/iosxr/restore.py
--rw-r--r--  2.0 unx     1981 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/iosxr/subsection.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/libs/abstracted_libs/iosxr/iosxrv/__init__.py
--rw-r--r--  2.0 unx     1946 b- defN 18-May-14 16:03 genie/libs/sdk/libs/abstracted_libs/iosxr/iosxrv/ha.py
--rw-r--r--  2.0 unx      256 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/junos/__init__.py
--rw-r--r--  2.0 unx      967 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/junos/configure_snapshot_command.py
--rw-r--r--  2.0 unx     1054 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/junos/init_exec_commands.py
--rw-r--r--  2.0 unx     2168 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/junos/management_interface.py
--rw-r--r--  2.0 unx     1212 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/junos/subsection.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/libs/abstracted_libs/nxos/__init__.py
--rw-r--r--  2.0 unx     7432 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/nxos/ha.py
--rw-r--r--  2.0 unx     1092 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/nxos/init_exec_commands.py
--rw-r--r--  2.0 unx     1651 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/nxos/management_interface.py
--rw-r--r--  2.0 unx     9736 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/nxos/restore.py
--rw-r--r--  2.0 unx     1316 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/nxos/subsection.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/libs/abstracted_libs/nxos/n7k/__init__.py
--rw-r--r--  2.0 unx     1498 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/nxos/n7k/ha.py
--rw-r--r--  2.0 unx     3134 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/nxos/n7k/subsection.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/libs/abstracted_libs/nxos/n9k/__init__.py
--rw-r--r--  2.0 unx     2487 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/abstracted_libs/nxos/n9k/subsection.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/libs/utils/__init__.py
--rw-r--r--  2.0 unx    11848 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/utils/common.py
--rw-r--r--  2.0 unx    59108 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/utils/mapping.py
--rw-r--r--  2.0 unx    20100 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/utils/normalize.py
--rw-r--r--  2.0 unx    12396 b- defN 18-Dec-06 20:24 genie/libs/sdk/libs/utils/triggeractions.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/addremove/__init__.py
--rw-r--r--  2.0 unx     5942 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/addremove.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/acl/__init__.py
--rw-r--r--  2.0 unx      420 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/acl/addremove.py
--rw-r--r--  2.0 unx      256 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/acl/iosxe/__init__.py
--rw-r--r--  2.0 unx    29414 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/acl/iosxe/addremove.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/addremove/bgp/__init__.py
--rw-r--r--  2.0 unx    12955 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/addremove/bgp/addremove.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/addremove/bgp/nxos/__init__.py
--rw-r--r--  2.0 unx   138570 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/bgp/nxos/addremove.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/igmp/__init__.py
--rw-r--r--  2.0 unx      386 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/igmp/addremove.py
--rw-r--r--  2.0 unx      256 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/igmp/nxos/__init__.py
--rw-r--r--  2.0 unx    28001 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/igmp/nxos/addremove.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/lag/__init__.py
--rw-r--r--  2.0 unx      405 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/lag/addremove.py
--rw-r--r--  2.0 unx      256 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/lag/iosxe/__init__.py
--rw-r--r--  2.0 unx    25243 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/lag/iosxe/addremove.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/mld/__init__.py
--rw-r--r--  2.0 unx      381 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/mld/addremove.py
--rw-r--r--  2.0 unx      256 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/mld/nxos/__init__.py
--rw-r--r--  2.0 unx    28181 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/mld/nxos/addremove.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/msdp/__init__.py
--rw-r--r--  2.0 unx      718 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/msdp/addremove.py
--rw-r--r--  2.0 unx      256 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/msdp/nxos/__init__.py
--rw-r--r--  2.0 unx    48935 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/msdp/nxos/addremove.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/pim/__init__.py
--rw-r--r--  2.0 unx      202 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/pim/addremove.py
--rw-r--r--  2.0 unx      257 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/pim/nxos/__init__.py
--rw-r--r--  2.0 unx     5426 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/pim/nxos/addremove.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/routing/__init__.py
--rw-r--r--  2.0 unx      299 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/routing/addremove.py
--rw-r--r--  2.0 unx      256 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/routing/iosxe/__init__.py
--rw-r--r--  2.0 unx    13808 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/routing/iosxe/addremove.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/trm/__init__.py
--rw-r--r--  2.0 unx       51 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/trm/addremove.py
--rw-r--r--  2.0 unx      256 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/trm/nxos/__init__.py
--rw-r--r--  2.0 unx    13443 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/trm/nxos/addremove.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/vxlan/__init__.py
--rw-r--r--  2.0 unx      138 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/vxlan/addremove.py
--rw-r--r--  2.0 unx      256 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/vxlan/nxos/__init__.py
--rw-r--r--  2.0 unx    27040 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/addremove/vxlan/nxos/addremove.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/clear/__init__.py
--rw-r--r--  2.0 unx     5705 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/clear/clear.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/clear/bgp/__init__.py
--rw-r--r--  2.0 unx    26523 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/clear/bgp/clear.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/clear/bgp/iosxr/__init__.py
--rw-r--r--  2.0 unx     1775 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/clear/bgp/iosxr/clear.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/clear/bgp/nxos/__init__.py
--rw-r--r--  2.0 unx    20065 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/clear/bgp/nxos/clear.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/clear/interface/__init__.py
--rw-r--r--  2.0 unx     4146 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/clear/interface/clear.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/clear/interface/iosxe/__init__.py
--rw-r--r--  2.0 unx     1492 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/clear/interface/iosxe/clear.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/clear/interface/iosxr/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/clear/interface/nxos/__init__.py
--rw-r--r--  2.0 unx     1544 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/clear/interface/nxos/clear.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/clear/ipv6/__init__.py
--rw-r--r--  2.0 unx     2203 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/clear/ipv6/clear.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/clear/ipv6/nxos/__init__.py
--rw-r--r--  2.0 unx     1635 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/clear/ipv6/nxos/clear.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/clear/mcast/__init__.py
--rw-r--r--  2.0 unx     9536 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/clear/mcast/clear.py
--rw-r--r--  2.0 unx      256 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/clear/mcast/nxos/__init__.py
--rw-r--r--  2.0 unx    12106 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/clear/mcast/nxos/clear.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/clear/msdp/__init__.py
--rw-r--r--  2.0 unx    12517 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/clear/msdp/clear.py
--rw-r--r--  2.0 unx      256 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/clear/msdp/nxos/__init__.py
--rw-r--r--  2.0 unx     9817 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/clear/msdp/nxos/clear.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/clear/ospf/__init__.py
--rw-r--r--  2.0 unx     2831 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/clear/ospf/clear.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/clear/ospf/nxos/__init__.py
--rw-r--r--  2.0 unx     3260 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/clear/ospf/nxos/clear.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/clear/routing/__init__.py
--rw-r--r--  2.0 unx     8970 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/clear/routing/clear.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/clear/routing/nxos/__init__.py
--rw-r--r--  2.0 unx    14872 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/clear/routing/nxos/clear.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/disableenable/__init__.py
--rw-r--r--  2.0 unx     6394 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/disableenable/disableenable.py
--rw-r--r--  2.0 unx     7589 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/disableenable/disableenablereqhandler.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/disableenable/bgp/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/disableenable/bgp/nxos/__init__.py
--rw-r--r--  2.0 unx     5143 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/disableenable/bgp/nxos/disableenable.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/disableenable/hsrp/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/disableenable/hsrp/nxos/__init__.py
--rw-r--r--  2.0 unx     3840 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/disableenable/hsrp/nxos/disableenable.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/disableenable/mcast/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/disableenable/mcast/nxos/__init__.py
--rw-r--r--  2.0 unx     7265 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/disableenable/mcast/nxos/disableenable.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/disableenable/trm/__init__.py
--rw-r--r--  2.0 unx      255 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/disableenable/trm/nxos/__init__.py
--rw-r--r--  2.0 unx     3814 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/disableenable/trm/nxos/disableenable.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/disableenable/vlan/__init__.py
--rw-r--r--  2.0 unx      255 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/disableenable/vlan/nxos/__init__.py
--rw-r--r--  2.0 unx     7071 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/disableenable/vlan/nxos/disableenable.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/disableenable/vxlan/__init__.py
--rw-r--r--  2.0 unx      255 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/disableenable/vxlan/nxos/__init__.py
--rw-r--r--  2.0 unx     8003 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/disableenable/vxlan/nxos/disableenable.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/ha/__init__.py
--rw-r--r--  2.0 unx    17963 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/ha/ha.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/ha/issu/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/ha/issu/iosxe/__init__.py
--rw-r--r--  2.0 unx      862 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/ha/issu/iosxe/issu.py
--rw-r--r--  2.0 unx      256 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/ha/issu/iosxe/asr1k/__init__.py
--rw-r--r--  2.0 unx     2022 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/ha/issu/iosxe/asr1k/issu.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/ha/reload/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/ha/reload/iosxe/__init__.py
--rw-r--r--  2.0 unx     3802 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/ha/reload/iosxe/reload.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/ha/reload/iosxe/asr1k/__init__.py
--rw-r--r--  2.0 unx    12779 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/ha/reload/iosxe/asr1k/reload.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/ha/reload/iosxe/c3850/__init__.py
--rw-r--r--  2.0 unx    15628 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/ha/reload/iosxe/c3850/reload.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/ha/reload/iosxe/csr1000v/__init__.py
--rw-r--r--  2.0 unx     3415 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/ha/reload/iosxe/csr1000v/reload.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/ha/reload/iosxr/__init__.py
--rw-r--r--  2.0 unx    14385 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/ha/reload/iosxr/reload.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/ha/reload/iosxr/iosxrv/__init__.py
--rw-r--r--  2.0 unx     1884 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/ha/reload/iosxr/iosxrv/reload.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/ha/reload/nxos/__init__.py
--rw-r--r--  2.0 unx    19641 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/ha/reload/nxos/reload.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/ha/reload/nxos/n9k/__init__.py
--rw-r--r--  2.0 unx     2870 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/ha/reload/nxos/n9k/reload.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/ha/switchover/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/ha/switchover/iosxe/__init__.py
--rw-r--r--  2.0 unx      923 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/ha/switchover/iosxe/switchover.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/ha/switchover/iosxe/asr1k/__init__.py
--rw-r--r--  2.0 unx     3911 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/ha/switchover/iosxe/asr1k/switchover.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/ha/switchover/iosxe/c3850/__init__.py
--rw-r--r--  2.0 unx     7072 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/ha/switchover/iosxe/c3850/switchover.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/ha/switchover/iosxr/__init__.py
--rw-r--r--  2.0 unx     5306 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/ha/switchover/iosxr/switchover.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/ha/switchover/nxos/__init__.py
--rw-r--r--  2.0 unx     4165 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/ha/switchover/nxos/switchover.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/modify/__init__.py
--rw-r--r--  2.0 unx     5497 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/modify.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/modify/bgp/__init__.py
--rw-r--r--  2.0 unx    20857 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/bgp/modify.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/modify/bgp/iosxe/__init__.py
--rw-r--r--  2.0 unx     9616 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/modify/bgp/iosxe/modify.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/modify/bgp/iosxr/__init__.py
--rw-r--r--  2.0 unx     5380 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/modify/bgp/iosxr/modify.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/modify/bgp/nxos/__init__.py
--rw-r--r--  2.0 unx    51732 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/bgp/nxos/modify.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/dot1x/__init__.py
--rw-r--r--  2.0 unx      196 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/dot1x/modify.py
--rw-r--r--  2.0 unx      256 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/dot1x/iosxe/__init__.py
--rw-r--r--  2.0 unx     8262 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/dot1x/iosxe/modify.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/modify/hsrp/__init__.py
--rw-r--r--  2.0 unx    12654 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/modify/hsrp/modify.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/igmp/__init__.py
--rw-r--r--  2.0 unx      180 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/igmp/modify.py
--rw-r--r--  2.0 unx      257 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/igmp/nxos/__init__.py
--rw-r--r--  2.0 unx     4771 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/igmp/nxos/modify.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/modify/interface/__init__.py
--rw-r--r--  2.0 unx    27099 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/interface/modify.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/modify/interface/iosxe/__init__.py
--rw-r--r--  2.0 unx     3880 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/interface/iosxe/modify.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/modify/interface/iosxr/__init__.py
--rw-r--r--  2.0 unx     2338 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/interface/iosxr/modify.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/lldp/__init__.py
--rw-r--r--  2.0 unx     4488 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/lldp/modify.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/mld/__init__.py
--rw-r--r--  2.0 unx      180 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/mld/modify.py
--rw-r--r--  2.0 unx      257 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/mld/nxos/__init__.py
--rw-r--r--  2.0 unx     4744 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/mld/nxos/modify.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/msdp/__init__.py
--rw-r--r--  2.0 unx      727 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/msdp/modify.py
--rw-r--r--  2.0 unx      257 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/msdp/nxos/__init__.py
--rw-r--r--  2.0 unx    53843 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/msdp/nxos/modify.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/pim/__init__.py
--rw-r--r--  2.0 unx      184 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/pim/modify.py
--rw-r--r--  2.0 unx      257 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/pim/nxos/__init__.py
--rw-r--r--  2.0 unx     5476 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/pim/nxos/modify.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/stp/__init__.py
--rw-r--r--  2.0 unx      280 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/stp/modify.py
--rw-r--r--  2.0 unx      256 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/stp/iosxe/__init__.py
--rw-r--r--  2.0 unx    15013 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/stp/iosxe/modify.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/vlan/__init__.py
--rw-r--r--  2.0 unx      111 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/vlan/modify.py
--rw-r--r--  2.0 unx      256 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/vlan/nxos/__init__.py
--rw-r--r--  2.0 unx     5409 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/vlan/nxos/modify.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/vxlan/__init__.py
--rw-r--r--  2.0 unx      132 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/vxlan/modify.py
--rw-r--r--  2.0 unx      256 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/vxlan/nxos/__init__.py
--rw-r--r--  2.0 unx    33227 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/modify/vxlan/nxos/modify.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/__init__.py
--rw-r--r--  2.0 unx     4087 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/processrestart/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/aclmgr/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/aclmgr/nxos/__init__.py
--rw-r--r--  2.0 unx     3647 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/aclmgr/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/bfd/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/bfd/nxos/__init__.py
--rw-r--r--  2.0 unx     3570 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/bfd/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/bgp/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/bgp/nxos/__init__.py
--rw-r--r--  2.0 unx     5035 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/bgp/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/cfs/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/cfs/nxos/__init__.py
--rw-r--r--  2.0 unx     3570 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/cfs/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/confcheck/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/confcheck/nxos/__init__.py
--rw-r--r--  2.0 unx     3608 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/confcheck/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/eigrp/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/eigrp/nxos/__init__.py
--rw-r--r--  2.0 unx     5097 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/eigrp/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/eltm/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/eltm/nxos/__init__.py
--rw-r--r--  2.0 unx     3573 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/eltm/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/feature_mgr/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/feature_mgr/nxos/__init__.py
--rw-r--r--  2.0 unx     3743 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/feature_mgr/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/fs_daemon/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/fs_daemon/nxos/__init__.py
--rw-r--r--  2.0 unx     3712 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/fs_daemon/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/glbp/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/glbp/nxos/__init__.py
--rw-r--r--  2.0 unx     3592 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/glbp/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/igmp/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/igmp/nxos/__init__.py
--rw-r--r--  2.0 unx     5066 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/igmp/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/isis/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/isis/nxos/__init__.py
--rw-r--r--  2.0 unx     5065 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/isis/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/l2rib/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/l2rib/nxos/__init__.py
--rw-r--r--  2.0 unx     3616 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/l2rib/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/lacp/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/lacp/nxos/__init__.py
--rw-r--r--  2.0 unx     3592 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/lacp/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/libs/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/libs/nxos/__init__.py
--rw-r--r--  2.0 unx    18028 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/processrestart/libs/nxos/processrestart.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/libs/nxos/n7k/__init__.py
--rw-r--r--  2.0 unx     1737 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/libs/nxos/n7k/processrestart.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/libs/nxos/n9k/__init__.py
--rw-r--r--  2.0 unx     2098 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/processrestart/libs/nxos/n9k/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/monitorc/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/monitorc/nxos/__init__.py
--rw-r--r--  2.0 unx     3680 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/monitorc/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/mrib/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/mrib/nxos/__init__.py
--rw-r--r--  2.0 unx     3905 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/mrib/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/msdp/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/msdp/nxos/__init__.py
--rw-r--r--  2.0 unx     5073 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/msdp/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/netstack/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/netstack/nxos/__init__.py
--rw-r--r--  2.0 unx     3728 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/netstack/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/nve/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/nve/nxos/__init__.py
--rw-r--r--  2.0 unx     3570 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/nve/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/ospf/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/ospf/nxos/__init__.py
--rw-r--r--  2.0 unx     5345 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/ospf/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/ospfv3/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/ospfv3/nxos/__init__.py
--rw-r--r--  2.0 unx     5415 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/ospfv3/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/pim/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/pim/nxos/__init__.py
--rw-r--r--  2.0 unx     5033 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/pim/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/pim6/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/pim6/nxos/__init__.py
--rw-r--r--  2.0 unx     5066 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/pim6/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/plugin/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/plugin/nxos/__init__.py
--rw-r--r--  2.0 unx     3638 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/plugin/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/rip/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/rip/nxos/__init__.py
--rw-r--r--  2.0 unx     5039 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/rip/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/rsvp/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/rsvp/nxos/__init__.py
--rw-r--r--  2.0 unx     5066 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/rsvp/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/stp/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/stp/nxos/__init__.py
--rw-r--r--  2.0 unx     3572 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/stp/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/syslogd/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/syslogd/nxos/__init__.py
--rw-r--r--  2.0 unx     3510 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/syslogd/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/sysmgr/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/sysmgr/nxos/__init__.py
--rw-r--r--  2.0 unx     3866 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/sysmgr/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/processrestart/trm/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/processrestart/trm/nxos/__init__.py
--rw-r--r--  2.0 unx     3602 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/processrestart/trm/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/tunnel/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/tunnel/nxos/__init__.py
--rw-r--r--  2.0 unx     3638 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/tunnel/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/urib/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/urib/nxos/__init__.py
--rw-r--r--  2.0 unx     3946 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/urib/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/vdc_mgr/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/vdc_mgr/nxos/__init__.py
--rw-r--r--  2.0 unx     3657 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/vdc_mgr/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/vlan_mgr/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/vlan_mgr/nxos/__init__.py
--rw-r--r--  2.0 unx     3679 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/vlan_mgr/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/vpc/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/vpc/nxos/__init__.py
--rw-r--r--  2.0 unx     3572 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/processrestart/vpc/nxos/processrestart.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/shutnoshut/__init__.py
--rw-r--r--  2.0 unx     4441 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/shutnoshut/shutnoshut.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/shutnoshut/bgp/__init__.py
--rw-r--r--  2.0 unx    14052 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/shutnoshut/bgp/shutnoshut.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/shutnoshut/bgp/iosxe/__init__.py
--rw-r--r--  2.0 unx     2451 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/shutnoshut/bgp/iosxe/shutnoshut.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/shutnoshut/bgp/iosxr/__init__.py
--rw-r--r--  2.0 unx     4012 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/shutnoshut/bgp/iosxr/shutnoshut.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/shutnoshut/bgp/nxos/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/shutnoshut/interface/__init__.py
--rw-r--r--  2.0 unx    14043 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/shutnoshut/interface/shutnoshut.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/shutnoshut/interface/iosxe/__init__.py
--rw-r--r--  2.0 unx    28431 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/shutnoshut/interface/iosxe/shutnoshut.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/shutnoshut/interface/iosxr/__init__.py
--rw-r--r--  2.0 unx     2166 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/shutnoshut/interface/iosxr/shutnoshut.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/shutnoshut/interface/nxos/__init__.py
--rw-r--r--  2.0 unx    59829 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/shutnoshut/interface/nxos/shutnoshut.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/shutnoshut/msdp/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/shutnoshut/msdp/nxos/__init__.py
--rw-r--r--  2.0 unx     3900 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/shutnoshut/msdp/nxos/shutnoshut.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/shutnoshut/vlan/__init__.py
--rw-r--r--  2.0 unx      266 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/shutnoshut/vlan/shutnoshut.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/shutnoshut/vlan/iosxe/__init__.py
--rw-r--r--  2.0 unx     3360 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/shutnoshut/vlan/iosxe/shutnoshut.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/shutnoshut/vlan/nxos/__init__.py
--rw-r--r--  2.0 unx     3376 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/shutnoshut/vlan/nxos/shutnoshut.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/shutnoshut/vxlan/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/shutnoshut/vxlan/shutnoshut.py
--rw-r--r--  2.0 unx      256 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/shutnoshut/vxlan/nxos/__init__.py
--rw-r--r--  2.0 unx     9009 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/shutnoshut/vxlan/nxos/shutnoshut.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/sleep/__init__.py
--rw-r--r--  2.0 unx      886 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/sleep/sleep.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/template/__init__.py
--rw-r--r--  2.0 unx     1313 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/template/addremove.py
--rw-r--r--  2.0 unx      954 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/template/checkcommands.py
--rw-r--r--  2.0 unx      655 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/template/clear.py
--rw-r--r--  2.0 unx     2847 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/template/disableenable.py
--rw-r--r--  2.0 unx     2722 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/template/ha.py
--rw-r--r--  2.0 unx     1394 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/template/modify.py
--rw-r--r--  2.0 unx      769 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/template/processrestart.py
--rw-r--r--  2.0 unx     1262 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/template/shutnoshut.py
--rw-r--r--  2.0 unx      328 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/template/sleep.py
--rw-r--r--  2.0 unx     1425 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/template/unconfigconfig.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/unconfigconfig/__init__.py
--rw-r--r--  2.0 unx     5784 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/unconfigconfig.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/unconfigconfig/bgp/__init__.py
--rw-r--r--  2.0 unx     8410 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/unconfigconfig/bgp/unconfigconfig.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/unconfigconfig/bgp/nxos/__init__.py
--rw-r--r--  2.0 unx   112324 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/bgp/nxos/unconfigconfig.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/igmp/__init__.py
--rw-r--r--  2.0 unx      234 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/igmp/unconfigconfig.py
--rw-r--r--  2.0 unx      257 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/igmp/nxos/__init__.py
--rw-r--r--  2.0 unx    20436 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/igmp/nxos/unconfigconfig.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/unconfigconfig/interface/__init__.py
--rw-r--r--  2.0 unx    25955 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/interface/unconfigconfig.py
--rw-r--r--  2.0 unx      257 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/unconfigconfig/interface/iosxe/__init__.py
--rw-r--r--  2.0 unx     9059 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/interface/iosxe/unconfigconfig.py
--rw-r--r--  2.0 unx      257 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/unconfigconfig/interface/iosxr/__init__.py
--rw-r--r--  2.0 unx     2890 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/interface/iosxr/unconfigconfig.py
--rw-r--r--  2.0 unx      257 b- defN 18-May-21 19:41 genie/libs/sdk/triggers/unconfigconfig/interface/nxos/__init__.py
--rw-r--r--  2.0 unx    45993 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/interface/nxos/unconfigconfig.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/mld/__init__.py
--rw-r--r--  2.0 unx      226 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/mld/unconfigconfig.py
--rw-r--r--  2.0 unx      257 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/mld/nxos/__init__.py
--rw-r--r--  2.0 unx    20374 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/mld/nxos/unconfigconfig.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/msdp/__init__.py
--rw-r--r--  2.0 unx      830 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/msdp/unconfigconfig.py
--rw-r--r--  2.0 unx      257 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/msdp/nxos/__init__.py
--rw-r--r--  2.0 unx    43046 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/msdp/nxos/unconfigconfig.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/pim/__init__.py
--rw-r--r--  2.0 unx      233 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/pim/unconfigconfig.py
--rw-r--r--  2.0 unx      257 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/pim/nxos/__init__.py
--rw-r--r--  2.0 unx     5204 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/pim/nxos/unconfigconfig.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/trm/__init__.py
--rw-r--r--  2.0 unx       53 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/trm/unconfigconfig.py
--rw-r--r--  2.0 unx      256 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/trm/nxos/__init__.py
--rw-r--r--  2.0 unx    13230 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/trm/nxos/unconfigconfig.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/unconfigconfig/vlan/__init__.py
--rw-r--r--  2.0 unx     2652 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/unconfigconfig/vlan/unconfigconfig.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/unconfigconfig/vlan/iosxe/__init__.py
--rw-r--r--  2.0 unx     3892 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/unconfigconfig/vlan/iosxe/unconfigconfig.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/triggers/unconfigconfig/vlan/nxos/__init__.py
--rw-r--r--  2.0 unx     7687 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/vlan/nxos/unconfigconfig.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/vxlan/__init__.py
--rw-r--r--  2.0 unx      302 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/vxlan/unconfigconfig.py
--rw-r--r--  2.0 unx      256 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/vxlan/nxos/__init__.py
--rw-r--r--  2.0 unx    57717 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/unconfigconfig/vxlan/nxos/unconfigconfig.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/xe_sanity/__init__.py
--rw-r--r--  2.0 unx    65291 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/xe_sanity/configurations.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/xe_sanity/checkcommands/__init__.py
--rw-r--r--  2.0 unx      322 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/xe_sanity/checkcommands/checkcommands.py
--rw-r--r--  2.0 unx      184 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/xe_sanity/checkcommands/iosxe/__init__.py
--rw-r--r--  2.0 unx    32870 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/xe_sanity/checkcommands/iosxe/checkcommands.py
--rw-r--r--  2.0 unx        0 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/xe_sanity/checkcommands/libs/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/xe_sanity/checkcommands/libs/iosxe/__init__.py
--rw-r--r--  2.0 unx    10217 b- defN 18-Dec-06 20:24 genie/libs/sdk/triggers/xe_sanity/checkcommands/libs/iosxe/checkcommands.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/verifications/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 18-May-14 16:03 genie/libs/sdk/verifications/ospf/__init__.py
--rw-r--r--  2.0 unx      256 b- defN 18-May-14 16:03 genie/libs/sdk/verifications/ospf/iosxe/__init__.py
--rw-r--r--  2.0 unx      990 b- defN 18-Dec-06 20:24 genie.libs.sdk-3.1.8.data/data/genie_yamls/__init__.py
--rw-r--r--  2.0 unx     6136 b- defN 18-Dec-06 20:24 genie.libs.sdk-3.1.8.data/data/genie_yamls/pts_datafile.yaml
--rw-r--r--  2.0 unx     1241 b- defN 18-May-14 16:03 genie.libs.sdk-3.1.8.data/data/genie_yamls/subsection_datafile.yaml
--rw-r--r--  2.0 unx    64550 b- defN 18-Dec-06 20:24 genie.libs.sdk-3.1.8.data/data/genie_yamls/trigger_datafile.yaml
--rw-r--r--  2.0 unx    78843 b- defN 18-Dec-06 20:24 genie.libs.sdk-3.1.8.data/data/genie_yamls/verification_datafile.yaml
--rw-r--r--  2.0 unx      683 b- defN 18-Dec-06 20:24 genie.libs.sdk-3.1.8.data/data/genie_yamls/ios/trigger_datafile_ios.yaml
--rw-r--r--  2.0 unx     1803 b- defN 18-Dec-06 20:24 genie.libs.sdk-3.1.8.data/data/genie_yamls/ios/verification_datafile_ios.yaml
--rw-r--r--  2.0 unx    12379 b- defN 18-Dec-06 20:24 genie.libs.sdk-3.1.8.data/data/genie_yamls/iosxe/trigger_datafile_iosxe.yaml
--rw-r--r--  2.0 unx    15358 b- defN 18-Dec-06 20:24 genie.libs.sdk-3.1.8.data/data/genie_yamls/iosxe/verification_datafile_iosxe.yaml
--rw-r--r--  2.0 unx     6365 b- defN 18-Dec-06 20:24 genie.libs.sdk-3.1.8.data/data/genie_yamls/iosxr/trigger_datafile_xr.yaml
--rwxr-xr-x  2.0 unx    15374 b- defN 18-Dec-06 20:24 genie.libs.sdk-3.1.8.data/data/genie_yamls/iosxr/verification_datafile_xr.yaml
--rw-r--r--  2.0 unx      172 b- defN 18-Dec-06 20:24 genie.libs.sdk-3.1.8.data/data/genie_yamls/junos/trigger_datafile_junos.yaml
--rw-r--r--  2.0 unx      617 b- defN 18-Dec-06 20:24 genie.libs.sdk-3.1.8.data/data/genie_yamls/junos/verification_datafile_junos.yaml
--rw-r--r--  2.0 unx    85023 b- defN 18-Dec-06 20:24 genie.libs.sdk-3.1.8.data/data/genie_yamls/nxos/trigger_datafile_nxos.yaml
--rw-r--r--  2.0 unx    36037 b- defN 18-Dec-06 20:24 genie.libs.sdk-3.1.8.data/data/genie_yamls/nxos/verification_datafile_nxos.yaml
--rw-r--r--  2.0 unx    17544 b- defN 18-Dec-06 20:24 genie.libs.sdk-3.1.8.data/data/genie_yamls/tools/verification_generator/datafiles_maker.py
--rw-r--r--  2.0 unx      906 b- defN 18-May-14 16:03 genie.libs.sdk-3.1.8.data/data/genie_yamls/tools/verification_generator/differ.py
--rw-r--r--  2.0 unx     5792 b- defN 18-Dec-06 20:24 genie.libs.sdk-3.1.8.data/data/genie_yamls/tools/verification_generator/parsers.yaml
--rw-r--r--  2.0 unx       17 b- defN 18-Dec-06 20:25 genie.libs.sdk-3.1.8.dist-info/namespace_packages.txt
--rw-r--r--  2.0 unx        6 b- defN 18-Dec-06 20:25 genie.libs.sdk-3.1.8.dist-info/top_level.txt
--rw-r--r--  2.0 unx       92 b- defN 18-Dec-06 20:25 genie.libs.sdk-3.1.8.dist-info/WHEEL
--rw-r--r--  2.0 unx     3210 b- defN 18-Dec-06 20:25 genie.libs.sdk-3.1.8.dist-info/METADATA
--rw-r--r--  2.0 unx    53866 b- defN 18-Dec-06 20:25 genie.libs.sdk-3.1.8.dist-info/RECORD
-477 files, 2519549 bytes uncompressed, 364075 bytes compressed:  85.6%
+Zip file size: 479793 bytes, number of entries: 478
+-rw-r--r--  2.0 unx     1676 b- defN 19-Jan-29 19:36 genie.libs.sdk-3.1.9-py3.4-nspkg.pth
+-rw-r--r--  2.0 unx     1128 b- defN 19-Jan-29 19:36 genie/libs/sdk/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/libs/__init__.py
+-rw-r--r--  2.0 unx       26 b- defN 18-May-10 16:16 genie/libs/sdk/libs/abstracted_libs/__init__.py
+-rw-r--r--  2.0 unx     1002 b- defN 18-Nov-27 23:08 genie/libs/sdk/libs/abstracted_libs/configure_snapshot_command.py
+-rw-r--r--  2.0 unx    10315 b- defN 19-Jan-16 23:35 genie/libs/sdk/libs/abstracted_libs/ha.py
+-rw-r--r--  2.0 unx     1019 b- defN 18-Nov-27 23:08 genie/libs/sdk/libs/abstracted_libs/init_exec_commands.py
+-rw-r--r--  2.0 unx     1853 b- defN 18-Nov-27 23:08 genie/libs/sdk/libs/abstracted_libs/management_interface.py
+-rw-r--r--  2.0 unx    31603 b- defN 18-Oct-26 16:18 genie/libs/sdk/libs/abstracted_libs/processors.py
+-rw-r--r--  2.0 unx     1369 b- defN 19-Jan-16 23:37 genie/libs/sdk/libs/abstracted_libs/restore.py
+-rw-r--r--  2.0 unx    12327 b- defN 18-Nov-29 22:37 genie/libs/sdk/libs/abstracted_libs/subsection.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Nov-19 21:02 genie/libs/sdk/libs/abstracted_libs/ios/__init__.py
+-rw-r--r--  2.0 unx     1016 b- defN 18-Nov-19 21:02 genie/libs/sdk/libs/abstracted_libs/ios/init_exec_commands.py
+-rw-r--r--  2.0 unx     1641 b- defN 18-Nov-19 21:02 genie/libs/sdk/libs/abstracted_libs/ios/management_interface.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/libs/abstracted_libs/iosxe/__init__.py
+-rw-r--r--  2.0 unx      680 b- defN 18-May-10 16:16 genie/libs/sdk/libs/abstracted_libs/iosxe/ha.py
+-rw-r--r--  2.0 unx     1018 b- defN 18-Oct-12 19:25 genie/libs/sdk/libs/abstracted_libs/iosxe/init_exec_commands.py
+-rw-r--r--  2.0 unx     1653 b- defN 18-Nov-27 23:08 genie/libs/sdk/libs/abstracted_libs/iosxe/management_interface.py
+-rw-r--r--  2.0 unx     5567 b- defN 18-Oct-12 19:25 genie/libs/sdk/libs/abstracted_libs/iosxe/processors.py
+-rw-r--r--  2.0 unx    11230 b- defN 19-Jan-16 23:37 genie/libs/sdk/libs/abstracted_libs/iosxe/restore.py
+-rw-r--r--  2.0 unx    23667 b- defN 18-Oct-12 19:25 genie/libs/sdk/libs/abstracted_libs/iosxe/subsection.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/libs/abstracted_libs/iosxe/asr1k/__init__.py
+-rw-r--r--  2.0 unx    20020 b- defN 18-Oct-12 19:25 genie/libs/sdk/libs/abstracted_libs/iosxe/asr1k/ha.py
+-rw-r--r--  2.0 unx     3186 b- defN 18-Oct-12 19:25 genie/libs/sdk/libs/abstracted_libs/iosxe/asr1k/subsection.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/libs/abstracted_libs/iosxe/c3850/__init__.py
+-rw-r--r--  2.0 unx     1056 b- defN 18-May-10 16:16 genie/libs/sdk/libs/abstracted_libs/iosxe/c3850/ha.py
+-rw-r--r--  2.0 unx     3111 b- defN 18-Oct-12 19:25 genie/libs/sdk/libs/abstracted_libs/iosxe/c3850/subsection.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/libs/abstracted_libs/iosxr/__init__.py
+-rw-r--r--  2.0 unx     2594 b- defN 18-May-10 16:16 genie/libs/sdk/libs/abstracted_libs/iosxr/ha.py
+-rw-r--r--  2.0 unx     1018 b- defN 18-Oct-12 19:25 genie/libs/sdk/libs/abstracted_libs/iosxr/init_exec_commands.py
+-rw-r--r--  2.0 unx     1641 b- defN 18-Nov-27 23:08 genie/libs/sdk/libs/abstracted_libs/iosxr/management_interface.py
+-rw-r--r--  2.0 unx     8623 b- defN 18-Oct-26 16:18 genie/libs/sdk/libs/abstracted_libs/iosxr/restore.py
+-rw-r--r--  2.0 unx     1981 b- defN 18-Nov-06 18:09 genie/libs/sdk/libs/abstracted_libs/iosxr/subsection.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/libs/abstracted_libs/iosxr/iosxrv/__init__.py
+-rw-r--r--  2.0 unx     1946 b- defN 18-May-10 16:16 genie/libs/sdk/libs/abstracted_libs/iosxr/iosxrv/ha.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Nov-27 23:08 genie/libs/sdk/libs/abstracted_libs/junos/__init__.py
+-rw-r--r--  2.0 unx      967 b- defN 18-Nov-27 23:08 genie/libs/sdk/libs/abstracted_libs/junos/configure_snapshot_command.py
+-rw-r--r--  2.0 unx     1054 b- defN 18-Nov-27 23:08 genie/libs/sdk/libs/abstracted_libs/junos/init_exec_commands.py
+-rw-r--r--  2.0 unx     2168 b- defN 18-Nov-27 23:08 genie/libs/sdk/libs/abstracted_libs/junos/management_interface.py
+-rw-r--r--  2.0 unx     1212 b- defN 18-Nov-29 16:19 genie/libs/sdk/libs/abstracted_libs/junos/subsection.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/libs/abstracted_libs/nxos/__init__.py
+-rw-r--r--  2.0 unx     7432 b- defN 18-Oct-26 16:18 genie/libs/sdk/libs/abstracted_libs/nxos/ha.py
+-rw-r--r--  2.0 unx     1092 b- defN 18-Oct-12 19:25 genie/libs/sdk/libs/abstracted_libs/nxos/init_exec_commands.py
+-rw-r--r--  2.0 unx     1651 b- defN 18-Nov-27 23:08 genie/libs/sdk/libs/abstracted_libs/nxos/management_interface.py
+-rw-r--r--  2.0 unx     9736 b- defN 18-Oct-26 16:18 genie/libs/sdk/libs/abstracted_libs/nxos/restore.py
+-rw-r--r--  2.0 unx     1316 b- defN 18-Oct-12 19:25 genie/libs/sdk/libs/abstracted_libs/nxos/subsection.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/libs/abstracted_libs/nxos/n7k/__init__.py
+-rw-r--r--  2.0 unx     1498 b- defN 18-Oct-12 19:25 genie/libs/sdk/libs/abstracted_libs/nxos/n7k/ha.py
+-rw-r--r--  2.0 unx     3134 b- defN 19-Jan-16 23:35 genie/libs/sdk/libs/abstracted_libs/nxos/n7k/subsection.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/libs/abstracted_libs/nxos/n9k/__init__.py
+-rw-r--r--  2.0 unx     2487 b- defN 19-Jan-16 23:35 genie/libs/sdk/libs/abstracted_libs/nxos/n9k/subsection.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/libs/utils/__init__.py
+-rw-r--r--  2.0 unx    33489 b- defN 19-Jan-16 23:37 genie/libs/sdk/libs/utils/common.py
+-rw-r--r--  2.0 unx    61253 b- defN 19-Jan-16 23:37 genie/libs/sdk/libs/utils/mapping.py
+-rw-r--r--  2.0 unx    20100 b- defN 18-Oct-12 19:25 genie/libs/sdk/libs/utils/normalize.py
+-rw-r--r--  2.0 unx    13702 b- defN 19-Jan-16 23:37 genie/libs/sdk/libs/utils/triggeractions.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/addremove/__init__.py
+-rw-r--r--  2.0 unx     5942 b- defN 18-Nov-27 23:08 genie/libs/sdk/triggers/addremove/addremove.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/addremove/acl/__init__.py
+-rw-r--r--  2.0 unx      420 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/addremove/acl/addremove.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/addremove/acl/iosxe/__init__.py
+-rw-r--r--  2.0 unx    30674 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/addremove/acl/iosxe/addremove.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/addremove/bgp/__init__.py
+-rw-r--r--  2.0 unx    14355 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/addremove/bgp/addremove.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/addremove/bgp/nxos/__init__.py
+-rw-r--r--  2.0 unx   152410 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/addremove/bgp/nxos/addremove.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-26 16:18 genie/libs/sdk/triggers/addremove/igmp/__init__.py
+-rw-r--r--  2.0 unx      386 b- defN 18-Oct-26 16:18 genie/libs/sdk/triggers/addremove/igmp/addremove.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Oct-26 16:18 genie/libs/sdk/triggers/addremove/igmp/nxos/__init__.py
+-rw-r--r--  2.0 unx    29761 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/addremove/igmp/nxos/addremove.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/addremove/lag/__init__.py
+-rw-r--r--  2.0 unx      405 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/addremove/lag/addremove.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/addremove/lag/iosxe/__init__.py
+-rw-r--r--  2.0 unx    26615 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/addremove/lag/iosxe/addremove.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-26 16:18 genie/libs/sdk/triggers/addremove/mld/__init__.py
+-rw-r--r--  2.0 unx      381 b- defN 18-Oct-26 16:18 genie/libs/sdk/triggers/addremove/mld/addremove.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Oct-26 16:18 genie/libs/sdk/triggers/addremove/mld/nxos/__init__.py
+-rw-r--r--  2.0 unx    29915 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/addremove/mld/nxos/addremove.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/addremove/msdp/__init__.py
+-rw-r--r--  2.0 unx      718 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/addremove/msdp/addremove.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/addremove/msdp/nxos/__init__.py
+-rw-r--r--  2.0 unx    52754 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/addremove/msdp/nxos/addremove.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/addremove/pim/__init__.py
+-rw-r--r--  2.0 unx      202 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/addremove/pim/addremove.py
+-rw-r--r--  2.0 unx      257 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/addremove/pim/nxos/__init__.py
+-rw-r--r--  2.0 unx     5962 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/addremove/pim/nxos/addremove.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/addremove/routing/__init__.py
+-rw-r--r--  2.0 unx      299 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/addremove/routing/addremove.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/addremove/routing/iosxe/__init__.py
+-rw-r--r--  2.0 unx    14643 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/addremove/routing/iosxe/addremove.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Nov-19 21:02 genie/libs/sdk/triggers/addremove/trm/__init__.py
+-rw-r--r--  2.0 unx       51 b- defN 18-Nov-19 21:02 genie/libs/sdk/triggers/addremove/trm/addremove.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Nov-19 21:02 genie/libs/sdk/triggers/addremove/trm/nxos/__init__.py
+-rw-r--r--  2.0 unx    14531 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/addremove/trm/nxos/addremove.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/addremove/vxlan/__init__.py
+-rw-r--r--  2.0 unx      138 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/addremove/vxlan/addremove.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/addremove/vxlan/nxos/__init__.py
+-rw-r--r--  2.0 unx    29463 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/addremove/vxlan/nxos/addremove.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/clear/__init__.py
+-rw-r--r--  2.0 unx     5680 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/clear/clear.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/clear/bgp/__init__.py
+-rw-r--r--  2.0 unx    26523 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/clear/bgp/clear.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/clear/bgp/iosxr/__init__.py
+-rw-r--r--  2.0 unx     1775 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/clear/bgp/iosxr/clear.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/clear/bgp/nxos/__init__.py
+-rw-r--r--  2.0 unx    20065 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/clear/bgp/nxos/clear.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/clear/interface/__init__.py
+-rw-r--r--  2.0 unx     4146 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/clear/interface/clear.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/clear/interface/iosxe/__init__.py
+-rw-r--r--  2.0 unx     1492 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/clear/interface/iosxe/clear.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/clear/interface/iosxr/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/clear/interface/nxos/__init__.py
+-rw-r--r--  2.0 unx     1544 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/clear/interface/nxos/clear.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/clear/ipv6/__init__.py
+-rw-r--r--  2.0 unx     2203 b- defN 18-Oct-26 16:18 genie/libs/sdk/triggers/clear/ipv6/clear.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/clear/ipv6/nxos/__init__.py
+-rw-r--r--  2.0 unx     1635 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/clear/ipv6/nxos/clear.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/clear/mcast/__init__.py
+-rw-r--r--  2.0 unx     9536 b- defN 18-Oct-26 16:18 genie/libs/sdk/triggers/clear/mcast/clear.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/clear/mcast/nxos/__init__.py
+-rw-r--r--  2.0 unx    12106 b- defN 18-Oct-26 16:18 genie/libs/sdk/triggers/clear/mcast/nxos/clear.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/clear/msdp/__init__.py
+-rw-r--r--  2.0 unx    12517 b- defN 18-Oct-26 16:18 genie/libs/sdk/triggers/clear/msdp/clear.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/clear/msdp/nxos/__init__.py
+-rw-r--r--  2.0 unx     9817 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/clear/msdp/nxos/clear.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/clear/ospf/__init__.py
+-rw-r--r--  2.0 unx     2831 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/clear/ospf/clear.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/clear/ospf/nxos/__init__.py
+-rw-r--r--  2.0 unx     3260 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/clear/ospf/nxos/clear.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/clear/routing/__init__.py
+-rw-r--r--  2.0 unx     8970 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/clear/routing/clear.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/clear/routing/nxos/__init__.py
+-rw-r--r--  2.0 unx    14872 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/clear/routing/nxos/clear.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/disableenable/__init__.py
+-rw-r--r--  2.0 unx     6394 b- defN 18-Nov-27 23:08 genie/libs/sdk/triggers/disableenable/disableenable.py
+-rw-r--r--  2.0 unx     7589 b- defN 18-Nov-27 23:08 genie/libs/sdk/triggers/disableenable/disableenablereqhandler.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/disableenable/bgp/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/disableenable/bgp/nxos/__init__.py
+-rw-r--r--  2.0 unx     5560 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/disableenable/bgp/nxos/disableenable.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/disableenable/hsrp/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/disableenable/hsrp/nxos/__init__.py
+-rw-r--r--  2.0 unx     4367 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/disableenable/hsrp/nxos/disableenable.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/disableenable/mcast/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/disableenable/mcast/nxos/__init__.py
+-rw-r--r--  2.0 unx     8094 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/disableenable/mcast/nxos/disableenable.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Nov-19 21:02 genie/libs/sdk/triggers/disableenable/trm/__init__.py
+-rw-r--r--  2.0 unx      255 b- defN 18-Nov-19 21:02 genie/libs/sdk/triggers/disableenable/trm/nxos/__init__.py
+-rw-r--r--  2.0 unx     3814 b- defN 18-Nov-19 21:02 genie/libs/sdk/triggers/disableenable/trm/nxos/disableenable.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/disableenable/vlan/__init__.py
+-rw-r--r--  2.0 unx      255 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/disableenable/vlan/nxos/__init__.py
+-rw-r--r--  2.0 unx     7071 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/disableenable/vlan/nxos/disableenable.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/disableenable/vxlan/__init__.py
+-rw-r--r--  2.0 unx      255 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/disableenable/vxlan/nxos/__init__.py
+-rw-r--r--  2.0 unx     8207 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/disableenable/vxlan/nxos/disableenable.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/ha/__init__.py
+-rw-r--r--  2.0 unx    17924 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/ha/ha.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/ha/issu/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/ha/issu/iosxe/__init__.py
+-rw-r--r--  2.0 unx      862 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/ha/issu/iosxe/issu.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/ha/issu/iosxe/asr1k/__init__.py
+-rw-r--r--  2.0 unx     3481 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/ha/issu/iosxe/asr1k/issu.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/ha/reload/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/ha/reload/iosxe/__init__.py
+-rw-r--r--  2.0 unx     3802 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/ha/reload/iosxe/reload.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/ha/reload/iosxe/asr1k/__init__.py
+-rw-r--r--  2.0 unx    13167 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/ha/reload/iosxe/asr1k/reload.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/ha/reload/iosxe/c3850/__init__.py
+-rw-r--r--  2.0 unx    16884 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/ha/reload/iosxe/c3850/reload.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/ha/reload/iosxe/csr1000v/__init__.py
+-rw-r--r--  2.0 unx     3888 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/ha/reload/iosxe/csr1000v/reload.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/ha/reload/iosxr/__init__.py
+-rw-r--r--  2.0 unx    14385 b- defN 18-Nov-29 22:37 genie/libs/sdk/triggers/ha/reload/iosxr/reload.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/ha/reload/iosxr/iosxrv/__init__.py
+-rw-r--r--  2.0 unx     1884 b- defN 18-Nov-27 23:08 genie/libs/sdk/triggers/ha/reload/iosxr/iosxrv/reload.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/ha/reload/nxos/__init__.py
+-rw-r--r--  2.0 unx    19649 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/ha/reload/nxos/reload.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/ha/reload/nxos/n9k/__init__.py
+-rw-r--r--  2.0 unx     2870 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/ha/reload/nxos/n9k/reload.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/ha/switchover/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/ha/switchover/iosxe/__init__.py
+-rw-r--r--  2.0 unx      923 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/ha/switchover/iosxe/switchover.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/ha/switchover/iosxe/asr1k/__init__.py
+-rw-r--r--  2.0 unx     4334 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/ha/switchover/iosxe/asr1k/switchover.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/ha/switchover/iosxe/c3850/__init__.py
+-rw-r--r--  2.0 unx     7527 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/ha/switchover/iosxe/c3850/switchover.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/ha/switchover/iosxr/__init__.py
+-rw-r--r--  2.0 unx     5842 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/ha/switchover/iosxr/switchover.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/ha/switchover/nxos/__init__.py
+-rw-r--r--  2.0 unx     4614 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/ha/switchover/nxos/switchover.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/modify/__init__.py
+-rw-r--r--  2.0 unx     5497 b- defN 18-Nov-27 23:08 genie/libs/sdk/triggers/modify/modify.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/modify/bgp/__init__.py
+-rw-r--r--  2.0 unx    22396 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/modify/bgp/modify.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/modify/bgp/iosxe/__init__.py
+-rw-r--r--  2.0 unx    22822 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/modify/bgp/iosxe/modify.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/modify/bgp/iosxr/__init__.py
+-rw-r--r--  2.0 unx    11624 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/modify/bgp/iosxr/modify.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/modify/bgp/nxos/__init__.py
+-rw-r--r--  2.0 unx    57387 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/modify/bgp/nxos/modify.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/modify/dot1x/__init__.py
+-rw-r--r--  2.0 unx      196 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/modify/dot1x/modify.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/modify/dot1x/iosxe/__init__.py
+-rw-r--r--  2.0 unx     8764 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/modify/dot1x/iosxe/modify.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/modify/hsrp/__init__.py
+-rw-r--r--  2.0 unx    13707 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/modify/hsrp/modify.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-26 16:18 genie/libs/sdk/triggers/modify/igmp/__init__.py
+-rw-r--r--  2.0 unx      180 b- defN 18-Oct-26 16:18 genie/libs/sdk/triggers/modify/igmp/modify.py
+-rw-r--r--  2.0 unx      257 b- defN 18-Oct-26 16:18 genie/libs/sdk/triggers/modify/igmp/nxos/__init__.py
+-rw-r--r--  2.0 unx     5138 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/modify/igmp/nxos/modify.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/modify/interface/__init__.py
+-rw-r--r--  2.0 unx    27984 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/modify/interface/modify.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/modify/interface/iosxe/__init__.py
+-rw-r--r--  2.0 unx    10111 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/modify/interface/iosxe/modify.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/modify/interface/iosxr/__init__.py
+-rw-r--r--  2.0 unx     5387 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/modify/interface/iosxr/modify.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/modify/lldp/__init__.py
+-rw-r--r--  2.0 unx     4488 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/modify/lldp/modify.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-26 16:18 genie/libs/sdk/triggers/modify/mld/__init__.py
+-rw-r--r--  2.0 unx      180 b- defN 18-Oct-26 16:18 genie/libs/sdk/triggers/modify/mld/modify.py
+-rw-r--r--  2.0 unx      257 b- defN 18-Oct-26 16:18 genie/libs/sdk/triggers/modify/mld/nxos/__init__.py
+-rw-r--r--  2.0 unx     5087 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/modify/mld/nxos/modify.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/modify/msdp/__init__.py
+-rw-r--r--  2.0 unx      727 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/modify/msdp/modify.py
+-rw-r--r--  2.0 unx      257 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/modify/msdp/nxos/__init__.py
+-rw-r--r--  2.0 unx    58380 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/modify/msdp/nxos/modify.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/modify/pim/__init__.py
+-rw-r--r--  2.0 unx      184 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/modify/pim/modify.py
+-rw-r--r--  2.0 unx      257 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/modify/pim/nxos/__init__.py
+-rw-r--r--  2.0 unx     6051 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/modify/pim/nxos/modify.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/modify/stp/__init__.py
+-rw-r--r--  2.0 unx      280 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/modify/stp/modify.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/modify/stp/iosxe/__init__.py
+-rw-r--r--  2.0 unx    15922 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/modify/stp/iosxe/modify.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/modify/vlan/__init__.py
+-rw-r--r--  2.0 unx      111 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/modify/vlan/modify.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/modify/vlan/nxos/__init__.py
+-rw-r--r--  2.0 unx     5832 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/modify/vlan/nxos/modify.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/modify/vxlan/__init__.py
+-rw-r--r--  2.0 unx      132 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/modify/vxlan/modify.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/modify/vxlan/nxos/__init__.py
+-rw-r--r--  2.0 unx    35894 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/modify/vxlan/nxos/modify.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/__init__.py
+-rw-r--r--  2.0 unx     4087 b- defN 18-Nov-27 23:08 genie/libs/sdk/triggers/processrestart/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/aclmgr/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/aclmgr/nxos/__init__.py
+-rw-r--r--  2.0 unx     3647 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/aclmgr/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/bfd/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/bfd/nxos/__init__.py
+-rw-r--r--  2.0 unx     3570 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/bfd/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/bgp/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/bgp/nxos/__init__.py
+-rw-r--r--  2.0 unx     5035 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/bgp/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/cfs/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/cfs/nxos/__init__.py
+-rw-r--r--  2.0 unx     3570 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/cfs/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/confcheck/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/confcheck/nxos/__init__.py
+-rw-r--r--  2.0 unx     3608 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/confcheck/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/eigrp/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/eigrp/nxos/__init__.py
+-rw-r--r--  2.0 unx     5097 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/eigrp/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/eltm/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/eltm/nxos/__init__.py
+-rw-r--r--  2.0 unx     3573 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/eltm/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/feature_mgr/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/feature_mgr/nxos/__init__.py
+-rw-r--r--  2.0 unx     3743 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/feature_mgr/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/fs_daemon/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/fs_daemon/nxos/__init__.py
+-rw-r--r--  2.0 unx     3712 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/fs_daemon/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/glbp/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/glbp/nxos/__init__.py
+-rw-r--r--  2.0 unx     3592 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/glbp/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/igmp/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/igmp/nxos/__init__.py
+-rw-r--r--  2.0 unx     5066 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/igmp/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/isis/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/isis/nxos/__init__.py
+-rw-r--r--  2.0 unx     5065 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/isis/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/l2rib/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/l2rib/nxos/__init__.py
+-rw-r--r--  2.0 unx     3616 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/l2rib/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/lacp/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/lacp/nxos/__init__.py
+-rw-r--r--  2.0 unx     3592 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/lacp/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/libs/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/libs/nxos/__init__.py
+-rw-r--r--  2.0 unx    18028 b- defN 18-Oct-26 16:18 genie/libs/sdk/triggers/processrestart/libs/nxos/processrestart.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/libs/nxos/n7k/__init__.py
+-rw-r--r--  2.0 unx     1737 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/libs/nxos/n7k/processrestart.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/libs/nxos/n9k/__init__.py
+-rw-r--r--  2.0 unx     2098 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/processrestart/libs/nxos/n9k/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/monitorc/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/monitorc/nxos/__init__.py
+-rw-r--r--  2.0 unx     3680 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/monitorc/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/mrib/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/mrib/nxos/__init__.py
+-rw-r--r--  2.0 unx     3905 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/mrib/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/msdp/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/msdp/nxos/__init__.py
+-rw-r--r--  2.0 unx     5073 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/msdp/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/netstack/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/netstack/nxos/__init__.py
+-rw-r--r--  2.0 unx     3728 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/netstack/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/nve/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/nve/nxos/__init__.py
+-rw-r--r--  2.0 unx     3570 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/nve/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/ospf/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/ospf/nxos/__init__.py
+-rw-r--r--  2.0 unx     5345 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/ospf/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/ospfv3/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/ospfv3/nxos/__init__.py
+-rw-r--r--  2.0 unx     5415 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/ospfv3/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/pim/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/pim/nxos/__init__.py
+-rw-r--r--  2.0 unx     5033 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/pim/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/pim6/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/pim6/nxos/__init__.py
+-rw-r--r--  2.0 unx     5066 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/pim6/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/plugin/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/plugin/nxos/__init__.py
+-rw-r--r--  2.0 unx     3638 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/plugin/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/rip/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/rip/nxos/__init__.py
+-rw-r--r--  2.0 unx     5039 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/rip/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/rsvp/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/rsvp/nxos/__init__.py
+-rw-r--r--  2.0 unx     5066 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/rsvp/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/stp/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/stp/nxos/__init__.py
+-rw-r--r--  2.0 unx     3572 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/stp/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/syslogd/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/syslogd/nxos/__init__.py
+-rw-r--r--  2.0 unx     3510 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/syslogd/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/sysmgr/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/sysmgr/nxos/__init__.py
+-rw-r--r--  2.0 unx     3866 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/sysmgr/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Nov-19 21:02 genie/libs/sdk/triggers/processrestart/trm/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Nov-19 21:02 genie/libs/sdk/triggers/processrestart/trm/nxos/__init__.py
+-rw-r--r--  2.0 unx     3602 b- defN 18-Nov-19 21:02 genie/libs/sdk/triggers/processrestart/trm/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/tunnel/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/tunnel/nxos/__init__.py
+-rw-r--r--  2.0 unx     3638 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/tunnel/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/urib/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/urib/nxos/__init__.py
+-rw-r--r--  2.0 unx     3946 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/urib/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/vdc_mgr/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/vdc_mgr/nxos/__init__.py
+-rw-r--r--  2.0 unx     3657 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/vdc_mgr/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/vlan_mgr/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/vlan_mgr/nxos/__init__.py
+-rw-r--r--  2.0 unx     3679 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/vlan_mgr/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/vpc/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/vpc/nxos/__init__.py
+-rw-r--r--  2.0 unx     3572 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/processrestart/vpc/nxos/processrestart.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/shutnoshut/__init__.py
+-rw-r--r--  2.0 unx     4441 b- defN 18-Nov-27 23:08 genie/libs/sdk/triggers/shutnoshut/shutnoshut.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/shutnoshut/bgp/__init__.py
+-rw-r--r--  2.0 unx    15586 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/shutnoshut/bgp/shutnoshut.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/shutnoshut/bgp/iosxe/__init__.py
+-rw-r--r--  2.0 unx     4823 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/shutnoshut/bgp/iosxe/shutnoshut.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/shutnoshut/bgp/iosxr/__init__.py
+-rw-r--r--  2.0 unx     5590 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/shutnoshut/bgp/iosxr/shutnoshut.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/shutnoshut/bgp/nxos/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/shutnoshut/interface/__init__.py
+-rw-r--r--  2.0 unx    15752 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/shutnoshut/interface/shutnoshut.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/shutnoshut/interface/iosxe/__init__.py
+-rw-r--r--  2.0 unx    44787 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/shutnoshut/interface/iosxe/shutnoshut.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/shutnoshut/interface/iosxr/__init__.py
+-rw-r--r--  2.0 unx     4613 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/shutnoshut/interface/iosxr/shutnoshut.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/shutnoshut/interface/nxos/__init__.py
+-rw-r--r--  2.0 unx    63521 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/shutnoshut/interface/nxos/shutnoshut.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/shutnoshut/msdp/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/shutnoshut/msdp/nxos/__init__.py
+-rw-r--r--  2.0 unx     4308 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/shutnoshut/msdp/nxos/shutnoshut.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/shutnoshut/vlan/__init__.py
+-rw-r--r--  2.0 unx      266 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/shutnoshut/vlan/shutnoshut.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/shutnoshut/vlan/iosxe/__init__.py
+-rw-r--r--  2.0 unx     3728 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/shutnoshut/vlan/iosxe/shutnoshut.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/shutnoshut/vlan/nxos/__init__.py
+-rw-r--r--  2.0 unx     3744 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/shutnoshut/vlan/nxos/shutnoshut.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/shutnoshut/vxlan/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/shutnoshut/vxlan/shutnoshut.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/shutnoshut/vxlan/nxos/__init__.py
+-rw-r--r--  2.0 unx     9829 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/shutnoshut/vxlan/nxos/shutnoshut.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/sleep/__init__.py
+-rw-r--r--  2.0 unx      886 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/sleep/sleep.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/template/__init__.py
+-rw-r--r--  2.0 unx     1313 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/template/addremove.py
+-rw-r--r--  2.0 unx      954 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/template/checkcommands.py
+-rw-r--r--  2.0 unx      655 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/template/clear.py
+-rw-r--r--  2.0 unx     2847 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/template/disableenable.py
+-rw-r--r--  2.0 unx     2722 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/template/ha.py
+-rw-r--r--  2.0 unx     1394 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/template/modify.py
+-rw-r--r--  2.0 unx      769 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/template/processrestart.py
+-rw-r--r--  2.0 unx     1262 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/template/shutnoshut.py
+-rw-r--r--  2.0 unx      328 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/template/sleep.py
+-rw-r--r--  2.0 unx     1425 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/template/unconfigconfig.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/unconfigconfig/__init__.py
+-rw-r--r--  2.0 unx     5760 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/unconfigconfig/unconfigconfig.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/unconfigconfig/bgp/__init__.py
+-rw-r--r--  2.0 unx     9264 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/unconfigconfig/bgp/unconfigconfig.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/unconfigconfig/bgp/nxos/__init__.py
+-rw-r--r--  2.0 unx   127165 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/unconfigconfig/bgp/nxos/unconfigconfig.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-26 16:18 genie/libs/sdk/triggers/unconfigconfig/igmp/__init__.py
+-rw-r--r--  2.0 unx      234 b- defN 18-Oct-26 16:18 genie/libs/sdk/triggers/unconfigconfig/igmp/unconfigconfig.py
+-rw-r--r--  2.0 unx      257 b- defN 18-Oct-26 16:18 genie/libs/sdk/triggers/unconfigconfig/igmp/nxos/__init__.py
+-rw-r--r--  2.0 unx    25980 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/unconfigconfig/igmp/nxos/unconfigconfig.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/unconfigconfig/interface/__init__.py
+-rw-r--r--  2.0 unx    27862 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/unconfigconfig/interface/unconfigconfig.py
+-rw-r--r--  2.0 unx      257 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/unconfigconfig/interface/iosxe/__init__.py
+-rw-r--r--  2.0 unx    19872 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/unconfigconfig/interface/iosxe/unconfigconfig.py
+-rw-r--r--  2.0 unx      257 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/unconfigconfig/interface/iosxr/__init__.py
+-rw-r--r--  2.0 unx     6028 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/unconfigconfig/interface/iosxr/unconfigconfig.py
+-rw-r--r--  2.0 unx      257 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/unconfigconfig/interface/nxos/__init__.py
+-rw-r--r--  2.0 unx    47270 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/unconfigconfig/interface/nxos/unconfigconfig.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-26 16:18 genie/libs/sdk/triggers/unconfigconfig/mld/__init__.py
+-rw-r--r--  2.0 unx      226 b- defN 18-Oct-26 16:18 genie/libs/sdk/triggers/unconfigconfig/mld/unconfigconfig.py
+-rw-r--r--  2.0 unx      257 b- defN 18-Oct-26 16:18 genie/libs/sdk/triggers/unconfigconfig/mld/nxos/__init__.py
+-rw-r--r--  2.0 unx    25935 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/unconfigconfig/mld/nxos/unconfigconfig.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/unconfigconfig/msdp/__init__.py
+-rw-r--r--  2.0 unx      830 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/unconfigconfig/msdp/unconfigconfig.py
+-rw-r--r--  2.0 unx      257 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/unconfigconfig/msdp/nxos/__init__.py
+-rw-r--r--  2.0 unx    47250 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/unconfigconfig/msdp/nxos/unconfigconfig.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/unconfigconfig/pim/__init__.py
+-rw-r--r--  2.0 unx      233 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/unconfigconfig/pim/unconfigconfig.py
+-rw-r--r--  2.0 unx      257 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/unconfigconfig/pim/nxos/__init__.py
+-rw-r--r--  2.0 unx     5798 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/unconfigconfig/pim/nxos/unconfigconfig.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Nov-19 21:02 genie/libs/sdk/triggers/unconfigconfig/trm/__init__.py
+-rw-r--r--  2.0 unx       53 b- defN 18-Nov-19 21:02 genie/libs/sdk/triggers/unconfigconfig/trm/unconfigconfig.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Nov-19 21:02 genie/libs/sdk/triggers/unconfigconfig/trm/nxos/__init__.py
+-rw-r--r--  2.0 unx    14856 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/unconfigconfig/trm/nxos/unconfigconfig.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/unconfigconfig/vlan/__init__.py
+-rw-r--r--  2.0 unx     2652 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/unconfigconfig/vlan/unconfigconfig.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/unconfigconfig/vlan/iosxe/__init__.py
+-rw-r--r--  2.0 unx     4322 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/unconfigconfig/vlan/iosxe/unconfigconfig.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/triggers/unconfigconfig/vlan/nxos/__init__.py
+-rw-r--r--  2.0 unx     8505 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/unconfigconfig/vlan/nxos/unconfigconfig.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/unconfigconfig/vxlan/__init__.py
+-rw-r--r--  2.0 unx      302 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/unconfigconfig/vxlan/unconfigconfig.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/unconfigconfig/vxlan/nxos/__init__.py
+-rw-r--r--  2.0 unx    63027 b- defN 19-Jan-16 23:37 genie/libs/sdk/triggers/unconfigconfig/vxlan/nxos/unconfigconfig.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/xe_sanity/__init__.py
+-rw-r--r--  2.0 unx    65291 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/xe_sanity/configurations.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/xe_sanity/checkcommands/__init__.py
+-rw-r--r--  2.0 unx      322 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/xe_sanity/checkcommands/checkcommands.py
+-rw-r--r--  2.0 unx      184 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/xe_sanity/checkcommands/iosxe/__init__.py
+-rw-r--r--  2.0 unx    32870 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/xe_sanity/checkcommands/iosxe/checkcommands.py
+-rw-r--r--  2.0 unx        0 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/xe_sanity/checkcommands/libs/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/xe_sanity/checkcommands/libs/iosxe/__init__.py
+-rw-r--r--  2.0 unx    10217 b- defN 18-Oct-12 19:25 genie/libs/sdk/triggers/xe_sanity/checkcommands/libs/iosxe/checkcommands.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/verifications/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 18-May-10 16:16 genie/libs/sdk/verifications/ospf/__init__.py
+-rw-r--r--  2.0 unx      256 b- defN 18-May-10 16:16 genie/libs/sdk/verifications/ospf/iosxe/__init__.py
+-rw-r--r--  2.0 unx      990 b- defN 18-Nov-27 23:08 genie.libs.sdk-3.1.9.data/data/genie_yamls/__init__.py
+-rw-r--r--  2.0 unx     6138 b- defN 19-Jan-24 23:41 genie.libs.sdk-3.1.9.data/data/genie_yamls/pts_datafile.yaml
+-rw-r--r--  2.0 unx     1241 b- defN 18-May-10 16:16 genie.libs.sdk-3.1.9.data/data/genie_yamls/subsection_datafile.yaml
+-rw-r--r--  2.0 unx    64550 b- defN 18-Nov-27 23:08 genie.libs.sdk-3.1.9.data/data/genie_yamls/trigger_datafile.yaml
+-rw-r--r--  2.0 unx    78843 b- defN 18-Nov-27 23:08 genie.libs.sdk-3.1.9.data/data/genie_yamls/verification_datafile.yaml
+-rw-r--r--  2.0 unx      683 b- defN 18-Nov-19 21:02 genie.libs.sdk-3.1.9.data/data/genie_yamls/ios/trigger_datafile_ios.yaml
+-rw-r--r--  2.0 unx     1803 b- defN 18-Nov-19 21:02 genie.libs.sdk-3.1.9.data/data/genie_yamls/ios/verification_datafile_ios.yaml
+-rw-r--r--  2.0 unx    12379 b- defN 18-Nov-06 18:09 genie.libs.sdk-3.1.9.data/data/genie_yamls/iosxe/trigger_datafile_iosxe.yaml
+-rw-r--r--  2.0 unx    15358 b- defN 18-Nov-06 18:09 genie.libs.sdk-3.1.9.data/data/genie_yamls/iosxe/verification_datafile_iosxe.yaml
+-rw-r--r--  2.0 unx     6365 b- defN 18-Nov-06 18:09 genie.libs.sdk-3.1.9.data/data/genie_yamls/iosxr/trigger_datafile_xr.yaml
+-rwxr-xr-x  2.0 unx    15374 b- defN 18-Nov-27 23:08 genie.libs.sdk-3.1.9.data/data/genie_yamls/iosxr/verification_datafile_xr.yaml
+-rw-r--r--  2.0 unx      172 b- defN 18-Nov-27 23:08 genie.libs.sdk-3.1.9.data/data/genie_yamls/junos/trigger_datafile_junos.yaml
+-rw-r--r--  2.0 unx      617 b- defN 18-Nov-27 23:08 genie.libs.sdk-3.1.9.data/data/genie_yamls/junos/verification_datafile_junos.yaml
+-rw-r--r--  2.0 unx    85023 b- defN 18-Nov-29 22:37 genie.libs.sdk-3.1.9.data/data/genie_yamls/nxos/trigger_datafile_nxos.yaml
+-rw-r--r--  2.0 unx    36037 b- defN 19-Jan-16 23:35 genie.libs.sdk-3.1.9.data/data/genie_yamls/nxos/verification_datafile_nxos.yaml
+-rw-r--r--  2.0 unx    17544 b- defN 18-Nov-27 23:08 genie.libs.sdk-3.1.9.data/data/genie_yamls/tools/verification_generator/datafiles_maker.py
+-rw-r--r--  2.0 unx      906 b- defN 18-May-10 22:11 genie.libs.sdk-3.1.9.data/data/genie_yamls/tools/verification_generator/differ.py
+-rw-r--r--  2.0 unx     5792 b- defN 18-Nov-06 18:09 genie.libs.sdk-3.1.9.data/data/genie_yamls/tools/verification_generator/parsers.yaml
+-rw-r--r--  2.0 unx       17 b- defN 19-Jan-29 19:36 genie.libs.sdk-3.1.9.dist-info/namespace_packages.txt
+-rw-r--r--  2.0 unx        6 b- defN 19-Jan-29 19:36 genie.libs.sdk-3.1.9.dist-info/top_level.txt
+-rw-r--r--  2.0 unx       92 b- defN 19-Jan-29 19:36 genie.libs.sdk-3.1.9.dist-info/WHEEL
+-rw-r--r--  2.0 unx     3210 b- defN 19-Jan-29 19:36 genie.libs.sdk-3.1.9.dist-info/METADATA
+-rw-r--r--  2.0 unx    53974 b- defN 19-Jan-29 19:36 genie.libs.sdk-3.1.9.dist-info/RECORD
+478 files, 2720113 bytes uncompressed, 389973 bytes compressed:  85.7%
```

## zipnote {}

```diff
@@ -1,8 +1,8 @@
-Filename: genie.libs.sdk-3.1.8-py3.5-nspkg.pth
+Filename: genie.libs.sdk-3.1.9-py3.4-nspkg.pth
 Comment: 
 
 Filename: genie/libs/sdk/__init__.py
 Comment: 
 
 Filename: genie/libs/sdk/libs/__init__.py
 Comment: 
@@ -21,14 +21,17 @@
 
 Filename: genie/libs/sdk/libs/abstracted_libs/management_interface.py
 Comment: 
 
 Filename: genie/libs/sdk/libs/abstracted_libs/processors.py
 Comment: 
 
+Filename: genie/libs/sdk/libs/abstracted_libs/restore.py
+Comment: 
+
 Filename: genie/libs/sdk/libs/abstracted_libs/subsection.py
 Comment: 
 
 Filename: genie/libs/sdk/libs/abstracted_libs/ios/__init__.py
 Comment: 
 
 Filename: genie/libs/sdk/libs/abstracted_libs/ios/init_exec_commands.py
@@ -1356,77 +1359,77 @@
 
 Filename: genie/libs/sdk/verifications/ospf/__init__.py
 Comment: 
 
 Filename: genie/libs/sdk/verifications/ospf/iosxe/__init__.py
 Comment: 
 
-Filename: genie.libs.sdk-3.1.8.data/data/genie_yamls/__init__.py
+Filename: genie.libs.sdk-3.1.9.data/data/genie_yamls/__init__.py
 Comment: 
 
-Filename: genie.libs.sdk-3.1.8.data/data/genie_yamls/pts_datafile.yaml
+Filename: genie.libs.sdk-3.1.9.data/data/genie_yamls/pts_datafile.yaml
 Comment: 
 
-Filename: genie.libs.sdk-3.1.8.data/data/genie_yamls/subsection_datafile.yaml
+Filename: genie.libs.sdk-3.1.9.data/data/genie_yamls/subsection_datafile.yaml
 Comment: 
 
-Filename: genie.libs.sdk-3.1.8.data/data/genie_yamls/trigger_datafile.yaml
+Filename: genie.libs.sdk-3.1.9.data/data/genie_yamls/trigger_datafile.yaml
 Comment: 
 
-Filename: genie.libs.sdk-3.1.8.data/data/genie_yamls/verification_datafile.yaml
+Filename: genie.libs.sdk-3.1.9.data/data/genie_yamls/verification_datafile.yaml
 Comment: 
 
-Filename: genie.libs.sdk-3.1.8.data/data/genie_yamls/ios/trigger_datafile_ios.yaml
+Filename: genie.libs.sdk-3.1.9.data/data/genie_yamls/ios/trigger_datafile_ios.yaml
 Comment: 
 
-Filename: genie.libs.sdk-3.1.8.data/data/genie_yamls/ios/verification_datafile_ios.yaml
+Filename: genie.libs.sdk-3.1.9.data/data/genie_yamls/ios/verification_datafile_ios.yaml
 Comment: 
 
-Filename: genie.libs.sdk-3.1.8.data/data/genie_yamls/iosxe/trigger_datafile_iosxe.yaml
+Filename: genie.libs.sdk-3.1.9.data/data/genie_yamls/iosxe/trigger_datafile_iosxe.yaml
 Comment: 
 
-Filename: genie.libs.sdk-3.1.8.data/data/genie_yamls/iosxe/verification_datafile_iosxe.yaml
+Filename: genie.libs.sdk-3.1.9.data/data/genie_yamls/iosxe/verification_datafile_iosxe.yaml
 Comment: 
 
-Filename: genie.libs.sdk-3.1.8.data/data/genie_yamls/iosxr/trigger_datafile_xr.yaml
+Filename: genie.libs.sdk-3.1.9.data/data/genie_yamls/iosxr/trigger_datafile_xr.yaml
 Comment: 
 
-Filename: genie.libs.sdk-3.1.8.data/data/genie_yamls/iosxr/verification_datafile_xr.yaml
+Filename: genie.libs.sdk-3.1.9.data/data/genie_yamls/iosxr/verification_datafile_xr.yaml
 Comment: 
 
-Filename: genie.libs.sdk-3.1.8.data/data/genie_yamls/junos/trigger_datafile_junos.yaml
+Filename: genie.libs.sdk-3.1.9.data/data/genie_yamls/junos/trigger_datafile_junos.yaml
 Comment: 
 
-Filename: genie.libs.sdk-3.1.8.data/data/genie_yamls/junos/verification_datafile_junos.yaml
+Filename: genie.libs.sdk-3.1.9.data/data/genie_yamls/junos/verification_datafile_junos.yaml
 Comment: 
 
-Filename: genie.libs.sdk-3.1.8.data/data/genie_yamls/nxos/trigger_datafile_nxos.yaml
+Filename: genie.libs.sdk-3.1.9.data/data/genie_yamls/nxos/trigger_datafile_nxos.yaml
 Comment: 
 
-Filename: genie.libs.sdk-3.1.8.data/data/genie_yamls/nxos/verification_datafile_nxos.yaml
+Filename: genie.libs.sdk-3.1.9.data/data/genie_yamls/nxos/verification_datafile_nxos.yaml
 Comment: 
 
-Filename: genie.libs.sdk-3.1.8.data/data/genie_yamls/tools/verification_generator/datafiles_maker.py
+Filename: genie.libs.sdk-3.1.9.data/data/genie_yamls/tools/verification_generator/datafiles_maker.py
 Comment: 
 
-Filename: genie.libs.sdk-3.1.8.data/data/genie_yamls/tools/verification_generator/differ.py
+Filename: genie.libs.sdk-3.1.9.data/data/genie_yamls/tools/verification_generator/differ.py
 Comment: 
 
-Filename: genie.libs.sdk-3.1.8.data/data/genie_yamls/tools/verification_generator/parsers.yaml
+Filename: genie.libs.sdk-3.1.9.data/data/genie_yamls/tools/verification_generator/parsers.yaml
 Comment: 
 
-Filename: genie.libs.sdk-3.1.8.dist-info/namespace_packages.txt
+Filename: genie.libs.sdk-3.1.9.dist-info/namespace_packages.txt
 Comment: 
 
-Filename: genie.libs.sdk-3.1.8.dist-info/top_level.txt
+Filename: genie.libs.sdk-3.1.9.dist-info/top_level.txt
 Comment: 
 
-Filename: genie.libs.sdk-3.1.8.dist-info/WHEEL
+Filename: genie.libs.sdk-3.1.9.dist-info/WHEEL
 Comment: 
 
-Filename: genie.libs.sdk-3.1.8.dist-info/METADATA
+Filename: genie.libs.sdk-3.1.9.dist-info/METADATA
 Comment: 
 
-Filename: genie.libs.sdk-3.1.8.dist-info/RECORD
+Filename: genie.libs.sdk-3.1.9.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## genie/libs/sdk/__init__.py

```diff
@@ -3,15 +3,15 @@
         libs.sdk
 
     Description:
         This is the library sub-component of Genie for `genie.sdk`.
 '''
 
 # metadata
-__version__ = '3.1.8'
+__version__ = '3.1.9'
 __author__ = 'Cisco Systems Inc.'
 __contact__ = ['pyats-support@cisco.com', 'pyats-support-ext@cisco.com']
 __copyright__ = 'Copyright (c) 2018, Cisco Systems Inc.'
 
 
 from genie import abstract
 abstract.declare_package(__name__)
```

## genie/libs/sdk/libs/abstracted_libs/iosxe/restore.py

```diff
@@ -156,25 +156,22 @@
         if action == 'create':
             # create checkpoint
             try:
                 # get dir location
                 dir_loc = abstract.parser.show_platform.Dir(device=device).parse()
                 dir_loc = dir_loc['dir']['dir'].replace(':/', '')
                 # activate archive mode
-                cfg_str = '''
-                          archive
-                          path {dir}:{name}
-                          do-exec archive config
-                          '''
-                ret = device.configure(cfg_str.format(dir=dir_loc, name=name))
+                cfg_strs = ["archive", "path {dir}:{name}".format(dir=dir_loc, name=name),
+                            "do-exec archive config"]
+                ret = device.configure(cfg_strs)
             except Exception as e:
-                raise SyntaxError("Issue seding {c}".format(c=cfg_str)) from e
+                raise SyntaxError("Issue sending {c}".format(c=cfg_strs)) from e
             else:
                 if 'ERROR' in ret:
-                    raise SyntaxError("Issue seding {c}".format(c=cfg_str)) from e
+                    raise SyntaxError("Issue sending {c}".format(c=cfg_strs)) from e
         else:
             try:
                 # get location
                 location = re.search('(([\w\-]+)\:+).*', self.ckname).groups()[0]
 
                 # delete the archive file
                 dialog = Dialog([
@@ -195,25 +192,21 @@
                               loop_continue=True,
                               continue_timer=False),
                     ])
 
                 device.execute('delete {}'.format(self.ckname), reply=dialog)
 
                 # deactivate archive mode
-                cfg_str = '''
-                          archive
-                          no path
-                          exit
-                          '''
-                ret = device.configure(cfg_str)
+                cfg_strs = ['archive', 'no path', 'exit']
+                ret = device.configure(cfg_strs)
             except Exception as e:
-                raise SyntaxError("Issue seding {c}".format(c=cfg_str)) from e
+                raise SyntaxError("Issue sending {c}".format(c=cfg_strs)) from e
             else:
                 if 'ERROR' in ret:
-                    raise SyntaxError("Issue seding {c}".format(c=cfg_str)) from e
+                    raise SyntaxError("Issue sending {c}".format(c=cfg_strs)) from e
 
 
     def rollback_checkpoint(self, device, name):
         '''
             Rollback configuration by checkpoint
 
             Args:
```

## genie/libs/sdk/libs/utils/common.py

```diff
@@ -4,219 +4,485 @@
 import re
 import random
 import logging
 from enum import Enum
 from copy import deepcopy
 from ipaddress import _BaseAddress
 from collections import defaultdict, Iterable
+from prettytable import PrettyTable as ptable
 
 # import genie
+from genie.ops.base import get_ops
 from genie.utils.diff import Diff
 from genie.conf.base.attributes import SubAttributesDict
+from genie.libs.sdk.libs.utils.normalize import GroupKeys
+from genie.libs.conf.base import IPv4Network
+from genie.libs import parser
+from genie.utils.summary import Summary
+
+# abstract
+from genie.abstract import Lookup
 
 # import ats
 from ats.log.utils import banner
 from ats.utils.objects import find, R, Operator
 
 # Genie Libs
 from genie.libs.conf.base.neighbor import Neighbor
+from genie.libs.sdk.libs.utils.mapping import Mapping
 
 # module logger
 log = logging.getLogger(__name__)
 
 
 class UpdateLearntDatabase(object):
     """Class to update local/global verifications and PTS"""
 
-    def __init__(self, obj, device):
+    def __init__(self, obj, device, update_ver_list=None, update_feature_list=None):
         """built-in __init__
 
         instantiates each update actions.
 
         Arguments
         ---------
             device (`obj`): Device object
+            obj (`obj`): Genie Trigger Object
+            update_ver_list (`list`): List of verifications names
+            update_feature_list(`list`): List of pts features names
         """
         self.device = device
         self.obj = obj
+        # update verifications list
+        self.update_ver_list = update_ver_list
+        # update pts features list
+        self.update_feature_list = update_feature_list
+        # build up abstract object based on the os of device
+        self.abstract = Lookup.from_device(device)
+
+    @property
+    def is_local_ver_enabled(self):
+        '''To check if local verifications need to be udpated.'''
+
+        # create summary instnace for local verification
+        self.local_summary = Summary(title='Local Verifications', width=150)
+
+        if not self.obj.parent.verifications:
+            self.local_summary.add_message(
+              '* No verifications imported')
+            self.local_summary.add_subtitle_line()
+            log.info('No verifications imported')
+            return False
+
+        if not self.obj.verf:
+            self.local_summary.add_message(
+              '* No local verifications executed')
+            self.local_summary.add_subtitle_line()
+            log.info('No local verifications executed')
+            return False
+
+        if not self.update_ver_list:
+            self.local_summary.add_message(
+              '* No verifications defined to be updated')
+            self.local_summary.add_subtitle_line()
+            log.info('No verifications defined to be updated')
+            return False
+
+        for ver in self.update_ver_list:
+            if self.obj.verf and self.device.name in self.obj.verf and \
+               self.obj.verf[self.device.name] and \
+               ver in self.obj.verf[self.device.name]:
+                return True
+
+        # add seperate line
+        self.local_summary.add_sep_line()
+
+        # compose the summary message
+        self.local_summary.add_message(
+          '* Skipped Update\n')
+        msgs = ''
+        for ver in self.update_ver_list:
+            msgs += '%s: Not learned before on device %s\n' % \
+                (self.local_summary.add_indent(ver), self.device.name)
+        self.local_summary.add_message(msgs)
+        self.local_summary.add_subtitle_line()
+
+        log.info('Required Local verification "{v}" is '
+                'not learned before on device {d}, Skip updating local'
+                .format(v=self.update_ver_list, d=self.device.name))
+        return False
+
+    @property
+    def is_global_ver_enabled(self):
+        '''To check if global verifications need to be udpated.'''
+
+        # create summary instnace for Global verification
+        self.global_summary = Summary(title='Global Verifications', width=150)
+
+        if not self.obj.parent.verifications:
+            self.global_summary.add_message(
+              '* No verifications imported')
+            self.global_summary.add_subtitle_line()
+            log.info('No verifications imported')
+            return False
+
+        if not self.obj.parent.verf:
+            self.global_summary.add_message(
+              '* No global verifications executed')
+            self.global_summary.add_subtitle_line()
+            log.info('No global verifications executed')
+            return False
+
+        if not self.update_ver_list:
+            self.global_summary.add_message(
+              '* No verifications defined to be updated')
+            self.global_summary.add_subtitle_line()
+            log.info('No verifications require to be updated')
+            return False
+
+        for ver in self.update_ver_list:
+            if self.device.name in self.obj.parent.verf and \
+               self.obj.parent.verf[self.device.name] and \
+               ver in self.obj.parent.verf[self.device.name]:
+                return True
+
+        # add seperate line
+        self.global_summary.add_sep_line()
+
+        # compose the summary message
+        self.global_summary.add_message(
+          '* Skipped Update\n')
+        msgs = ''
+        for ver in self.update_ver_list:
+            msgs += '%s: Not learned before on device %s\n' % \
+                (self.global_summary.add_indent(ver), self.device.name)
+        self.global_summary.add_message(msgs)
+        self.global_summary.add_subtitle_line()
+
+        log.info('Required Global verification "{v}" is '
+                'not learned before on device {d}, Skip updating global'
+                .format(v=self.update_ver_list, d=self.device.name))
+        return False
+
+    @property
+    def is_pts_enabled(self):
+        '''To check if PTS need to be udpated.'''
+        # create summary instnace for PTS
+        self.pts_summary = Summary(title='PTS', width=150)
+
+        if 'pts' not in self.obj.parent.parameters:
+            self.pts_summary.add_message('* No PTS executed')
+            log.info('No PTS executed')
+            self.pts_summary.add_subtitle_line()
+            return False
+
+        if not self.update_feature_list:
+            self.pts_summary.add_message(
+              '* No PTS features require to be updated')
+            self.pts_summary.add_subtitle_line()
+            log.info('No PTS features require to be updated')
+            return False
+
+        for feature in self.update_feature_list:
+            if feature in self.obj.parent.parameters['pts']:
+                return True
+
+        # add seperate line
+        self.pts_summary.add_sep_line()
+        
+        # compose the summary message
+        self.pts_summary.add_message(
+          '* Skipped Update')
+        msgs = ''
+        for fe in self.update_feature_list:
+            msgs += '%s: Not learned before on device %s\n' % \
+                (self.pts_summary.add_indent(fe), self.device.name)
+        self.pts_summary.add_message(msgs)
+        self.pts_summary.add_subtitle_line()
+
+        log.info('Required features "{v}" is '
+                'not learned before on device {d}, Skip updating PTS'
+                .format(v=self.update_feature_list, d=self.device.name))
+        return False
+
+    def _get_command_output(self, ver):
+        '''Extract the Verification output.
+           Args:
+              Mandatory:
+                ver (`str`) : verification name.
+
+           Returns:
+               str: parser output
+               ops object: ops object after learn
+
+           Raises:
+               Metaparser errors
+        '''
+
+        # Check if verificaiton is parser, callable or Ops
+        if 'cmd' in self.obj.parent.verifications[ver]:
+            # compose the command object
+            execute_obj = self.abstract.parser
+            for item in self.obj.parent.verifications[ver]['cmd']['class'].split('.'):
+                execute_obj = getattr(execute_obj, item)
+            execute_obj = execute_obj(self.device)
+        elif 'source' in self.obj.parent.verifications[ver]:
+            # compose the source object
+            execute_obj = self.abstract
+            for item in self.obj.parent.verifications[ver]['source']['class'].split('.'):
+                execute_obj = getattr(execute_obj, item)
+            execute_obj = execute_obj(self.device)
+        
+        # parser update
+        if hasattr(execute_obj, 'parse'):
+            # check if has parameters
+            if 'parameters' in self.obj.parent.verifications[ver]:
+                para = self.obj.parent.verifications[ver]['parameters']
+            else:
+                para = {}
+            output = execute_obj.parse(**para)
+            return output
+
+        # Ops update
+        if hasattr(execute_obj, 'learn'):
+            execute_obj.learn()
+            return execute_obj
+
+        # Callable update
+        # TODO
+
+    def _update_msg_summary(self, summary, successes, skips):
+        if successes:
+            summary.add_message(
+              '* Successfully Updated')
+            for ver in successes:
+                msg = summary.add_indent(ver)
+                summary.add_message(msg)
+
+        if skips:
+            summary.add_message(
+              '* Skipped Update')
+            for ver, msg in skips.items():
+                msgs = '%s: %s\n' % \
+                    (summary.add_indent(ver), msg)
+                summary.add_message(msgs)
 
-    def update_verification(self, abstract, update_ver_list):
+    def update_verification(self):
         '''Learn the verifications from the given list and
         overwrite it into local and global verifications.
 
        Args:
-          Mandatory:
-            abstract (`obj`): Abstract object
-            update_ver_list (`list`) : Verifications that want to be updatd
+          None
 
        Returns:
            None
 
        Raises:
            None
 
        Example:
-           >>> update_obj = UpdateLearntDatabase(object)
-           >>> update_obj.update_verification(
-                   abstract=abstract,
-                   update_ver_list=['Verify_Module', 'Verify_RedundancyStatus'])
+           >>> update_obj = UpdateLearntDatabase(object, device, 
+                 update_ver_list=['Verify_Module', 'Verify_RedundancyStatus'])
+           >>> update_obj.update_verification()
         '''
-        if self.obj.parent.verifications:
-            for ver in update_ver_list:
-                # skip updating verification for the ones
-                # not in the previous learned list
-                if ver not in self.obj.parent.verifications:
-                    log.warning('Verification {} was not supported'
-                            .format(ver))
-                    continue
-
-                # Check if verificaiton is parser, callable or Ops
-                if 'cmd' in self.obj.parent.verifications[ver]:
-                    # compose the command object
-                    execute_obj = abstract.parser
-                    for item in self.obj.parent.verifications[ver]['cmd']['class'].split('.'):
-                        execute_obj = getattr(execute_obj, item)
-                    execute_obj = execute_obj(self.device)
-                elif 'source' in self.obj.parent.verifications[ver]:
-                    # compose the source object
-                    execute_obj = abstract
-                    for item in self.obj.parent.verifications[ver]['source']['class'].split('.'):
-                        execute_obj = getattr(execute_obj, item)
-                    execute_obj = execute_obj(self.device)
-                else:
-                    # no source execute command valid
-                    continue
-
-                # parser update
-                if hasattr(execute_obj, 'parse'):
-                    # check if has parameters
-                    if 'parameters' in self.obj.parent.verifications[ver]:
-                        para = self.obj.parent.verifications[ver]['parameters']
-                    else:
-                        para = {}
-                    try:
-                        parser_output = execute_obj.parse(**para)
-                    except Exception as e:
-                        log.warning(
-                            'Local verification "{}" cannot be updated'.format(ver))
-                        log.warning(str(e))
-                        continue
-                else:
-                    # initial parser_output
-                    parser_output = None
-
-                # Ops update
-                if hasattr(execute_obj, 'learn'):
-                    try:
-                        execute_obj.learn()
-                    except Exception as e:
-                        # ignore when the output is empty
-                        log.warning(
-                            'Local verification "{}" cannot be updated'.format(ver))
-                        log.warning(str(e))
-                        continue
-
-                # Callable update
-                # TODO
-                    
-                # update local verififations
-                if self.obj.verf and self.device.name in self.obj.verf and \
-                   self.obj.verf[self.device.name] and \
-                   ver in self.obj.verf[self.device.name]:
-                    if parser_output:
-                        self.obj.verf[self.device.name][ver].name = parser_output
-                    elif isinstance(execute_obj, object):
-                        self.obj.verf[self.device.name][ver] = execute_obj
-                else:
-                    log.warning('Local verification "{v}" is '
-                        'not learned before on device {d}, Skip updating local'
-                        .format(v=ver, d=self.device.name))
-
-                # update global verififations
-                if self.device.name in self.obj.parent.verf and \
-                   self.obj.parent.verf[self.device.name] and \
-                   ver in self.obj.parent.verf[self.device.name]:
-                    if parser_output:
-                        self.obj.parent.verf[self.device.name][ver].name = parser_output
-                    elif isinstance(execute_obj, object):
-                        self.obj.parent.verf[self.device.name][ver] = execute_obj
-                else:
-                    log.warning('Global verification "{v}" is '
-                        'not learned before on device {d}, Skip updating global'
-                        .format(v=ver, d=self.device.name))
+        # Check if neede to update
+        if not self.is_local_ver_enabled:
+            # no combining the logic is to let it run each function
+            # to initial the summary object
+            if not self.is_global_ver_enabled:
+                return
+        else:
+            # inital the global summary object
+            self.is_global_ver_enabled
 
-
-    def update_pts(self, abstract, update_feature_list, update_attributes=None):
-        '''Learn the verifications from the given list and
-        overwrite it into local and global verifications.
+        # Initial lists for updating local/global vers
+        tmp_list_local = []
+        tmp_list_global = []
+        # initial for message print
+        skip_dict_local = {}
+        skip_dict_global = {}
+        success_list_local = []
+        success_list_global = []
+
+        # get same commands for local/global to avoid the duplicated show commands
+        for ver in self.update_ver_list:
+            # local verififations
+            if self.obj.verf and self.device.name in self.obj.verf and \
+               self.obj.verf[self.device.name] and \
+               ver in self.obj.verf[self.device.name]:
+                tmp_list_local.append(ver)
+            else:
+                skip_dict_local.update(
+                  {ver: 'Not learned before on device %s' % self.device.name})
+
+            # global verififations
+            if self.device.name in self.obj.parent.verf and \
+               self.obj.parent.verf[self.device.name] and \
+               ver in self.obj.parent.verf[self.device.name]:
+                tmp_list_global.append(ver)
+            else:
+                skip_dict_global.update(
+                  {ver: 'Not learned before on device %s' % self.device.name})
+
+        # get same list
+        same_list = list(set(tmp_list_local).intersection(tmp_list_global))
+
+        # get diff list
+        [tmp_list_local.remove(i) for i in same_list]
+        [tmp_list_global.remove(i) for i in same_list]
+
+        # update same commands for local and global
+        for ver in same_list:
+            try:
+                output = self._get_command_output(ver)
+            except Exception as e:
+                skip_dict_local.update(
+                  {ver: '%s' % e.__class__.__name__})
+                skip_dict_global.update(
+                  {ver: '%s' % e.__class__.__name__})
+                # ignore when the output is empty
+                log.warning(
+                    'Local verification "{}" cannot be updated'.format(ver))
+                log.warning(str(e))
+                continue
+            else:
+                success_list_local.append(ver)
+                success_list_global.append(ver)
+
+            if isinstance(output, dict):
+                self.obj.verf[self.device.name][ver].name = output
+                self.obj.parent.verf[self.device.name][ver].name = output
+            elif isinstance(execute_obj, object):
+                self.obj.verf[self.device.name][ver] = execute_obj
+                self.obj.parent.verf[self.device.name][ver] = execute_obj
+        
+        # update local specific
+        for ver in tmp_list_local:
+            try:
+                output = self._get_command_output(ver)
+            except Exception as e:
+                skip_dict_local.update(
+                  {ver: '%s' % e.__class__.__name__})
+                # ignore when the output is empty
+                log.warning(
+                    'Local verification "{}" cannot be updated'.format(ver))
+                log.warning(str(e))
+                continue
+            else:
+                success_list_local.append(ver)
+
+            if isinstance(output, dict):
+                self.obj.verf[self.device.name][ver].name = output
+            elif isinstance(execute_obj, object):
+                self.obj.verf[self.device.name][ver] = execute_obj
+        
+        # update global  specific
+        for ver in tmp_list_global:
+            try:
+                output = self._get_command_output(ver)
+            except Exception as e:
+                skip_dict_global.update(
+                  {ver: '%s' % e.__class__.__name__})
+                # ignore when the output is empty
+                log.warning(
+                    'Global verification "{}" cannot be updated'.format(ver))
+                log.warning(str(e))
+                continue
+            else:
+                success_list_global.append(ver)
+
+            if isinstance(output, dict):
+                self.obj.parent.verf[self.device.name][ver].name = output
+            elif isinstance(execute_obj, object):
+                self.obj.parent.verf[self.device.name][ver] = execute_obj
+
+        # print out messages
+        # - LOCAL
+        self._update_msg_summary(self.local_summary, 
+                                 success_list_local,
+                                 skip_dict_local)
+      
+        # - Global
+        self._update_msg_summary(self.global_summary, 
+                                 success_list_global,
+                                 skip_dict_global)
+     
+    def update_pts(self, update_attributes=None):
+        '''Learn the PTS from the given list and
+        overwrite it.
 
        Args:
           Mandatory:
-            abstract (`obj`): Abstract object
-            update_feature_list (`list`) : Features of the PTSs
-                                           that want to be updatd
           Optional:
             update_attributes (`dict`) : 
                 Attributes from the PTSs that want to be updatd,
                 should be {'feature': ['key1_path', 'key2_path']}.
                 Default: None (will update the whole PTS)
 
        Returns:
            None
 
        Raises:
            None
 
        Example:
-           >>> update_obj = UpdateLearntDatabase(object)
+           >>> update_obj = UpdateLearntDatabase(object, device, 
+                   update_feature_list=['platform', 'bgp'])
            >>> update_obj.update_verification(
-                   abstract=abstract,
-                   update_feature_list=['platform', 'bgp'],
                    update_attributes={'bgp': ['info'],
                                       'platform': ['chassis_sn', 'slot']})
         '''
+        if not self.is_pts_enabled:
+            return
+
+        # initial skip list for pring message
+        skip_dict_pts = {}
+        success_list_pts = []
+
         # update pts
-        if 'pts' in self.obj.parent.parameters:
-            for feature in update_feature_list:
-                if feature not in self.obj.parent.parameters['pts']:
-                    log.warning(
-                        'Feature {} was not learned before, Skip updating'
-                        .format(feature))
+        for feature in self.update_feature_list:
+               
+            log.info("Update {f} pts on {d}".format(f=feature, d=self.device))
+
+            # check if pts runs on this device before
+            if self.device.alias in self.obj.parent.parameters['pts'][feature]:
+
+                # learn the ops again
+                try:
+                    module = self.obj.parent.parameters['pts'][feature][self.device.alias]\
+                        .__class__(self.device)
+                    module.learn()
+                except Exception as e:
+                    skip_dict_pts.update({feature: e.__class__.__name__})
+                    log.warning('Feature {} cannot be learned, Skip updating'
+                                 .format(feature))
+                    log.warning(str(e))
                     continue
-                   
-                log.info("Update {f} pts on {d}".format(f=feature, d=self.device))
 
-                # check if pts runs on this device before
-                if self.device.alias in self.obj.parent.parameters['pts'][feature]:
-
-                    # learn the ops again
+                # update the given keys
+                for attr in update_attributes[feature]:
                     try:
-                        module = self.obj.parent.parameters['pts'][feature][self.device.alias]\
-                            .__class__(self.device)
-                        module.learn()
+                        setattr(self.obj.parent.parameters['pts'][feature][self.device.alias],
+                                   attr, (getattr(module, attr)))
                     except Exception as e:
-                        log.warning('Feature {} cannot be learned, Skip updating'
-                                     .format(feature))
-                        log.warning(str(e))
-                        continue
-
-                    # update the given keys
-                    for attr in update_attributes[feature]:
-                        try:
-                            setattr(self.obj.parent.parameters['pts'][feature][self.device.alias],
-                                       attr, (getattr(module, attr)))
-                        except Exception as e:
-                            pass
-                else:
-                    log.warning(
-                        'Feature {f} was not learned on {d} before, Skip updating'
-                        .format(f=feature, d=self.device))
-
-        else:
-            log.info('There is no PTS learned previously, Skip updating the PTS')
+                        skip_dict_pts.update({feature: e.__class__.__name__})
+                        
+                success_list_pts.append(feature)
+            else:
+                skip_dict_pts.update({feature: 
+                  'Feature {f} was not learned on {d} before, Skip updating'
+                    .format(f=feature, d=self.device)})
+                log.warning(
+                    'Feature {f} was not learned on {d} before, Skip updating'
+                    .format(f=feature, d=self.device))
+        # print out messages
+        # - PTS
+        self._update_msg_summary(self.pts_summary, 
+                                 success_list_pts,
+                                 skip_dict_pts)        
+        self.pts_summary.add_subtitle_line()
 
 
 class LearnPollDiff():
 
     @classmethod
     def ops_diff(self, ops_learn, ops_compare, exclude=None, ops_modified=None,
                   conf_argument=None):
@@ -287,8 +553,308 @@
 
         diff = Diff(ops_compare, ops_learn, exclude=exclude)
         diff.findDiff()
 
         if str(diff):
             log.info("The output is not same with diff\n{}".format(str(diff)))
             raise AssertionError("The output is not same with diff\n{}"
-                                 .format(str(diff)))
+                                 .format(str(diff)))
+
+
+def learn_ops(feature, device, attributes=None, **kwargs):
+    '''function to get ops class and create object then learn the features.
+    It can be the child process from pcall as well'''
+    # print the messages
+    log.info(banner('Sending the corresponding clis to learn {} \n'
+        'Operational status on device {}'
+        .format(feature, device.name), align='left'))
+    # get uut os corresponding feature ops class by genie provided function
+    try:
+        ops = get_ops(feature, device)
+    except Exception as e:
+        raise Exception('Cannot get the {f} corresponding '
+            'abstracted class on {d}\n{m}'
+              .format(m=str(e), f=feature, d=device.name))
+    
+    ops_obj = ops(device, attributes=attributes)
+    # learn the ops
+    ops_obj.learn_poll(**kwargs)
+
+    return ops_obj
+
+
+def get_ops_diff(new, original, exclude=None, modified_path=None, keys=None):
+    '''Diff two ops object with ignoring the keys from the exclude list
+
+       Args:
+          Mandatory:
+            new (`obj`) : Ops object.
+            original (`obj`) : Ops object.
+          Optional:
+            exclude (`list`) : Keys/attributs to ignore in the diff.
+            modified_path (`list`) : List of items that needs to be checked.
+                                     The item is following the ops attributes path
+                                     in a list.
+            keys (`list`) : List of items that contains the key values for the
+                            'modified_path' regexp items.
+
+       Returns:
+           None
+
+       Raises:
+           AssertionError: When diff is found
+           ValueError: When required attributes are not in the ops
+
+       Example:
+           >>> ops_diff(new = <bgp_ops_obj>,
+                        original = <bgp_ops_obj>,
+                        exclude = ['up_time', 'keepalive', 'maker'],
+                        modified_path = [['info', 'instance', '(?P<instance>.*)',
+                                          'vrf', '(?P<vrf>.*)', 'neighbor', '(?P<neighbor>.*)',
+                                          'remote_as', '900']],
+                        keys = [{'instance': '1', 'vrf': 'default', 'neighbor': '1.1.1.1'},
+                                {'instance': '1', 'vrf': 'VRF1', 'neighbor': '2.2.2.2'},])
+    '''
+
+    def _modify_ops_snapshot(original, current, path):
+        # First does path exists in original, except the value
+        r = R(path[:-1] + ['(.*)'])
+        ret = find([original], r, filter_=False)
+        if not ret:
+            raise ValueError("'{p}' does not exist on original snapshot "
+                "as per the original trigger requirement".format(p=path))
+        _modify_value(current, path[:-1], ret[0][0])
+
+    def _modify_value(snapshot, path, value):
+        for p in path[:-1]:
+            try:
+                snapshot = snapshot[p]
+            except (TypeError):
+                snapshot = getattr(snapshot, p)
+        if isinstance(snapshot, dict):
+            snapshot[path[-1]] = value
+        else:
+            setattr(snapshot, path[-1], value)
+    
+    if modified_path and keys:
+        mapping = Mapping()
+        for req in modified_path:
+
+            # use mapping internal function to populate the path with learned values
+            req = mapping._populate_path([req], new.device, keys=keys)
+            rs = [R(requirement) for requirement in req]
+
+            # want to print one by one
+            for rs_item in rs:
+                ret = find([new], rs_item, filter_=False, all_keys=True)
+                if not ret:
+                    # return rs_item.args
+                    raise ValueError("'{req}' does not exists in "
+                                    "'{o}'".format(req=rs_item.args, o=new))
+
+            # Let's modify the ops value to be equal to the original
+            # snapshot. This will allow for comparing the other keys
+            for require in req:
+                try:
+                    _modify_ops_snapshot(original=original,
+                                         current=new, path=require)
+                except Exception as e:
+                    return
+
+    diff = Diff(original, new, exclude= (exclude or []) + ['maker', 'callables', 'device', 'diff_ignore'])
+    diff.findDiff()
+    if diff.diffs:
+        log.error("Current ops is not equal to the initial Snapshot "
+                  "taken on device {d}.\n{e}".format(e=str(diff),
+                                                    d=getattr(new, 'device', 'name')))
+        raise AssertionError("Current ops is not equal to the initial Snapshot "
+                        "taken on device {d}.\n{e}".format(e=str(diff),
+                                                          d=getattr(new, 'device', 'name')))
+
+
+def get_duplicated_interface_ip(ops):
+    '''Get interface A which has ipv4 address, and find another interface B'''
+    # initial return values
+    duplicated_ip = None
+    duplicated_iprefix_length = None
+    ip_intf = None
+    duplicated_intf = None
+    network_addr = None
+
+    intfs = list(ops.info.keys())
+    # find any 'up' interface
+    for intf in ops.info:
+        for ipv4, item in ops.info[intf].get('ipv4', {}).items():
+            # choose one different interfaces
+            diff_intfs = intfs.copy()
+            diff_intfs.remove(intf)
+            if not diff_intfs:
+                # no diff_intf found, find the next item
+                continue
+
+            # store the ip and interface lists for next section
+            duplicated_ip = item['ip']
+            duplicated_iprefix_length = item['prefix_length']
+
+            if duplicated_iprefix_length == '32':
+                # looks for loopback interfaces
+                duplicated_intfs = [i for i in diff_intfs if 'Loopback' in i]
+                if not duplicated_intfs:
+                    continue
+            else:
+                # choose one non-loopback interface
+                duplicated_intfs = [i for i in diff_intfs if 'Loopback' not in i]
+                if not duplicated_intfs:
+                    continue
+
+            # get interface from same vrf
+            for interface in duplicated_intfs:
+                try:
+                    assert ops.info[intf].get('vrf') == ops.info[interface].get('vrf')
+                except Exception:
+                    continue
+                else:
+                    duplicated_intf = interface
+                    break
+
+            # store interface to accurate the error message
+            ip_intf = intf
+            # store network address to accurate the error message
+            network_addr = IPv4Network(ipv4, False).network_address
+            # print out the message
+            log.info(banner("The ip address {ip} is collected from {o_intf}".format(
+                        ip=ipv4, o_intf=intf), align='left'))
+        if duplicated_intf:
+            break
+
+    # return the values
+    return duplicated_ip, duplicated_iprefix_length, ip_intf, duplicated_intf, network_addr
+
+def get_ospf_router_id(ops):
+    '''Get OSPF router-id from ospf ops'''
+    # Create R object to contain the required interface ops attributes path
+    # find router_id
+    rs_rd_helper = R(['info', 'vrf', '(?P<vrf>.*)', 'address_family', '(?P<af>.*)',
+                      'instance', '(?P<instance>.*)', 'router_id', '(?P<router_id>.*)'])
+
+    # use find object to find required interfaces and ip address
+    # returned value is like
+    # [('10.2.2.2', ['info', 'vrf', 'default', 'address_family', 'ipv4', 'instance', '1', 'router_id'])]
+    ret_rd_helper = find([ops], rs_rd_helper, filter_=False)
+
+    if not ret_rd_helper:
+        return None
+
+    # call function to get dict of {key: value}
+    ret = GroupKeys.group_keys(ret_num={}, source=ret_rd_helper,
+                               reqs=rs_rd_helper.args)
+    # return the values
+    return ret
+
+def get_ospf_interfaces_with_neighbor(ops, neighbor):
+    '''Get OSPF interfaces by given neighbor'''
+    
+    # find the neighbors on uut connected to the helper device
+    reqs = [['info', 'vrf', '(?P<vrf>.*)', 'address_family', '(?P<af>.*)',
+            'instance', '(?P<instance>.*)', 'areas', '(?P<areas>.*)', 'interfaces',
+            '(?P<interfaces>.*)', 'neighbors', neighbor, '(?P<neighbors_info>.*)']]
+    rs_uut = [R(i) for i in reqs]
+    ret_uut = find([ops], *rs_uut, filter_=False)
+
+    return GroupKeys.group_keys(ret_num={}, source=ret_uut, reqs=reqs)
+
+def get_ospf_interfaces(ops):
+    '''Get OSPF interfaces by given neighbor'''
+    
+    # Create R object to contain the required interface ops attributes path
+    # find any ospf 'up' interface
+    reqs = [['info', 'vrf', '(?P<vrf>.*)', 'address_family', '(?P<af>.*)',
+            'instance', '(?P<instance>.*)', 'areas', '(?P<areas>.*)', 'interfaces',
+            '(?P<interfaces>.*)','state', '(?P<state>(dr|bdr|dr_other|point_to_point))'],
+            ['info', 'vrf', '(?P<vrf>.*)', 'address_family', '(?P<af>.*)',
+             'instance', '(?P<instance>.*)', 'areas', '(?P<areas>.*)', 'interfaces',
+             '(?P<interfaces>.*)', 'cost', '(?P<cost>.*)']]
+
+    rs = [R(i) for i in reqs]
+    ret = find([ops], *rs, filter_=False, all_keys=True)
+
+    return GroupKeys.group_keys(ret_num={}, source=ret, reqs=reqs, all_keys=True)
+
+def get_ready_rps_lcs(ops):
+    '''Get ready RPs/LCs from platform ops'''
+    
+    reqs = [['slot', 'rp', '(?P<rp>.*)',
+             'state', '(?P<state>ok, active|ok, standby|Ready)'],
+            # ['slot', 'lc', '(?P<lc>.*)','state', 'ok'],
+            ['slot', 'oc', '(?P<oc>.*)', 'state',
+             '(?P<oc_state>ok, active|ok, standby|ok|ps, fail)']]
+
+    rs = [R(i) for i in reqs]
+    ret = find([ops], *rs, filter_=False, all_keys=True)
+    return GroupKeys.group_keys(ret_num={}, source=ret,
+                                reqs=reqs, all_keys=True)
+
+def check_regexp_uptime(log_output, expect_uptime, pre_time, tolerance=0.5):
+    '''Get the uptime by given regexp from the routers show logging, 
+    and compare them with the given expected uptime.'''
+
+    # create table info for Neighbors
+    log.info(banner('Calculate Method for "tolerance check" is below:\n'
+        '|a - b| <= 0.5 * (a + b) * tolerance'))
+
+    # create table headers
+    table = ptable(['log pattern', 'expected time', 'actual time', 'tolerance check', 'result'])
+
+    # initial
+    flag = True
+
+    # check feature uptime
+    # setup the regexp pattern
+    p = r'.+ +(?P<uptime>\d+\:\d+\:\d+).\d+.+{}.+'
+
+    for item in (expect_uptime or []):
+        for regexp, expect_up in item.items():
+
+            # *Dec  6 11:51:37.043: %OSPF-5-ADJCHG: Process 1, Nbr 10.2.2.2 on GigabitEthernet3 from LOADING to FULL, Loading Done
+            pattern = re.compile(p.format(regexp))
+
+            # find all the matched value
+            uptimes = pattern.findall(log_output)
+
+            # find the lastest one
+            try:
+                assert uptimes
+            except AssertionError:
+                step.failed('Cannot find log message for {}'.format(regexp))
+            else:
+                latest_uptime = list(uptimes)[-1]
+
+            # calculate the time slot it takes to reach ready
+            start = pre_time.split(':')
+            start = int(start[0]) * 3600 + int(start[1]) * 60 + int(start[2])
+            end = latest_uptime.split(':')
+            end = int(end[0]) * 3600 + int(end[1]) * 60 + int(end[2])
+
+            # get real uptime
+            time_consume = end - start
+            
+            # calculate the Equation left and right sides
+            equal_left = abs(time_consume - expect_up)
+            equal_right = 0.5 * tolerance * (time_consume + expect_up)
+
+            # check uptime
+            try:
+                # calculate to see if the real time consuming is clased to the expect number
+                assert equal_left <= equal_right
+            except Exception:
+                flag = False
+                table.add_row([regexp, expect_up, time_consume, '{} <= {}'.format(equal_left, equal_right), 'Failed' ] )
+            else:
+                table.add_row([regexp, expect_up, time_consume, '{} <= {}'.format(equal_left, equal_right), 'Passed' ]  )
+
+    table_str = table.get_string()
+    log.info('\n{}'.format(banner('Overall Information', width=len(table._hrule))))
+    log.info(table_str)
+
+    if not flag:
+      raise Exception('Not all the regexps uptime are closed to the ones given from trigger yaml file. \n'
+        'Please refer the table to see if anything needs to be adjusted from trigger yaml file')
```

## genie/libs/sdk/libs/utils/mapping.py

```diff
@@ -75,14 +75,19 @@
         # Default is  False - Dont learn, and as soon we see a regex, changed
         # to True
         self._static_learn = False
 
         # Check if parent has static key from trigger datafile
         # Remove device name at the end
         name = self.parent.uid.rsplit('.', 1)[0]
+        if not hasattr(self.parent.parent, 'triggers'):
+            self._static_learn = True
+            self._static = False
+            return
+
         if name not in self.parent.parent.triggers:
             # Weird corner case
             raise Exception("'{name}' is not defined in the Trigger"
                             "datafile".format(name=name))
 
         data = self.parent.parent.triggers[name]
         if 'static' not in data:
@@ -558,14 +563,31 @@
         return current_ops
 
     def _verify_find(self, ops, requirements, missing=False, all_keys=False,
                      **kwargs):
         '''Verify the ops response to the requirements'''
         if not requirements:
             return
+
+        # check if requires the output is empty
+        # this function only take one requirement at a time, so safe to do
+        # len(requirements[0])
+        # when the requirements is like below:
+        # verify_ops={ \
+        #     'conf.vxlan.Vxlan': {
+        #         'requirements': [ \
+        #             [NotExists('device_attr')]]}},
+        # verify_ops={ \
+        #     'ops.vxlan.vxlan.Vxlan': {
+        #         'requirements': [ \
+        #             [NotExists('nve')]]}},
+        if len(requirements[0]) == 1 and isinstance(requirements[0][0], NotExists) and \
+           not getattr(ops, requirements[0][0].value, {}):
+            return
+
         rs = [R(requirement) for requirement in requirements]
         ret = find([ops], *rs, filter_=False, all_keys=all_keys)
         # If missing is True, then we expect it to be missing, aka ret empty
         if not ret and not missing:
             raise Exception("'{req}' does not exists in "
                             "'{o}'".format(req=requirements, o=ops))
         if ret and missing:
@@ -609,23 +631,23 @@
 
         # Alright now compare
         if obj_mod in self._ops_ret:
             # add handle for modify_exclude and exclude
             exclude = self._populate_exclude(org_req['exclude'])
 
             diff = Diff(self._ops_ret[obj_mod], ops,
-                        exclude=exclude + ['callables'])
+                        exclude=exclude + ['callables', 'maker'])
             diff.findDiff()
 
             if str(diff):
                 raise Exception("The output is not same with diff\n{}"
                                 .format(str(diff)))
 
     def _verify_same(self, ops, initial, exclude, **kwargs):
-        diff = Diff(initial, ops, exclude=exclude + ['callables'])
+        diff = Diff(initial, ops, exclude=exclude + ['callables', 'maker'])
         diff.findDiff()
         if diff.diffs:
             raise Exception("Current ops is not equal to the initial Snapshot "
                             "taken\n{e}".format(e=str(diff)))
 
     def _populate_exclude(self, exclude):
         kwargs = defaultdict(list)
@@ -692,15 +714,30 @@
                     if callable(item[0]):
                         reqs['callable'].append(item)
                     elif isinstance(item[0], str):
                         reqs['list'].append(item)
 
                 # Instantiate the abstracted Ops object
                 kwargs = self._populate_kwargs(device, requirements)
-                reqs['list'] = self._populate_path(reqs['list'], device, self.keys)
+                # Check if the requriements are required empty output
+                # like below, if it is, do not popluate the path
+                # verify_ops={ \
+                #     'conf.vxlan.Vxlan': {
+                #         'requirements': [ \
+                #             [NotExists('device_attr')]]}},
+                # verify_ops={ \
+                #     'ops.vxlan.vxlan.Vxlan': {
+                #         'requirements': [ \
+                #             [NotExists('nve')]]}},
+                if len(requirements.get('requirements', [])) == 1 and \
+                   len(requirements.get('requirements', [[None]])[0]) == 1 and\
+                   not isinstance(requirements.get('requirements', [[None]])[0][0], functools.partial):
+                    reqs['list'] = requirements.get('requirements', [])
+                else:
+                    reqs['list'] = self._populate_path(reqs['list'], device, self.keys)
 
                 msg = '\n'.join([str(re) for re in reqs['list']])
                 log.info("Verifying the following requirements "
                          "are {condition}\n{rs}".format(rs=msg,
                             condition='not presented' if missing else 'satisfied'))
 
                 if not kwargs:
@@ -763,50 +800,60 @@
         except Exception as e:
             raise Exception("Could not verify the configuration was "
                             "applied correctly as per the exception: "
                             "{e}".format(e=e))
 
     def _verify_ops(self, device, o, reqs, missing, ops, requirements):
 
+        # verify callable if requirements path
+        # contains customized verify functions
+        if reqs.get('callable', None):
+            for item in reqs['callable']:
+                try:
+                    o.learn_poll(verify=item[0].func,
+                                 mapping=self, local_reqs=reqs,
+                                 timeout=self.timeout, **item[0].keywords)
+                except Exception as e:
+                    raise e
+
         # verify the ops paths values
         try:
             o.learn_poll(verify=self._verify_finds_ops,
                          requirements=reqs['list'],
                          timeout=self.timeout,
                          missing=missing,
                          obj_mod=ops,
                          org_req=requirements)
             # add to self to provide access for parent 
             # that can get information from the learned ops object
             self.verify_ops_object = o
         except Exception as e:
             raise e
 
-        # verify callable if requirements path
-        # contains customized verify functions
-        if reqs.get('callable', None):
-            for item in reqs['callable']:
-                try:
-                    o.learn_poll(verify=item[0].func,
-                                 timeout=self.timeout, **item[0].keywords)
-                except Exception as e:
-                    raise e
-
     def _modify_ops_snapshot(self, original, current, path, obj=None):
         # Handling the case of 'NotExists' in the trigger prerequisites
         required_key = ''
         if obj:
             compiled_line = re.compile(r'NotExists\(\'(?P<required_key>[\w]+)\'\)')
             for req in self.requirements[obj]['requirements']:
                 for key in req:
                     matched = compiled_line.match(str(key))
                     if matched:
                         required_key = str(matched.groupdict()['required_key'])
 
-        # First does path exists in original, except the value
+        # When output is empty, modify the current ops to the same as original
+        # since it already passed the testing empty step,
+        # can pass the diff check between ops
+        if len(path) == 1 and isinstance(path[0], NotExists):
+            try:
+                setattr(current,  path[0].value, getattr(original, path[0].value, None))
+            except Exception:
+                pass
+            return
+
         r = R(path[:-1] + ['(.*)'])
         ret = find([original], r, filter_=False)
         if not ret:
             if not required_key:
                 raise Exception("'{p}' does not exist on original "
                                 "snapshot".format(p=path))
             else:
@@ -873,35 +920,36 @@
                             loc.append(device.name)
                         else:
                             loc.append(item)
                         continue
 
                     if isinstance(item, Operator):
                         if not isinstance(item.value, str):
-                            loc.append(item.value)
+                            loc.append(item)
                             continue
                         if item.value == '{uut}':
                             loc.append(device.name)
                             continue
                         if item.regex and item.value.startswith('(?P<'):
                             # Get the variable name
                             var = list(item.regex.groupindex)[0]
                             # Does var exists in key?
                             if var not in key:
                                 # So key does not exists
                                 # just keep doing with this as a value
-                                loc.append(item.value)
+                                loc.append(item)
                             else:
                                 # This mean var is in key
                                 vkeys = key[var]
                                 if not item == str(vkeys):
                                     break
-                                loc.append(vkeys)
+                                item.value = vkeys
+                                loc.append(item)
                             continue
-                        loc.append(item.value)
+                        loc.append(item)
                         continue
 
                     # TODO: Make this..more unique
                     if callable(item):
                         # This try is for avoiding populate_path for
                         # _requirtment_printer when conf object has
                         # callable
```

## genie/libs/sdk/libs/utils/triggeractions.py

```diff
@@ -273,15 +273,14 @@
                       '<=': counter <= threshold_counter,
                       '>=': counter >= threshold_counter}[relation]
             if not result:
                 raise Exception('Fail - {n}: {t}s is not {r} {tt}s'
                                 .format(n=items[1][1:],
                   r=relation, t=counter, tt=threshold_counter))
 
-
 def configure_add_attributes(add_obj, base, add_attribute, add_method, **kwargs):
 
     # initial configuration attributes
     attrs = {}
 
     # populate base and add_attribute
     # loop for mapping.keys due to base and add_attribute
@@ -308,7 +307,43 @@
         attrs.update(Configure._build_attribute(base_paths))
 
     # apply configurations on devices
     if kwargs['unconfig']:
         kwargs['conf_obj'].build_unconfig(attributes=attrs)
     else:
         kwargs['conf_obj'].build_config(attributes=attrs)
+
+def verify_ops_or_logic(ops, **kwargs):
+
+    origin_req = []
+
+    if not kwargs.get('mapping'):
+        return
+
+    # poluate the path
+    reqs = kwargs['mapping']._populate_path(
+             kwargs.get('requires', []), ops.device, keys=kwargs['mapping'].keys)
+
+    # print out message
+    log.info('Check if output match any of following requirements\n{}'\
+        .format('\n'.join([str(re) for re in reqs])))
+
+    # check if one of the requires suite for the ops output
+    for req in kwargs.get('requires', []):
+        # find if requirement matches for current ops
+        req = kwargs['mapping']._populate_path(
+             [req], ops.device, keys=kwargs['mapping'].keys)
+        rs = [R(i) for i in req]
+        ret = find([ops], *rs, filter_=False, all_keys=True)
+        if not ret:
+            log.info('Not found requirement:\n{}'
+            .format(req))
+            continue
+        # update the requires in mapping object to
+        # modify the original ops with right requirement
+        origin_req = kwargs['local_reqs']['list']
+        origin_req.extend(req)
+        log.info('Found the requirement:\n{}'.format(req))
+        break
+    else:
+        raise Exception('Failed to find match for any of following requirements\n{}'
+            .format('\n'.join([str(re) for re in reqs])))
```

## genie/libs/sdk/triggers/addremove/acl/iosxe/addremove.py

```diff
@@ -54,15 +54,23 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iterations when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+
+               (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                     OR
+                     interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn acl Ops object and store the acls info if has any.
            Learn Interface ops object to select one trunk interface to add mac acl
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of acl with acl Conf object
         4. Verify the acl from step 3 has configured
         5. Remove the acl configurations.
@@ -73,17 +81,17 @@
     ADD_ACL_NAME = 'etherent_mac_acl_add'
 
 
     mapping = Mapping(requirements={'ops.acl.acl.Acl':{
                                             'requirements':[['info', 'acls', NotExists(ADD_ACL_NAME)]],
                                             'exclude': acl_exclude},
                                     'ops.interface.interface.Interface':{
-                                            'requirements':[['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                            'requirements':[['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                              'switchport_mode', 'trunk'],
-                                                            ['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                                            ['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                              'oper_status', 'up']],
                                             'exclude': interface_exclude,
                                             'kwargs': {'attributes': ['info[(.*)][switchport_mode]',
                                                                       'info[(.*)][oper_status]']}}},
                       config_info={'conf.acl.Acl':{
                                       'requirements':[['device_attr', '{uut}',
                                                        'acl_attr', ADD_ACL_NAME,
@@ -98,15 +106,15 @@
                                                        'src', 'host 0011.2233.1111'],
                                                       ['device_attr', '{uut}',
                                                        'acl_attr', ADD_ACL_NAME,
                                                        'ace_attr', '10',
                                                        'dst', 'host 0011.2233.2222'],
                                                       ['device_attr', '{uut}',
                                                        'acl_attr', ADD_ACL_NAME,
-                                                       'interface_attr', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                                       'interface_attr', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                        'if_in', True]],
                                       'verify_conf':False,
                                       'kwargs':{}}},
                       verify_ops={'ops.acl.acl.Acl':{
                                       'requirements': [['info', 'acls', ADD_ACL_NAME, 'name', ADD_ACL_NAME],
                                                        ['info', 'acls', ADD_ACL_NAME, 'type', 'eth-acl-type'],
                                                        ['info', 'acls', ADD_ACL_NAME, 'aces', '10', 'name', '10'],
@@ -117,22 +125,22 @@
                                                        ['info', 'acls', ADD_ACL_NAME, 'aces', '10', 'actions',
                                                         'logging', 'log-none'],
                                                        ['info', 'acls', ADD_ACL_NAME, 'aces', '10', 'actions',
                                                         'forwarding', 'permit']],
                                       'kwargs':{'attributes':['info']},
                                       'exclude': acl_exclude},
                                   'ops.interface.interface.Interface':{
-                                          'requirements':[['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                          'requirements':[['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                            'switchport_mode', 'trunk'],
-                                                          ['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                                          ['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                            'oper_status', 'up']],
                                             'kwargs': {'attributes': ['info[(.*)][switchport_mode]',
                                                                       'info[(.*)][oper_status]']},
                                           'exclude': interface_exclude}},
-                      num_values={'intf':1})
+                      num_values={'interface':1})
 
 
 class TriggerAddRemoveEthernetIpAclPermit(TriggerAddRemove):
     """Apply the IP acls with L2 ports which is Ethernet interfaces to device, and remove the
     added IP acls.
     """
 
@@ -162,15 +170,23 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iterations when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+
+               (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                     OR
+                     interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn acl Ops object and store the acls info if has any.
            Learn Interface ops object to select one trunk interface to add mac acl
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of acl with acl Conf object
         4. Verify the acl from step 3 has configured
         5. Remove the acl configurations.
@@ -181,17 +197,17 @@
     ADD_ACL_NAME = 'ethernet_ip_acl_permit_add'
     ACTION = 'permit'
 
     mapping = Mapping(requirements={'ops.acl.acl.Acl':{
                                             'requirements':[['info', 'acls', NotExists(ADD_ACL_NAME)]],
                                             'exclude': acl_exclude},
                                     'ops.interface.interface.Interface':{
-                                            'requirements':[['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                            'requirements':[['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                              'switchport_mode', 'trunk'],
-                                                            ['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                                            ['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                              'oper_status', 'up']],
                                             'kwargs': {'attributes': ['info[(.*)][switchport_mode]',
                                                                       'info[(.*)][oper_status]']},
                                             'exclude': interface_exclude}},
                       config_info={'conf.acl.Acl':{
                                       'requirements':[['device_attr', '{uut}',
                                                        'acl_attr', ADD_ACL_NAME,
@@ -210,37 +226,37 @@
                                                        'src', 'any'],
                                                       ['device_attr', '{uut}',
                                                        'acl_attr', ADD_ACL_NAME,
                                                        'ace_attr', '10',
                                                        'dst', 'any'],
                                                       ['device_attr', '{uut}',
                                                        'acl_attr', ADD_ACL_NAME,
-                                                       'interface_attr', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                                       'interface_attr', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                        'if_in', True]],
                                       'verify_conf':False,
                                       'kwargs':{}}},
                       verify_ops={'ops.acl.acl.Acl':{
                                       'requirements': [['info', 'acls', ADD_ACL_NAME, 'name', ADD_ACL_NAME],
                                                        ['info', 'acls', ADD_ACL_NAME, 'type', 'ipv4-acl-type'],
                                                        ['info', 'acls', ADD_ACL_NAME, 'aces', '10', 'name', '10'],
                                                        ['info', 'acls', ADD_ACL_NAME, 'aces', '10', 'actions',
                                                         'logging', 'log-none'],
                                                        ['info', 'acls', ADD_ACL_NAME, 'aces', '10', 'actions',
                                                         'forwarding', ACTION]],
                                       'kwargs':{'attributes':['info']},
                                       'exclude': acl_exclude},
                                   'ops.interface.interface.Interface':{
-                                          'requirements':[['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                          'requirements':[['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                            'switchport_mode', 'trunk'],
-                                                          ['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                                          ['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                            'oper_status', 'up']],
                                           'kwargs': {'attributes': ['info[(.*)][switchport_mode]',
                                                                       'info[(.*)][oper_status]']},
                                           'exclude': interface_exclude}},
-                      num_values={'intf':1})
+                      num_values={'interface':1})
 
 
 class TriggerAddRemoveEthernetIpAclDeny(TriggerAddRemove):
     """Apply the IP acls with L2 ports which is Ethernet interfaces to device, and remove the
     added IP acls.
     """
 
@@ -270,15 +286,23 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iterations when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+
+               (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                     OR
+                     interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn acl Ops object and store the acls info if has any.
            Learn Interface ops object to select one trunk interface to add mac acl
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of acl with acl Conf object
         4. Verify the acl from step 3 has configured
         5. Remove the acl configurations.
@@ -289,17 +313,17 @@
     ADD_ACL_NAME = 'ethernet_ip_acl_deny_add'
     ACTION = 'deny'
 
     mapping = Mapping(requirements={'ops.acl.acl.Acl':{
                                             'requirements':[['info', 'acls', NotExists(ADD_ACL_NAME)]],
                                             'exclude': acl_exclude},
                                     'ops.interface.interface.Interface':{
-                                            'requirements':[['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                            'requirements':[['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                              'switchport_mode', 'trunk'],
-                                                            ['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                                            ['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                              'oper_status', 'up']],
                                             'kwargs': {'attributes': ['info[(.*)][switchport_mode]',
                                                                       'info[(.*)][oper_status]']},
                                             'exclude': interface_exclude}},
                       config_info={'conf.acl.Acl':{
                                       'requirements':[['device_attr', '{uut}',
                                                        'acl_attr', ADD_ACL_NAME,
@@ -318,37 +342,37 @@
                                                        'src', 'any'],
                                                       ['device_attr', '{uut}',
                                                        'acl_attr', ADD_ACL_NAME,
                                                        'ace_attr', '10',
                                                        'dst', 'any'],
                                                       ['device_attr', '{uut}',
                                                        'acl_attr', ADD_ACL_NAME,
-                                                       'interface_attr', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                                       'interface_attr', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                        'if_in', True]],
                                       'verify_conf':False,
                                       'kwargs':{}}},
                       verify_ops={'ops.acl.acl.Acl':{
                                       'requirements': [['info', 'acls', ADD_ACL_NAME, 'name', ADD_ACL_NAME],
                                                        ['info', 'acls', ADD_ACL_NAME, 'type', 'ipv4-acl-type'],
                                                        ['info', 'acls', ADD_ACL_NAME, 'aces', '10', 'name', '10'],
                                                        ['info', 'acls', ADD_ACL_NAME, 'aces', '10', 'actions',
                                                         'logging', 'log-none'],
                                                        ['info', 'acls', ADD_ACL_NAME, 'aces', '10', 'actions',
                                                         'forwarding', ACTION]],
                                       'kwargs':{'attributes':['info']},
                                       'exclude': acl_exclude},
                                   'ops.interface.interface.Interface':{
-                                          'requirements':[['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                          'requirements':[['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                            'switchport_mode', 'trunk'],
-                                                          ['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                                          ['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                            'oper_status', 'up']],
                                           'kwargs': {'attributes': ['info[(.*)][switchport_mode]',
                                                                       'info[(.*)][oper_status]']},
                                           'exclude': interface_exclude}},
-                      num_values={'intf':1})
+                      num_values={'interface':1})
 
 
 
 class TriggerAddRemoveVlanIpAclPermit(TriggerAddRemove):
     """Apply the IP acls with L2 ports which is Vlan interfaces to device, and remove the
     added IP acls.
     """
```

## genie/libs/sdk/triggers/addremove/bgp/addremove.py

```diff
@@ -58,15 +58,30 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iterations when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                address_family: `str`
+                neighbor: `str`
+                policy_definition: `str`
+                statements: `str`
+                bgp_id: `int`
+                bgp_table_version: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn BGP Ops object and store the BGP neighbor(s) if has any,
            otherwise, SKIP the trigger. Learn RoutePolicy Ops object
            to store the route-map name with prefix-list configured if has any,
            otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of the inbound route-map (step 1) to learned
@@ -75,15 +90,15 @@
         5. Remove the route-map (step 1) configurations from the learned
            BGP neighbor(s) from step 1
         6. Recover the device configurations to the one in step 2
         7. Learn BGP Ops again and verify it is the same as the Ops in step 1
 
     """
     mapping = Mapping(requirements={'ops.route_policy.route_policy.RoutePolicy':{
-                                            'requirements':[['info', '(?P<info>.*)',
+                                            'requirements':[['info', '(?P<policy_definition>.*)',
                                                              'statements', '(?P<statements>.*)',
                                                              'conditions',
                                                              'match_prefix_list', '(?P<match_prefix_list>.*)']],
                                             'exclude': route_map_exclude},
                                         'ops.bgp.bgp.Bgp':{
                                             'requirements':[['info', 'instance', '(?P<instance>.*)',
                                                              'vrf', '(?P<vrf>.*)',
@@ -95,26 +110,26 @@
                                             'kwargs':{'attributes':['info']},
                                             'exclude': bgp_exclude}},
                       config_info={'conf.bgp.Bgp':{
                                       'requirements':[['device_attr', '{uut}',
                                                        'vrf_attr', '(?P<vrf>.*)',
                                                        'neighbor_attr','(?P<neighbor>.*)',
                                                        'address_family_attr', '(?P<address_family>.*)',
-                                                       'nbr_af_route_map_name_in', '(?P<info>.*)']],
+                                                       'nbr_af_route_map_name_in', '(?P<policy_definition>.*)']],
                                       'verify_conf':False,
                                       'kwargs':{'mandatory':{'bgp_id': '(?P<bgp_id>.*)'}}}},
                       verify_ops={'ops.bgp.bgp.Bgp':{
                                       'requirements': [['info', 'instance', '(?P<instance>.*)',
                                                         'vrf', '(?P<vrf>.*)',
                                                         'neighbor', '(?P<neighbor>.*)',
                                                         'address_family', '(?P<address_family>.*)',
-                                                        'route_map_name_in', '(?P<info>.*)']],
+                                                        'route_map_name_in', '(?P<policy_definition>.*)']],
                                       'kwargs':{'attributes':['info']},
                                       'exclude': bgp_exclude}},
-                      num_values={'info':1, 'statements':'all', 'match_prefix_list':1, 'instance':1, 'vrf':1, 'address_family':1, 'neighbor':1, 'bgp_id':1, 'bgp_table_version':1})
+                      num_values={'policy_definition':1, 'statements':'all', 'match_prefix_list':1, 'instance':1, 'vrf':1, 'address_family':1, 'neighbor':1, 'bgp_id':1, 'bgp_table_version':1})
 
 
 class TriggerAddRemoveBgpNeighborRoutemapWeight(TriggerAddRemove):
     """Apply the inbound dynamically learned "weight" route-map
     to the dynamically learned BGP neighbor(s), and remove the
     added route-map configurations.
     """
@@ -146,15 +161,31 @@
                 Buffer recovery timeout when the previous timeout has been exhausted,
                 to make sure the devices are recovered before ending the trigger
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iterations when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                address_family: `str`
+                neighbor: `str`
+                policy_definition: `str`
+                statements: `str`
+                set_weight: `int`
+                bgp_id: `int`
+                bgp_table_version: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn BGP Ops object and store the BGP neighbor(s) if has any,
            otherwise, SKIP the trigger. Learn RoutePolicy Ops object
            to store the route-map name with weight configured if has any,
            otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of the inbound route-map (step 1) to learned
@@ -163,15 +194,15 @@
         5. Remove the route-map (step 1) configurations from the learned BGP
            neighbor(s) from step 1
         6. Recover the device configurations to the one in step 2
         7. Learn BGP Ops again and verify it is the same as the Ops in step 1
 
     """
     mapping = Mapping(requirements={'ops.route_policy.route_policy.RoutePolicy':{
-                                            'requirements':[['info', '(?P<info>.*)',
+                                            'requirements':[['info', '(?P<policy_definition>.*)',
                                                              'statements', '(?P<statements>.*)',
                                                              'actions',
                                                              'set_weight', '(?P<set_weight>.*)']],
                                             'exclude': route_map_exclude},
                                         'ops.bgp.bgp.Bgp':{
                                             'requirements':[['info', 'instance', '(?P<instance>.*)',
                                                              'vrf', '(?P<vrf>.*)',
@@ -183,20 +214,20 @@
                                             'kwargs':{'attributes':['info']},
                                             'exclude': bgp_exclude}},
                       config_info={'conf.bgp.Bgp':{
                                       'requirements':[['device_attr', '{uut}',
                                                        'vrf_attr', '(?P<vrf>.*)',
                                                        'neighbor_attr','(?P<neighbor>.*)',
                                                        'address_family_attr', '(?P<address_family>.*)',
-                                                       'nbr_af_route_map_name_in', '(?P<info>.*)']],
+                                                       'nbr_af_route_map_name_in', '(?P<policy_definition>.*)']],
                                       'verify_conf':False,
                                       'kwargs':{'mandatory':{'bgp_id': '(?P<bgp_id>.*)'}}}},
                       verify_ops={'ops.bgp.bgp.Bgp':{
                                       'requirements': [['info', 'instance', '(?P<instance>.*)',
                                                         'vrf', '(?P<vrf>.*)',
                                                         'neighbor', '(?P<neighbor>.*)',
                                                         'address_family', '(?P<address_family>.*)',
-                                                        'route_map_name_in', '(?P<info>.*)']],
+                                                        'route_map_name_in', '(?P<policy_definition>.*)']],
                                       'kwargs':{'attributes':['info']},
                                       'exclude': bgp_exclude}},
-                      num_values={'info':1, 'statements':'all', 'set_weight':1, 'instance':1, 'vrf':1, 'address_family':1, 'neighbor':1, 'bgp_id':1, 'bgp_table_version':1})
+                      num_values={'policy_definition':1, 'statements':'all', 'set_weight':1, 'instance':1, 'vrf':1, 'address_family':1, 'neighbor':1, 'bgp_id':1, 'bgp_table_version':1})
```

## genie/libs/sdk/triggers/addremove/bgp/nxos/addremove.py

```diff
@@ -84,15 +84,26 @@
                 Buffer recovery timeout make sure devices are recovered at the
                 end of the trigger execution. Used when previous timeouts have
                 been exhausted.
                 max_time (`int`): Maximum wait time for the last step of the 
                                   trigger in seconds. Default: 180
                 interval (`int`): Wait time between iteration when looping is 
                                   needed in seconds. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                bgp_id: 'int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     Steps:
         1. Learn BGP Ops configured on device. SKIP the trigger if there
            is no BGP configured on the device.
         2. Save the current device configurations using "method" specified.
         3. Add update source configuration under BGP neighbor of BGP  pid 
            learned in step 1 using Genie BGP Conf.
         4. Verify the newly added update source config under BGP neighbor is 
@@ -165,15 +176,26 @@
                 Buffer recovery timeout make sure devices are recovered at the
                 end of the trigger execution. Used when previous timeouts have
                 been exhausted.
                 max_time (`int`): Maximum wait time for the last step of the 
                                   trigger in seconds. Default: 180
                 interval (`int`): Wait time between iteration when looping is 
                                   needed in seconds. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     Steps:
         1. Learn BGP Ops configured on device. SKIP the trigger if there
            is no BGP configured on the device.
         2. Save the current device configurations using "method" specified.
         3. Add description configuration under BGP neighbor of BGP  pid 
            learned in step 1 using Genie BGP Conf.
         4. Verify the newly added description config under BGP neighbor is 
@@ -240,15 +262,26 @@
                 Buffer recovery timeout make sure devices are recovered at the
                 end of the trigger execution. Used when previous timeouts have
                 been exhausted.
                 max_time (`int`): Maximum wait time for the last step of the 
                                   trigger in seconds. Default: 180
                 interval (`int`): Wait time between iteration when looping is 
                                   needed in seconds. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     Steps:
         1. Learn BGP Ops configured on device. SKIP the trigger if there
            is no BGP configured on the device.
         2. Save the current device configurations using "method" specified.
         3. Add connected-check configuration under BGP neighbor of BGP  pid 
            learned in step 1 using Genie BGP Conf.
         4. Verify the newly added connected-check config under BGP neighbor is 
@@ -316,15 +349,26 @@
                 Buffer recovery timeout make sure devices are recovered at the
                 end of the trigger execution. Used when previous timeouts have
                 been exhausted.
                 max_time (`int`): Maximum wait time for the last step of the 
                                   trigger in seconds. Default: 180
                 interval (`int`): Wait time between iteration when looping is 
                                   needed in seconds. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     Steps:
         1. Learn BGP Ops configured on device. SKIP the trigger if there
            is no BGP configured on the device.
         2. Save the current device configurations using "method" specified.
         3. Add bfd configuration under BGP neighbor of BGP  pid 
            learned in step 1 using Genie BGP Conf.
         4. Verify the newly added bfd config under BGP neighbor is 
@@ -390,15 +434,26 @@
                 Buffer recovery timeout make sure devices are recovered at the
                 end of the trigger execution. Used when previous timeouts have
                 been exhausted.
                 max_time (`int`): Maximum wait time for the last step of the 
                                   trigger in seconds. Default: 180
                 interval (`int`): Wait time between iteration when looping is 
                                   needed in seconds. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     Steps:
         1. Learn BGP Ops configured on device. SKIP the trigger if there
            is no BGP configured on the device.
         2. Save the current device configurations using "method" specified.
         3. Add maximum-prefix configuration under BGP neighbor of BGP  pid 
            learned in step 1 using Genie BGP Conf.
         4. Verify the newly added maximum-prefix config under BGP neighbor is 
@@ -465,15 +520,26 @@
                 Buffer recovery timeout make sure devices are recovered at the
                 end of the trigger execution. Used when previous timeouts have
                 been exhausted.
                 max_time (`int`): Maximum wait time for the last step of the 
                                   trigger in seconds. Default: 180
                 interval (`int`): Wait time between iteration when looping is 
                                   needed in seconds. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     Steps:
         1. Learn BGP Ops configured on device. SKIP the trigger if there
            is no BGP configured on the device.
         2. Save the current device configurations using "method" specified.
         3. Add next-hop self configuration under BGP neighbor of BGP  pid 
            learned in step 1 using Genie BGP Conf.
         4. Verify the newly added next-hop self config under BGP neighbor is 
@@ -540,15 +606,26 @@
                 Buffer recovery timeout make sure devices are recovered at the
                 end of the trigger execution. Used when previous timeouts have
                 been exhausted.
                 max_time (`int`): Maximum wait time for the last step of the 
                                   trigger in seconds. Default: 180
                 interval (`int`): Wait time between iteration when looping is 
                                   needed in seconds. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     Steps:
         1. Learn BGP Ops configured on device. SKIP the trigger if there
            is no BGP configured on the device.
         2. Save the current device configurations using "method" specified.
         3. Add default originate configuration under BGP neighbor of BGP  pid 
            learned in step 1 using Genie BGP Conf.
         4. Verify the newly added default originate config under BGP neighbor is 
@@ -615,15 +692,26 @@
                 Buffer recovery timeout make sure devices are recovered at the
                 end of the trigger execution. Used when previous timeouts have
                 been exhausted.
                 max_time (`int`): Maximum wait time for the last step of the 
                                   trigger in seconds. Default: 180
                 interval (`int`): Wait time between iteration when looping is 
                                   needed in seconds. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     Steps:
         1. Learn BGP Ops configured on device. SKIP the trigger if there
            is no BGP configured on the device.
         2. Save the current device configurations using "method" specified.
         3. Add password configuration under BGP neighbor of BGP  pid 
            learned in step 1 using Genie BGP Conf.
         4. Verify the newly added password config under BGP neighbor is 
@@ -716,15 +804,26 @@
                 Buffer recovery timeout make sure devices are recovered at the
                 end of the trigger execution. Used when previous timeouts have
                 been exhausted.
                 max_time (`int`): Maximum wait time for the last step of the 
                                   trigger in seconds. Default: 180
                 interval (`int`): Wait time between iteration when looping is 
                                   needed in seconds. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     Steps:
         1. Learn BGP Ops configured on device. SKIP the trigger if there
            is no BGP configured on the device.
         2. Save the current device configurations using "method" specified.
         3. Add transport connection mode configuration under BGP neighbor of BGP
            pid learned in step 1 using Genie BGP Conf.
         4. Verify the newly added transport connection mode config under BGP 
@@ -790,15 +889,26 @@
                     Buffer recovery timeout make sure devices are recovered at the
                     end of the trigger execution. Used when previous timeouts have
                     been exhausted.
                     max_time (`int`): Maximum wait time for the last step of the
                                       trigger in seconds. Default: 180
                     interval (`int`): Wait time between iteration when looping is
                                       needed in seconds. Default: 15
-
+                static:
+                    The keys below are dynamically learnt by default.
+                    However, they can also be set to a custom value when provided in the trigger datafile.
+
+                    instance: `str`
+                    vrf: `str`
+                    neighbor: `str`
+                    bgp_id: `int`
+
+                    (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                          OR
+                          interface: 'Ethernet1/1/1' (Specific value)
         Steps:
             1. Learn BGP Ops configured on device. SKIP the trigger if there
                is no BGP configured on the device.
             2. Save the current device configurations using "method" specified.
             3. Add route-map in and route-map out configuration under a BGP neighbor of BGP pid learned in
                step 1 using Genie BGP Conf.
             4. Verify the newly route-maps under BGP neighbor is reflected in
@@ -883,15 +993,26 @@
                        Buffer recovery timeout make sure devices are recovered at the
                        end of the trigger execution. Used when previous timeouts have
                        been exhausted.
                        max_time (`int`): Maximum wait time for the last step of the
                                          trigger in seconds. Default: 180
                        interval (`int`): Wait time between iteration when looping is
                                          needed in seconds. Default: 15
-
+                   static:
+                       The keys below are dynamically learnt by default.
+                       However, they can also be set to a custom value when provided in the trigger datafile.
+
+                       instance: `str`
+                       vrf: `str`
+                       neighbor: `str`
+                       bgp_id: `int`
+
+                       (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                             OR
+                             interface: 'Ethernet1/1/1' (Specific value)
            Steps:
                1. Learn BGP Ops configured on device. SKIP the trigger if there
                   is no BGP configured on the device.
                2. Save the current device configurations using "method" specified.
                3. Add capability suppress 4-byte-as under a BGP neighbor of BGP pid learned in
                   step 1 using Genie BGP Conf.
                4. Verify the newly capability suppress 4-byte-as under BGP neighbor is reflected in
@@ -962,15 +1083,26 @@
                            Buffer recovery timeout make sure devices are recovered at the
                            end of the trigger execution. Used when previous timeouts have
                            been exhausted.
                            max_time (`int`): Maximum wait time for the last step of the
                                              trigger in seconds. Default: 180
                            interval (`int`): Wait time between iteration when looping is
                                              needed in seconds. Default: 15
-
+                       static:
+                           The keys below are dynamically learnt by default.
+                           However, they can also be set to a custom value when provided in the trigger datafile.
+
+                           instance: `str`
+                           vrf: `str`
+                           neighbor: `str`
+                           bgp_id: `int`
+
+                           (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                                 OR
+                                 interface: 'Ethernet1/1/1' (Specific value)
                Steps:
                    1. Learn BGP Ops configured on device. SKIP the trigger if there
                       is no BGP configured on the device.
                    2. Save the current device configurations using "method" specified.
                    3. Add send-community under a BGP neighbor of BGP pid learned in
                       step 1 using Genie BGP Conf.
                    4. Verify the newly send-community under BGP neighbor is reflected in
@@ -1041,14 +1173,27 @@
                              end of the trigger execution. Used when previous timeouts have
                              been exhausted.
                              max_time (`int`): Maximum wait time for the last step of the
                                                trigger in seconds. Default: 180
                              interval (`int`): Wait time between iteration when looping is
                                                needed in seconds. Default: 15
 
+                         static:
+                             The keys below are dynamically learnt by default.
+                             However, they can also be set to a custom value when provided in the trigger datafile.
+
+                             instance: `str`
+                             vrf: `str`
+                             neighbor: `str`
+                             bgp_id: `int`
+
+                             (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                                   OR
+                                   interface: 'Ethernet1/1/1' (Specific value)
+
                  Steps:
                      1. Learn BGP Ops configured on device. SKIP the trigger if there
                         is no BGP configured on the device.
                      2. Save the current device configurations using "method" specified.
                      3. Add send-community extended under a BGP neighbor of BGP pid learned in
                         step 1 using Genie BGP Conf.
                      4. Verify the newly send-community extended under BGP neighbor is reflected in
@@ -1118,15 +1263,26 @@
                                  Buffer recovery timeout make sure devices are recovered at the
                                  end of the trigger execution. Used when previous timeouts have
                                  been exhausted.
                                  max_time (`int`): Maximum wait time for the last step of the
                                                    trigger in seconds. Default: 180
                                  interval (`int`): Wait time between iteration when looping is
                                                    needed in seconds. Default: 15
-
+                             static:
+                                 The keys below are dynamically learnt by default.
+                                 However, they can also be set to a custom value when provided in the trigger datafile.
+
+                                 instance: `str`
+                                 vrf: `str`
+                                 neighbor: `str`
+                                 bgp_id: `int`
+
+                                 (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                                       OR
+                                       interface: 'Ethernet1/1/1' (Specific value)
                      Steps:
                          1. Learn BGP Ops configured on device. SKIP the trigger if there
                             is no BGP configured on the device.
                          2. Save the current device configurations using "method" specified.
                          3. Add soft-reconfiguration inbound under BGP neighbor of BGP pid learned in
                             step 1 using Genie BGP Conf.
                          4. Verify the newly soft-reconfiguration inbound under BGP neighbor is reflected in
@@ -1196,15 +1352,26 @@
                       Buffer recovery timeout make sure devices are recovered at the
                       end of the trigger execution. Used when previous timeouts have
                       been exhausted.
                       max_time (`int`): Maximum wait time for the last step of the
                                         trigger in seconds. Default: 180
                       interval (`int`): Wait time between iteration when looping is
                                         needed in seconds. Default: 15
-
+                  static:
+                      The keys below are dynamically learnt by default.
+                      However, they can also be set to a custom value when provided in the trigger datafile.
+
+                      instance: `str`
+                      vrf: `str`
+                      neighbor: `str`
+                      bgp_id: `int`
+
+                      (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                            OR
+                            interface: 'Ethernet1/1/1' (Specific value)
           Steps:
               1. Learn BGP Ops configured on device. SKIP the trigger if there
                  is no BGP configured on the device.
               2. Save the current device configurations using "method" specified.
               3. Add remove-private-as configuration under a BGP neighbor of BGP pid learned in
                  step 1 using Genie BGP Conf.
               4. Verify the newly remove-private-as under BGP is reflected in device configuration.
@@ -1276,15 +1443,26 @@
                       Buffer recovery timeout make sure devices are recovered at the
                       end of the trigger execution. Used when previous timeouts have
                       been exhausted.
                       max_time (`int`): Maximum wait time for the last step of the
                                         trigger in seconds. Default: 180
                       interval (`int`): Wait time between iteration when looping is
                                         needed in seconds. Default: 15
-
+                  static:
+                      The keys below are dynamically learnt by default.
+                      However, they can also be set to a custom value when provided in the trigger datafile.
+
+                      instance: `str`
+                      vrf: `str`
+                      neighbor: `str`
+                      bgp_id: `int`
+
+                      (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                            OR
+                            interface: 'Ethernet1/1/1' (Specific value)
           Steps:
               1. Learn BGP Ops configured on device. SKIP the trigger if there
                  is no BGP configured on the device.
               2. Save the current device configurations using "method" specified.
               3. Add aggregate-address configuration for ipv4 under BGP pid learned in
                  step 1 using Genie BGP Conf.
               4. Verify the newly aggregate-address under BGP is reflected in device
@@ -1363,15 +1541,26 @@
                            Buffer recovery timeout make sure devices are recovered at the
                            end of the trigger execution. Used when previous timeouts have
                            been exhausted.
                            max_time (`int`): Maximum wait time for the last step of the
                                              trigger in seconds. Default: 180
                            interval (`int`): Wait time between iteration when looping is
                                              needed in seconds. Default: 15
-
+                       static:
+                           The keys below are dynamically learnt by default.
+                           However, they can also be set to a custom value when provided in the trigger datafile.
+
+                           instance: `str`
+                           vrf: `str`
+                           neighbor: `str`
+                           bgp_id: `int`
+
+                           (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                                 OR
+                                 interface: 'Ethernet1/1/1' (Specific value)
                Steps:
                    1. Learn BGP Ops configured on device. SKIP the trigger if there
                       is no BGP configured on the device.
                    2. Save the current device configurations using "method" specified.
                    3. Add aggregate-address configuration for ipv6 under BGP pid learned in
                       step 1 using Genie BGP Conf.
                    4. Verify the newly aggregate-address under BGP is reflected in
@@ -1438,14 +1627,26 @@
                        Buffer recovery timeout make sure devices are recovered at the
                        end of the trigger execution. Used when previous timeouts have
                        been exhausted.
                        max_time (`int`): Maximum wait time for the last step of the
                                          trigger in seconds. Default: 180
                        interval (`int`): Wait time between iteration when looping is
                                          needed in seconds. Default: 15
+                  static:
+                      The keys below are dynamically learnt by default.
+                      However, they can also be set to a custom value when provided in the trigger datafile.
+
+                      instance: `str`
+                      vrf: `str`
+                      neighbor: `str`
+                      bgp_id: `int`
+
+                      (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                            OR
+                            interface: 'Ethernet1/1/1' (Specific value)
 
            Steps:
                1. Learn BGP Ops configured on device. SKIP the trigger if there
                   is no BGP configured on the device.
                2. Save the current device configurations using "method" specified.
                3. Add keepalive interval and holdtime under BGP pid learned in
                   step 1 using Genie BGP Conf.
@@ -1517,15 +1718,24 @@
                        Buffer recovery timeout make sure devices are recovered at the
                        end of the trigger execution. Used when previous timeouts have
                        been exhausted.
                        max_time (`int`): Maximum wait time for the last step of the
                                          trigger in seconds. Default: 180
                        interval (`int`): Wait time between iteration when looping is
                                          needed in seconds. Default: 15
-
+                   static:
+                        The keys below are dynamically learnt by default.
+                        However, they can also be set to a custom value when provided in the trigger datafile.
+
+                        vrf: `str`
+                        bgp_id: `int`
+
+                       (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                             OR
+                             interface: 'Ethernet1/1/1' (Specific value)
            Steps:
                1. Learn BGP Ops configured on device. SKIP the trigger if there
                   is no BGP configured on the device.
                2. Save the current device configurations using "method" specified.
                3. Add network ip configuration under BGP pid learned in
                   step 1 using Genie BGP Conf.
                4. Verify the newly network ip under BGP is
@@ -1594,15 +1804,24 @@
                        Buffer recovery timeout make sure devices are recovered at the
                        end of the trigger execution. Used when previous timeouts have
                        been exhausted.
                        max_time (`int`): Maximum wait time for the last step of the
                                          trigger in seconds. Default: 180
                        interval (`int`): Wait time between iteration when looping is
                                          needed in seconds. Default: 15
-
+                   static:
+                        The keys below are dynamically learnt by default.
+                        However, they can also be set to a custom value when provided in the trigger datafile.
+
+                        vrf: `str`
+                        bgp_id: `int`
+
+                       (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                             OR
+                             interface: 'Ethernet1/1/1' (Specific value)
            Steps:
                1. Learn BGP Ops configured on device. SKIP the trigger if there
                   is no BGP configured on the device.
                2. Save the current device configurations using "method" specified.
                3. Add network ipv6 configuration under BGP pid learned in
                   step 1 using Genie BGP Conf.
                4. Verify the newly network ipv6 under BGP is
@@ -1672,15 +1891,24 @@
                    Buffer recovery timeout make sure devices are recovered at the
                    end of the trigger execution. Used when previous timeouts have
                    been exhausted.
                    max_time (`int`): Maximum wait time for the last step of the
                                      trigger in seconds. Default: 180
                    interval (`int`): Wait time between iteration when looping is
                                      needed in seconds. Default: 15
-
+               static:
+                    The keys below are dynamically learnt by default.
+                    However, they can also be set to a custom value when provided in the trigger datafile.
+
+                    vrf: `str`
+                    bgp_id: `int`
+
+                   (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                         OR
+                         interface: 'Ethernet1/1/1' (Specific value)
        Steps:
            1. Learn BGP Ops configured on device. SKIP the trigger if there
               is no BGP configured on the device.
            2. Save the current device configurations using "method" specified.
            3. Add maximum ebgp paths configuration under BGP pid learned in
               step 1 using Genie BGP Conf.
            4. Verify the newly maximum ebgp paths under BGP is
@@ -1746,15 +1974,27 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iterations when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                address_family: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn BGP Ops object and store the BGP neighbor(s) if it does 
            not have "as-override" enabled,
            otherwise, SKIP the trigger.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of the "as-override" to learned
            BGP neighbor(s) from step 1 with BGP Conf object
@@ -1833,15 +2073,27 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iterations when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                address_family: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn BGP Ops object and store the BGP neighbor(s) if it does 
            not have "route-reflector-client" enabled,
            otherwise, SKIP the trigger.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of the "route-reflector-client" to learned
            BGP neighbor(s) from step 1 with BGP Conf object
@@ -1924,15 +2176,26 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iterations when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                address_family: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn BGP Ops object and store the BGP vrf(s) if it does 
            not have "redistribute direct" enabled,
            otherwise, SKIP the trigger.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of the "redistribute direct" to learned
            BGP vrf(s) from step 1 with BGP Conf object
@@ -2022,15 +2285,26 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iterations when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                address_family: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn BGP Ops object and store the BGP vrf(s) if it does 
            not have "redistribute static" enabled,
            otherwise, SKIP the trigger.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of the "redistribute static" to learned
            BGP vrf(s) from step 1 with BGP Conf object
@@ -2120,15 +2394,25 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iterations when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn BGP Ops object and store the BGP vrf(s) if it does 
            not have "redistribute ospf opsf_pid" enabled,
            otherwise, SKIP the trigger.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of the "redistribute ospf opsf_pid" to learned
            BGP vrf(s) from step 1 with BGP Conf object
@@ -2220,15 +2504,26 @@
                     Buffer recovery timeout make sure devices are recovered at the end
                     of the trigger execution. Used when previous timeouts have been exhausted.
 
                     max_time (`int`): Maximum wait time for the last step of the trigger,
                                     in second. Default: 180
                     interval (`int`): Wait time between iterations when looping is needed,
                                     in second. Default: 15
-
+                static:
+                    The keys below are dynamically learnt by default.
+                    However, they can also be set to a custom value when provided in the trigger datafile.
+
+                    instance: `str`
+                    vrf: `str`
+                    neighbor: `str`
+                    bgp_id: `int`
+
+                    (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                        OR
+                        interface: 'Ethernet1/1/1' (Specific value)
         steps:
             1. Learn BGP Ops object and store the BGP vrf(s) if it does
                not have "rewrite-evpn-rt-asn" enabled,
                otherwise, SKIP the trigger.
             2. Save the current device configurations through "method" which user uses
             3. Add the configuration of the "rewrite-evpn-rt-asn" to learned
                BGP vrf(s) from step 1 with BGP Conf object
@@ -2241,15 +2536,15 @@
         """
 
     mapping = Mapping(\
                 requirements={ \
                     'conf.bgp.Bgp': {
                         'requirements': [ \
                             ['device_attr', '{uut}', '_vrf_attr', '(?P<vrf>.*)', '_neighbor_attr',
-                              '(?P<neighbor>.*)', '_address_family_attr', '(?P<af>.*)', NotExists('nbr_af_rewrite_evpn_rt_asn')]],
+                              '(?P<neighbor>.*)', '_address_family_attr', '(?P<address_family>.*)', NotExists('nbr_af_rewrite_evpn_rt_asn')]],
                         'exclude': bgp_exclude},
                     'ops.bgp.bgp.Bgp':{
                         'requirements':[\
                             [['info', 'instance', '(?P<instance>.*)', 'vrf', '(?P<vrf>.*)',
                              'neighbor', '(?P<neighbor>.*)', 'address_family', '(?P<address_family>^l2vpn +evpn$)',
                              'session_state', 'established']],
                             [['info', 'instance', '(?P<instance>.*)', 'bgp_id', '(?P<bgp_id>.*)']],
```

## genie/libs/sdk/triggers/addremove/igmp/nxos/addremove.py

```diff
@@ -59,14 +59,24 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                interface: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn Igmp Ops/Conf object and store the Igmp interface enable, learn Interface ops to 
            get interface with ip address and not same to the existing igmp interface.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of interface as igmp originator-id with Igmp Conf object
         4. Verify the igmp interface enable from step 3 has configured
@@ -81,17 +91,17 @@
         super().verify_prerequisite(uut, abstract, steps, timeout)
         igmp_keys = self.mapping.keys
 
 
         # learn interafce ops to get ipv4 up interfaces
         self.mapping.requirements = {}
         self.mapping.requirements['ops.interface.interface.Interface'] = \
-            {'requirements':[['info', '(?P<igmp_intf>^(?!mgmt).*)', 'ipv4',
+            {'requirements':[['info', '(?P<interface>^(?!mgmt).*)', 'ipv4',
                               '(?P<ip>.*)', 'ip', '(?P<address>.*)'],
-                             ['info', '(?P<igmp_intf>.*)', 'vrf',
+                             ['info', '(?P<interface>.*)', 'vrf',
                               '(?P<add_igmp_intf_vrf>.*)']],
             'all_keys': True,
             'kwargs':{'attributes': [
                 'info[(.*)][ipv4][(.*)][ip]',
                 'info[(.*)][vrf]']},
             'exclude': interface_exclude}
         super().verify_prerequisite(uut, abstract, steps, timeout)
@@ -99,18 +109,18 @@
 
         # find interface
         with steps.start("Extracting ipv4 interfaces "
           "which are not igmp interfaces") as step:
 
             add_keys = {}
             for item in intf_keys:
-                if all(item['igmp_intf'] not in \
-                    i['igmp_intf'] for i in igmp_keys):
+                if all(item['interface'] not in \
+                    i['interface'] for i in igmp_keys):
                     # attach the add value to mapping keys
-                    add_keys.update({'add_igmp_intf': item['igmp_intf'],
+                    add_keys.update({'add_igmp_intf': item['interface'],
                                      'add_igmp_intf_vrf': item['add_igmp_intf_vrf']})
                     break
 
             if not add_keys:
                 step.skipped('Could not find up ipv4 interface which is '
                     'not existed igmp interface')
                 self.skipped('Could not find up ipv4 interface which is '
@@ -119,15 +129,15 @@
         self.mapping.keys = [add_keys]
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.igmp.igmp.Igmp':{
                                           'requirements':[\
                                               ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                               '(?P<igmp_intf>.*)']],
+                                               '(?P<interface>.*)']],
                                           'kwargs':{'attributes': [
                                               'info[vrfs][(.*)][interfaces]']},
                                           'exclude': igmp_exclude}},
                       config_info={'conf.igmp.Igmp':{
                                        'requirements':[
                                          ['device_attr', '{uut}', 'vrf_attr', '(?P<add_igmp_intf_vrf>.*)',
                                           'interface_attr', '(?P<add_igmp_intf>.*)', 'enable', True]],
@@ -135,15 +145,15 @@
                                        'kwargs':{}}},
                       verify_ops={'ops.igmp.igmp.Igmp':{
                                           'requirements':[\
                                               ['info', 'vrfs', '(?P<add_igmp_intf_vrf>.*)', 'interfaces',
                                                '(?P<add_igmp_intf>.*)', 'enable', True]],
                                           'kwargs':{'attributes': ['info[vrfs][(.*)][interfaces]']},
                                           'exclude': igmp_exclude}},
-                      num_values={'vrf': 'all', 'igmp_intf': 'all'})
+                      num_values={'vrf': 'all', 'interface': 'all'})
 
 
 class TriggerAddRemoveIgmpVersion(TriggerAddRemove):
     """Apply Igmp interface version, and remove added Igmp interface version"""
 
     __description__ = """Apply Igmp interface version, and remove added Igmp interface version.
 
@@ -170,15 +180,24 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                interface: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Igmp Ops object and store the Igmp which interface version is default value.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of igmp interface version with Igmp Conf object
         4. Verify the igmp interface version from step 3 has configured
         5. Remove the igmp interface version configurations.
         6. Recover the device configurations to the one in step 2
@@ -188,38 +207,37 @@
     ADD_VERSION = 3
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={
                           'ops.igmp.igmp.Igmp':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'enable', True],
+                                     '(?P<interface>.*)', 'enable', True],
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'version', '(?P<version>2)']],
+                                     '(?P<interface>.*)', 'version', '(?P<version>2)']],
                                 'all_keys': True,
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)]']},
                                 'exclude': igmp_exclude}},
                       config_info={'conf.igmp.Igmp':{
                                        'requirements':[
                                          ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
-                                          'interface_attr', '(?P<igmp_intf>.*)', 'version',
+                                          'interface_attr', '(?P<interface>.*)', 'version',
                                           ADD_VERSION]],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={
                           'ops.igmp.igmp.Igmp':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'version', ADD_VERSION]],
-                                'missing': False,
+                                     '(?P<interface>.*)', 'version', ADD_VERSION]],
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)]']},
                                 'exclude': igmp_exclude}},
-                      num_values={'vrf': 1, 'igmp_intf': 1})
+                      num_values={'vrf': 1, 'interface': 1})
 
 
 class TriggerAddRemoveIgmpJoinGroup(TriggerAddRemove):
     """Apply the Igmp interface join-group, and remove added Igmp interface join-group"""
 
     __description__ = """Apply the Igmp peer(s) sa-filter out, and
     remove added Igmp peer(s) sa-filter out.
@@ -248,15 +266,26 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                join_group: `str`
+                group: `str`
+                interface: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Igmp Ops object and store the Igmp interface(s) which does not have added join-group.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of igmp interface join-group with Igmp Conf object
         4. Verify the igmp interface join-group from step 3 has configured
         5. Remove the igmp interface join-group configurations.
         6. Recover the device configurations to the one in step 2
@@ -279,15 +308,15 @@
             self.errored("Section failed due to: '{e}'".format(e=e))
 
         # nothing in the static groups,
         # then learn if any groups to have some vrf interface value
         if any(not item for item in self.mapping.keys):
             self.mapping.requirements['ops.igmp.igmp.Igmp']['requirements'] = \
               [['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-               '(?P<igmp_intf>.*)', 'group', '(?P<group>.*)', '(?P<dummy>.*)']] # incase there is nothing learned
+               '(?P<interface>.*)', 'group', '(?P<group>.*)', '(?P<dummy>.*)']] # incase there is nothing learned
 
             try:
                 self.pre_snap = self.mapping.learn_ops(device=uut,
                                                        abstract=abstract,
                                                        steps=steps,
                                                        timeout=timeout)
             except Exception as e:
@@ -317,52 +346,52 @@
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={
                           'ops.igmp.igmp.Igmp':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'join_group', '(?P<join_group>.*)',
+                                     '(?P<interface>.*)', 'join_group', '(?P<join_group>.*)',
                                      'group', '(?P<group>.*)']],
                                 'all_keys': True,
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)][interfaces][(.*)][join_group][(.*)]',
                                     'info[vrfs][(.*)][interfaces][(.*)][static_group][(.*)]',
                                     'info[vrfs][(.*)][interfaces][(.*)][group][(.*)]']},
                                 'exclude': igmp_exclude}},
                       config_info={'conf.igmp.Igmp':{
                                        'requirements':[
                                          [partial(configure_add_attributes,  # callable configuration
                                             add_obj=IgmpGroup,
                                             base=[['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
-                                                  'interface_attr', '(?P<igmp_intf>.*)']],
+                                                  'interface_attr', '(?P<interface>.*)']],
                                             add_attribute=[['join_group', '(?P<add_igmp_group>.*)'],
                                                            ['join_group_source_addr', '(?P<add_igmp_source>.*)'],],
                                             add_method='add_groups',
                                         )]],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={
                           'ops.igmp.igmp.Igmp':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'join_group', '(?P<add_igmp_group_key>.*)',
+                                     '(?P<interface>.*)', 'join_group', '(?P<add_igmp_group_key>.*)',
                                      'group', '(?P<add_igmp_group>.*)'],
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'join_group', '(?P<add_igmp_group_key>.*)',
+                                     '(?P<interface>.*)', 'join_group', '(?P<add_igmp_group_key>.*)',
                                      'source', '(?P<add_igmp_source>.*)'],
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'group', '(?P<add_igmp_group>.*)',
+                                     '(?P<interface>.*)', 'group', '(?P<add_igmp_group>.*)',
                                      'last_reporter', '([\w\.]+)']],
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)][interfaces][(.*)][join_group][(.*)]',
                                     'info[vrfs][(.*)][interfaces][(.*)][static_group][(.*)]',
                                     'info[vrfs][(.*)][interfaces][(.*)][group][(.*)]']},
                                 'exclude': igmp_exclude}},
-                      num_values={'vrf': 1, 'igmp_intf': 1, 'join_group': 1, 'group': 1, 'source': 1})
+                      num_values={'vrf': 1, 'interface': 1, 'join_group': 1, 'group': 1, 'source': 1})
 
 
 class TriggerAddRemoveIgmpStaticGroup(TriggerAddRemove):
     """Apply the Igmp interface static-group, and remove added Igmp interface static-group"""
 
     __description__ = """Apply the Igmp interface static-group,
     and remove added Igmp interface static-group.
@@ -390,14 +419,26 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                static_group: `str`
+                group: `str`
+                interface: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn Igmp Ops object and store the Igmp interface(s) which does not have added static-group.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of igmp interface static-group with Igmp Conf object
         4. Verify the igmp interface static-group from step 3 has configured
         5. Remove the igmp interface static-group configurations.
@@ -421,15 +462,15 @@
             self.errored("Section failed due to: '{e}'".format(e=e))
 
         # nothing in the static groups,
         # then learn if any groups to have some vrf interface value
         if any(not item for item in self.mapping.keys):
             self.mapping.requirements['ops.igmp.igmp.Igmp']['requirements'] = \
               [['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-               '(?P<igmp_intf>.*)', 'group', '(?P<group>.*)', '(?P<dummy>.*)']] # incase there is nothing learned
+               '(?P<interface>.*)', 'group', '(?P<group>.*)', '(?P<dummy>.*)']] # incase there is nothing learned
 
             try:
                 self.pre_snap = self.mapping.learn_ops(device=uut,
                                                        abstract=abstract,
                                                        steps=steps,
                                                        timeout=timeout)
             except Exception as e:
@@ -459,44 +500,44 @@
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={
                           'ops.igmp.igmp.Igmp':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'static_group', '(?P<static_group>.*)',
+                                     '(?P<interface>.*)', 'static_group', '(?P<static_group>.*)',
                                      'group', '(?P<group>.*)']],
                                 'all_keys': True,
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)][interfaces][(.*)][join_group][(.*)]',
                                     'info[vrfs][(.*)][interfaces][(.*)][static_group][(.*)]',
                                     'info[vrfs][(.*)][interfaces][(.*)][group][(.*)]']},
                                 'exclude': igmp_exclude}},
                       config_info={'conf.igmp.Igmp':{
                                        'requirements':[
                                          [partial(configure_add_attributes,  # callable configuration
                                             add_obj=IgmpGroup,
                                             base=[['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
-                                                  'interface_attr', '(?P<igmp_intf>.*)']],
+                                                  'interface_attr', '(?P<interface>.*)']],
                                             add_attribute=[['static_group', '(?P<add_igmp_group>.*)'],
                                                            ['static_group_source_addr', '(?P<add_igmp_source>.*)'],],
                                             add_method='add_groups',
                                         )]],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={
                           'ops.igmp.igmp.Igmp':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'static_group', '(?P<add_igmp_group_key>.*)',
+                                     '(?P<interface>.*)', 'static_group', '(?P<add_igmp_group_key>.*)',
                                      'group', '(?P<add_igmp_group>.*)'],
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'static_group', '(?P<add_igmp_group_key>.*)',
+                                     '(?P<interface>.*)', 'static_group', '(?P<add_igmp_group_key>.*)',
                                      'source', '(?P<add_igmp_source>.*)'],
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'group', '(?P<add_igmp_group>.*)', 'last_reporter', '([\w\.]+)']],
+                                     '(?P<interface>.*)', 'group', '(?P<add_igmp_group>.*)', 'last_reporter', '([\w\.]+)']],
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)][interfaces][(.*)][join_group][(.*)]',
                                     'info[vrfs][(.*)][interfaces][(.*)][static_group][(.*)]',
                                     'info[vrfs][(.*)][interfaces][(.*)][group][(.*)]']},
                                 'exclude': igmp_exclude}},
-                      num_values={'vrf': 1, 'igmp_intf': 1, 'static_group': 1, 'group': 1, 'source': 1})
+                      num_values={'vrf': 1, 'interface': 1, 'static_group': 1, 'group': 1, 'source': 1})
```

## genie/libs/sdk/triggers/addremove/lag/iosxe/addremove.py

```diff
@@ -55,15 +55,23 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iterations when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Interface Ops object to select trunk interfaces.
            Learn LAG ops object to find port-channle interfaces which does not have
            the learned interfaces as memebers.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of Etherchannel in LACP mode with interface Conf object
         4. Verify the interfaces are in the por-channle interfaces from step 3 has configured
@@ -87,51 +95,51 @@
     mapping = Mapping(requirements={'ops.lag.lag.Lag':{
                                             'requirements': [['info', 'interfaces', NotExists({BUNDLE_ID_INTF})], 
                                                              [NotExists('info')]],
                                             'all_keys': True,
                                             'kwargs':{'attributes':['info[interfaces][(.*)]']},
                                             'exclude': lag_exclude},
                                     'ops.interface.interface.Interface':{
-                                            'requirements':[['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                            'requirements':[['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                              'switchport_mode', 'trunk'],
-                                                            ['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                                            ['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                              'oper_status', 'up']],
                                             'kwargs': {'attributes': ['info[(.*)][switchport_mode]',
                                                                       'info[(.*)][enabled]',
                                                                       'info[(.*)][oper_status]',
                                                                       'info[(.*)][port_channel]']},
                                             'exclude': interface_exclude}},
                        config_info={'conf.interface.Interface':{
                                         'requirements':[['lag_bundle_id', BUNDLE_ID],
                                                         ['lag_activity', 'active']],
                                         'verify_conf':False,
-                                        'kwargs':{'mandatory':{'name': '(?P<intf>.*)',
+                                        'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                                'attach': False}}}},
                       verify_ops={'ops.lag.lag.Lag':{
                                       'requirements': [\
                                                 ['info', 'interfaces', BUNDLE_ID_INTF,
                                                  'bundle_id', BUNDLE_ID],
                                                 ['info', 'interfaces', BUNDLE_ID_INTF,
                                                  'protocol', 'lacp'],
                                                 ['info', 'interfaces', BUNDLE_ID_INTF,
                                                  'oper_status', 'up'],
                                                 ['info', 'interfaces', BUNDLE_ID_INTF,
                                                  'name', 'Port-channel10'],
                                                 ['info', 'interfaces', BUNDLE_ID_INTF,
-                                                 'members', '(?P<intf>.*)', 'bundled', True]],
+                                                 'members', '(?P<interface>.*)', 'bundled', True]],
                                       'kwargs':{'attributes':['info[interfaces][(.*)]']},
                                       'exclude': lag_exclude},
                                   'ops.interface.interface.Interface':{
-                                          'requirements':[['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                          'requirements':[['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                            'switchport_mode', 'trunk'],
-                                                          ['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                                          ['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                            'oper_status', 'up'],
-                                                          ['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                                          ['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                            'port_channel', 'port_channel_member', True],
-                                                          ['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                                          ['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                            'port_channel', 'port_channel_int', BUNDLE_ID_INTF],
                                                           ['info', BUNDLE_ID_INTF,
                                                            'oper_status', 'up'],
                                                           ['info', BUNDLE_ID_INTF,
                                                            'enabled', True],
                                                           ['info', BUNDLE_ID_INTF,
                                                            'oper_status', 'up'],
@@ -141,15 +149,15 @@
                                                            'port_channel', 'port_channel_member_intfs', '(.*)'],
                                                           ['info', BUNDLE_ID_INTF,
                                                            'switchport_enable', True],
                                                           ['info', BUNDLE_ID_INTF,
                                                            'switchport_mode', 'trunk'],],
                                           'kwargs': {'attributes': ['info']},
                                           'exclude': interface_exclude}},
-                      num_values={'intf':'all', 'bundle_id': 1})
+                      num_values={'interface':'all', 'bundle_id': 1})
 
 
 class TriggerAddRemoveAccessEtherchannelPagp(TriggerAddRemove):
     """Apply the Etherchannel in PAGP mode, and remove the
     added Etherchannel in PAGP mode
     """
 
@@ -179,15 +187,23 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iterations when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Interface Ops object to select trunk interfaces.
            Learn LAG ops object to find port-channle interfaces which does not have
            the learned interfaces as memebers.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of Etherchannel in PAGP mode with interface Conf object
         4. Verify the interfaces are in the por-channle interfaces from step 3 has configured
@@ -203,65 +219,65 @@
                                             'requirements':[\
                                                 ['info', 'interfaces', NotExists(BUNDLE_ID_INTF)],
                                                 [NotExists('info')]],
                                             'all_keys': True,
                                             'kwargs':{'attributes':['info[interfaces][(.*)]']},
                                             'exclude': lag_exclude},
                                     'ops.interface.interface.Interface':{
-                                            'requirements':[['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                            'requirements':[['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                              'switchport_mode', 'static access'],
-                                                            ['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                                            ['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                              'oper_status', 'up']],
                                           'kwargs': {'attributes': ['info[(.*)][switchport_mode]',
                                                                     'info[(.*)][enabled]',
                                                                     'info[(.*)][oper_status]',
                                                                     'info[(.*)][port_channel]']},
                                             'exclude': interface_exclude}},
                        config_info={'conf.interface.Interface':{
                                         'requirements':[['lag_bundle_id', BUNDLE_ID],
                                                         ['lag_activity', 'desirable']],
                                         'verify_conf':False,
-                                        'kwargs':{'mandatory':{'name': '(?P<intf>.*)',
+                                        'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                                'attach': False}}}},
                       verify_ops={'ops.lag.lag.Lag':{
                                       'requirements': [\
                                                 ['info', 'interfaces', BUNDLE_ID_INTF,
                                                  'bundle_id', BUNDLE_ID],
                                                 ['info', 'interfaces', BUNDLE_ID_INTF,
                                                  'protocol', 'pagp'],
                                                 ['info', 'interfaces', BUNDLE_ID_INTF,
                                                  'oper_status', 'up'],
                                                 ['info', 'interfaces', BUNDLE_ID_INTF,
                                                  'name', 'Port-channel10'],
                                                 ['info', 'interfaces', BUNDLE_ID_INTF,
-                                                 'members', '(?P<intf>.*)', 'bundled', True]],
+                                                 'members', '(?P<interface>.*)', 'bundled', True]],
                                       'kwargs':{'attributes':['info[interfaces][(.*)]']},
                                       'exclude': lag_exclude},
                                   'ops.interface.interface.Interface':{
-                                          'requirements':[['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                          'requirements':[['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                            'switchport_mode', 'static access'],
-                                                          ['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                                          ['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                            'oper_status', 'up'],
-                                                          ['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                                          ['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                            'port_channel', 'port_channel_member', True],
-                                                          ['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                                          ['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                            'port_channel', 'port_channel_int', BUNDLE_ID_INTF],
                                                           ['info', BUNDLE_ID_INTF,
                                                            'oper_status', 'up'],
                                                           ['info', BUNDLE_ID_INTF,
                                                            'enabled', True],
                                                           ['info', BUNDLE_ID_INTF,
                                                            'port_channel', 'port_channel_member', True],
                                                           ['info', BUNDLE_ID_INTF,
                                                            'port_channel', 'port_channel_member_intfs', '(.*)'],
                                                           ['info', BUNDLE_ID_INTF,
                                                            'switchport_mode', 'static access']],
                                           'kwargs': {'attributes': ['info']},
                                           'exclude': interface_exclude}},
-                      num_values={'intf':'all', 'bundle_id': 1})
+                      num_values={'interface':'all', 'bundle_id': 1})
 
 
 class TriggerAddRemoveL3EtherchannelPagp(TriggerAddRemove):
     """Apply the configuration for L3 Etherchannel in PAGP mode, and remove the
     added Etherchannel in PAGP mode
     """
 
@@ -291,15 +307,25 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iterations when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+                bundle_intf: `str`
+                bundle_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Interface Ops object to select up interfaces.
            Learn LAG ops object to find port-channle interfaces which does not exists.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of Etherchannel in PAGP mode with interface Conf object,
            Add ip address configuration to the learned port-channel interfaces
         4. Verify the interfaces are in the por-channle interfaces from step 3 has configured
@@ -322,48 +348,48 @@
                                             'requirements':[\
                                                 ['info', 'interfaces', '(?P<bundle_intf>.*)', NotExists('members')],
                                                 ['info', 'interfaces', '(?P<bundle_intf>.*)', 'bundle_id', '(?P<bundle_id>.*)']],
                                             'all_keys': True,
                                             'kwargs':{'attributes':['info[interfaces][(.*)]']},
                                             'exclude': lag_exclude},
                                     'ops.interface.interface.Interface':{
-                                            'requirements':[['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                            'requirements':[['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                              'switchport_enable', False],
-                                                            ['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                                            ['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                              'oper_status', 'up']],
                                             'kwargs': {'attributes': ['info[(.*)][switchport_enable]',
                                                                       'info[(.*)][operational_mode]',
                                                                       'info[(.*)][oper_status]',
                                                                       'info[(.*)][enabled]',
                                                                       'info[(.*)][port_channel]']},
                                             'exclude': interface_exclude}},
                        config_info={'conf.interface.Interface':{
                                         'requirements':[['lag_bundle_id', '(?P<bundle_id>.*)'],
                                                         ['lag_activity', 'desirable']],
                                         'verify_conf':False,
-                                        'kwargs':{'mandatory':{'name': '(?P<intf>.*)',
+                                        'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                                'attach': False}}}},
                       verify_ops={'ops.lag.lag.Lag':{
                                       'requirements': [\
                                                 ['info', 'interfaces', '(?P<bundle_intf>.*)',
                                                  'bundle_id', '(?P<bundle_id>.*)'],
                                                 ['info', 'interfaces', '(?P<bundle_intf>.*)',
                                                  'protocol', 'pagp'],
                                                 ['info', 'interfaces', '(?P<bundle_intf>.*)',
                                                  'oper_status', 'up'],
                                                 ['info', 'interfaces', '(?P<bundle_intf>.*)',
                                                  'name', '(?P<bundle_intf>.*)'],
                                                 ['info', 'interfaces', '(?P<bundle_intf>.*)',
-                                                 'members', '(?P<intf>.*)', 'bundled', True]],
+                                                 'members', '(?P<interface>.*)', 'bundled', True]],
                                       'kwargs':{'attributes':['info[interfaces][(.*)]']},
                                       'exclude': lag_exclude + ['attribute']},
                                   'ops.interface.interface.Interface':{
-                                          'requirements':[['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                          'requirements':[['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                            'switchport_enable', False],
-                                                          ['info', '(?P<intf>\w+Ethernet[\d\/]+$)',
+                                                          ['info', '(?P<interface>\w+Ethernet[\d\/]+$)',
                                                            'oper_status', 'up'],
                                                           ['info', '(?P<bundle_intf>.*)',
                                                            'oper_status', 'up'],
                                                           ['info', '(?P<bundle_intf>.*)',
                                                            'enabled', True],
                                                           ['info', '(?P<bundle_intf>.*)',
                                                            'oper_status', 'up'],
@@ -373,8 +399,8 @@
                                                            'port_channel', 'port_channel_member_intfs', '(.*)']],
                                             'kwargs': {'attributes': ['info[(.*)][switchport_enable]',
                                                                       'info[(.*)][operational_mode]',
                                                                       'info[(.*)][oper_status]',
                                                                       'info[(.*)][enabled]',
                                                                       'info[(.*)][port_channel]']},
                                           'exclude': interface_exclude}},
-                      num_values={'intf':'all', 'bundle_id': 1})
+                      num_values={'interface':'all', 'bundle_id': 1})
```

## genie/libs/sdk/triggers/addremove/mld/nxos/addremove.py

```diff
@@ -59,15 +59,23 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Mld Ops/Conf object and store the Mld interface enable, learn Interface ops to 
            get interface with ip address and not same to the existing mld interface.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of interface as mld originator-id with Mld Conf object
         4. Verify the mld interface enable from step 3 has configured
         5. Remove the mld interface enable configurations.
@@ -81,35 +89,35 @@
         super().verify_prerequisite(uut, abstract, steps, timeout)
         mld_keys = self.mapping.keys
 
 
         # learn interafce ops to get ipv6 up interfaces
         self.mapping.requirements = {}
         self.mapping.requirements['ops.interface.interface.Interface'] = \
-            {'requirements':[['info', '(?P<mld_intf>^(?!mgmt).*)', 'ipv6',
+            {'requirements':[['info', '(?P<interface>^(?!mgmt).*)', 'ipv6',
                               '(?P<ip>.*)', 'ip', '(?P<address>.*)'],
-                             ['info', '(?P<mld_intf>.*)', 'vrf',
+                             ['info', '(?P<interface>.*)', 'vrf',
                               '(?P<add_mld_intf_vrf>.*)']],
             'all_keys': True,
             'kwargs':{'attributes': [
                 'info[(.*)][ipv6][(.*)][ip]',
                 'info[(.*)][vrf]']},
             'exclude': interface_exclude}
         super().verify_prerequisite(uut, abstract, steps, timeout)
         intf_keys = self.mapping.keys
 
         # find interface
         with steps.start("Extracting ipv6 interfaces "
           "which are not igmp interfaces") as step:
             add_keys = {}
             for item in intf_keys:
-                if all(item['mld_intf'] not in \
-                    i['mld_intf'] for i in mld_keys):
+                if all(item['interface'] not in \
+                    i['interface'] for i in mld_keys):
                     # attach the add value to mapping keys
-                    add_keys.update({'add_mld_intf': item['mld_intf'],
+                    add_keys.update({'add_mld_intf': item['interface'],
                                      'add_mld_intf_vrf': item['add_mld_intf_vrf']})
                     break
 
             if not add_keys:
                 step.skipped('Could not find up ipv6 interface which is '
                     'not existed igmp interface')
                 self.skipped('Could not find up ipv6 interface which is not '
@@ -118,15 +126,15 @@
         self.mapping.keys = [add_keys]
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.mld.mld.Mld':{
                                           'requirements':[\
                                               ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                               '(?P<mld_intf>.*)']],
+                                               '(?P<interface>.*)']],
                                           'kwargs':{'attributes': [
                                               'info[vrfs][(.*)][interfaces]']},
                                           'exclude': mld_exclude}},
                       config_info={'conf.mld.Mld':{
                                        'requirements':[
                                          ['device_attr', '{uut}', 'vrf_attr', '(?P<add_mld_intf_vrf>.*)',
                                           'interface_attr', '(?P<add_mld_intf>.*)', 'enable', True]],
@@ -134,15 +142,15 @@
                                        'kwargs':{}}},
                       verify_ops={'ops.mld.mld.Mld':{
                                           'requirements':[\
                                               ['info', 'vrfs', '(?P<add_mld_intf_vrf>.*)', 'interfaces',
                                                '(?P<add_mld_intf>.*)', 'enable', True]],
                                           'kwargs':{'attributes': ['info[vrfs][(.*)][interfaces]']},
                                           'exclude': mld_exclude}},
-                      num_values={'vrf': 'all', 'mld_intf': 'all'})
+                      num_values={'vrf': 'all', 'interface': 'all'})
 
 
 class TriggerAddRemoveMldVersion(TriggerAddRemove):
     """Apply Mld interface version, and remove added Mld interface version"""
 
     __description__ = """Apply Mld interface version, and remove added Mld interface version.
 
@@ -169,15 +177,23 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Mld Ops object and store the Mld which interface version is default value.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of mld interface version with Mld Conf object
         4. Verify the mld interface version from step 3 has configured
         5. Remove the mld interface version configurations.
         6. Recover the device configurations to the one in step 2
@@ -187,38 +203,37 @@
     ADD_VERSION = 1
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={
                           'ops.mld.mld.Mld':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'enable', True],
+                                     '(?P<interface>.*)', 'enable', True],
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'version', '(?P<version>2)']],
+                                     '(?P<interface>.*)', 'version', '(?P<version>2)']],
                                 'all_keys': True,
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)]']},
                                 'exclude': mld_exclude}},
                       config_info={'conf.mld.Mld':{
                                        'requirements':[
                                          ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
-                                          'interface_attr', '(?P<mld_intf>.*)', 'version',
+                                          'interface_attr', '(?P<interface>.*)', 'version',
                                           ADD_VERSION]],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={
                           'ops.mld.mld.Mld':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'version', ADD_VERSION]],
-                                'missing': False,
+                                     '(?P<interface>.*)', 'version', ADD_VERSION]],
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)]']},
                                 'exclude': mld_exclude}},
-                      num_values={'vrf': 1, 'mld_intf': 1})
+                      num_values={'vrf': 1, 'interface': 1})
 
 
 class TriggerAddRemoveMldJoinGroup(TriggerAddRemove):
     """Apply the Mld interface join-group, and remove added Mld interface join-group"""
 
     __description__ = """Apply the Mld peer(s) sa-filter out, and
     remove added Mld peer(s) sa-filter out.
@@ -247,15 +262,26 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+                source: `str`
+                join_group: `str`
+                group: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Mld Ops object and store the Mld interface(s) which does not have added join-group.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of mld interface join-group with Mld Conf object
         4. Verify the mld interface join-group from step 3 has configured
         5. Remove the mld interface join-group configurations.
         6. Recover the device configurations to the one in step 2
@@ -278,15 +304,15 @@
             self.errored("Section failed due to: '{e}'".format(e=e))
 
         # nothing in the static groups,
         # then learn if any groups to have some vrf interface value
         if any(not item for item in self.mapping.keys):
             self.mapping.requirements['ops.mld.mld.Mld']['requirements'] = \
               [['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-               '(?P<mld_intf>.*)', 'group', '(?P<group>.*)', '(?P<dummy>.*)']] # incase there is nothing learned
+               '(?P<interface>.*)', 'group', '(?P<group>.*)', '(?P<dummy>.*)']] # incase there is nothing learned
 
             try:
                 self.pre_snap = self.mapping.learn_ops(device=uut,
                                                        abstract=abstract,
                                                        steps=steps,
                                                        timeout=timeout)
             except Exception as e:
@@ -316,57 +342,57 @@
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={
                           'ops.mld.mld.Mld':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'join_group', '(?P<join_group>.*)',
+                                     '(?P<interface>.*)', 'join_group', '(?P<join_group>.*)',
                                      'group', '(?P<group>.*)'],
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'join_group', '(?P<join_group>.*)',
+                                     '(?P<interface>.*)', 'join_group', '(?P<join_group>.*)',
                                      'source', '(?P<source>\*)'],
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'group', '(?P<group>.*)', '(?P<dummy>.*)'], # incase there is nothing learned
+                                     '(?P<interface>.*)', 'group', '(?P<group>.*)', '(?P<dummy>.*)'], # incase there is nothing learned
                                     ],
                                 'all_keys': True,
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)][interfaces][(.*)][join_group][(.*)]',
                                     'info[vrfs][(.*)][interfaces][(.*)][static_group][(.*)]',
                                     'info[vrfs][(.*)][interfaces][(.*)][group][(.*)]']},
                                 'exclude': mld_exclude}},
                       config_info={'conf.mld.Mld':{
                                        'requirements':[
                                          [partial(configure_add_attributes,  # callable configuration
                                             add_obj=MldGroup,
                                             base=[['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
-                                                  'interface_attr', '(?P<mld_intf>.*)']],
+                                                  'interface_attr', '(?P<interface>.*)']],
                                             add_attribute=[['join_group', '(?P<add_mld_group>.*)'],
                                                            ['join_group_source_addr', '(?P<add_mld_source>.*)'],],
                                             add_method='add_groups',
                                         )]],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={
                           'ops.mld.mld.Mld':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'join_group', '(?P<add_mld_group_key>.*)',
+                                     '(?P<interface>.*)', 'join_group', '(?P<add_mld_group_key>.*)',
                                      'group', '(?P<add_mld_group>.*)'],
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'join_group', '(?P<add_mld_group_key>.*)',
+                                     '(?P<interface>.*)', 'join_group', '(?P<add_mld_group_key>.*)',
                                      'source', '(?P<add_mld_source>.*)'],
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'group', '(?P<add_mld_group>.*)', '(.*)']],
+                                     '(?P<interface>.*)', 'group', '(?P<add_mld_group>.*)', '(.*)']],
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)][interfaces][(.*)][join_group][(.*)]',
                                     'info[vrfs][(.*)][interfaces][(.*)][static_group][(.*)]',
                                     'info[vrfs][(.*)][interfaces][(.*)][group][(.*)]']},
                                 'exclude': mld_exclude}},
-                      num_values={'vrf': 1, 'mld_intf': 1, 'join_group': 1, 'group': 1, 'source': 1})
+                      num_values={'vrf': 1, 'interface': 1, 'join_group': 1, 'group': 1, 'source': 1})
 
 
 class TriggerAddRemoveMldStaticGroup(TriggerAddRemove):
     """Apply the Mld interface static-group, and remove added Mld interface static-group"""
 
     __description__ = """Apply the Mld interface static-group,
     and remove added Mld interface static-group.
@@ -394,15 +420,26 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+                source: `str`
+                static_group: `str`
+                group: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Mld Ops object and store the Mld interface(s) which does not have added static-group.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of mld interface static-group with Mld Conf object
         4. Verify the mld interface static-group from step 3 has configured
         5. Remove the mld interface static-group configurations.
         6. Recover the device configurations to the one in step 2
@@ -425,15 +462,15 @@
             self.errored("Section failed due to: '{e}'".format(e=e))
 
         # nothing in the static groups,
         # then learn if any groups to have some vrf interface value
         if any(not item for item in self.mapping.keys):
             self.mapping.requirements['ops.mld.mld.Mld']['requirements'] = \
               [['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-               '(?P<mld_intf>.*)', 'group', '(?P<group>.*)', '(?P<dummy>.*)']] # incase there is nothing learned
+               '(?P<interface>.*)', 'group', '(?P<group>.*)', '(?P<dummy>.*)']] # incase there is nothing learned
 
             try:
                 self.pre_snap = self.mapping.learn_ops(device=uut,
                                                        abstract=abstract,
                                                        steps=steps,
                                                        timeout=timeout)
             except Exception as e:
@@ -463,43 +500,43 @@
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={
                           'ops.mld.mld.Mld':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'static_group', '(?P<static_group>.*)',
+                                     '(?P<interface>.*)', 'static_group', '(?P<static_group>.*)',
                                      'group', '(?P<group>.*)']],
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)][interfaces][(.*)][join_group][(.*)]',
                                     'info[vrfs][(.*)][interfaces][(.*)][static_group][(.*)]',
                                     'info[vrfs][(.*)][interfaces][(.*)][group][(.*)]']},
                                 'exclude': mld_exclude}},
                       config_info={'conf.mld.Mld':{
                                        'requirements':[
                                          [partial(configure_add_attributes,  # callable configuration
                                             add_obj=MldGroup,
                                             base=[['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
-                                                  'interface_attr', '(?P<mld_intf>.*)']],
+                                                  'interface_attr', '(?P<interface>.*)']],
                                             add_attribute=[['static_group', '(?P<add_mld_group>.*)'],
                                                            ['static_group_source_addr', '(?P<add_mld_source>.*)'],],
                                             add_method='add_groups',
                                         )]],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={
                           'ops.mld.mld.Mld':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'static_group', '(?P<add_mld_group_key>.*)',
+                                     '(?P<interface>.*)', 'static_group', '(?P<add_mld_group_key>.*)',
                                      'group', '(?P<add_mld_group>.*)'],
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'static_group', '(?P<add_mld_group_key>.*)',
+                                     '(?P<interface>.*)', 'static_group', '(?P<add_mld_group_key>.*)',
                                      'source', '(?P<add_mld_source>.*)'],
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'group', '(?P<add_mld_group>.*)', '(.*)']],
+                                     '(?P<interface>.*)', 'group', '(?P<add_mld_group>.*)', '(.*)']],
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)][interfaces][(.*)][join_group][(.*)]',
                                     'info[vrfs][(.*)][interfaces][(.*)][static_group][(.*)]',
                                     'info[vrfs][(.*)][interfaces][(.*)][group][(.*)]']},
                                 'exclude': mld_exclude}},
-                      num_values={'vrf': 1, 'mld_intf': 1, 'static_group': 1, 'group': 1, 'source': 1})
+                      num_values={'vrf': 1, 'interface': 1, 'static_group': 1, 'group': 1, 'source': 1})
```

## genie/libs/sdk/triggers/addremove/msdp/nxos/addremove.py

```diff
@@ -61,15 +61,24 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                originator_id: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Msdp Ops/Conf object and store the MSDP originator-id, learn Interface ops to 
            get interface with ip address and under same vrf as msdp originator-id.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of interface as msdp originator-id with Msdp Conf object
         4. Verify the msdp originator-id from step 3 has configured
         5. Remove the msdp originator-id configurations.
@@ -143,15 +152,24 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Msdp Ops object and store the MSDP peer(s) which does not have sa-filter in.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of msdp sa-filter in with Msdp Conf object
         4. Verify the msdp sa-filter in from step 3 has configured
         5. Remove the msdp sa-filter in configurations.
         6. Recover the device configurations to the one in step 2
@@ -215,15 +233,24 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Msdp Ops object and store the MSDP peer(s) which does not have sa-filter out.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of msdp sa-filter out with Msdp Conf object
         4. Verify the msdp sa-filter out from step 3 has configured
         5. Remove the msdp sa-filter out configurations.
         6. Recover the device configurations to the one in step 2
@@ -286,15 +313,24 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Msdp Ops object and store the MSDP peer(s) which does not have sa-limit.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of msdp sa-limit with Msdp Conf object
         4. Verify the msdp sa-limit from step 3 has configured
         5. Remove the msdp sa-limit configurations.
         6. Recover the device configurations to the one in step 2
@@ -360,14 +396,24 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn Msdp Ops object and store the MSDP peer(s) which does not have mesh-group.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of msdp mesh-group with Msdp Conf object
         4. Verify the msdp mesh-group from step 3 has configured
         5. Remove the msdp mesh-group configurations.
@@ -435,14 +481,24 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn Msdp Ops/Conf object and store the MSDP peer(s) which does not have
            keepalive&holdtime interval configured.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of msdp keepalive&holdtime interval with Msdp Conf object
         4. Verify the msdp keepalive&holdtime interval from step 3 has configured
@@ -548,15 +604,24 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Msdp Ops/Conf object and store the MSDP vrf(s) which does not have
            reconnect interval configured.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of msdp reconnect interval with Msdp Conf object
         4. Verify the msdp reconnect interval from step 3 has configured
         5. Remove the msdp reconnect interval configurations.
@@ -628,14 +693,24 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn Msdp Ops object and store the MSDP peer(s) which does not have
            description configured.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of msdp description with Msdp Conf object
         4. Verify the msdp description from step 3 has configured
@@ -698,14 +773,26 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+                originator_id: `str`
+                connect_source: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn Msdp Ops object and store the "established" MSDP peer(s), get different peer
            address as new msdp peer.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of msdp peer with Msdp Conf object
         4. Verify the msdp peer from step 3 has configured
```

## genie/libs/sdk/triggers/addremove/pim/nxos/addremove.py

```diff
@@ -40,15 +40,25 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
 
+                vrf: `str`
+                interface: `str`
+                address_family: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Pim Ops/Conf object and store the Pim interface(s)'s neighbor-filter.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of Pim interface(s)'s neighbor-filter with Pim Conf object
         4. Verify the Pim interface(s)'s neighbor-filter from step 3 has configured
         5. Remove the Pim interface(s)'s neighbor-filter configurations.
         6. Recover the device configurations to the one in step 2
@@ -59,38 +69,38 @@
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={
                           'ops.pim.pim.Pim':{
                                 'requirements':[\
                                     ['info', 'vrf', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<pim_intf>.*)', 'address_family', '(?P<af>.*)',
+                                     '(?P<interface>.*)', 'address_family', '(?P<address_family>.*)',
                                      NotExists('neighbor_filter')],
                                     ['info', 'vrf', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<pim_intf>.*)', 'address_family', '(?P<af>.*)',
+                                     '(?P<interface>.*)', 'address_family', '(?P<address_family>.*)',
                                      'oper_status', 'up']],
                                 'kwargs':{'attributes': [
                                     'info[vrf][(.*)][interfaces][(.*)][address_family][(.*)][oper_status]',
                                     'info[vrf][(.*)][interfaces][(.*)][address_family][(.*)][neighbor_filter]']},
                                 'exclude': pim_exclude}},
                       config_info={'conf.pim.Pim':{
                                        'requirements':[
                                          ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
-                                          'address_family_attr', '(?P<af>.*)', 'interface_attr',
-                                          '(?P<pim_intf>.*)', 'neighbor_filter', ADD_NAME]],
+                                          'address_family_attr', '(?P<address_family>.*)', 'interface_attr',
+                                          '(?P<interface>.*)', 'neighbor_filter', ADD_NAME]],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={
                           'ops.pim.pim.Pim':{
                                 'requirements':[\
                                     ['info', 'vrf', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<pim_intf>.*)', 'address_family', '(?P<af>.*)',
+                                     '(?P<interface>.*)', 'address_family', '(?P<address_family>.*)',
                                      'neighbor_filter', ADD_NAME],
                                     ['info', 'vrf', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<pim_intf>.*)', 'address_family', '(?P<af>.*)',
+                                     '(?P<interface>.*)', 'address_family', '(?P<address_family>.*)',
                                      'oper_status', 'up']],
                                 'kwargs':{'attributes': [
                                     'info[vrf][(.*)][interfaces][(.*)][address_family][(.*)][oper_status]',
                                     'info[vrf][(.*)][interfaces][(.*)][address_family][(.*)][neighbor_filter]']},
                                 'exclude': pim_exclude}},
-                      num_values={'vrf': 1, 'af': 1, 'pim_intf': 1})
+                      num_values={'vrf': 1, 'address_family': 1, 'interface': 1})
```

## genie/libs/sdk/triggers/addremove/routing/iosxe/addremove.py

```diff
@@ -47,15 +47,23 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iterations when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn static_routing Ops object and store the routes info if has any.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of static routing with static_routing Conf object
         4. Verify the static_routing from step 3 has configured
         5. Remove the static_routing configurations.
         6. Recover the device configurations to the one in step 2
@@ -159,15 +167,25 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iterations when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                route: `str`
+                out_intf: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn static_routing Ops object and store the routes info if has any.
         2. Save the current device configurations through "method" which user uses
         3. Add the configuration of static routing with static_routing Conf object
         4. Verify the static_routing from step 3 has configured
         5. Remove the static_routing configurations.
         6. Recover the device configurations to the one in step 2
```

## genie/libs/sdk/triggers/addremove/trm/nxos/addremove.py

```diff
@@ -46,15 +46,25 @@
                    Buffer recovery timeout make sure devices are recovered at the
                    end of the trigger execution. Used when previous timeouts have
                    been exhausted.
                    max_time (`int`): Maximum wait time for the last step of the
                                      trigger in seconds. Default: 180
                    interval (`int`): Wait time between iteration when looping is
                                      needed in seconds. Default: 15
-
+               static:
+                   The keys below are dynamically learnt by default.
+                   However, they can also be set to a custom value when provided in the trigger datafile.
+
+                    vrf: `str`
+                    address_family: `str`
+                    rt: `str`
+
+                    (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                          OR
+                          interface: 'Ethernet1/1/1' (Specific value)
        Steps:
            1. Learn Vrf Conf object configured on device. SKIP the trigger if there
               is no vrf configured on the device.
            2. Save the current device configurations using "method" specified.
            3. Add route-target mvpn that using Genie Vrf Conf.
            4. Verify the newly route-target mvpn under Vrf is reflected in
               device configuration.
@@ -68,15 +78,15 @@
         time.sleep(30)
         super().verify_configuration(uut, abstract, steps)
 
     PROTOCOL = 'mvpn'
     requirements = OrderedDict()
     requirements['conf.vrf.Vrf'] = {
         'requirements': [
-            ['device_attr', '{uut}', 'address_family_attr', '(?P<af>.*)', '_route_target_attr', '(?P<rt>.*)',
+            ['device_attr', '{uut}', 'address_family_attr', '(?P<address_family>.*)', '_route_target_attr', '(?P<rt>.*)',
               '_protocol_attr', NotExists(PROTOCOL)],
             ['device_attr', '{uut}', 'vrf_name', '(?P<vrf>.*)']],
         'all_keys': True,
         'exclude': trm_exclude}
 
     requirements['ops.vrf.vrf.Vrf'] = {
         'requirements': [['info', 'vrfs', '(?P<vrf>.*)', '(.*)']],
@@ -84,33 +94,33 @@
         'exclude': trm_exclude}
 
     mapping = Mapping( \
         requirements= requirements,
         config_info={ \
             'conf.vrf.Vrf': {
                 'requirements': [ \
-                    ['device_attr', '{uut}', 'address_family_attr', '(?P<af>.*)', 'route_target_attr', '(?P<rt>.*)', \
+                    ['device_attr', '{uut}', 'address_family_attr', '(?P<address_family>.*)', 'route_target_attr', '(?P<rt>.*)', \
                      'rt_type', 'both'],
-                    ['device_attr', '{uut}', 'address_family_attr', '(?P<af>.*)', 'route_target_attr', '(?P<rt>.*)', \
+                    ['device_attr', '{uut}', 'address_family_attr', '(?P<address_family>.*)', 'route_target_attr', '(?P<rt>.*)', \
                      'protocol_attr', 'mvpn', 'rt_mvpn', True]
                 ],
                 'verify_conf': False,
                 'kwargs': {'mandatory': {'name': '(?P<vrf>.*)'}}}},
         verify_ops={ \
             'conf.vrf.Vrf': {
                 'requirements': [ \
-                    ['device_attr', '{uut}', 'address_family_attr', '(?P<af>.*)', '_route_target_attr', '(?P<rt>.*)',
+                    ['device_attr', '{uut}', 'address_family_attr', '(?P<address_family>.*)', '_route_target_attr', '(?P<rt>.*)',
                      '_protocol_attr', 'mvpn', 'rt_mvpn', True]],
                 'exclude': trm_exclude},
             'ops.vrf.vrf.Vrf': {
                 'requirements': [ \
                     ['info', 'vrfs', '(?P<vrf>.*)', '(.*)']],
                 'kwargs': {'attributes': ['info']},
                 'exclude': trm_exclude}},
-        num_values={'vrf': 1, 'rt': 1, 'af': 1})
+        num_values={'vrf': 1, 'rt': 1, 'address_family': 1})
 
 class TriggerAddRemoveRouteTargetEvpn(TriggerAddRemove):
     """Add route-target evpn then restore the
         configuration by reapplying the whole running configuration"""
 
     __description__ = """Add route-target evpn then restore the
                             configuration by re-applying the whole running configuration
@@ -139,15 +149,25 @@
                    Buffer recovery timeout make sure devices are recovered at the
                    end of the trigger execution. Used when previous timeouts have
                    been exhausted.
                    max_time (`int`): Maximum wait time for the last step of the
                                      trigger in seconds. Default: 180
                    interval (`int`): Wait time between iteration when looping is
                                      needed in seconds. Default: 15
-
+               static:
+                   The keys below are dynamically learnt by default.
+                   However, they can also be set to a custom value when provided in the trigger datafile.
+
+                    vrf: `str`
+                    rt: `str`
+                    address_family: `str`
+
+                    (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                          OR
+                          interface: 'Ethernet1/1/1' (Specific value)
        Steps:
            1. Learn Vrf Conf object configured on device. SKIP the trigger if there
               is no vrf configured on the device.
            2. Save the current device configurations using "method" specified.
            3. Add route-target evpn that using Genie Vrf Conf.
            4. Verify the newly route-target evpn under Vrf is reflected in
               device configuration.
@@ -161,15 +181,15 @@
         time.sleep(30)
         super().verify_configuration( uut, abstract, steps)
 
     PROTOCOL = 'evpn'
     requirements = OrderedDict()
     requirements['conf.vrf.Vrf'] = {
         'requirements': [
-            ['device_attr', '{uut}', 'address_family_attr', '(?P<af>.*)', '_route_target_attr', '(?P<rt>.*)',
+            ['device_attr', '{uut}', 'address_family_attr', '(?P<address_family>.*)', '_route_target_attr', '(?P<rt>.*)',
              '_protocol_attr', NotExists(PROTOCOL),  NotExists('(.*)')],
             ['device_attr', '{uut}', 'vrf_name', '(?P<vrf>.*)']],
         'all_keys': True,
         'exclude': trm_exclude}
 
     requirements['ops.vrf.vrf.Vrf'] = {
         'requirements': [['info', 'vrfs', '(?P<vrf>.*)', '(.*)']],
@@ -177,33 +197,33 @@
         'exclude': trm_exclude}
 
     mapping = Mapping( \
         requirements=requirements,
         config_info={ \
             'conf.vrf.Vrf': {
                 'requirements': [ \
-                    ['device_attr', '{uut}', 'address_family_attr', '(?P<af>.*)', 'route_target_attr', '(?P<rt>.*)', \
+                    ['device_attr', '{uut}', 'address_family_attr', '(?P<address_family>.*)', 'route_target_attr', '(?P<rt>.*)', \
                      'rt_type', 'both'],
-                    ['device_attr', '{uut}', 'address_family_attr', '(?P<af>.*)', 'route_target_attr', '(?P<rt>.*)', \
+                    ['device_attr', '{uut}', 'address_family_attr', '(?P<address_family>.*)', 'route_target_attr', '(?P<rt>.*)', \
                      'protocol_attr', 'evpn', 'rt_evpn', True]
                 ],
                 'verify_conf': False,
                 'kwargs': {'mandatory': {'name': '(?P<vrf>.*)'}}}},
         verify_ops={ \
             'conf.vrf.Vrf': {
                 'requirements': [ \
-                    ['device_attr', '{uut}', 'address_family_attr', '(?P<af>.*)', '_route_target_attr', '(?P<rt>.*)',
+                    ['device_attr', '{uut}', 'address_family_attr', '(?P<address_family>.*)', '_route_target_attr', '(?P<rt>.*)',
                      '_protocol_attr', 'evpn', 'rt_evpn', True]],
                 'exclude': trm_exclude},
             'ops.vrf.vrf.Vrf': {
                 'requirements': [ \
                     ['info', 'vrfs', '(?P<vrf>.*)', '(.*)']],
                 'kwargs': {'attributes': ['info']},
                 'exclude': trm_exclude}},
-        num_values={'vrf': 1, 'rt': 1, 'af': 1})
+        num_values={'vrf': 1, 'rt': 1, 'address_family': 1})
 
 class TriggerAddRemoveAdvertiseEvpnMulticast(TriggerAddRemove):
     """Add advertise evpn multicast then restore the
         configuration by reapplying the whole running configuration"""
 
     __description__ = """Add advertise evpn multicast then restore the
                                configuration by re-applying the whole running configuration
```

## genie/libs/sdk/triggers/addremove/vxlan/nxos/addremove.py

```diff
@@ -62,15 +62,23 @@
                        Buffer recovery timeout make sure devices are recovered at the
                        end of the trigger execution. Used when previous timeouts have
                        been exhausted.
                        max_time (`int`): Maximum wait time for the last step of the
                                          trigger in seconds. Default: 180
                        interval (`int`): Wait time between iteration when looping is
                                          needed in seconds. Default: 15
-
+                   static:
+                       The keys below are dynamically learnt by default.
+                       However, they can also be set to a custom value when provided in the trigger datafile.
+
+                        nve_name: `str`
+
+                        (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                              OR
+                              interface: 'Ethernet1/1/1' (Specific value)
            Steps:
                1. Learn Vxlan Ops configured on device. SKIP the trigger if there
                   is no vxlan configured on the device.
                2. Save the current device configurations using "method" specified.
                3. Add virtual rmac advertised that using Genie Interface Conf.
                4. Verify the newly Virtual rmac advertised under Vxlan is reflected in
                   device configuration.
@@ -130,46 +138,54 @@
                        Buffer recovery timeout make sure devices are recovered at the
                        end of the trigger execution. Used when previous timeouts have
                        been exhausted.
                        max_time (`int`): Maximum wait time for the last step of the
                                          trigger in seconds. Default: 180
                        interval (`int`): Wait time between iteration when looping is
                                          needed in seconds. Default: 15
-
+                   static:
+                       The keys below are dynamically learnt by default.
+                       However, they can also be set to a custom value when provided in the trigger datafile.
+
+                       evpn_multisite_border_gateway: `int`
+
+                       (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                             OR
+                             interface: 'Ethernet1/1/1' (Specific value)
            Steps:
                1. Learn Vxlan Ops configured on device. SKIP the trigger if there
                   is no Vxlan configured on the device.
                2. Save the current device configurations using "method" specified.
                3. Add msite bgw delay restore time that using Genie Vxlan Conf.
                4. Verify the newly msite bgw delay restore time under Vxlan is reflected in
                   device configuration.
                5. Restore the device configuration to the original configuration saved
                   in step 2.
                6. Learn Vxlan Ops again and verify it is the same as the Ops in step 1.
            """
     mapping = Mapping(requirements={'ops.vxlan.vxlan.Vxlan': {
-                                        'requirements': [['nve', 'evpn_multisite_border_gateway', '(?P<border_gateway>.*)'],
+                                        'requirements': [['nve', 'evpn_multisite_border_gateway', '(?P<evpn_multisite_border_gateway>.*)'],
                                                          ['nve', NotExists('multisite_convergence_time'), NotExists('(.*)')]],
                                         'kwargs': {'attributes': ['nve[(.*)][vni][(.*)]',
                                                                   'nve[evpn_multisite_border_gateway]',
                                                                   'nve[multisite_convergence_time]','bgp_l2vpn_evpn','l2route']},
                                         'all_keys': True,
                                         'exclude': vxlan_exclude + multisite_exclude + ['flags'] }},
                     config_info={'conf.vxlan.Vxlan': {
-                                        'requirements': [['device_attr', '{uut}', 'evpn_msite_attr', '(?P<border_gateway>.*)',\
+                                        'requirements': [['device_attr', '{uut}', 'evpn_msite_attr', '(?P<evpn_multisite_border_gateway>.*)',\
                                                           'evpn_msite_bgw_delay_restore_time', 30]],
                                         'verify_conf': False,
                                         'kwargs': {}}},
                     verify_ops={'ops.vxlan.vxlan.Vxlan': {
                                         'requirements': [['nve', 'multisite_convergence_time', 30]],
                                         'kwargs': {'attributes': ['nve[(.*)][vni][(.*)]',
                                                                   'nve[evpn_multisite_border_gateway]',
                                                                   'nve[multisite_convergence_time]','bgp_l2vpn_evpn','l2route']},
                                         'exclude': vxlan_exclude+ ['bgp_l2vpn_evpn','l2route'] }},
-                    num_values={'nve_name': 1, 'nve_vni':1 ,'border_gateway':1 })
+                    num_values={'nve_name': 1, 'nve_vni':1 ,'evpn_multisite_border_gateway':1 })
 
 class TriggerAddRemoveNveVniMcastGroup(TriggerAddRemove):
     """Add mcast group under vxlan and then restore the
         configuration by reapplying the whole running configuration"""
 
     __description__ = """Add mcast group under Vxlan then restore the
                          configuration by reapplying the whole running configuration
@@ -198,15 +214,25 @@
                    Buffer recovery timeout make sure devices are recovered at the
                    end of the trigger execution. Used when previous timeouts have
                    been exhausted.
                    max_time (`int`): Maximum wait time for the last step of the
                                      trigger in seconds. Default: 180
                    interval (`int`): Wait time between iteration when looping is
                                      needed in seconds. Default: 15
-
+               static:
+                   The keys below are dynamically learnt by default.
+                   However, they can also be set to a custom value when provided in the trigger datafile.
+
+                   nve_name: `str`
+                   nve_vni: `int`
+                   mcast_group: `str`
+
+                   (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                         OR
+                         interface: 'Ethernet1/1/1' (Specific value)
        Steps:
            1. Learn Vxlan Ops configured on device. SKIP the trigger if there
               is no vxlan configured on the device.
            2. Save the current device configurations using "method" specified.
            3. Add mcast group that using Genie Interface Conf.
            4. Verify the newly mcast group under Vxlan is reflected in
               device configuration.
@@ -274,14 +300,24 @@
                        Buffer recovery timeout make sure devices are recovered at the
                        end of the trigger execution. Used when previous timeouts have
                        been exhausted.
                        max_time (`int`): Maximum wait time for the last step of the
                                          trigger in seconds. Default: 180
                        interval (`int`): Wait time between iteration when looping is
                                          needed in seconds. Default: 15
+                   static:
+                       The keys below are dynamically learnt by default.
+                       However, they can also be set to a custom value when provided in the trigger datafile.
+
+                       nve_name: `str`
+                       nve_vni: `int`
+
+                       (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                             OR
+                             interface: 'Ethernet1/1/1' (Specific value)
 
            Steps:
                1. Learn Vxlan Ops configured on device. SKIP the trigger if there
                   is no vxlan configured on the device.
                2. Save the current device configurations using "method" specified.
                3. Add multisite ingress replication that using Genie Interface Conf.
                4. Verify the newly multisite ingress replication under Vxlan is reflected in
@@ -341,14 +377,24 @@
                           Buffer recovery timeout make sure devices are recovered at the
                           end of the trigger execution. Used when previous timeouts have
                           been exhausted.
                           max_time (`int`): Maximum wait time for the last step of the
                                             trigger in seconds. Default: 180
                           interval (`int`): Wait time between iteration when looping is
                                             needed in seconds. Default: 15
+                      static:
+                          The keys below are dynamically learnt by default.
+                          However, they can also be set to a custom value when provided in the trigger datafile.
+
+                          nve_name: `str`
+                          source_if: `str`
+
+                          (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                                OR
+                                interface: 'Ethernet1/1/1' (Specific value)
 
               Steps:
                   1. Learn Vxlan Ops configured on device. SKIP the trigger if there
                      is no Vxlan configured on the device.
                   2. Save the current device configurations using "method" specified.
                   3. Add multisite bgw interface that using Genie Interface Conf.
                   4. Verify the newly multisite bgw interface under Vxlan is reflected in
```

## genie/libs/sdk/triggers/clear/clear.py

```diff
@@ -111,15 +111,15 @@
         '''
         # update the verify_ops callable with required information
         for req in self.mapping._verify_ops_dict.values():
             for item in req.get('requirements', {}):
                 if not callable(item[0]):
                     continue
                 ret = item[0]
-                ret.keywords.update({'uut': uut, 'pre_time': self.pre_time, 'mapping': self.mapping})
+                ret.keywords.update({'uut': uut, 'pre_time': self.pre_time})
 
         try:
             self.mapping.verify_ops(device=uut, abstract=abstract,
                                     steps=steps)
         except Exception as e:
             self.failed("The clear verification has failed", from_exception=e)
```

## genie/libs/sdk/triggers/disableenable/bgp/nxos/disableenable.py

```diff
@@ -47,14 +47,24 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                bgp_id: `int`
+
+              (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn BGP Ops object and store the BGP instance(s)
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Disable BGP feature with command "no feature bgp"
            via BGP Conf object
```

## genie/libs/sdk/triggers/disableenable/hsrp/nxos/disableenable.py

```diff
@@ -41,14 +41,27 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+                address_family: `str`
+                version: `int`
+                groups: `int`
+                standby_router: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn HSRP Ops object and store the HSRP group(s)
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Disable HSRP feature with command "no feature hsrp"
            via HSRP Conf object
```

## genie/libs/sdk/triggers/disableenable/mcast/nxos/disableenable.py

```diff
@@ -41,14 +41,24 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
+
 
     steps:
         1. Learn Mcast Ops object and store the Mcast vrf(s) with ipv4 feature enabled
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Disable pim feature with command "no feature pim"
            via Mcast Conf object
@@ -74,16 +84,17 @@
                                     'exclude': mcast_exclude}})
     # feature name
     # used for creating checkpoint name and log information
     feature_name = 'pim'
 
 
 class TriggerDisableEnablePim6(TriggerDisableEnable):
-    """Disable and enable feature Pim6.
+    """Disable and enable feature Pim6."""
 
+    __description__ = """Disable and enable feature Pim6.
     trigger_datafile:
         Mandatory:
             timeout: 
                 max_time (`int`): Maximum wait time for the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
@@ -103,15 +114,23 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Mcast Ops object and store the Mcast vrf(s) with ipv6 feature enabled
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Disable pim6 feature with command "no feature pim6"
            via Mcast Conf object
         4. Verify the state of feature pim6 is "disabled"
```

## genie/libs/sdk/triggers/disableenable/vxlan/nxos/disableenable.py

```diff
@@ -125,15 +125,17 @@
            learn Vxlan Ops again and verify it is the same as the Ops in step 1
 
     """
     mapping = Mapping(requirements={'ops.vxlan.vxlan.Vxlan': {
                                         'requirements': [['nve', 'enabled_vn_segment_vlan_based', True]],
                                         'kwargs': {'attributes': ['nve','l2route','bgp_l2vpn_evpn']},
                                         'exclude': vxlan_exclude + multisite_exclude + ['tx_id','peer_id','flags','pathnr',
-                                                                    'bestpathnr','totalpaths','prefix','advertisedto','resettime','resetreason']}},
+                                                                    'bestpathnr','totalpaths','prefix','advertisedto',
+                                                                    'resettime','resetreason','memoryused','prefixreceived',
+                                                                                        'totalnetworks']}},
                     config_info={'conf.vxlan.Vxlan': {
                                     'requirements': [['device_attr', '{uut}', 'enabled_vn_segment_vlan_based', True]],
                                     'verify_conf': False}},
                     verify_ops={'ops.vxlan.vxlan.Vxlan': {
                                     'requirements': [['nve', 'enabled_vn_segment_vlan_based', False]],
                                     'kwargs': {'attributes': ['nve','l2route','bgp_l2vpn_evpn']},
                                     'exclude': vxlan_exclude + ['l2route','bgp_l2vpn_evpn']}},
```

## genie/libs/sdk/triggers/ha/ha.py

```diff
@@ -117,31 +117,33 @@
            Returns:
                None
 
            Raises:
                pyATS Results
         '''
         # initial UpdateLearntDatabase object to update the database
-        update_obj = UpdateLearntDatabase(obj=self, device=uut)
+        update_obj = UpdateLearntDatabase(obj=self, device=uut,
+                                          update_ver_list=update_verifications,
+                                          update_feature_list=update_pts_features)
+
 
         # update global/local verification
-        if update_verifications:
-            with steps.start("Update global and local verifications for {}"
-              .format(update_verifications)) as step:
-                update_obj.update_verification(abstract=abstract,
-                                               update_ver_list=update_verifications)
+        with steps.start("Update global and local verifications for {}"
+          .format(update_verifications)) as step:
+            update_obj.update_verification()
 
         # update platform pts
         # update chassis_sn and slot info
-        if update_pts_features:
-            with steps.start("Update PTS for features {}"
-              .format(update_pts_features)) as step:
-                update_obj.update_pts(abstract=abstract,
-                                      update_feature_list=update_pts_features,
-                                      update_attributes={'platform': ['chassis_sn', 'slot', 'virtual_device']})
+        with steps.start("Update PTS for features {}"
+          .format(update_pts_features)) as step:
+            update_obj.update_pts(update_attributes={'platform': ['chassis_sn', 'slot', 'virtual_device']})
+        # print messages
+        update_obj.local_summary.print()
+        update_obj.global_summary.print()
+        update_obj.pts_summary.print()
 
 
 class TriggerReload(ReloadTemplate):
     '''Trigger class for Reload action'''
 
     @aetest.setup
     def verify_prerequisite(self, uut, abstract, steps, timeout):
@@ -252,31 +254,33 @@
            Returns:
                None
 
            Raises:
                pyATS Results
         '''
         # initial UpdateLearntDatabase object to update the database
-        update_obj = UpdateLearntDatabase(obj=self, device=uut)
+        update_obj = UpdateLearntDatabase(obj=self, device=uut,
+                                          update_ver_list=update_verifications,
+                                          update_feature_list=update_pts_features)
+
 
         # update global/local verification
-        if update_verifications:
-            with steps.start("Update global and local verifications for {}"
-              .format(update_verifications)) as step:
-                update_obj.update_verification(abstract=abstract,
-                                               update_ver_list=update_verifications)
+        with steps.start("Update global and local verifications for {}"
+          .format(update_verifications)) as step:
+            update_obj.update_verification()
 
         # update platform pts
         # update chassis_sn and slot info
-        if update_pts_features:
-            with steps.start("Update PTS for features {}"
-              .format(update_pts_features)) as step:
-                update_obj.update_pts(abstract=abstract,
-                                      update_feature_list=update_pts_features,
-                                      update_attributes={'platform': ['chassis_sn', 'slot', 'virtual_device']})
+        with steps.start("Update PTS for features {}"
+          .format(update_pts_features)) as step:
+            update_obj.update_pts(update_attributes={'platform': ['chassis_sn', 'slot', 'virtual_device']})
+        # print messages
+        update_obj.local_summary.print()
+        update_obj.global_summary.print()
+        update_obj.pts_summary.print()
 
 
 class TriggerReloadLc(TriggerReload):
     '''Trigger class for Reload LCs action'''
 
     @aetest.test
     def reload(self, uut, abstract, steps, lcRole=None):
@@ -472,24 +476,27 @@
            Returns:
                None
 
            Raises:
                pyATS Results
         '''
         # initial UpdateLearntDatabase object to update the database
-        update_obj = UpdateLearntDatabase(obj=self, device=uut)
+        update_obj = UpdateLearntDatabase(obj=self, device=uut,
+                                          update_ver_list=update_verifications,
+                                          update_feature_list=update_pts_features)
+
 
         # update global/local verification
-        if update_verifications:
-            with steps.start("Update global and local verifications for {}"
-              .format(update_verifications)) as step:
-                update_obj.update_verification(abstract=abstract,
-                                               update_ver_list=update_verifications)
+        with steps.start("Update global and local verifications for {}"
+          .format(update_verifications)) as step:
+            update_obj.update_verification()
 
         # update platform pts
         # update chassis_sn and slot info
-        if update_pts_features:
-            with steps.start("Update PTS for features {}"
-              .format(update_pts_features)) as step:
-                update_obj.update_pts(abstract=abstract,
-                                      update_feature_list=update_pts_features,
-                                      update_attributes={'platform': ['chassis_sn', 'slot', 'virtual_device']})
+        with steps.start("Update PTS for features {}"
+          .format(update_pts_features)) as step:
+            update_obj.update_pts(update_attributes={'platform': ['chassis_sn', 'slot', 'virtual_device']})
+        # print messages
+        update_obj.local_summary.print()
+        update_obj.global_summary.print()
+        update_obj.pts_summary.print()
+
```

## genie/libs/sdk/triggers/ha/issu/iosxe/asr1k/issu.py

```diff
@@ -20,14 +20,47 @@
 platform_exclude = ['maker', 'rp_uptime', 'sn', 'main_mem',
                     'switchover_reason', 'config_register']
 
 
 class TriggerIssu(CommonIssu):
     """Do ISSU on device."""
 
+    __description__ = """"Do ISSU on device.
+
+     trigger_datafile:
+         Mandatory:
+             timeout:
+                 max_time (`int`): Maximum wait time for the trigger,
+                                 in second. Default: 180
+                 interval (`int`): Wait time between iteration when looping is needed,
+                                 in second. Default: 15
+         Optional:
+             tgn_timeout (`int`): Maximum wait time for all traffic threads to be
+                                  restored to the reference rate,
+                                  in second. Default: 60
+             tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
+                                in second. Default: 10
+             static:
+                 The keys below are dynamically learnt by default.
+                 However, they can also be set to a custom value when provided in the trigger datafile.
+
+                 active_rp: `str`
+                 standby_rp: `str`
+
+                 (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
+     steps:
+         1. Learn Platform Ops object and store the state of active rp ans standby rp
+            if has any, otherwise, SKIP the trigger
+         2. Do Issue on device.
+         3. Learn Platform Ops again and the ops are the same as the Ops in step 1
+
+     """
+
     # Parse argv for '--issu_upgrade_image'
     def parse_args(self, argv):
         parser = argparse.ArgumentParser()
         parser.add_argument('--issu_upgrade_image',
                             default=None,
                             help='URL path of the ISSU upgrade image')
         self.parameters['upgrade_image'] = parser.parse_args(argv).issu_upgrade_image
```

## genie/libs/sdk/triggers/ha/reload/iosxe/asr1k/reload.py

```diff
@@ -227,15 +227,23 @@
             lcRole (`str`): The role of LC which is 'active'
         Optional:
             tgn_timeout (`int`): Maximum wait time for all traffic threads to be
                                  restored to the reference rate,
                                  in second. Default: 60
             tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
                                in second. Default: 10
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
 
+                standby_rp: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                   OR
+                   interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Platform Ops object and store the "ok, standby" RP
            if has any, otherwise, SKIP the trigger
         2. Do reload by command "hw-module slot <lc> reload"
         3. Learn Platform Ops again and the ops are the same as the Ops in step 1
         4. Update platform PTS if feature pts is enabled,
            Update global/local veirifications if enabled
```

## genie/libs/sdk/triggers/ha/reload/iosxe/c3850/reload.py

```diff
@@ -169,15 +169,25 @@
             lcRole (`str`): The role of LC which is 'active'
         Optional:
             tgn_timeout (`int`): Maximum wait time for all traffic threads to be
                                  restored to the reference rate,
                                  in second. Default: 60
             tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
                                in second. Default: 10
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                active_rp: `str`
+                standby_rp: `str`
+                members: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                   OR
+                   interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Platform Ops object and store the "active" and "standby" switch
            if has any, otherwise, SKIP the trigger
         2. Do reload by command "reload slot <lc>"
         3. Learn Platform Ops again and verify the role of "active" switch changes to "standby",
            verify the role of "standby" switch changes to "member",
            verify the role of "member" switch with highest priority changes to "standby",
@@ -232,15 +242,24 @@
             lcRole (`str`): The role of LC which is 'standby'
         Optional:
             tgn_timeout (`int`): Maximum wait time for all traffic threads to be
                                  restored to the reference rate,
                                  in second. Default: 60
             tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
                                in second. Default: 10
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                standby_rp: `str`
+                members: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                   OR
+                   interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Platform Ops object and store the "standby" switch and "member" switch(es)
            if has any, otherwise, SKIP the trigger
         2. Do reload by command "reload slot <lc>"
         3. Learn Platform Ops again and verify role of "standby" switch changes to "member",
            verify the role of "member" switch with highest priority changes to "standby",
            and verify left attributes from the ops are the same as the Ops in step 1
@@ -287,15 +306,23 @@
                                 in second. Default: 15
         Optional:
             tgn_timeout (`int`): Maximum wait time for all traffic threads to be
                                  restored to the reference rate,
                                  in second. Default: 60
             tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
                                in second. Default: 10
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                members: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                   OR
+                   interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Platform Ops object and store the "member" switch(es)
            if has any, otherwise, SKIP the trigger
         2. Do reload by command "reload slot <lc>"
         3. Learn Platform Ops again and the ops are the same as the Ops in step 1
         4. Update platform PTS if feature pts is enabled,
            Update global/local veirifications if enabled
```

## genie/libs/sdk/triggers/ha/reload/iosxe/csr1000v/reload.py

```diff
@@ -34,15 +34,26 @@
                                 in second. Default: 15
         Optional:
             tgn_timeout (`int`): Maximum wait time for all traffic threads to be
                                  restored to the reference rate,
                                  in second. Default: 60
             tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
                                in second. Default: 10
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
 
+                rp: `str`
+                oc: `str`
+                rp_state: `str`
+                oc_state: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                   OR
+                   interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Platform Ops object and store the "ok, active|ok, standby|Ready" slot(s)
            if has any, otherwise, SKIP the trigger
         2. Do reload by command "reload"
         3. Learn Platform Ops again and verify the state of RP(s) is 
            "ok, active|ok, standby", verify every LC status is "Ready",
            and verify left attributes from the ops are the same as the Ops in step 1
@@ -52,15 +63,15 @@
     """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictates which key to verify
     mapping = Mapping(requirements={'ops.platform.platform.Platform':{
                                         'requirements': [\
                                             ['slot', 'rp', '(?P<rp>.*)',
-                                              'state', '(?P<state>ok, active|ok, standby|Ready)'],
+                                              'state', '(?P<rp_state>ok, active|ok, standby|Ready)'],
                                             ['slot', 'oc', '(?P<oc>.*)',
                                               'state', '(?P<oc_state>ok, active|ok, standby|ok|ps, fail)'],
                                           ],
                                         'all_keys': True,
                                         'exclude': platform_exclude}},
                       verify_ops={'ops.platform.platform.Platform':{
                                       'requirements': [\
```

## genie/libs/sdk/triggers/ha/reload/nxos/reload.py

```diff
@@ -336,15 +336,15 @@
                                           ['slot', 'rp', '(?P<standby_rp>.*)',
                                            'redundancy_state', 'active'],
                                           ['slot', 'rp', '(?P<standby_rp>.*)',
                                            'state', 'active'],
                                           ['slot', 'lc', '(?P<lc>.*)',
                                            'state', '(ok|active|standby)']],
                                     'exclude': platform_exclude}},
-                      num_values={'active_rp':1, 'standby_rp':1})
+                      num_values={'active_rp':1, 'standby_rp':1, 'lc':1})
 
 
 class TriggerReloadStandbyRP(TriggerReloadLc):
     """Reload standby supervisor module on device."""
 
     __description__ = """Reload standby supervisor module on device.
```

## genie/libs/sdk/triggers/ha/switchover/iosxe/asr1k/switchover.py

```diff
@@ -34,15 +34,24 @@
                                 in second. Default: 15
         Optional:
             tgn_timeout (`int`): Maximum wait time for all traffic threads to be
                                  restored to the reference rate,
                                  in second. Default: 60
             tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
                                in second. Default: 10
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
 
+                active_rp: `str`
+                standby_rp: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Platform Ops object and store the "active" RP and "standby" RP
            if has any, otherwise, SKIP the trigger
         2. Do switchover by command "redundancy force-switchover"
         3. Learn Platform Ops again and verify the roles of 
            "active" RP and "standby" RP are swapped,
            and verify left attributes from the ops are the same as the Ops in step 1
```

## genie/libs/sdk/triggers/ha/switchover/iosxe/c3850/switchover.py

```diff
@@ -37,14 +37,25 @@
                                 in second. Default: 15
         Optional:
             tgn_timeout (`int`): Maximum wait time for all traffic threads to be
                                  restored to the reference rate,
                                  in second. Default: 60
             tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
                                in second. Default: 10
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                active_rp: `str`
+                standby_rp: `str`
+                members: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn Platform Ops object and store the "active" RP and "standby" RP
            if has any, otherwise, SKIP the trigger
         2. Do switchover by command "redundancy force-switchover"
         3. Learn Platform Ops again and verify the roles of 
            "active" RP and "standby" RP are swapped,
```

## genie/libs/sdk/triggers/ha/switchover/iosxr/switchover.py

```diff
@@ -33,15 +33,27 @@
                                 in second. Default: 15
         Optional:
             tgn_timeout (`int`): Maximum wait time for all traffic threads to be
                                  restored to the reference rate,
                                  in second. Default: 60
             tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
                                in second. Default: 10
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
 
+                active_rp: `str`
+                standby_rp: `str`
+                virtual_device: `str`
+                active_device: `str`
+                standby_device: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Platform Ops object and store the "active" RP and "standby" RP
            if has any, otherwise, SKIP the trigger
         2. Do switchover by command "redundancy switchover"
         3. Learn Platform Ops again and verify the roles of 
            "active" RP and "standby" RP are swapped,
            and verify left attributes from the ops are the same as the Ops in step 1
```

## genie/libs/sdk/triggers/ha/switchover/nxos/switchover.py

```diff
@@ -35,15 +35,25 @@
                                 in second. Default: 15
         Optional:
             tgn_timeout (`int`): Maximum wait time for all traffic threads to be
                                  restored to the reference rate,
                                  in second. Default: 60
             tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
                                in second. Default: 10
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
 
+                active_rp: `str`
+                standby_rp: `str`
+                lc: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Platform Ops object and store the "active" RP and "standby" RP
            if has any, otherwise, SKIP the trigger
         2. Do switchover by command "system switchover"
         3. Learn Platform Ops again and verify the roles of 
            "active" RP and "standby" RP are swapped,
            and verify left attributes from the ops are the same as the Ops in step 1
```

## genie/libs/sdk/triggers/modify/bgp/modify.py

```diff
@@ -51,14 +51,28 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `vrf`
+                neighbor: `str`
+                address_family: `str`
+                remote_as: `int`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn BGP Ops object and store the "established" BGP neighbor(s) which has 
            remote-as configured. SKIP the trigger if there is no BGP neighbor(s) found
         2. Save the current device configurations through "method" which user uses
         3. Modify the remote-as number of the learned BGP neighbor(s) from step 1
            with BGP Conf object
@@ -143,15 +157,26 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `vrf`
+                cluster_id: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn BGP Ops object and store the BGP instance(s) which has cluster id
            configured. SKIP the trigger if there is no BGP instance(s) found
         2. Save the current device configurations through "method" which user uses
         3. Modify the cluster id of the learned BGP neighbor(s) from step 1
            with BGP Conf object
         4. Verify the cluster id of learned BGP neighbor(s) from step 3
@@ -212,14 +237,27 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `vrf`
+                neighbor: `str`
+                route_map: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn BGP Ops object and store the BGP neighbors(s) which has inbound route-map
            configured. SKIP the trigger if there is no BGP neighbors(s) found
         2. Save the current device configurations through "method" which user uses
         3. Modify the inbound route-map of the learned BGP neighbor(s) from step 1
            with BGP Conf object
```

## genie/libs/sdk/triggers/modify/bgp/iosxe/modify.py

```diff
@@ -16,14 +16,72 @@
                'route_reflector_client', 'capability',
                'distance_internal_as', 'bgp_neighbor_counters', 'memory_usage',
                'total_entries', 'routing_table_version', 'total_memory',
                'path', 'prefixes', 'cluster_id']
 
 
 class TriggerModifyBgpNeighborAsn(TriggerModify):
+    """Modify the neighbor remote_as configured under BGP and then restore the
+      configuration by reapplying the whole running configuration"""
+
+    __description__ = """Modify the neighbor remote_as configured under BGP and then restore the
+      configuration by reapplying the whole running configuration
+
+      trigger_datafile:
+          Mandatory Arguments:
+              timeout:
+                  max_time (`int`): Maximum wait time for the trigger in seconds.
+                                    Default: 180
+                  interval (`int`): Wait time between iteration when looping is
+                                    needed in seconds. Default: 15
+                  method (`str`): Method to recover the device configuration.
+                                  Supported methods:
+                                      'checkpoint': Rollback the configuration
+                                                    using checkpoint (nxos),
+                                                    archive file (iosxe),
+                                                    load the saved running-config
+                                                    file on disk (iosxr)
+          Optional Arguments:
+              tgn_timeout (`int`): Maximum wait time for all traffic streams to be
+                                   restored to the reference rate in seconds.
+                                   Default: 60
+              tgn_delay (`int`): Wait time between each poll to verify if traffic
+                                 is resumed in seconds. Default: 10
+              timeout_recovery:
+                  Buffer recovery timeout make sure devices are recovered at the
+                  end of the trigger execution. Used when previous timeouts have
+                  been exhausted.
+                  max_time (`int`): Maximum wait time for the last step of the
+                                    trigger in seconds. Default: 180
+                  interval (`int`): Wait time between iteration when looping is
+                                    needed in seconds. Default: 15
+              static:
+                  The keys below are dynamically learnt by default.
+                  However, they can also be set to a custom value when provided in the trigger datafile.
+
+                  instance: `str`
+                  vrf: `str`
+                  neighbor: `str`
+                  remote_as: `int`
+                  bgp_id: `int`
+
+                  (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                        OR
+                        interface: 'Ethernet1/1/1' (Specific value)
+      Steps:
+          1. Learn BGP Ops configured on device. SKIP the trigger if there
+             is no BGP configured on the device.
+          2. Save the current device configurations using "method" specified.
+          3. Modify the remote-as learned in step 1 using Genie BGP Conf.
+          4. Verify the change to remote_as config under BGP is
+             reflected in device configuration.
+          5. Restore the device configuration to the original configuration saved
+             in step 2.
+          6. Learn BGP Ops again and verify it is the same as the Ops in step 1.
+      """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictates which key to verify
     mapping = Mapping(requirements={'ops.bgp.bgp.Bgp':{
                                           'requirements':[['info', 'instance', '(?P<instance>.*)',
                                                            'vrf', '(?P<vrf>.*)', 'neighbor',
                                                            '(?P<neighbor>.*)', 'remote_as',
@@ -50,15 +108,70 @@
                                                    '(?P<neighbor>.*)', 'session_state', 'idle']],
                                     'kwargs':{'attributes':['info']},
                                     'exclude': bgp_exclude}},
                       num_values={'vrf':1, 'instance':1, 'neighbor':1})
 
 
 class TriggerModifyBgpNeighborCluster(TriggerModify):
+    """Modify the cluster id configured under BGP and then restore the
+      configuration by reapplying the whole running configuration"""
 
+    __description__ = """Modify the cluster id configured under BGP and then restore the
+      configuration by reapplying the whole running configuration
+
+      trigger_datafile:
+          Mandatory Arguments:
+              timeout:
+                  max_time (`int`): Maximum wait time for the trigger in seconds.
+                                    Default: 180
+                  interval (`int`): Wait time between iteration when looping is
+                                    needed in seconds. Default: 15
+                  method (`str`): Method to recover the device configuration.
+                                  Supported methods:
+                                      'checkpoint': Rollback the configuration
+                                                    using checkpoint (nxos),
+                                                    archive file (iosxe),
+                                                    load the saved running-config
+                                                    file on disk (iosxr)
+          Optional Arguments:
+              tgn_timeout (`int`): Maximum wait time for all traffic streams to be
+                                   restored to the reference rate in seconds.
+                                   Default: 60
+              tgn_delay (`int`): Wait time between each poll to verify if traffic
+                                 is resumed in seconds. Default: 10
+              timeout_recovery:
+                  Buffer recovery timeout make sure devices are recovered at the
+                  end of the trigger execution. Used when previous timeouts have
+                  been exhausted.
+                  max_time (`int`): Maximum wait time for the last step of the
+                                    trigger in seconds. Default: 180
+                  interval (`int`): Wait time between iteration when looping is
+                                    needed in seconds. Default: 15
+              static:
+                  The keys below are dynamically learnt by default.
+                  However, they can also be set to a custom value when provided in the trigger datafile.
+
+                  instance: `str`
+                  cluster_id: `str`
+                  bgp_id: `int`
+
+                  (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                        OR
+                        interface: 'Ethernet1/1/1' (Specific value)
+      Steps:
+          1. Learn BGP Ops configured on device. SKIP the trigger if there
+             is no BGP configured on the device.
+          2. Save the current device configurations using "method" specified.
+          3. Modify the cluster id learned in step 1 using Genie BGP Conf.
+          4. Verify the change to cluster id config under BGP is
+             reflected in device configuration.
+          5. Restore the device configuration to the original configuration saved
+             in step 2.
+          6. Learn BGP Ops again and verify it is the same as the Ops in step 1.
+    """
     # Mapping of Information between Ops and Conf
     # Also permit to dictates which key to verify
     mapping = Mapping(requirements={'ops.bgp.bgp.Bgp':{
                                          'requirements':[['info', 'instance', '(?P<instance>.*)',
                                              'vrf', 'default', 'cluster_id', '(?P<cluster_id>.*)'],
                                                         ['info', 'instance', '(?P<instance>.*)', 'bgp_id', '(?P<bgp_id>.*)']],
                                                     'all_keys':True,
@@ -74,14 +187,73 @@
                                                      'default', 'cluster_id', '1.0.0.1']],
                                     'kwargs':{'attributes':['info']},
                                     'exclude': bgp_exclude}},
                       num_values={'instance':1, 'neighbor':1, 'address_family':1})
 
 
 class TriggerModifyBgpNeighborRoutemapIn(TriggerModify):
+    """Modify the neighbor inbound route map configured under BGP and then restore the
+          configuration by reapplying the whole running configuration"""
+
+    __description__ = """Modify the neighbor inbound route map configured under BGP and then restore the
+      configuration by reapplying the whole running configuration
+
+      trigger_datafile:
+          Mandatory Arguments:
+              timeout:
+                  max_time (`int`): Maximum wait time for the trigger in seconds.
+                                    Default: 180
+                  interval (`int`): Wait time between iteration when looping is
+                                    needed in seconds. Default: 15
+                  method (`str`): Method to recover the device configuration.
+                                  Supported methods:
+                                      'checkpoint': Rollback the configuration
+                                                    using checkpoint (nxos),
+                                                    archive file (iosxe),
+                                                    load the saved running-config
+                                                    file on disk (iosxr)
+          Optional Arguments:
+              tgn_timeout (`int`): Maximum wait time for all traffic streams to be
+                                   restored to the reference rate in seconds.
+                                   Default: 60
+              tgn_delay (`int`): Wait time between each poll to verify if traffic
+                                 is resumed in seconds. Default: 10
+              timeout_recovery:
+                  Buffer recovery timeout make sure devices are recovered at the
+                  end of the trigger execution. Used when previous timeouts have
+                  been exhausted.
+                  max_time (`int`): Maximum wait time for the last step of the
+                                    trigger in seconds. Default: 180
+                  interval (`int`): Wait time between iteration when looping is
+                                    needed in seconds. Default: 15
+              static:
+                  The keys below are dynamically learnt by default.
+                  However, they can also be set to a custom value when provided in the trigger datafile.
+
+                  instance: `str`
+                  vrf: `vrf`
+                  neighbor: `str`
+                  address_family: `str`
+                  route_map: `str`
+                  bgp_id: `int`
+
+                  (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                        OR
+                        interface: 'Ethernet1/1/1' (Specific value)
+      Steps:
+          1. Learn BGP Ops configured on device. SKIP the trigger if there
+             is no BGP configured on the device.
+          2. Save the current device configurations using "method" specified.
+          3. Modify the inbound route map learned in step 1 using Genie BGP Conf.
+          4. Verify the change to inbound route map config under BGP is
+             reflected in device configuration.
+          5. Restore the device configuration to the original configuration saved
+             in step 2.
+          6. Learn BGP Ops again and verify it is the same as the Ops in step 1.
+    """
 
     # Create a name for router map in
     new_name = 'bgp_' + time.ctime().replace(' ', '_').replace(':', '_')
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictates which key to verify
     mapping = Mapping(requirements={'ops.bgp.bgp.Bgp':{
@@ -108,14 +280,73 @@
                                     'kwargs':{'attributes':['info']},
                                     'exclude': bgp_exclude}},
                       num_values={'vrf':1, 'instance':1, 'neighbor':1,
                                   'address_family':1})
 
 
 class TriggerModifyBgpNeighborRoutemapOut(TriggerModify):
+    """Modify the neighbor outbound route map configured under BGP and then restore the
+          configuration by reapplying the whole running configuration"""
+
+    __description__ = """Modify the neighbor outbound route map configured under BGP and then restore the
+          configuration by reapplying the whole running configuration
+
+          trigger_datafile:
+              Mandatory Arguments:
+                  timeout:
+                      max_time (`int`): Maximum wait time for the trigger in seconds.
+                                        Default: 180
+                      interval (`int`): Wait time between iteration when looping is
+                                        needed in seconds. Default: 15
+                      method (`str`): Method to recover the device configuration.
+                                      Supported methods:
+                                          'checkpoint': Rollback the configuration
+                                                        using checkpoint (nxos),
+                                                        archive file (iosxe),
+                                                        load the saved running-config
+                                                        file on disk (iosxr)
+              Optional Arguments:
+                  tgn_timeout (`int`): Maximum wait time for all traffic streams to be
+                                       restored to the reference rate in seconds.
+                                       Default: 60
+                  tgn_delay (`int`): Wait time between each poll to verify if traffic
+                                     is resumed in seconds. Default: 10
+                  timeout_recovery:
+                      Buffer recovery timeout make sure devices are recovered at the
+                      end of the trigger execution. Used when previous timeouts have
+                      been exhausted.
+                      max_time (`int`): Maximum wait time for the last step of the
+                                        trigger in seconds. Default: 180
+                      interval (`int`): Wait time between iteration when looping is
+                                        needed in seconds. Default: 15
+                  static:
+                      The keys below are dynamically learnt by default.
+                      However, they can also be set to a custom value when provided in the trigger datafile.
+
+                      instance: `str`
+                      vrf: `vrf`
+                      neighbor: `str`
+                      address_family: `str`
+                      route_map: `str`
+                      bgp_id: `int`
+
+                      (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                            OR
+                            interface: 'Ethernet1/1/1' (Specific value)
+          Steps:
+              1. Learn BGP Ops configured on device. SKIP the trigger if there
+                 is no BGP configured on the device.
+              2. Save the current device configurations using "method" specified.
+              3. Modify the outbound route map learned out step 1 using Genie BGP Conf.
+              4. Verify the change to outbound route map config under BGP is
+                 reflected in device configuration.
+              5. Restore the device configuration to the original configuration saved
+                 in step 2.
+              6. Learn BGP Ops again and verify it is the same as the Ops in step 1.
+        """
 
     # Create a name for router map in
     new_name = 'bgp_' + time.ctime().replace(' ', '_').replace(':', '_')
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictates which key to verify
     mapping = Mapping(requirements={'ops.bgp.bgp.Bgp':{
```

## genie/libs/sdk/triggers/modify/bgp/iosxr/modify.py

```diff
@@ -5,14 +5,72 @@
 import collections
 
 # Genie Libs
 from genie.libs.sdk.libs.utils.mapping import Mapping
 from genie.libs.sdk.triggers.modify.bgp import modify
 
 class TriggerModifyBgpNeighborRoutemapIn(modify.TriggerModifyBgpNeighborRoutemapIn):
+    """Modify and revert the inbound route-map for dynamically learned BGP neighbors(s)."""
+
+    __description__ = """Modify and revert the inbound route-map for dynamically learned BGP neighbors(s).
+
+    trigger_datafile:
+        Mandatory:
+            timeout:
+                max_time (`int`): Maximum wait time for the trigger,
+                                in second. Default: 180
+                interval (`int`): Wait time between iteration when looping is needed,
+                                in second. Default: 15
+                method (`str`): Method to recover the device configuration,
+                              Support methods:
+                                'checkpoint': Rollback the configuration by
+                                              checkpoint (nxos),
+                                              archive file (iosxe),
+                                              load the saved running-config file on disk (iosxr)
+        Optional:
+            tgn_timeout (`int`): Maximum wait time for all traffic threads to be
+                                 restored to the reference rate,
+                                 in second. Default: 60
+            tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
+                               in second. Default: 10
+            timeout_recovery:
+                Buffer recovery timeout make sure devices are recovered at the end
+                of the trigger execution. Used when previous timeouts have been exhausted.
+
+                max_time (`int`): Maximum wait time for the last step of the trigger,
+                                in second. Default: 180
+                interval (`int`): Wait time between iteration when looping is needed,
+                                in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `vrf`
+                neighbor: `str`
+                address_family: `str`
+                route_map: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
+
+    steps:
+        1. Learn BGP Ops object and store the BGP neighbors(s) which has inbound route-map
+           configured. SKIP the trigger if there is no BGP neighbors(s) found
+        2. Save the current device configurations through "method" which user uses
+        3. Modify the inbound route-map of the learned BGP neighbor(s) from step 1
+           with BGP Conf object
+        4. Verify the inbound route-map of learned BGP neighbor(s) from step 3
+           changes to the modified name in step 3
+        5. Recover the device configurations to the one in step 2
+        6. Learn BGP Ops again and verify it is the same as the Ops in step 1
+
+    """
 
     config_info = collections.OrderedDict()
     config_info['conf.route_policy.RoutePolicy'] =\
                      {'requirements':[],
                       'verify_conf':False,
                       'kwargs':{'mandatory':{'name': modify.TriggerModifyBgpNeighborRoutemapIn.new_name}}}
 
@@ -44,14 +102,72 @@
                                     'kwargs':{'attributes':['info']},
                                     'exclude': modify.bgp_exclude}},
                       num_values={'vrf':1, 'instance':1, 'neighbor':1,
                                   'address_family':1})
 
 
 class TriggerModifyBgpNeighborRoutemapOut(modify.TriggerModifyBgpNeighborRoutemapOut):
+    """Modify and revert the outbound route-map for dynamically learned BGP neighbors(s)."""
+
+    __description__ = """Modify and revert the outbound route-map for dynamically learned BGP neighbors(s).
+
+        trigger_datafile:
+            Mandatory:
+                timeout:
+                    max_time (`int`): Maximum wait time for the trigger,
+                                    in second. Default: 180
+                    interval (`int`): Wait time between iteration when looping is needed,
+                                    in second. Default: 15
+                    method (`str`): Method to recover the device configuration,
+                                  Support methods:
+                                    'checkpoint': Rollback the configuration by
+                                                  checkpoint (nxos),
+                                                  archive file (iosxe),
+                                                  load the saved running-config file on disk (iosxr)
+            Optional:
+                tgn_timeout (`int`): Maximum wait time for all traffic threads to be
+                                     restored to the reference rate,
+                                     in second. Default: 60
+                tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
+                                   in second. Default: 10
+                timeout_recovery:
+                    Buffer recovery timeout make sure devices are recovered at the end
+                    of the trigger execution. Used when previous timeouts have been exhausted.
+
+                    max_time (`int`): Maximum wait time for the last step of the trigger,
+                                    in second. Default: 180
+                    interval (`int`): Wait time between iteration when looping is needed,
+                                    in second. Default: 15
+                static:
+                    The keys below are dynamically learnt by default.
+                    However, they can also be set to a custom value when provided in the trigger datafile.
+
+                    instance: `str`
+                    vrf: `vrf`
+                    neighbor: `str`
+                    address_family: `str`
+                    route_map: `str`
+                    bgp_id: `int`
+
+                    (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                        OR
+                        interface: 'Ethernet1/1/1' (Specific value)
+
+        steps:
+            1. Learn BGP Ops object and store the BGP neighbors(s) which has inbound route-map
+               configured. SKIP the trigger if there is no BGP neighbors(s) found
+            2. Save the current device configurations through "method" which user uses
+            3. Modify the outbound route-map of the learned BGP neighbor(s) from step 1
+               with BGP Conf object
+            4. Verify the outbound route-map of learned BGP neighbor(s) from step 3
+               changes to the modified name in step 3
+            5. Recover the device configurations to the one in step 2
+            6. Learn BGP Ops again and verify it is the same as the Ops in step 1
+
+        """
 
     config_info = collections.OrderedDict()
     config_info['conf.route_policy.RoutePolicy'] =\
                      {'requirements':[],
                       'verify_conf':False,
                       'kwargs':{'mandatory':{'name': modify.TriggerModifyBgpNeighborRoutemapOut.new_name}}}
```

## genie/libs/sdk/triggers/modify/bgp/nxos/modify.py

```diff
@@ -22,16 +22,18 @@
                'route_reflector_client', 'capability',
                'distance_internal_as', 'bgp_neighbor_counters', 'memory_usage',
                'total_entries', 'routing_table_version', 'total_memory',
                'path', 'prefixes', 'cluster_id']
 
 
 class TriggerModifyBgpKeepaliveHoldtime(TriggerModify):
-    """
-       Modify the keepalive interval and holdtime configured under BGP and then restore the
+    """Modify the keepalive interval and holdtime configured under BGP and then restore the
+       configuration by reapplying the whole running configuration"""
+
+    __description__= """Modify the keepalive interval and holdtime configured under BGP and then restore the
        configuration by reapplying the whole running configuration
 
        trigger_datafile:
            Mandatory Arguments:
                timeout:
                    max_time (`int`): Maximum wait time for the trigger in seconds.
                                      Default: 180
@@ -54,14 +56,28 @@
                    Buffer recovery timeout make sure devices are recovered at the
                    end of the trigger execution. Used when previous timeouts have
                    been exhausted.
                    max_time (`int`): Maximum wait time for the last step of the
                                      trigger in seconds. Default: 180
                    interval (`int`): Wait time between iteration when looping is
                                      needed in seconds. Default: 15
+               static:
+                    The keys below are dynamically learnt by default.
+                    However, they can also be set to a custom value when provided in the trigger datafile.
+
+                    instance: `str`
+                    vrf: `str`
+                    keepalive_interval: `int`
+                    holdtime: `int`
+                    neighbor: `str`
+                    bgp_id: `int`
+
+                    (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                        OR
+                        interface: 'Ethernet1/1/1' (Specific value)
 
        Steps:
            1. Learn BGP Ops configured on device. SKIP the trigger if there
               is no BGP configured on the device.
            2. Save the current device configurations using "method" specified.
            3. Modify the keepalive interval of BGP  pid learned in step 1 using
               Genie BGP Conf.
@@ -142,15 +158,28 @@
                 Buffer recovery timeout make sure devices are recovered at the
                 end of the trigger execution. Used when previous timeouts have
                 been exhausted.
                 max_time (`int`): Maximum wait time for the last step of the
                                   trigger in seconds. Default: 180
                 interval (`int`): Wait time between iteration when looping is
                                   needed in seconds. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                keepalive_interval: `int`
+                holdtime: `int`
+                neighbor: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     Steps:
         1. Learn BGP Ops configured on device. SKIP the trigger if there
            is no BGP configured on the device.
         2. Save the current device configurations using "method" specified.
         3. Modify the keepalive interval of BGP  pid learned in step 1 using
            Genie BGP Conf.
         4. Verify the change to keepalive interval config under BGP is
@@ -228,15 +257,27 @@
                 Buffer recovery timeout make sure devices are recovered at the
                 end of the trigger execution. Used when previous timeouts have
                 been exhausted.
                 max_time (`int`): Maximum wait time for the last step of the
                                   trigger in seconds. Default: 180
                 interval (`int`): Wait time between iteration when looping is
                                   needed in seconds. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                graceful_restart_restart_time: `int`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     Steps:
         1. Learn BGP Ops configured on device. SKIP the trigger if there
            is no BGP configured on the device.
         2. Save the current device configurations using "method" specified.
         3. Modify the graceful restart restart-time of BGP  pid learned in
            step 1 using  Genie BGP Conf.
         4. Verify the change to graceful restart restart-time config under BGP
@@ -311,15 +352,27 @@
                 Buffer recovery timeout make sure devices are recovered at the
                 end of the trigger execution. Used when previous timeouts have
                 been exhausted.
                 max_time (`int`): Maximum wait time for the last step of the
                                   trigger in seconds. Default: 180
                 interval (`int`): Wait time between iteration when looping is
                                   needed in seconds. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                graceful_restart_stalepath_time: `int`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     Steps:
         1. Learn BGP Ops configured on device. SKIP the trigger if there
            is no BGP configured on the device.
         2. Save the current device configurations using "method" specified.
         3. Modify the graceful restart stalepath-time of BGP pid learned in
            step 1 using  Genie BGP Conf.
         4. Verify the change to graceful restart stalepath-time config under
@@ -394,15 +447,28 @@
                 Buffer recovery timeout make sure devices are recovered at the
                 end of the trigger execution. Used when previous timeouts have
                 been exhausted.
                 max_time (`int`): Maximum wait time for the last step of the
                                   trigger in seconds. Default: 180
                 interval (`int`): Wait time between iteration when looping is
                                   needed in seconds. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                holdtime: `int`
+                keepalive_interval: `int`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     Steps:
         1. Learn BGP Ops configured on device. SKIP the trigger if there
            is no BGP configured on the device.
         2. Save the current device configurations using "method" specified.
         3. Modify the keepalive interval of BGP neighbor learned in
            step 1 using  Genie BGP Conf.
         4. Verify the change to keepalive interval config under BGP neighbor
@@ -497,15 +563,27 @@
                 Buffer recovery timeout make sure devices are recovered at the
                 end of the trigger execution. Used when previous timeouts have
                 been exhausted.
                 max_time (`int`): Maximum wait time for the last step of the
                                   trigger in seconds. Default: 180
                 interval (`int`): Wait time between iteration when looping is
                                   needed in seconds. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                max_hop: `int`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     Steps:
         1. Learn BGP Ops configured on device. SKIP the trigger if there
            is no BGP configured on the device.
         2. Save the current device configurations using "method" specified.
         3. Modify the EBGP multihop of BGP neighbor learned in
            step 1 using  Genie BGP Conf.
         4. Verify the change to EBGP multihop config under BGP neighbor
@@ -575,15 +653,27 @@
                 Buffer recovery timeout make sure devices are recovered at the
                 end of the trigger execution. Used when previous timeouts have
                 been exhausted.
                 max_time (`int`): Maximum wait time for the last step of the
                                   trigger in seconds. Default: 180
                 interval (`int`): Wait time between iteration when looping is
                                   needed in seconds. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                update_source: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     Steps:
         1. Learn BGP Ops configured on device. SKIP the trigger if there
            is no BGP configured on the device.
         2. Save the current device configurations using "method" specified.
         3. Modify the update source of BGP neighbor learned in
            step 1 using  Genie BGP Conf.
         4. Verify the change to update source config under BGP neighbor
@@ -650,15 +740,28 @@
                 Buffer recovery timeout make sure devices are recovered at the
                 end of the trigger execution. Used when previous timeouts have
                 been exhausted.
                 max_time (`int`): Maximum wait time for the last step of the
                                   trigger in seconds. Default: 180
                 interval (`int`): Wait time between iteration when looping is
                                   needed in seconds. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                address_family: `str`
+                maximum_prefix_max_prefix_no: `int`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     Steps:
         1. Learn BGP Ops configured on device. SKIP the trigger if there
            is no BGP configured on the device.
         2. Save the current device configurations using "method" specified.
         3. Modify the maximum prefixes of BGP neighbor learned in
            step 1 using  Genie BGP Conf.
         4. Verify the change to maximum prefixes config under BGP neighbor
@@ -725,15 +828,28 @@
                 Buffer recovery timeout make sure devices are recovered at the
                 end of the trigger execution. Used when previous timeouts have
                 been exhausted.
                 max_time (`int`): Maximum wait time for the last step of the
                                   trigger in seconds. Default: 180
                 interval (`int`): Wait time between iteration when looping is
                                   needed in seconds. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                address_family: `str`
+                password_text: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     Steps:
         1. Learn BGP Ops configured on device. SKIP the trigger if there
            is no BGP configured on the device.
         2. Save the current device configurations using "method" specified.
         3. Modify the password of BGP neighbor learned in
            step 1 using  Genie BGP Conf.
         4. Verify the change to password config under BGP neighbor
@@ -827,15 +943,28 @@
                 Buffer recovery timeout when the previous timeout has been exhausted,
                 to make sure the devices are recovered before ending the trigger
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                address_family: `str`
+                rd: `str`
+                default_vrf: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn BGP Ops object and store the BGP vrf(s) with route_distinguisher
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Modify the learned BGP vrf(s) route-distinguisher from step 1 
            with BGP Conf object
         4. Verify the BGP vrf(s) route_distinguisher from step 3 are changed
@@ -863,33 +992,33 @@
                                           'requirements':[['table', 'instance', '(?P<instance>.*)',
                                                            'vrf', '(?P<vrf>.*)', 'address_family',
                                                            '(?P<address_family>.*)', 'route_distinguisher',
                                                            '(?P<rd>.*)'],
                                                            ['table', 'instance', '(?P<instance>.*)',
                                                            'vrf', '(?P<vrf>.*)', 'address_family',
                                                            '(?P<address_family>.*)', 'default_vrf',
-                                                           '(?P<name>^(?!L3|vpn).*)']],
+                                                           '(?P<default_vrf>^(?!L3|vpn).*)']],
                                         'kwargs':{'attributes':['table', 'info']},
                                         'all_keys': True,
                                         'exclude': bgp_exclude},
                                     'ops.vrf.vrf.Vrf':{
-                                          'requirements':[['info', 'vrfs', '(?P<name>^(?!default).*)',
+                                          'requirements':[['info', 'vrfs', '(?P<default_vrf>^(?!default).*)',
                                                            'route_distinguisher', '(?P<rd>.*)']],
                                         'kwargs':{'attributes':['info']},
                                         'exclude': ['maker']}},
                       config_info={'conf.vrf.Vrf':{
                                      'requirements':[['device_attr', '{uut}', 'rd', MODIFY_RD]],
                                      'verify_conf':False,
-                                     'kwargs':{'mandatory':{'name': '(?P<name>.*)'}}}},
+                                     'kwargs':{'mandatory':{'name': '(?P<default_vrf>.*)'}}}},
                       verify_ops={'ops.bgp.bgp.Bgp':{
                                     'requirements': [['table', 'instance', '(?P<instance>.*)',
                                                      'vrf', '(?P<vrf>.*)', 'address_family',
                                                      '(?P<address_family>.*)', 'route_distinguisher', MODIFY_RD]],
                                     'kwargs':{'attributes':['table', 'info']},
                                     'exclude': bgp_exclude + ['label_allocation_mode']},
                                   'ops.vrf.vrf.Vrf':{
-                                        'requirements':[['info', 'vrfs', '(?P<name>.*)',
+                                        'requirements':[['info', 'vrfs', '(?P<default_vrf>.*)',
                                                          'route_distinguisher', MODIFY_RD]],
                                       'kwargs':{'attributes':['info']},
                                       'exclude': ['maker']}},
                       num_values={'vrf': 1, 'instance':1, 
-                                  'address_family': 'all', 'rd': 1, 'name': 1})
+                                  'address_family': 'all', 'rd': 1, 'default_vrf': 1})
```

## genie/libs/sdk/triggers/modify/dot1x/iosxe/modify.py

```diff
@@ -46,15 +46,25 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+                client: `str`
+                vlan: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Dot1x Ops object to check if there is any 'auth' interface(s),
            otherwise SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Modify the dot1x user cedential to mimatched values with DOT1x Conf object on uut
         4. Verify the status of dot1x changed from 'auth' to 'unauth' from step 3,
            Verify the peer mac-address in UUT's table is 'drop'
@@ -69,52 +79,52 @@
 
     @aetest.test
     def modify_configuration(self, uut, abstract, steps):
         super().modify_configuration(uut.peer, abstract, steps)
 
         # shut no shut the interface on UUT to let the session restart
         for key in self.mapping.keys:
-            if hasattr(uut, 'interfaces') and key['name'] in uut.interfaces:
-                intf_conf = uut.interfaces[key['name']]
+            if hasattr(uut, 'interfaces') and key['interface'] in uut.interfaces:
+                intf_conf = uut.interfaces[key['interface']]
             else:
-                intf_conf = abstract.conf.interface.Interface(device=uut, name=key['name'])
+                intf_conf = abstract.conf.interface.Interface(device=uut, name=key['interface'])
             intf_conf.enabled = False
             intf_conf.build_config()
             intf_conf.build_unconfig(attributes={'enabled': None})
 
 
     @aetest.test
     def restore_configuration(self, uut, method, abstract):
         super().restore_configuration(uut.peer, method, abstract)
 
         # shut no shut the interface on UUT to let the session restart
         for key in self.mapping.keys:
-            if hasattr(uut, 'interfaces') and key['name'] in uut.interfaces:
-                intf_conf = uut.interfaces[key['name']]
+            if hasattr(uut, 'interfaces') and key['interface'] in uut.interfaces:
+                intf_conf = uut.interfaces[key['interface']]
             else:
-                intf_conf = abstract.conf.interface.Interface(device=uut, name=key['name'])
+                intf_conf = abstract.conf.interface.Interface(device=uut, name=key['interface'])
             intf_conf.enabled = False
             intf_conf.build_config()
             intf_conf.build_unconfig(attributes={'enabled': None})
-            del(uut.interfaces[key['name']])
+            del(uut.interfaces[key['interface']])
 
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.dot1x.dot1x.Dot1x':{
-                                       'requirements':[['info', 'interfaces', '(?P<name>.*)',
+                                       'requirements':[['info', 'interfaces', '(?P<interface>.*)',
                                                         'clients', '(?P<client>.*)', 'status', 'authorized']],
                                        'all_keys': True,
                                        'kwargs':{'attributes':['info[interfaces][(.*)][clients][(.*)][status]',
                                                                'info[sessions]']},
                                        'exclude': dot1x_exclude},
                                     'ops.fdb.fdb.Fdb':{
                                        'requirements':[['info', 'mac_table', 'vlans', '(?P<vlan>.*)',
                                                         'mac_addresses', '(?P<client>.*)',
-                                                        'interfaces', '(?P<name>.*)', 'entry_type', 'static']],
+                                                        'interfaces', '(?P<interface>.*)', 'entry_type', 'static']],
                                        'all_keys': True,
                                        'kwargs':{'attributes':['info[mac_table][vlans][(.*)]']},
                                        'exclude': fdb_exclude + ['mac_addresses']}},
                       config_info={'conf.dot1x.Dot1x':{
                                        'requirements':[['device_attr', '{uut}', 'credentials_attr', 'wrong',
                                                         'credential_username', 'wrong'],
                                                        ['device_attr', '{uut}', 'credentials_attr', 'wrong',
@@ -122,15 +132,15 @@
                                                        ['device_attr', '{uut}', 'credentials_attr', 'wrong',
                                                         'credential_secret', 'wrong'],
                                                        ['device_attr', '{uut}', 'interface_attr', '(?P<peer_intf>.*)',
                                                         'if_credentials', 'wrong']],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={'ops.dot1x.dot1x.Dot1x':{
-                                       'requirements':[['info', 'interfaces', '(?P<name>.*)',
+                                       'requirements':[['info', 'interfaces', '(?P<interface>.*)',
                                                         'clients', '(?P<client>.*)', 'status', 'unauthorized'],
                                                        ['info', 'sessions', 'authorized_clients', '(\d+)'],
                                                        ['info', 'sessions', 'unauthorized_clients', '(\d+)']],
                                        'kwargs':{'attributes':['info[interfaces][(.*)][clients][(.*)][status]',
                                                                'info[sessions]']},
                                        'exclude': dot1x_exclude},
                                   'ops.fdb.fdb.Fdb':{
@@ -138,8 +148,8 @@
                                                         'mac_addresses', '(?P<client>.*)',
                                                         'drop', 'drop', True],
                                                        ['info', 'mac_table', 'vlans', '(?P<vlan>.*)',
                                                         'mac_addresses', '(?P<client>.*)',
                                                         'drop', 'entry_type', 'dynamic']],
                                        'kwargs':{'attributes':['info[mac_table][vlans][(.*)]']},
                                        'exclude': fdb_exclude + ['mac_addresses']}},
-                      num_values={'name': 'all'})
+                      num_values={'interface': 'all'})
```

## genie/libs/sdk/triggers/modify/hsrp/modify.py

```diff
@@ -45,15 +45,27 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+                version: `int`
+                group_number: `int`
+                priority: `int`
+                standby_router: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn HSRP Ops object and store the HSRP ipv4 group(s) which is active and
            have standby connected. SKIP the trigger if there is no HSRP group(s) found
         2. Save the current device configurations through "method" which user uses
         3. Modify the priority of the learned HSRP group(s) from step 1 to the lowest value
            with HSRP Conf object
         4. Verify the priority of the learned HSRP group(s) from step 3
@@ -131,14 +143,27 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+                version: `int`
+                group_number: `int`
+                priority: `int`
+                standby_router: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn HSRP Ops object and store the HSRP ipv6 group(s) which is active and
            have standby connected. SKIP the trigger if there is no HSRP group(s) found
         2. Save the current device configurations through "method" which user uses
         3. Modify the priority of the learned HSRP group(s) from step 1 to the lowest value
            with HSRP Conf object
```

## genie/libs/sdk/triggers/modify/igmp/nxos/modify.py

```diff
@@ -47,14 +47,24 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+                vrf: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn Igmp Ops object and store the Igmp interface version
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Modify the learned Igmp interface version from step 1 
            with Igmp Conf object
@@ -65,31 +75,30 @@
     """
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={
                           'ops.igmp.igmp.Igmp':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'enable', True],
+                                     '(?P<interface>.*)', 'enable', True],
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'version', '(?P<version>2)']],
+                                     '(?P<interface>.*)', 'version', '(?P<version>2)']],
                                 'all_keys': True,
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)]']},
                                 'exclude': igmp_exclude}},
                       config_info={'conf.igmp.Igmp':{
                                        'requirements':[
                                          ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
-                                          'interface_attr', '(?P<igmp_intf>.*)', 'version',
+                                          'interface_attr', '(?P<interface>.*)', 'version',
                                           3]],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={
                           'ops.igmp.igmp.Igmp':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'version', 3]],
-                                'missing': False,
+                                     '(?P<interface>.*)', 'version', 3]],
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)]']},
                                 'exclude': igmp_exclude}},
-                      num_values={'vrf': 1, 'igmp_intf': 1})
+                      num_values={'vrf': 1, 'interface': 1})
```

## genie/libs/sdk/triggers/modify/interface/modify.py

```diff
@@ -47,14 +47,24 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+                mtu: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn Interface Ops object and store the "up" Ethernet interface(s)
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Modify the mtu of the learned Ethernet interface(s) from step 1
            with Interface Conf object
@@ -64,29 +74,29 @@
         6. Learn Interface Ops again and verify it is the same as the Ops in step 1
 
     """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictates which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
-                                        'requirements': [['info', '(?P<name>e|Ethernet[0-9\/\s]+$)', 'mtu', '(?P<mtu>.*)'],
-                                                         ['info', '(?P<name>.*)', 'enabled', True],
-                                                         ['info', '(?P<name>.*)', 'port_channel', 'port_channel_member', False],
-                                                         ['info', '(?P<name>.*)', 'oper_status', 'up']],
+                                        'requirements': [['info', '(?P<interface>e|Ethernet[0-9\/\s]+$)', 'mtu', '(?P<mtu>.*)'],
+                                                         ['info', '(?P<interface>.*)', 'enabled', True],
+                                                         ['info', '(?P<interface>.*)', 'port_channel', 'port_channel_member', False],
+                                                         ['info', '(?P<interface>.*)', 'oper_status', 'up']],
                                         'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                       'requirements':[['mtu', 9216]],
                                       'verify_conf':False,
-                                      'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                      'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                              'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                      'requirements': [['info', '(?P<name>.*)', 'mtu', 9216],
-                                                       ['info', '(?P<name>.*)', 'bandwidth', '(\d+)']],
+                                      'requirements': [['info', '(?P<interface>.*)', 'mtu', 9216],
+                                                       ['info', '(?P<interface>.*)', 'bandwidth', '(\d+)']],
                                       'exclude': interface_exclude}},
-                      num_values={'name': 1, 'mtu': 1})
+                      num_values={'interface': 1, 'mtu': 1})
 
 
 class TriggerModifySwitchportModeTrunkToAccess(TriggerModify):
     """Modify and revert the mode ("trunk" to "access") for dynamically learned switchport interface(s)."""
 
     __description__ = """Modify and revert the mode ("trunk" to "access") for dynamically learned switchport interface(s).
 
@@ -113,15 +123,23 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Interface Ops object and store the "up" "trunk" interface(s)
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Modify the mode of the learned "trunk" interface(s) from step 1 to "access"
            with Interface Conf object
         4. Verify the mode of the learned "trunk" interface(s) from step 3
@@ -131,31 +149,31 @@
 
     """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictates which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
                                         'requirements':[\
-                                            ['info', '(?P<name>.*)', 'switchport_mode', 'trunk'],
-                                            ['info', '(?P<name>.*)', 'enabled', True],
-                                            ['info', '(?P<name>.*)', 'oper_status', 'up'],
-                                            ['info', '(?P<name>.*)', 'port_channel', 'port_channel_member', False]],
+                                            ['info', '(?P<interface>.*)', 'switchport_mode', 'trunk'],
+                                            ['info', '(?P<interface>.*)', 'enabled', True],
+                                            ['info', '(?P<interface>.*)', 'oper_status', 'up'],
+                                            ['info', '(?P<interface>.*)', 'port_channel', 'port_channel_member', False]],
                                         'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                         'requirements':[['switchport_mode', 'access']],
                                         'verify_conf':False,
-                                        'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                        'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                                'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
                                         'requirements': [\
-                                            ['info', '(?P<name>.*)', 'switchport_mode', 'access'],
-                                            ['info', '(?P<name>.*)', 'enabled', False],
+                                            ['info', '(?P<interface>.*)', 'switchport_mode', 'access'],
+                                            ['info', '(?P<interface>.*)', 'enabled', False],
                                             ['info', '(.*)', 'switchport_mode', '(\w+)']],
                                         'exclude': interface_exclude + ['(Vlan.*)']}},
-                      num_values={'name': 1})
+                      num_values={'interface': 1})
 
 
 class TriggerModifyLoopbackInterfaceIp(TriggerModify):
     """Modify and revert the ipv4 address for dynamically learned Loopback interface(s)."""
 
     __description__ = """Modify and revert the ipv4 address for dynamically learned Loopback interface(s).
 
@@ -182,15 +200,14 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
     steps:
         1. Learn Interface Ops object and store the "up" "ipv4" Loopback interface(s)
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Modify the ipv4 address of the learned Loopback interface(s) from step 1
            with Interface Conf object
         4. Verify the ipv4 address of the learned Loopback interface(s) from step 3
```

## genie/libs/sdk/triggers/modify/interface/iosxe/modify.py

```diff
@@ -13,51 +13,158 @@
                      'in_pkts', 'in_unicast_pkts', 'out_octets',
                      'out_pkts', 'out_unicast_pkts', 'out_multicast_pkts',
                      'in_multicast_pkts', 'last_clear', 'in_broadcast_pkts',
                      'out_broadcast_pkts', 'accounting']
 
 
 class TriggerModifyEthernetMtu(TriggerModify):
+    """Modify and revert the mtu for dynamically learned Ethernet interface(s)."""
+
+    __description__ = """Modify and revert the mtu for dynamically learned Ethernet interface(s).
+
+        trigger_datafile:
+            Mandatory:
+                timeout:
+                    max_time (`int`): Maximum wait time for the trigger,
+                                    in second. Default: 180
+                    interval (`int`): Wait time between iteration when looping is needed,
+                                    in second. Default: 15
+                    method (`str`): Method to recover the device configuration,
+                                  Support methods:
+                                    'checkpoint': Rollback the configuration by
+                                                  checkpoint (nxos),
+                                                  archive file (iosxe),
+                                                  load the saved running-config file on disk (iosxr)
+            Optional:
+                tgn_timeout (`int`): Maximum wait time for all traffic threads to be
+                                     restored to the reference rate,
+                                     in second. Default: 60
+                tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
+                                   in second. Default: 10
+                timeout_recovery:
+                    Buffer recovery timeout make sure devices are recovered at the end
+                    of the trigger execution. Used when previous timeouts have been exhausted.
+
+                    max_time (`int`): Maximum wait time for the last step of the trigger,
+                                    in second. Default: 180
+                    interval (`int`): Wait time between iteration when looping is needed,
+                                    in second. Default: 15
+                static:
+                    The keys below are dynamically learnt by default.
+                    However, they can also be set to a custom value when provided in the trigger datafile.
+
+                    interface: `str`
+                    mtu: `str`
+
+                    (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                        OR
+                        interface: 'Ethernet1/1/1' (Specific value)
+
+        steps:
+            1. Learn Interface Ops object and store the "up" Ethernet interface(s)
+               if has any, otherwise, SKIP the trigger
+            2. Save the current device configurations through "method" which user uses
+            3. Modify the mtu of the learned Ethernet interface(s) from step 1
+               with Interface Conf object
+            4. Verify the mtu of the learned Ethernet interface(s) from step 3
+               changes to the modified value in step 3
+            5. Recover the device configurations to the one in step 2
+            6. Learn Interface Ops again and verify it is the same as the Ops in step 1
+
+        """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictates which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
-                                        'requirements': [['info', '(?P<name>\w+Ethernet[0-9\/]+$)', 'mtu', '(?P<mtu>.*)'],
-                                                         ['info', '(?P<name>.*)', 'port_channel', 'port_channel_member', False],
-                                                         ['info', '(?P<name>.*)', 'oper_status', 'up']],
+                                        'requirements': [['info', '(?P<interface>\w+Ethernet[0-9\/]+$)', 'mtu', '(?P<mtu>.*)'],
+                                                         ['info', '(?P<interface>.*)', 'port_channel', 'port_channel_member', False],
+                                                         ['info', '(?P<interface>.*)', 'oper_status', 'up']],
                                         'exclude': interface_exclude,
                                         'include_management_interface': False}},
                       config_info={'conf.interface.Interface':{
                                       'requirements':[['mtu', 9216]],
                                       'verify_conf':False,
-                                      'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                      'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                              'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                      'requirements': [['info', '(?P<name>.*)', 'mtu', 9216],
-                                                       ['info', '(?P<name>.*)', 'bandwidth', '(\d+)'],
+                                      'requirements': [['info', '(?P<interface>.*)', 'mtu', 9216],
+                                                       ['info', '(?P<interface>.*)', 'bandwidth', '(\d+)'],
                                                        ['info', '(.*)', 'mtu', '(\d+)']],
                                       'exclude': interface_exclude}},
-                      num_values={'name': 1, 'mtu': 1})
+                      num_values={'interface': 1, 'mtu': 1})
 
 
 class TriggerModifySwitchportModeTrunkToAccess(TriggerModify):
+    """Modify and revert the switchport mode to access for dynamically learned interface(s)."""
+
+    __description__ = """Modify and revert the switchport mode to access for dynamically learned interface(s).
+
+           trigger_datafile:
+               Mandatory:
+                   timeout:
+                       max_time (`int`): Maximum wait time for the trigger,
+                                       in second. Default: 180
+                       interval (`int`): Wait time between iteration when looping is needed,
+                                       in second. Default: 15
+                       method (`str`): Method to recover the device configuration,
+                                     Support methods:
+                                       'checkpoint': Rollback the configuration by
+                                                     checkpoint (nxos),
+                                                     archive file (iosxe),
+                                                     load the saved running-config file on disk (iosxr)
+               Optional:
+                   tgn_timeout (`int`): Maximum wait time for all traffic threads to be
+                                        restored to the reference rate,
+                                        in second. Default: 60
+                   tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
+                                      in second. Default: 10
+                   timeout_recovery:
+                       Buffer recovery timeout make sure devices are recovered at the end
+                       of the trigger execution. Used when previous timeouts have been exhausted.
+
+                       max_time (`int`): Maximum wait time for the last step of the trigger,
+                                       in second. Default: 180
+                       interval (`int`): Wait time between iteration when looping is needed,
+                                       in second. Default: 15
+                   static:
+                       The keys below are dynamically learnt by default.
+                       However, they can also be set to a custom value when provided in the trigger datafile.
+
+                       interface: `str`
+
+                       (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                           OR
+                           interface: 'Ethernet1/1/1' (Specific value)
+
+           steps:
+               1. Learn Interface Ops object and store the "up" interface(s)
+                  if has any, otherwise, SKIP the trigger
+               2. Save the current device configurations through "method" which user uses
+               3. Modify the switchport mode to "access" of the learned  interface(s) from step 1
+                  with Interface Conf object
+               4. Verify the switchport mode of the learned interface(s) from step 3
+                  changes to "access"  in step 3
+               5. Recover the device configurations to the one in step 2
+               6. Learn Interface Ops again and verify it is the same as the Ops in step 1
+
+           """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictates which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
                                         'requirements':[\
-                                            ['info', '(?P<name>.*)', 'switchport_mode', 'trunk'],
-                                            ['info', '(?P<name>.*)', 'enabled', True],
-                                            ['info', '(?P<name>.*)', 'oper_status', 'up'],
-                                            ['info', '(?P<name>.*)', 'port_channel', 'port_channel_member', False]],
+                                            ['info', '(?P<interface>.*)', 'switchport_mode', 'trunk'],
+                                            ['info', '(?P<interface>.*)', 'enabled', True],
+                                            ['info', '(?P<interface>.*)', 'oper_status', 'up'],
+                                            ['info', '(?P<interface>.*)', 'port_channel', 'port_channel_member', False]],
                                         'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                         'requirements':[['switchport_mode', 'access']],
                                         'verify_conf':False,
-                                        'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                        'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                                'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
                                         'requirements': [\
-                                            ['info', '(?P<name>.*)', 'switchport_mode', '(.*access)'],
-                                            ['info', '(?P<name>.*)', 'switchport_enable', False]],
+                                            ['info', '(?P<interface>.*)', 'switchport_mode', '(.*access)'],
+                                            ['info', '(?P<interface>.*)', 'switchport_enable', False]],
                                         'exclude': interface_exclude + ['(Vlan.*)']}},
-                      num_values={'name': 1})
+                      num_values={'interface': 1})
```

## genie/libs/sdk/triggers/modify/interface/iosxr/modify.py

```diff
@@ -14,26 +14,80 @@
                      'accounting']
 
 ## IOSXR TriggerModifyEthernetMtu implemented seperately since it doesn't need
 ## port_channel_member = False as in NXOS.
 
 
 class TriggerModifyEthernetMtu(TriggerModify):
+    """Modify and revert the mtu for dynamically learned Ethernet interface(s)."""
+
+    __description__ = """Modify and revert the mtu for dynamically learned Ethernet interface(s).
+
+        trigger_datafile:
+            Mandatory:
+                timeout:
+                    max_time (`int`): Maximum wait time for the trigger,
+                                    in second. Default: 180
+                    interval (`int`): Wait time between iteration when looping is needed,
+                                    in second. Default: 15
+                    method (`str`): Method to recover the device configuration,
+                                  Support methods:
+                                    'checkpoint': Rollback the configuration by
+                                                  checkpoint (nxos),
+                                                  archive file (iosxe),
+                                                  load the saved running-config file on disk (iosxr)
+            Optional:
+                tgn_timeout (`int`): Maximum wait time for all traffic threads to be
+                                     restored to the reference rate,
+                                     in second. Default: 60
+                tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
+                                   in second. Default: 10
+                timeout_recovery:
+                    Buffer recovery timeout make sure devices are recovered at the end
+                    of the trigger execution. Used when previous timeouts have been exhausted.
+
+                    max_time (`int`): Maximum wait time for the last step of the trigger,
+                                    in second. Default: 180
+                    interval (`int`): Wait time between iteration when looping is needed,
+                                    in second. Default: 15
+                static:
+                    The keys below are dynamically learnt by default.
+                    However, they can also be set to a custom value when provided in the trigger datafile.
+
+                    interface: `str`
+                    mtu: `str`
+
+                    (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                        OR
+                        interface: 'Ethernet1/1/1' (Specific value)
+
+        steps:
+            1. Learn Interface Ops object and store the "up" Ethernet interface(s)
+               if has any, otherwise, SKIP the trigger
+            2. Save the current device configurations through "method" which user uses
+            3. Modify the mtu of the learned Ethernet interface(s) from step 1
+               with Interface Conf object
+            4. Verify the mtu of the learned Ethernet interface(s) from step 3
+               changes to the modified value in step 3
+            5. Recover the device configurations to the one in step 2
+            6. Learn Interface Ops again and verify it is the same as the Ops in step 1
+
+        """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictates which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
-                                        'requirements': [['info', '(?P<name>(GigabitEthernet|gigabitEthernet|TenGigE|HundredGigE)[0-9\/\s]+$)', 'mtu', '(?P<mtu>.*)'],
-                                                         ['info', '(?P<name>.*)', 'enabled', True],
-                                                         ['info', '(?P<name>.*)', 'oper_status', 'up']],
+                                        'requirements': [['info', '(?P<interface>(GigabitEthernet|gigabitEthernet|TenGigE|HundredGigE)[0-9\/\s]+$)', 'mtu', '(?P<mtu>.*)'],
+                                                         ['info', '(?P<interface>.*)', 'enabled', True],
+                                                         ['info', '(?P<interface>.*)', 'oper_status', 'up']],
                                         'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                       'requirements':[['mtu', 9216]],
                                       'verify_conf':False,
-                                      'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                      'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                              'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                      'requirements': [['info', '(?P<name>.*)', 'mtu', 9216],
-                                                       ['info', '(?P<name>.*)', 'bandwidth', '(\d+)'],
+                                      'requirements': [['info', '(?P<interface>.*)', 'mtu', 9216],
+                                                       ['info', '(?P<interface>.*)', 'bandwidth', '(\d+)'],
                                                        ['info', '(.*)', 'mtu', '(\d+)']],
                                       'exclude': interface_exclude}},
-                      num_values={'name': 1, 'mtu': 1})
+                      num_values={'interface': 1, 'mtu': 1})
```

## genie/libs/sdk/triggers/modify/mld/nxos/modify.py

```diff
@@ -47,15 +47,23 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+           static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
 
+                interface: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Mld Ops object and store the Mld interface version
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Modify the learned Mld interface version from step 1 
            with Mld Conf object
         4. Verify the Mld interface version  from step 3 is reflected in device configuration
@@ -65,31 +73,30 @@
     """
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={
                           'ops.mld.mld.Mld':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'enable', True],
+                                     '(?P<interface>.*)', 'enable', True],
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'version', '(?P<version>2)']],
+                                     '(?P<interface>.*)', 'version', '(?P<version>2)']],
                                 'all_keys': True,
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)]']},
                                 'exclude': mld_exclude}},
                       config_info={'conf.mld.Mld':{
                                        'requirements':[
                                          ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
-                                          'interface_attr', '(?P<mld_intf>.*)', 'version',
+                                          'interface_attr', '(?P<interface>.*)', 'version',
                                           1]],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={
                           'ops.mld.mld.Mld':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'version', 1]],
-                                'missing': False,
+                                     '(?P<interface>.*)', 'version', 1]],
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)]']},
                                 'exclude': mld_exclude}},
-                      num_values={'vrf': 1, 'mld_intf': 1})
+                      num_values={'vrf': 1, 'interface': 1})
```

## genie/libs/sdk/triggers/modify/msdp/nxos/modify.py

```diff
@@ -60,15 +60,24 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                originator_id: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Msdp Ops object and store the MSDP originator-id
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Modify the learned MSDP originator-id from step 1 
            with Msdp Conf object
         4. Verify the MSDP originator-id from step 3 is reflected in device configuration
@@ -157,15 +166,25 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+                sa_filter_in: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Msdp Ops object and store the "established" MSDP peer(s) sa-filter in
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. MOdify the learned MSDP peer(s) sa-filter in from step 1 
            with Msdp Conf object
         4. Verify the MSDP peer(s) sa-filter in from step 3 is reflected in device configuration
@@ -232,14 +251,25 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+                sa_filter_out: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn Msdp Ops object and store the "established" MSDP peer(s) sa-filter out
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. MOdify the learned MSDP peer(s) sa-filter in from step 1 
            with Msdp Conf object
@@ -307,14 +337,25 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+                sa_limit: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn Msdp Ops object and store the "established" MSDP peer(s) sa-limit
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Modify the learned MSDP peer(s) sa-limit from step 1 
            with Msdp Conf object
@@ -383,14 +424,25 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+                mesh_group: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn Msdp Ops object and store the 'established' MSDP peer(s) mesh group
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Modify the learned MSDP peer(s) mesh group from step 1 
            with Msdp Conf object
@@ -459,15 +511,26 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+                keepalive_interval: `int`
+                holdtime_interval: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Msdp Ops object and store the 'established' MSDP peer(s)
            keepalive&holdtime interval if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Modify the learned MSDP peer(s) keepalive&holdtime interval from step 1 
            with Msdp Conf object
         4. Verify the MSDP peer(s) keepalive&holdtime interval from step 3
@@ -506,15 +569,14 @@
                                     'requirements':[\
                                           ['info', 'vrf', '(?P<vrf>.*)', 'peer', '(?P<peer>.*)',
                                            'timer', 'keepalive_interval', keepalive_interval],
                                           ['info', 'vrf', '(?P<vrf>.*)', 'peer', '(?P<peer>.*)',
                                            'timer', 'holdtime_interval', holdtime_interval]],
                                     'kwargs':{'attributes': ['info[vrf][(.*)][peer][(.*)][timer]',
                                               'info[vrf][(.*)][peer][(.*)][session_state]']},
-                                    'missing': False,
                                     'exclude': msdp_exclude}},
                       num_values={'vrf': 1, 'peer': 1})
 
 
 class TriggerModifyMsdpReconnectInterval(TriggerModify):
     """Modify dynamically learned MSDP peer(s) reconnect interval
       then restore the configuration by reapplying the whole running configuration."""
@@ -545,15 +607,25 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+                connect_retry_interval: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Msdp Ops object and store the MSDP reconnect interval
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. MOdify the learned MSDP reconnect interval from step 1 
            with Msdp Conf object
         4. Verify the MSDP reconnect interval from step 3 is reflected in device configuration
@@ -581,15 +653,14 @@
                                        'kwargs':{}}},
                       verify_ops={'ops.msdp.msdp.Msdp':{
                                     'requirements':[\
                                       ['info', 'vrf', '(?P<vrf>.*)', 'peer', '(?P<peer>.*)', 'timer',
                                        'connect_retry_interval', connect_retry_interval]], 
                                     'kwargs':{'attributes': ['info[vrf][(.*)][peer][(.*)][timer]',
                                               'info[vrf][(.*)][peer][(.*)][session_state]']},
-                                    'missing': False,
                                     'exclude': msdp_exclude}},
                       num_values={'vrf': 1, 'peer': 'all'})
 
 
 class TriggerModifyMsdpDescription(TriggerModify):
     """Modify dynamically learned MSDP peer(s) description
       then restore the configuration by reapplying the whole running configuration."""
@@ -620,15 +691,25 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+                description: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Msdp Ops object and store the MSDP peer(s) description
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Modify the learned MSDP peer(s) description from step 1 
            with Msdp Conf object
         4. Verify the MSDP peer(s) description from step 3 is reflected in device configuration
@@ -695,15 +776,27 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+                connect_source: `str`
+                modify_connect_source: `str`
+                ip: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Msdp Ops object and store the MSDP 'established' peer(s) connect-source 
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Modify the learned MSDP peer(s) connect-source from step 1 
            with Msdp Conf object
         4. Verify the MSDP peer(s) connect-source  from step 3 is reflected in device configuration
@@ -837,15 +930,26 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+                peer_as: `int`
+                connected_source: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Msdp Ops object and store the MSDP 'established' peer(s) remote-as
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Modify the learned MSDP peer(s) remote-as from step 1 
            with Msdp Conf object
         4. Verify the MSDP peer(s) remote-as from step 3 is reflected in device configuration
```

## genie/libs/sdk/triggers/modify/pim/nxos/modify.py

```diff
@@ -38,15 +38,26 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
 
+                vrf: `str`
+                address_family: `str`
+                interface: `str`
+                neighbor_filter: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Pim Ops object and store the PIM interface(s)'s neighbor-filter
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Modify the learned PIM interface(s)'s neighbor-filter from step 1 
            with Pim Conf object
         4. Verify the PIM interface(s)'s neighbor-filter from step 3 is
@@ -59,37 +70,37 @@
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={
                           'ops.pim.pim.Pim':{
                                 'requirements':[\
                                     ['info', 'vrf', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<pim_intf>.*)', 'address_family', '(?P<af>.*)',
+                                     '(?P<interface>.*)', 'address_family', '(?P<address_family>.*)',
                                      'neighbor_filter', '(?P<neighbor_filter>.*)'],
                                     ['info', 'vrf', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<pim_intf>.*)', 'address_family', '(?P<af>.*)',
+                                     '(?P<interface>.*)', 'address_family', '(?P<address_family>.*)',
                                      'oper_status', 'up']],
                                 'kwargs':{'attributes': [
                                     'info[vrf][(.*)][interfaces][(.*)][address_family][(.*)][oper_status]',
                                     'info[vrf][(.*)][interfaces][(.*)][address_family][(.*)][neighbor_filter]']},
                                 'exclude': pim_exclude}},
                       config_info={'conf.pim.Pim':{
                                        'requirements':[
                                          ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
-                                          'address_family_attr', '(?P<af>.*)', 'interface_attr',
-                                          '(?P<pim_intf>.*)', 'neighbor_filter', MODIFY_NAME]],
+                                          'address_family_attr', '(?P<address_family>.*)', 'interface_attr',
+                                          '(?P<interface>.*)', 'neighbor_filter', MODIFY_NAME]],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={
                           'ops.pim.pim.Pim':{
                                 'requirements':[\
                                     ['info', 'vrf', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<pim_intf>.*)', 'address_family', '(?P<af>.*)',
+                                     '(?P<interface>.*)', 'address_family', '(?P<address_family>.*)',
                                      'neighbor_filter', MODIFY_NAME],
                                     ['info', 'vrf', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<pim_intf>.*)', 'address_family', '(?P<af>.*)',
+                                     '(?P<interface>.*)', 'address_family', '(?P<address_family>.*)',
                                      'oper_status', 'up']],
                                 'kwargs':{'attributes': [
                                     'info[vrf][(.*)][interfaces][(.*)][address_family][(.*)][oper_status]',
                                     'info[vrf][(.*)][interfaces][(.*)][address_family][(.*)][neighbor_filter]']},
                                 'exclude': pim_exclude}},
-                      num_values={'vrf': 1, 'af': 1, 'pim_intf': 1})
+                      num_values={'vrf': 1, 'address_family': 1, 'interface': 1})
```

## genie/libs/sdk/triggers/modify/stp/iosxe/modify.py

```diff
@@ -82,15 +82,25 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                pvst_name: `str`
+                vlan: `str`
+                interface: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn STP Ops object and store the PVST Desg FWD instance if has any,
            otherwise SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Modify the priority of the learned STP instance priority from step 1 to
            the highest value with STP Conf object, to make this instance as Root
         4. Verify the priority of the learned PVST Desg instance from step 3
@@ -173,14 +183,25 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                pvst_name: `str`
+                vlan: `str`
+                interface: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn STP Ops object and store the Rapid-PVST Desg FWD instance if has any,
            otherwise SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Modify the priority of the learned STP instance priority from step 1 to
            the highest value with STP Conf object, to make this instance as Root
```

## genie/libs/sdk/triggers/modify/vlan/nxos/modify.py

```diff
@@ -42,14 +42,24 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vlan: `str`
+                vn_segment: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn Vlan Ops object and store the vlan which is active and has vnsegment.
             SKIP the trigger if there is no VLAN(s) found
         2. Save the current device configurations through "method" which user uses
         3. Modify the vnsegment of the learned VLAN from step 1 with VLAN Conf object
         4. Verify the vnsegment of the learned VLAN  from step 3
```

## genie/libs/sdk/triggers/modify/vxlan/nxos/modify.py

```diff
@@ -57,14 +57,26 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                nve_name: `str`
+                source_if: `str`
+                nve_vni: `int`
+                multisite_bgw_if: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn Vxlan Ops object and store the vni state which is active and has source interface
             and multisite bgw interface. SKIP the trigger if there is no VXLAN(s) found
         2. Save the current device configurations through "method" which user uses
         3. Modify the multisite bgw interface of the learned VXLAN from step 1 with Interface Conf object
         4. Verify the multisite bgw interface of the learned VXLAN group(s) from step 3
@@ -105,15 +117,15 @@
                                 'added feature', from_exception=e)
 
             super().verify_configuration(uut, abstract, steps)
 
     mapping = Mapping(requirements={'ops.vxlan.vxlan.Vxlan': {
                                         'requirements': [['nve', '(?P<nve_name>.*)', 'source_if', '(?P<source_if>.*)'],
                                                          ['nve', '(?P<nve_name>.*)', 'multisite_bgw_if', '(?P<multisite_bgw_if>.*)'],
-                                                         ['nve', '(?P<nve_name>.*)', 'vni', '(?P<vni>.*)', 'vni_state', 'up']],
+                                                         ['nve', '(?P<nve_name>.*)', 'vni', '(?P<nve_vni>.*)', 'vni_state', 'up']],
                                         'all_keys': True,
                                         'kwargs': {'attributes': ['nve[(.*)][vni][(.*)]',
                                                                   'nve[(.*)][source_if]',
                                                                   'nve[(.*)][multisite_bgw_if]','l2route']},
                                         'exclude': vxlan_exclude +['peer_id','tx_id']},
                                     'ops.interface.interface.Interface': {
                                         'requirements': [['info', '(?P<intf_name>loopback.*)', 'oper_status', 'up']],
@@ -121,19 +133,19 @@
                                         'exclude': interface_exclude}},
                     config_info={'conf.interface.Interface': {
                                         'requirements': [[partial(configure_multisite_bgw_interface, \
                                                                   nve_multisite_bgw_intf='(?P<source_if>.*)')]],
                                         'verify_conf': False,
                                         'kwargs': {'mandatory': {'name': '(?P<nve_name>.*)', 'attach': False}}}},
                     verify_ops={'ops.vxlan.vxlan.Vxlan': {
-                                        'requirements': [['nve', '(?P<nve_name>.*)', 'vni', '(?P<vni>.*)', 'vni_state', 'down']],
+                                        'requirements': [['nve', '(?P<nve_name>.*)', 'vni', '(?P<nve_vni>.*)', 'vni_state', 'down']],
                                         'kwargs': {'attributes': ['nve[(.*)][vni][(.*)]',
                                                                   'nve[(.*)][source_if]',
                                                                   'nve[(.*)][multisite_bgw_if]','l2route']},
-                                        'exclude': vxlan_exclude + multisite_exclude +['l2route']}},
+                                        'exclude': vxlan_exclude + multisite_exclude +['l2route', 'repl_ip']}},
                     num_values={'nve_name': 'all', 'source_if': 'all', 'intf_name': 'all'})
 
 
 class TriggerModifyNveVniMcastGroup(TriggerModify):
     """Modify and revert the mcast group dynamically learned vxlan(s)."""
 
     __description__ = """Modify and revert the mcast group dynamically learned vxlan(s).
@@ -161,15 +173,25 @@
                     Buffer recovery timeout make sure devices are recovered at the end
                     of the trigger execution. Used when previous timeouts have been exhausted.
 
                     max_time (`int`): Maximum wait time for the last step of the trigger,
                                     in second. Default: 180
                     interval (`int`): Wait time between iteration when looping is needed,
                                     in second. Default: 15
-
+           static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                nve_name: `str`
+                nve_vni: `int`
+                mcast: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
         steps:
             1. Learn Vxlan Ops object and store the vni state which is active.
                 SKIP the trigger if there is no VXLAN(s) found
             2. Save the current device configurations through "method" which user uses
             3. Modify the mcast group of the learned VXLAN from step 1 with Interface Conf object
             4. Verify the mcast group of the learned VXLAN(s) from step 3
                changes to the modified value in step 3.
@@ -256,47 +278,57 @@
                     Buffer recovery timeout make sure devices are recovered at the end
                     of the trigger execution. Used when previous timeouts have been exhausted.
 
                     max_time (`int`): Maximum wait time for the last step of the trigger,
                                     in second. Default: 180
                     interval (`int`): Wait time between iteration when looping is needed,
                                     in second. Default: 15
-
+                static:
+                    The keys below are dynamically learnt by default.
+                    However, they can also be set to a custom value when provided in the trigger datafile.
+
+                    nve_name: `str`
+                    evpn_multisite_border_gateway: `int`
+                    multisite_convergence_time: `int`
+
+                    (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                          OR
+                          interface: 'Ethernet1/1/1' (Specific value)
         steps:
             1. Learn Vxlan Ops object and store the the multisite bgw delay restore time.
                 SKIP the trigger if there is no VXLAN(s) found
             2. Save the current device configurations through "method" which user uses
             3. Modify the multisite bgw delay restore time of the learned VXLAN from step 1
                  with Vxlan Conf object
             4. Verify the multisite bgw delay restore time of the learned VXLAN(s) from step 3
                 changes to the modified value in step 3.
             5. Recover the device configurations to the one in step 2
             6. Learn VXLAN Ops again and verify it is the same as the Ops in step 1
     """
     mapping = Mapping(requirements={'ops.vxlan.vxlan.Vxlan': {
-                                        'requirements': [[['nve', 'evpn_multisite_border_gateway', '(?P<border_gateway>.*)']],
+                                        'requirements': [[['nve', 'evpn_multisite_border_gateway', '(?P<evpn_multisite_border_gateway>.*)']],
                                                          [['nve','(?P<nve_name>.*)', 'multisite_convergence_time',
                                                           '(?P<multisite_convergence_time>.*)']]],
                                         'kwargs': {'attributes': ['nve[(.*)][multisite_convergence_time]',
                                                                   'nve[(.*)][vni][(.*)]',
                                                                   'nve[evpn_multisite_border_gateway]']},
                                         'exclude': vxlan_base_exclude}},
                     config_info={'conf.vxlan.Vxlan': {
-                                        'requirements': [['device_attr', '{uut}', 'evpn_msite_attr', '(?P<border_gateway>.*)',\
+                                        'requirements': [['device_attr', '{uut}', 'evpn_msite_attr', '(?P<evpn_multisite_border_gateway>.*)',\
                                                           'evpn_msite_bgw_delay_restore_time', 101]],
                                         'verify_conf': False,
                                         'kwargs': {}}},
                     verify_ops={'ops.vxlan.vxlan.Vxlan': {
-                                        'requirements': [['nve', 'evpn_multisite_border_gateway', '(?P<border_gateway>.*)'],
+                                        'requirements': [['nve', 'evpn_multisite_border_gateway', '(?P<evpn_multisite_border_gateway>.*)'],
                                                          ['nve', '(?P<nve_name>.*)', 'multisite_convergence_time', 101]],
                                         'kwargs': {'attributes': ['nve[(.*)][multisite_convergence_time]',
                                                                   'nve[(.*)][vni][(.*)]',
                                                                   'nve[evpn_multisite_border_gateway]']},
                                         'exclude': vxlan_base_exclude}},
-                    num_values={'nve_name': 'all' , 'border_gateway':'all', 'delay_time':'all' })
+                    num_values={'nve_name': 'all' , 'evpn_multisite_border_gateway':'all', 'delay_time':'all' })
 
 class TriggerModifyNveSourceInterfaceLoopback(TriggerModify):
     """Modify and revert nve source interface dynamically learned Vxlan(s)."""
 
     __description__ = """Unconfigure nve source interface and reapply the whole configurations of dynamically learned Vxlan(s).
 
        trigger_datafile:
@@ -322,15 +354,25 @@
                  Buffer recovery timeout when the previous timeout has been exhausted,
                  to make sure the devices are recovered before ending the trigger
 
                  max_time (`int`): Maximum wait time for the last step of the trigger,
                                  in second. Default: 180
                  interval (`int`): Wait time between iteration when looping is needed,
                                  in second. Default: 15
-
+             static:
+                 The keys below are dynamically learnt by default.
+                 However, they can also be set to a custom value when provided in the trigger datafile.
+
+                 nve_name: `str`
+                 source_if: `str`
+                 multisite_bgw_if: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
        steps:
          1. Learn Vxlan Ops object and store the nve source interface under nve
             if has any, otherwise, SKIP the trigger
          2. Save the current device configurations through "method" which user uses
          3. Unconfigure the nve source interface with Interface Conf object
          4. Verify the nve source interface from step 3 are no longer existed
          5. Recover the device configurations to the one in step 2
@@ -469,15 +511,27 @@
                     Buffer recovery timeout make sure devices are recovered at the end
                     of the trigger execution. Used when previous timeouts have been exhausted.
 
                     max_time (`int`): Maximum wait time for the last step of the trigger,
                                     in second. Default: 180
                     interval (`int`): Wait time between iteration when looping is needed,
                                     in second. Default: 15
-
+                static:
+                     The keys below are dynamically learnt by default.
+                     However, they can also be set to a custom value when provided in the trigger datafile.
+
+                     instance: `str`
+                     vrf: `str`
+                     address_family: `str`
+                     rd: `str`
+                     rd_vniid: `str`
+
+                    (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                          OR
+                          interface: 'Ethernet1/1/1' (Specific value)
         steps:
             1. Learn Vxlan Ops object and store the rd and it's vni  .
                 SKIP the trigger if there is no VXLAN(s) found
             2. Save the current device configurations through "method" which user uses
             3. Modify the rd of the learned VXLAN from step 1 with Vxlan Conf object
             4. Verify the rd of the learned VXLAN(s) from step 3
                changes to the modified value in step 3.
@@ -509,39 +563,39 @@
     @aetest.test
     def verify_modification(self, uut, abstract, steps):
         for item in self.mapping.keys:
             try:
                 ret = item['new_rd']
                 req = ['bgp_l2vpn_evpn', 'instance', '(?P<instance>.*)',
                                'vrf', '(?P<vrf>.*)', 'address_family',
-                               '(?P<af>.*)', 'rd', ret,'rd']
+                               '(?P<address_family>.*)', 'rd', ret,'rd']
                 req.insert(len(req),ret)
                 req_2 = ['bgp_l2vpn_evpn', 'instance', '(?P<instance>.*)',
                                                            'vrf', '(?P<vrf>.*)', 'address_family',
-                                                           '(?P<af>.*)', 'rd', ret, 'rd_vniid', '(?P<rd_vniid>.*)']
+                                                           '(?P<address_family>.*)', 'rd', ret, 'rd_vniid', '(?P<rd_vniid>.*)']
                 self.mapping._verify_ops_dict['ops.vxlan.vxlan.Vxlan']['requirements'].append(req)
                 self.mapping._verify_ops_dict['ops.vxlan.vxlan.Vxlan']['requirements'].append(req_2)
             except Exception as e:
                 log.warning('Cannot verify rd information.'
                             'Mismatch is expected {}'.format(e))
 
         super().verify_modification(uut, abstract, steps)
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictates which key to verify
     mapping = Mapping(requirements={'ops.vxlan.vxlan.Vxlan':{
                                           'requirements':[['bgp_l2vpn_evpn', 'instance', '(?P<instance>.*)',
                                                            'vrf', '(?P<vrf>.*)', 'address_family',
-                                                           '(?P<af>.*)', 'rd', '(?P<rd>.*)','rd','(?P<rd>.*)'],
+                                                           '(?P<address_family>.*)', 'rd', '(?P<rd>.*)','rd','(?P<rd>.*)'],
                                                           ['bgp_l2vpn_evpn', 'instance', '(?P<instance>.*)',
                                                            'vrf', '(?P<vrf>.*)', 'address_family',
-                                                           '(?P<af>.*)', 'rd', '(?P<rd>.*)', 'rd_vniid', '(?P<rd_vniid>.*)'],
+                                                           '(?P<address_family>.*)', 'rd', '(?P<rd>.*)', 'rd_vniid', '(?P<rd_vniid>.*)'],
                                                           ['bgp_l2vpn_evpn', 'instance', '(?P<instance>.*)',
                                                             'vrf', '(?P<vrf>.*)', 'address_family',
-                                                            '(?P<af>.*)', 'rd', '(?P<rd>.*)', 'rd_vrf', 'l2']],
+                                                            '(?P<address_family>.*)', 'rd', '(?P<rd>.*)', 'rd_vrf', 'l2']],
                                           'kwargs':{'attributes':['bgp_l2vpn_evpn[instance][(.*)][vrf][(.*)][address_family][(.*)][rd][(.*)][rd]',
                                                                   'bgp_l2vpn_evpn[instance][(.*)][vrf][(.*)][address_family][(.*)][rd][(.*)][rd_vniid]',
                                                                   'bgp_l2vpn_evpn[instance][(.*)][vrf][(.*)][address_family][(.*)][rd][(.*)][rd_vrf]',
                                                                   ]},
                                           'all_keys':True,
                                           'exclude': vxlan_exclude}},
                       config_info={'conf.vxlan.Vxlan': {
@@ -552,8 +606,8 @@
                                          'kwargs': {}}},
                       verify_ops={'ops.vxlan.vxlan.Vxlan':{
                                         'requirements':[],
                                         'kwargs':{'attributes':['bgp_l2vpn_evpn[instance][(.*)][vrf][(.*)][address_family][(.*)][rd][(.*)][rd]',
                                                                 'bgp_l2vpn_evpn[instance][(.*)][vrf][(.*)][address_family][(.*)][rd][(.*)][rd_vniid]',
                                                                 'bgp_l2vpn_evpn[instance][(.*)][vrf][(.*)][address_family][(.*)][rd][(.*)][rd_vrf]']},
                                         'exclude': vxlan_exclude}},
-                      num_values={'rd': 1, 'instance':1, 'vrf':1, 'af':1, 'rd_vniid':1})
+                      num_values={'rd': 1, 'instance':1, 'vrf':1, 'address_family':1, 'rd_vniid':1})
```

## genie/libs/sdk/triggers/shutnoshut/bgp/shutnoshut.py

```diff
@@ -52,14 +52,26 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                 The keys below are dynamically learnt by default.
+                 However, they can also be set to a custom value when provided in the trigger datafile.
+
+                 instance: `str`
+                 vrf: `str`
+                 neighbor: `str`
+                 bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn BGP Ops object and store the instance(s) and neighbor(s)
            if has any, otherwise, SKIP the trigger
         2. Shut the learned BGP instance(s) from step 1 with BGP Conf object
         3. Verify the state of BGP instance(s) and
            state of neighbor(s) from step 2 are "shutdown"
@@ -128,15 +140,27 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                 The keys below are dynamically learnt by default.
+                 However, they can also be set to a custom value when provided in the trigger datafile.
+
+                 instance: `str`
+                 vrf: `str`
+                 neighbor: `str`
+                 address_family: `str`
+                 bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn BGP Ops object and store the "established" neighbor(s)
            if has any, otherwise, SKIP the trigger
         2. Shut the learned BGP neighbor(s) from step 1 with BGP Conf object
         3. Verify the state of BGP neighbor(s) from step 2 is "shutdown"
         4. Unshut the BGP neighbor(s)
         5. Learn BGP Ops again and verify it is the same as the Ops in step 1
@@ -214,15 +238,26 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                 The keys below are dynamically learnt by default.
+                 However, they can also be set to a custom value when provided in the trigger datafile.
+
+                 instance: `str`
+                 vrf: `str`
+                 neighbor: `str`
+                 interface: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn BGP Ops object and verify if has any update-source interface(s),
            and learn Interface Ops to verify if has any IP/IPv6 Loopback interface(s)
            that existed in the BGP update-source interface(s). Store the filtered
            BGP update-source Loopback interface(s) if has any, otherwise, SKIP the trigger
         2. Shut the BGP learned update-source Loopback interface(s) from step 1
            with Interface Conf object
@@ -238,29 +273,29 @@
     interface_exclude = interface_exclude + ['ipv6']
 
     requirements = OrderedDict()
     requirements['ops.bgp.bgp.Bgp'] = {
         'requirements':[['info', 'instance', '(?P<instance>.*)',
                          'vrf', '(?P<vrf>.*)',
                          'neighbor', '(?P<neighbor>.*)',
-                         'update_source', '(?P<name>.*)']],
+                         'update_source', '(?P<interface>.*)']],
         'kwargs':{'attributes':['info']},
         'exclude': bgp_exclude + ['distance_local']}
 
     requirements['ops.interface.interface.Interface'] = {
-        'requirements':[['info', '(?P<name>l|Loopback[0-9\s]+)',
+        'requirements':[['info', '(?P<interface>l|Loopback[0-9\s]+)',
                          'oper_status', 'up']],
         'exclude': interface_exclude}
 
     mapping = Mapping(requirements = requirements,
                       config_info={'conf.interface.Interface':{
                                        'requirements':[['enabled', False]],
                                        'verify_conf':False,
-                                       'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                       'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                      'requirements': [['info', '(?P<name>.*)', 'enabled', False],
-                                                       ['info', '(?P<name>.*)', 'oper_status', 'down']],
+                                      'requirements': [['info', '(?P<interface>.*)', 'enabled', False],
+                                                       ['info', '(?P<interface>.*)', 'oper_status', 'down']],
                                       'exclude': interface_exclude + ['(mti.*)'] + ['(tunnel.*)']}},
                       num_values={'instance': 1, 'vrf': 1, 'neighbor': 1,
-                                  'update_source': 1, 'name': 1,
+                                  'update_source': 1, 'interface': 1,
                                   'ipv6': 1, 'status': 1})
```

## genie/libs/sdk/triggers/shutnoshut/bgp/iosxe/shutnoshut.py

```diff
@@ -17,14 +17,60 @@
                'bgp_negotiated_keepalive_timers', 'updates', 'opens',
                'bgp_table_version', 'holdtime', 'keepalive_interval',
                'distance_internal_as', 'routing_table_version',
                'total_memory']
 
 
 class TriggerShutNoShutBgpNeighbors(TriggerShutNoShut):
+    """Shut and unshut the dynamically learned BGP neighbore(s)."""
+
+    __description__ = """Shut and unshut the dynamically learned BGP neighbore(s).
+
+        trigger_datafile:
+            Mandatory:
+                timeout:
+                    max_time (`int`): Maximum wait time for the trigger,
+                                    in second. Default: 180
+                    interval (`int`): Wait time between iteration when looping is needed,
+                                    in second. Default: 15
+            Optional:
+                tgn_timeout (`int`): Maximum wait time for all traffic threads to be
+                                     restored to the reference rate,
+                                     in second. Default: 60
+                tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
+                                   in second. Default: 10
+                timeout_recovery:
+                    Buffer recovery timeout make sure devices are recovered at the end
+                    of the trigger execution. Used when previous timeouts have been exhausted.
+
+                    max_time (`int`): Maximum wait time for the last step of the trigger,
+                                    in second. Default: 180
+                    interval (`int`): Wait time between iteration when looping is needed,
+                                    in second. Default: 15
+                static:
+                     The keys below are dynamically learnt by default.
+                     However, they can also be set to a custom value when provided in the trigger datafile.
+
+                     instance: `str`
+                     vrf: `str`
+                     neighbor: `str`
+                     bgp_id: `int`
+
+                    (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                          OR
+                          interface: 'Ethernet1/1/1' (Specific value)
+        steps:
+            1. Learn BGP Ops object and verify if has established state, otherwise, Skip the trigger.
+            2. Shut the BGP neighbor that learned from step 1 with BGP Conf object
+            3. Verify the state of learned neighbor(s)
+               from step 2 is "down"
+            4. Unshut the BGP neighbor(s)
+            5. Learn BGP Ops again and verify it is the same as the Ops in step 1
+
+        """
 
     mapping = Mapping(\
             requirements={\
                 'ops.bgp.bgp.Bgp': {
                     'requirements':[\
                         ['info', 'instance', '(?P<instance>.*)',
                         'vrf', '(?P<vrf>.*)', 'neighbor', '(?P<neighbor>.*)',
```

## genie/libs/sdk/triggers/shutnoshut/bgp/iosxr/shutnoshut.py

```diff
@@ -75,15 +75,46 @@
 
 
 class TriggerShutNoShutBgp(TriggerShutNoShut):
     """Shut BGP protocol by shutdown the dynamically learned BGP process,
     then unshut it by restart bpm. """
     
     __description__ = """Shut BGP protocol by shutdown the dynamically learned BGP process,
-    then unshut it by restart bpm. 
+    then unshut it by restart bpm.
+
+    trigger_datafile:
+        Mandatory:
+            timeout:
+                max_time (`int`): Maximum wait time for the trigger,
+                                in second. Default: 180
+                interval (`int`): Wait time between iteration when looping is needed,
+                                in second. Default: 15
+        Optional:
+            tgn_timeout (`int`): Maximum wait time for all traffic threads to be
+                                 restored to the reference rate,
+                                 in second. Default: 60
+            tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
+                               in second. Default: 10
+            timeout_recovery:
+                Buffer recovery timeout make sure devices are recovered at the end
+                of the trigger execution. Used when previous timeouts have been exhausted.
+
+                max_time (`int`): Maximum wait time for the last step of the trigger,
+                                in second. Default: 180
+                interval (`int`): Wait time between iteration when looping is needed,
+                                in second. Default: 15
+            static:
+                 The keys below are dynamically learnt by default.
+                 However, they can also be set to a custom value when provided in the trigger datafile.
+
+                 instance: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn BGP Ops object and store the BGP instance(s)
            if has any, otherwise, SKIP the trigger
         2. Do "process shutdown bgp"
         3. Verify the state of BGP instance(s) is "KILLED"
         4. Do "process restart bpm"
```

## genie/libs/sdk/triggers/shutnoshut/interface/shutnoshut.py

```diff
@@ -36,46 +36,54 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+               The keys below are dynamically learnt by default.
+               However, they can also be set to a custom value when provided in the trigger datafile.
+
+               interface: `str`
+
+               (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                     OR
+                     interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Interface Ops object and store the "up" trunk interface(s)
            if has any, otherwise, SKIP the trigger
         2. Shut the learned trunk interface(s) from step 1 with Interface Conf object
         3. Verify the state of learned trunk interface(s) from step 2 is "down"
         4. Unshut the trunk interface(s) with Interface Conf object
         5. Learn Interface Ops again and verify it is the same as the Ops in step 1
 
     """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>.*)', 'switchport_mode', 'trunk'],
-                                                       ['info', '(?P<name>.*)', 'enabled', True],
-                                                       ['info', '(?P<name>.*)', 'port_channel',
+                                       'requirements':[['info', '(?P<interface>.*)', 'switchport_mode', 'trunk'],
+                                                       ['info', '(?P<interface>.*)', 'enabled', True],
+                                                       ['info', '(?P<interface>.*)', 'port_channel',
                                                         'port_channel_int', '(?P<port_int>.*)'],
-                                                       ['info', '(?P<name>.*)', 'oper_status', 'up']],
+                                                       ['info', '(?P<interface>.*)', 'oper_status', 'up']],
                                        'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[['enabled', False]],
                                        'verify_conf':False,
-                                       'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                       'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>.*)', 'enabled', False],
-                                                       ['info', '(?P<name>.*)', 'oper_status', 'down'],
+                                       'requirements':[['info', '(?P<interface>.*)', 'enabled', False],
+                                                       ['info', '(?P<interface>.*)', 'oper_status', 'down'],
                                                        ['info', '(?P<port_int>.*)', 'enabled', False],
                                                        ['info', '(?P<port_int>.*)', 'oper_status', 'down']],
                                        'exclude': interface_exclude + ['(Vlan.*)']}},
-                      num_values={'name': 1, 'port_int': 'all'})
+                      num_values={'interface': 1, 'port_int': 'all'})
 
 
 class TriggerShutNoShutEthernetInterface(TriggerShutNoShut):
     """Shut and unshut the dynamically learned Ethernet interface(s)."""
 
     __description__ = """Shut and unshut the dynamically learned Ethernet interface(s).
 
@@ -96,45 +104,53 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+               The keys below are dynamically learnt by default.
+               However, they can also be set to a custom value when provided in the trigger datafile.
+
+               interface: `str`
+
+               (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                     OR
+                     interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Interface Ops object and store the "up" Ethernet interface(s)
            if has any, otherwise, SKIP the trigger
         2. Shut the learned Ethernet interface(s) from step 1 with Interface Conf object
         3. Verify the state of learned Ethernet interface(s) from step 2 is "down"
         4. Unshut the Ethernet interface(s) with Interface Conf object
         5. Learn Interface Ops again and verify it is the same as the Ops in step 1
 
     """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
                                         'requirements':[\
-                                            ['info', '(?P<name>Ethernet(\S+))', 'oper_status', 'up'],
-                                            ['info', '(?P<name>.*)', 'enabled', True],
-                                            ['info', '(?P<name>.*)', 'port_channel', 'port_channel_member', False]],
+                                            ['info', '(?P<interface>Ethernet(\S+))', 'oper_status', 'up'],
+                                            ['info', '(?P<interface>.*)', 'enabled', True],
+                                            ['info', '(?P<interface>.*)', 'port_channel', 'port_channel_member', False]],
                                         'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                         'requirements':[['enabled', False]],
                                         'verify_conf':False,
-                                        'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                        'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                                'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
                                         'requirements':[\
-                                            ['info', '(?P<name>.*)', 'enabled', False],
-                                            ['info', '(?P<name>.*)', 'oper_status', 'down'],
+                                            ['info', '(?P<interface>.*)', 'enabled', False],
+                                            ['info', '(?P<interface>.*)', 'oper_status', 'down'],
                                             ['info', '(.*)', 'enabled', False]],
                                         'exclude': interface_exclude}},
-                      num_values={'name': 1})
+                      num_values={'interface': 1})
 
 
 class TriggerShutNoShutVlanInterface(TriggerShutNoShut):
     """Shut and unshut the dynamically learned Vlan interface(s)."""
 
     __description__ = """Shut and unshut the dynamically learned Vlan interface(s).
 
@@ -155,42 +171,51 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+               The keys below are dynamically learnt by default.
+               However, they can also be set to a custom value when provided in the trigger datafile.
+
+               interface: `str`
+               mtu: `str`
+
+               (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                     OR
+                     interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Interface Ops object and store the "up" Vlan interface(s)
            if has any, otherwise, SKIP the trigger
         2. Shut the learned Vlan interface(s) from step 1 with Interface Conf object
         3. Verify the state of learned Vlan interface(s) from step 2 is "down"
         4. Unshut the Vlan interface(s) with Interface Conf object
         5. Learn Interface Ops again and verify it is the same as the Ops in step 1
         
     """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>Vlan[0-9]+)', 'mtu', '(?P<mtu>.*)'],
-                                                       ['info', '(?P<name>.*)', 'enabled', True],
-                                                       ['info', '(?P<name>.*)', 'oper_status', 'up']],
+                                       'requirements':[['info', '(?P<interface>Vlan[0-9]+)', 'mtu', '(?P<mtu>.*)'],
+                                                       ['info', '(?P<interface>.*)', 'enabled', True],
+                                                       ['info', '(?P<interface>.*)', 'oper_status', 'up']],
                                        'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[['enabled', False]],
                                        'verify_conf':False,
-                                       'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                       'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>.*)', 'enabled', False],
-                                                       ['info', '(?P<name>.*)', 'oper_status', 'down']],
+                                       'requirements':[['info', '(?P<interface>.*)', 'enabled', False],
+                                                       ['info', '(?P<interface>.*)', 'oper_status', 'down']],
                                        'exclude': interface_exclude}},
-                      num_values={'name': 1, 'mtu': 1})
+                      num_values={'interface': 1, 'mtu': 1})
 
 
 class TriggerShutNoShutLoopbackInterface(TriggerShutNoShut):
     """Shut and unshut the dynamically learned Loopback interface(s)."""
     
     __description__ = """Shut and unshut the dynamically learned Loopback interface(s).
 
@@ -211,15 +236,23 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+               The keys below are dynamically learnt by default.
+               However, they can also be set to a custom value when provided in the trigger datafile.
+
+               interface: `str`
+
+               (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                     OR
+                     interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Interface Ops object and store the "up" Loopback interface(s)
            if has any, otherwise, SKIP the trigger
         2. Shut the learned Loopback interface(s) from step 1 with Interface Conf object
         3. Verify the state of learned Loopback interface(s) from step 2 is "down"
         4. Unshut the Loopback interface(s) with Interface Conf object
         5. Learn Interface Ops again and verify it is the same as the Ops in step 1
@@ -227,19 +260,19 @@
     """
 
     loopback_exclude = interface_exclude + ['oper_status', 'enabled', 'status']
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>(Loopback|Lo|loopback)[0-9]+)', 'oper_status', 'up']],
+                                       'requirements':[['info', '(?P<interface>(Loopback|Lo|loopback)[0-9]+)', 'oper_status', 'up']],
                                        'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[['enabled', False]],
                                        'verify_conf':False,
-                                       'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                       'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>.*)', 'enabled', False],
-                                                       ['info', '(?P<name>.*)', 'oper_status', 'down']],
+                                       'requirements':[['info', '(?P<interface>.*)', 'enabled', False],
+                                                       ['info', '(?P<interface>.*)', 'oper_status', 'down']],
                                        'exclude': loopback_exclude}},
-                      num_values={'name': 1})
+                      num_values={'interface': 1})
```

## genie/libs/sdk/triggers/shutnoshut/interface/iosxe/shutnoshut.py

```diff
@@ -26,136 +26,397 @@
 dot1x_exclude = ['maker', 'statistics', 'session']
 
 # Which key to exclude for fdb Ops comparison
 fdb_exclude = ['maker', 'total_mac_addresses']
 
 
 class TriggerShutNoShutTrunkInterface(TriggerShutNoShut):
+    """Shut and unshut dynamically learned trunk interface(s)"""
+
+    __description__ = """Shut and unshut the dynamically learned trunk interface(s).
+
+       trigger_datafile:
+           Mandatory:
+               timeout:
+                   max_time (`int`): Maximum wait time for the trigger,
+                                   in second. Default: 180
+                   interval (`int`): Wait time between iteration when looping is needed,
+                                   in second. Default: 15
+           Optional:
+               tgn_timeout (`int`): Maximum wait time for all traffic threads to be
+                                    restored to the reference rate,
+                                    in second. Default: 60
+               tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
+                                  in second. Default: 10
+               timeout_recovery:
+                   Buffer recovery timeout make sure devices are recovered at the end
+                   of the trigger execution. Used when previous timeouts have been exhausted.
+
+                   max_time (`int`): Maximum wait time for the last step of the trigger,
+                                   in second. Default: 180
+                   interval (`int`): Wait time between iteration when looping is needed,
+                                   in second. Default: 15
+               static:
+                    The keys below are dynamically learnt by default.
+                    However, they can also be set to a custom value when provided in the trigger datafile.
+
+                    interface: `str`
+
+                   (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                         OR
+                         interface: 'Ethernet1/1/1' (Specific value)
+       steps:
+           1. Learn Interface Ops object and verify if has any enabled interface(s) with up status,
+              and also switch port mode should be trunk
+           2. Shut the Interface learned from step 1 with Interface Conf object
+           3. Verify the state of learned interface(s) and switchport and
+              from step 2 are "down"
+           4. Unshut the trunk interface(s)
+           5. Learn Interface Ops again and verify It is the same as the Ops in step 1
+
+       """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>.*)', 'switchport_mode', 'trunk'],
-                                                       ['info', '(?P<name>.*)', 'enabled', True],
-                                                       ['info', '(?P<name>.*)', 'port_channel', 'port_channel_member', False],
-                                                       ['info', '(?P<name>.*)', 'oper_status', 'up']],
+                                       'requirements':[['info', '(?P<interface>.*)', 'switchport_mode', 'trunk'],
+                                                       ['info', '(?P<interface>.*)', 'enabled', True],
+                                                       ['info', '(?P<interface>.*)', 'port_channel', 'port_channel_member', False],
+                                                       ['info', '(?P<interface>.*)', 'oper_status', 'up']],
                                         'kwargs': {'attributes': ['info[(.*)][switchport_mode]',
                                                                   'info[(.*)][switchport_enable]',
                                                                   'info[(.*)][oper_status]',
                                                                   'info[(.*)][enabled]',
                                                                   'info[(.*)][port_channel]']},
                                        'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[['enabled', False]],
                                        'verify_conf':False,
-                                       'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                       'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>.*)', 'enabled', False],
-                                                       ['info', '(?P<name>.*)', 'oper_status', 'down'],
-                                                       ['info', '(?P<name>.*)', 'switchport_enable', False]],
+                                       'requirements':[['info', '(?P<interface>.*)', 'enabled', False],
+                                                       ['info', '(?P<interface>.*)', 'oper_status', 'down'],
+                                                       ['info', '(?P<interface>.*)', 'switchport_enable', False]],
                                         'kwargs': {'attributes': ['info[(.*)][switchport_mode]',
                                                                   'info[(.*)][switchport_enable]',
                                                                   'info[(.*)][oper_status]',
                                                                   'info[(.*)][enabled]',
                                                                   'info[(.*)][port_channel]']},
                                        'exclude': interface_exclude}},
-                      num_values={'name': 1})
+                      num_values={'interface': 1})
 
 
 class TriggerShutNoShutVlanInterface(TriggerShutNoShut):
+    """Shut and unshut the dynamically learned vlan interface(s)."""
 
+    __description__ = """Shut and unshut the dynamically learned vlan interface(s).
+
+        trigger_datafile:
+            Mandatory:
+                timeout:
+                    max_time (`int`): Maximum wait time for the trigger,
+                                    in second. Default: 180
+                    interval (`int`): Wait time between iteration when looping is needed,
+                                    in second. Default: 15
+            Optional:
+                tgn_timeout (`int`): Maximum wait time for all traffic threads to be
+                                     restored to the reference rate,
+                                     in second. Default: 60
+                tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
+                                   in second. Default: 10
+                timeout_recovery:
+                    Buffer recovery timeout make sure devices are recovered at the end
+                    of the trigger execution. Used when previous timeouts have been exhausted.
+
+                    max_time (`int`): Maximum wait time for the last step of the trigger,
+                                    in second. Default: 180
+                    interval (`int`): Wait time between iteration when looping is needed,
+                                    in second. Default: 15
+                static:
+                    The keys below are dynamically learnt by default.
+                    However, they can also be set to a custom value when provided in the trigger datafile.
+
+                    interface: `str`
+                    mtu: `str`
+
+                   (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                         OR
+                         interface: 'Ethernet1/1/1' (Specific value)
+        steps:
+            1. Learn Interface Ops object and store the "up" vlan interface(s)
+               if has any, otherwise, SKIP the trigger.
+            2. Shut the learned vlan interface(s) from step 1 with Interface Conf object
+            3. Verify the state of learned vlan interface(s) from step 2 is "down"
+            4. Unshut the vlan interface(s) with Interface Conf object
+            5. Learn Interface Ops again and verify it is the same as the Ops in step 1
+
+        """
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>Vlan[0-9]+)', 'mtu', '(?P<mtu>.*)'],
-                                                       ['info', '(?P<name>.*)', 'enabled', True],
-                                                       ['info', '(?P<name>.*)', 'oper_status', 'up']],
+                                       'requirements':[['info', '(?P<interface>Vlan[0-9]+)', 'mtu', '(?P<mtu>.*)'],
+                                                       ['info', '(?P<interface>.*)', 'enabled', True],
+                                                       ['info', '(?P<interface>.*)', 'oper_status', 'up']],
                                        'all_keys': True,
                                        'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[['enabled', False]],
                                        'verify_conf':False,
-                                       'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                       'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>.*)', 'enabled', False],
-                                                       ['info', '(?P<name>.*)', 'oper_status', 'down']],
+                                       'requirements':[['info', '(?P<interface>.*)', 'enabled', False],
+                                                       ['info', '(?P<interface>.*)', 'oper_status', 'down']],
                                        'exclude': interface_exclude + ['ipv6']}},
-                      num_values={'name': 1, 'mtu': 1})
+                      num_values={'interface': 1, 'mtu': 1})
 
 
 class TriggerShutNoShutHsrpIpv4VlanInterface(TriggerShutNoShut):
+    """Shut and Unshut the dynamically learned Hsrp Ipv4 Vlan interface(s)."""
+
+    __description__ = """Shut and Unshut the dynamically learned Hsrp Ipv4 Vlan interface(s).
+
+        trigger_datafile:
+            Mandatory:
+                timeout:
+                    max_time (`int`): Maximum wait time for the trigger,
+                                    in second. Default: 180
+                    interval (`int`): Wait time between iteration when looping is needed,
+                                    in second. Default: 15
+            Optional:
+                tgn_timeout (`int`): Maximum wait time for all traffic threads to be
+                                     restored to the reference rate,
+                                     in second. Default: 60
+                tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
+                                   in second. Default: 10
+                timeout_recovery:
+                    Buffer recovery timeout make sure devices are recovered at the end
+                    of the trigger execution. Used when previous timeouts have been exhausted.
+
+                    max_time (`int`): Maximum wait time for the last step of the trigger,
+                                    in second. Default: 180
+                    interval (`int`): Wait time between iteration when looping is needed,
+                                    in second. Default: 15
+                static:
+                    The keys below are dynamically learnt by default.
+                    However, they can also be set to a custom value when provided in the trigger datafile.
+
+                    interface: `str`
+
+                   (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                         OR
+                         interface: 'Ethernet1/1/1' (Specific value)
+        steps:
+        1. Learn Interface Ops object and verify if has any "up" "ipv4" Vlan interface(s),
+           and learn Hsrp Ops verify if has any "up" "ipv4" Vlan interface(s) that exists
+           in learned Vlan interface(s) from Interface Ops. Store the filtered
+           "up" "ipv4" Vlan interface(s) if has any, otherwise, SKIP the trigger
+        2. Shut the learned Hsrp Ipv4 Vlan interface(s) from step 1 with Interface Conf object
+        3. Verify the state of learned Hsrp Ipv4 Vlan interface(s) from step 2 is "down"
+        4. Unshut the Hsrp Ipv4 Vlan interface(s) with Interface Conf object
+        5. Learn Interface Ops again and verify it is the same as the Ops in step 1
+        """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface': {
-                                        'requirements': [['info', '(?P<name>Vlan[0-9]+)', 'oper_status', 'up'],
-                                                         ['info', '(?P<name>.*)', 'ipv4', '(?P<ipv4>.*)']],
+                                        'requirements': [['info', '(?P<interface>Vlan[0-9]+)', 'oper_status', 'up'],
+                                                         ['info', '(?P<interface>.*)', 'ipv4', '(?P<ipv4>.*)']],
                                         'exclude': interface_exclude + ['ipv6']},
                                     'ops.hsrp.hsrp.Hsrp': {
-                                        'requirements': [['info', '(?P<name>Vlan[0-9]+)', 'address_family','ipv4','(.*)']],
+                                        'requirements': [['info', '(?P<interface>Vlan[0-9]+)', 'address_family','ipv4','(.*)']],
                                         'exclude': hsrp_exclude }},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[['enabled', False]],
                                        'verify_conf':False,
-                                       'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                       'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>Vlan[0-9]+)', 'enabled', False],
-                                                       ['info', '(?P<name>Vlan[0-9]+)', 'oper_status', 'down']],
+                                       'requirements':[['info', '(?P<interface>Vlan[0-9]+)', 'enabled', False],
+                                                       ['info', '(?P<interface>Vlan[0-9]+)', 'oper_status', 'down']],
                                        'exclude': interface_exclude + ['ipv6']}},
-                      num_values={'name': 1})
+                      num_values={'interface': 1})
 
 
 class TriggerShutNoShutHsrpIpv6VlanInterface(TriggerShutNoShut):
+    """Shut and Unshut the dynamically learned Hsrp Ipv6 Vlan interface(s)."""
+
+    __description__ = """Shut and Unshut the dynamically learned Hsrp Ipv6 Vlan interface(s).
+
+        trigger_datafile:
+            Mandatory:
+                timeout:
+                    max_time (`int`): Maximum wait time for the trigger,
+                                    in second. Default: 180
+                    interval (`int`): Wait time between iteration when looping is needed,
+                                    in second. Default: 15
+            Optional:
+                tgn_timeout (`int`): Maximum wait time for all traffic threads to be
+                                     restored to the reference rate,
+                                     in second. Default: 60
+                tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
+                                   in second. Default: 10
+                timeout_recovery:
+                    Buffer recovery timeout make sure devices are recovered at the end
+                    of the trigger execution. Used when previous timeouts have been exhausted.
+
+                    max_time (`int`): Maximum wait time for the last step of the trigger,
+                                    in second. Default: 180
+                    interval (`int`): Wait time between iteration when looping is needed,
+                                    in second. Default: 15
+                static:
+                    The keys below are dynamically learnt by default.
+                    However, they can also be set to a custom value when provided in the trigger datafile.
+
+                    interface: `str`
+
+                   (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                         OR
+                         interface: 'Ethernet1/1/1' (Specific value)
+        steps:
+        1. Learn Interface Ops object and verify if has any "up" "ipv6" Vlan interface(s),
+           and learn Hsrp Ops verify if has any "up" "ipv6" Vlan interface(s) that exists
+           in learned Vlan interface(s) from Interface Ops. Store the filtered
+           "up" "ipv6" Vlan interface(s) if has any, otherwise, SKIP the trigger
+        2. Shut the learned Hsrp Ipv6 Vlan interface(s) from step 1 with Interface Conf object
+        3. Verify the state of learned Hsrp Ipv6 Vlan interface(s) from step 2 is "down"
+        4. Unshut the Hsrp Ipv6 Vlan interface(s) with Interface Conf object
+        5. Learn Interface Ops again and verify it is the same as the Ops in step 1
+        """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface': {
-                                        'requirements': [['info', '(?P<name>Vlan[0-9]+)', 'oper_status', 'up'],
-                                                         ['info', '(?P<name>.*)', 'ipv6', '(?P<ipv6>.*)']],
+                                        'requirements': [['info', '(?P<interface>Vlan[0-9]+)', 'oper_status', 'up'],
+                                                         ['info', '(?P<interface>.*)', 'ipv6', '(?P<ipv6>.*)']],
                                         'exclude': interface_exclude + ['ipv4','status']},
                                     'ops.hsrp.hsrp.Hsrp': {
-                                        'requirements': [['info', '(?P<name>Vlan[0-9]+)', 'address_family','ipv6','(.*)']],
+                                        'requirements': [['info', '(?P<interface>Vlan[0-9]+)', 'address_family','ipv6','(.*)']],
                                         'exclude': hsrp_exclude }},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[['enabled', False]],
                                        'verify_conf':False,
-                                       'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                       'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>.*)', 'enabled', False],
-                                                       ['info', '(?P<name>.*)', 'oper_status', 'down']],
+                                       'requirements':[['info', '(?P<interface>.*)', 'enabled', False],
+                                                       ['info', '(?P<interface>.*)', 'oper_status', 'down']],
                                        'exclude': interface_exclude + ['ipv4','status']}},
-                      num_values={'name': 1})
+                      num_values={'interface': 1})
 
 
 class TriggerShutNoShutLoopbackInterface(TriggerShutNoShut):
+    """Shut and unshut the dynamically learned loopback interface(s)."""
+
+    __description__ = """Shut and unshut the dynamically learned loopback interface(s).
+
+           trigger_datafile:
+               Mandatory:
+                   timeout:
+                       max_time (`int`): Maximum wait time for the trigger,
+                                       in second. Default: 180
+                       interval (`int`): Wait time between iteration when looping is needed,
+                                       in second. Default: 15
+               Optional:
+                   tgn_timeout (`int`): Maximum wait time for all traffic threads to be
+                                        restored to the reference rate,
+                                        in second. Default: 60
+                   tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
+                                      in second. Default: 10
+                   timeout_recovery:
+                       Buffer recovery timeout make sure devices are recovered at the end
+                       of the trigger execution. Used when previous timeouts have been exhausted.
+
+                       max_time (`int`): Maximum wait time for the last step of the trigger,
+                                       in second. Default: 180
+                       interval (`int`): Wait time between iteration when looping is needed,
+                                       in second. Default: 15
+                   static:
+                       The keys below are dynamically learnt by default.
+                       However, they can also be set to a custom value when provided in the trigger datafile.
+
+                       interface: `str`
+
+                      (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                            OR
+                            interface: 'Ethernet1/1/1' (Specific value)
+           steps:
+               1. Learn Interface Ops object and store the "up" loopback interface(s)
+                  if has any, otherwise, SKIP the trigger.
+               2. Shut the learned loopback interface(s) from step 1 with Interface Conf object
+               3. Verify the state of learned loopback interface(s) from step 2 is "down"
+               4. Unshut the loopback interface(s) with Interface Conf object
+               5. Learn Interface Ops again and verify it is the same as the Ops in step 1
+
+           """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>(Loopback|Lo|loopback)[0-9]+)', 'oper_status', 'up'],
-                                                       ['info', '(?P<name>(Loopback|Lo|loopback)[0-9]+)', '(?P<af>ipv4|6)', Not('unnumbered')]
+                                       'requirements':[['info', '(?P<interface>(Loopback|Lo|loopback)[0-9]+)', 'oper_status', 'up'],
+                                                       ['info', '(?P<interface>(Loopback|Lo|loopback)[0-9]+)', '(?P<af>ipv4|6)', Not('unnumbered')]
                                        ],
                                        'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[['enabled', False]],
                                        'verify_conf':False,
-                                       'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                       'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>.*)', 'enabled', False],
-                                                       ['info', '(?P<name>.*)', 'oper_status', 'down']],
+                                       'requirements':[['info', '(?P<interface>.*)', 'enabled', False],
+                                                       ['info', '(?P<interface>.*)', 'oper_status', 'down']],
                                        'exclude': interface_exclude}},
-                      num_values={'name': 1})
+                      num_values={'interface': 1})
 
 
 class TriggerShutNoShutEthernetInterface(TriggerShutNoShut):
+    """Shut and unshut the dynamically learned Ethernet interface(s)."""
+
+    __description__ = """Shut and unshut the dynamically learned Ethernet interface(s).
+
+               trigger_datafile:
+                   Mandatory:
+                       timeout:
+                           max_time (`int`): Maximum wait time for the trigger,
+                                           in second. Default: 180
+                           interval (`int`): Wait time between iteration when looping is needed,
+                                           in second. Default: 15
+                   Optional:
+                       tgn_timeout (`int`): Maximum wait time for all traffic threads to be
+                                            restored to the reference rate,
+                                            in second. Default: 60
+                       tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
+                                          in second. Default: 10
+                       timeout_recovery:
+                           Buffer recovery timeout make sure devices are recovered at the end
+                           of the trigger execution. Used when previous timeouts have been exhausted.
+
+                           max_time (`int`): Maximum wait time for the last step of the trigger,
+                                           in second. Default: 180
+                           interval (`int`): Wait time between iteration when looping is needed,
+                                           in second. Default: 15
+                       static:
+                           The keys below are dynamically learnt by default.
+                           However, they can also be set to a custom value when provided in the trigger datafile.
+
+                           interface: `str`
+
+                          (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                                OR
+                                interface: 'Ethernet1/1/1' (Specific value)
+               steps:
+                   1. Learn Interface Ops object and store the "up" Ethernet interface(s) and "False" port channel member,
+                      if has any, otherwise, SKIP the trigger.
+                   2. Shut the learned Ethernet interface(s) from step 1 with Interface Conf object
+                   3. Verify the state of learned Ethernet interface(s) from step 2 is "down"
+                   4. Unshut the Ethernet interface(s) with Interface Conf object
+                   5. Learn Interface Ops again and verify it is the same as the Ops in step 1
+
+               """
 
     def remove_related_subinterface(item, name, **kwargs):
         """Check if interface (item) needs to remove sub-interfaces
         by checking with the given main interface (name).
 
            Args:
                item (`str`): Interface name to be checked if need to remove the sub-interfaces.
@@ -178,39 +439,39 @@
             return True
         return False
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
                                         'requirements':[\
-                                            ['info', '(?P<name>\w+Ethernet[\d\/]+$)', 'oper_status', 'up'],
-                                            ['info', '(?P<name>.*)', 'port_channel', 'port_channel_member', False]],
+                                            ['info', '(?P<interface>\w+Ethernet[\d\/]+$)', 'oper_status', 'up'],
+                                            ['info', '(?P<interface>.*)', 'port_channel', 'port_channel_member', False]],
                                         'exclude': interface_exclude,
                                         'kwargs': {'attributes': ['info[(.*)][switchport_enable]',
                                                                   'info[(.*)][enabled]',
                                                                   'info[(.*)][oper_status]',
                                                                   'info[(.*)][port_channel]']},
                                         'include_management_interface': False}},
                       config_info={'conf.interface.Interface':{
                                         'requirements':[['enabled', False]],
                                         'verify_conf':False,
-                                        'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                        'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                                'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
                                         'requirements':[\
-                                            ['info', '(?P<name>.*)', 'enabled', False],
-                                            ['info', '(?P<name>.*)', 'oper_status', 'down'],
-                                            ['info', '(?P<name>.*)', 'switchport_enable', False]],
+                                            ['info', '(?P<interface>.*)', 'enabled', False],
+                                            ['info', '(?P<interface>.*)', 'oper_status', 'down'],
+                                            ['info', '(?P<interface>.*)', 'switchport_enable', False]],
                                         'kwargs': {'attributes': ['info[(.*)][switchport_enable]',
                                                                   'info[(.*)][enabled]',
                                                                   'info[(.*)][oper_status]',
                                                                   'info[(.*)][port_channel]']},
                                         'exclude': interface_exclude +\
                                                    [remove_related_subinterface]}},
-                      num_values={'name': 1})
+                      num_values={'interface': 1})
 
 
 class TriggerShutNoShutNativeIpv4SviInterface(TriggerShutNoShut):
     """Shut and unshut Vlan 1 with ipv4 configured."""
 
     __description__ = """Shut and unshut Vlan 1 with ipv4 configured.
 
@@ -231,53 +492,61 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Interface Ops object and store the "up" Vlan 1 with ipv4 configured
            if has any, otherwise, SKIP the trigger
         2. Shut the Vlan 1 from step 1 with Interface Conf object
         3. Verify the state of Vlan 1 from step 2 is "down"
         4. Unshut the Vlan 1 with Interface Conf object
         5. Learn Interface Ops again and verify it is the same as the Ops in step 1
 
     """
 
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>Vlan1)', 'enabled', True],
-                                                       ['info', '(?P<name>.*)', 'port_channel', 'port_channel_member', False],
-                                                       ['info', '(?P<name>.*)', 'oper_status', 'up']],
+                                       'requirements':[['info', '(?P<interface>Vlan1)', 'enabled', True],
+                                                       ['info', '(?P<interface>.*)', 'port_channel', 'port_channel_member', False],
+                                                       ['info', '(?P<interface>.*)', 'oper_status', 'up']],
                                         'kwargs': {'attributes': ['info[(.*)][port_channel]',
                                                                   'info[(.*)][switchport_enable]',
                                                                   'info[(.*)][enabled]',
                                                                   'info[(.*)][oper_status]']},
                                        'all_keys': True,
                                        'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[['enabled', False]],
                                        'verify_conf':False,
-                                       'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                       'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>.*)', 'enabled', False],
-                                                       ['info', '(?P<name>.*)', 'oper_status', 'down'],
-                                                       ['info', '(?P<name>.*)', 'switchport_enable', False]],
+                                       'requirements':[['info', '(?P<interface>.*)', 'enabled', False],
+                                                       ['info', '(?P<interface>.*)', 'oper_status', 'down'],
+                                                       ['info', '(?P<interface>.*)', 'switchport_enable', False]],
                                         'kwargs': {'attributes': ['info[(.*)][port_channel]',
                                                                   'info[(.*)][switchport_enable]',
                                                                   'info[(.*)][enabled]',
                                                                   'info[(.*)][oper_status]']},
                                        'exclude': interface_exclude}},
-                      num_values={'name': 1})
+                      num_values={'interface': 1})
 
 
 class TriggerShutNoShutIpv4SviInterface(TriggerShutNoShut):
     """Shut and unshut Learned Vlan interface(s) with ipv4 configured."""
 
     __description__ = """Shut and unshut Learned Vlan interface(s) with ipv4 configured.
 
@@ -298,14 +567,23 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn Interface Ops object and store the "up" Vlan interface(s) with ipv4 configured
            if has any, otherwise, SKIP the trigger
         2. Shut the learned Vlan interface(s) from step 1 with Interface Conf object
         3. Verify the state of learned Vlan interface(s) from step 2 is "down"
         4. Unshut the Vlan interface(s) with Interface Conf object
@@ -313,39 +591,39 @@
 
     """
 
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>Vlan[0-9]+)', 'enabled', True],
-                                                       ['info', '(?P<name>.*)', 'ipv4', '(?P<ip>.*)', 'ip', '(?P<ipaddr>.*)'],
-                                                       ['info', '(?P<name>.*)', 'port_channel', 'port_channel_member', False],
-                                                       ['info', '(?P<name>.*)', 'oper_status', 'up']],
+                                       'requirements':[['info', '(?P<interface>Vlan[0-9]+)', 'enabled', True],
+                                                       ['info', '(?P<interface>.*)', 'ipv4', '(?P<ip>.*)', 'ip', '(?P<ipaddr>.*)'],
+                                                       ['info', '(?P<interface>.*)', 'port_channel', 'port_channel_member', False],
+                                                       ['info', '(?P<interface>.*)', 'oper_status', 'up']],
                                        'all_keys': True,
                                        'kwargs': {'attributes': ['info[(.*)][port_channel]',
                                                                  'info[(.*)][enabled]',
                                                                  'info[(.*)][oper_status]',
                                                                  'info[(.*)][ipv4][(.*)]']},
                                        'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[['enabled', False]],
                                        'verify_conf':False,
-                                       'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                       'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>.*)', 'enabled', False],
-                                                       ['info', '(?P<name>.*)', 'oper_status', 'down'],
-                                                       ['info', '(?P<name>.*)', 'switchport_enable', False]],
+                                       'requirements':[['info', '(?P<interface>.*)', 'enabled', False],
+                                                       ['info', '(?P<interface>.*)', 'oper_status', 'down'],
+                                                       ['info', '(?P<interface>.*)', 'switchport_enable', False]],
                                        'kwargs': {'attributes': ['info[(.*)][port_channel]',
                                                                  'info[(.*)][enabled]',
                                                                  'info[(.*)][oper_status]',
                                                                  'info[(.*)][ipv4][(.*)]']},
                                        'exclude': interface_exclude}},
-                      num_values={'name': 1})
+                      num_values={'interface': 1})
 
 
 class TriggerShutNoShutDot1xInterface(TriggerShutNoShut):
     """Shut and unshut the dynamically learned Dot1x Ethernet interface(s)."""
 
     __description__ = """Shut and unshut the dynamically learned Dot1x Ethernet interface(s).
 
@@ -366,15 +644,25 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+                vlan: `str`
+                client: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Interface Ops object and store the "up" Ethernet interface(s)
            if has any, otherwise, SKIP the trigger, then check if the status of dot1x is 'auth',
            and the peer mac-address in UUT's table is 'static', if not, SKIP the trigger
            And Learn Dot1x Ops object and store the dot1x interface whcih are from the
            interface ops.
         2. Shut the learned Dot1x Ethernet interface(s) from step 1 with Interface Conf object
@@ -383,60 +671,57 @@
         5. Learn Interface Ops again and verify it is the same as the Ops in step 1
 
     """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>\w+Ethernet[\d\/]+$)', 'enabled', True],
-                                                       ['info', '(?P<name>.*)', 'switchport_enable', True],
-                                                       ['info', '(?P<name>.*)', 'switchport_mode', 'static access'],
-                                                       ['info', '(?P<name>.*)', 'oper_status', 'up']],
+                                       'requirements':[['info', '(?P<interface>\w+Ethernet[\d\/]+$)', 'enabled', True],
+                                                       ['info', '(?P<interface>.*)', 'switchport_enable', True],
+                                                       ['info', '(?P<interface>.*)', 'switchport_mode', 'static access'],
+                                                       ['info', '(?P<interface>.*)', 'oper_status', 'up']],
                                        'all_keys': True,
                                        'kwargs': {'attributes': ['info[(.*)][switchport_mode]',
                                                                  'info[(.*)][oper_status]',
                                                                  'info[(.*)][enabled]',
                                                                  'info[(.*)][switchport_enable]',
                                                                  'info[(.*)][operational_mode]']},
                                        'exclude': interface_exclude},
                                     'ops.fdb.fdb.Fdb':{
                                        'requirements':[['info', 'mac_table', 'vlans', '(?P<vlan>.*)',
                                                         'mac_addresses', '(?P<client>.*)',
-                                                        'interfaces', '(?P<name>.*)', 'entry_type', 'static']],
+                                                        'interfaces', '(?P<interface>.*)', 'entry_type', 'static']],
                                        'all_keys': True,
                                        'kwargs':{'attributes':['info[mac_table][vlans][(.*)]']},
                                        'exclude': fdb_exclude + ['mac_addresses']},
                                     'ops.dot1x.dot1x.Dot1x':{
-                                       'requirements':[['info', 'interfaces', '(?P<name>.*)',
+                                       'requirements':[['info', 'interfaces', '(?P<interface>.*)',
                                                         'clients', '(?P<client>.*)', 'status', 'authorized']],
                                        'kwargs':{'attributes':['info[interfaces][(.*)][clients][(.*)][status]']},
                                        'all_keys': True,
                                        'exclude': dot1x_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[['enabled', False]],
                                        'verify_conf':False,
-                                       'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                       'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>.*)', 'enabled', False],
-                                                       ['info', '(?P<name>.*)', 'oper_status', 'down'],
-                                                       ['info', '(?P<name>.*)', 'switchport_enable', False]],
+                                       'requirements':[['info', '(?P<interface>.*)', 'enabled', False],
+                                                       ['info', '(?P<interface>.*)', 'oper_status', 'down'],
+                                                       ['info', '(?P<interface>.*)', 'switchport_enable', False]],
                                        'kwargs': {'attributes': ['info[(.*)][switchport_mode]',
                                                                  'info[(.*)][oper_status]',
                                                                  'info[(.*)][enabled]',
                                                                  'info[(.*)][switchport_enable]',
                                                                  'info[(.*)][operational_mode]']},
-                                       'missing': False,
                                        'exclude': interface_exclude},
                                   'ops.fdb.fdb.Fdb':{
                                        'requirements':[['info', 'mac_table', 'vlans', '(?P<vlan>.*)',
-                                                        'mac_addresses', '(?P<client>.*)']],
+                                                        'mac_addresses', NotExists('(?P<client>.*)')]],
                                        'kwargs':{'attributes':['info[mac_table][vlans][(.*)]']},
-                                       'missing': True,
                                        'exclude': fdb_exclude + ['mac_addresses']},
                                     'ops.dot1x.dot1x.Dot1x':{
-                                       'requirements':[['info', 'interfaces', '(?P<name>.*)']],
+                                       'requirements':[['info', 'interfaces', NotExists('(?P<interface>.*)')]],
                                        'kwargs':{'attributes':['info[interfaces][(.*)][clients][(.*)][status]']},
                                        'all_keys': True,
-                                       'missing': True,
                                        'exclude': dot1x_exclude + ['attributes']}},
-                      num_values={'name': 'all'})
+                      num_values={'interface': 'all'})
```

## genie/libs/sdk/triggers/shutnoshut/interface/iosxr/shutnoshut.py

```diff
@@ -13,25 +13,69 @@
                      'out_broadcast_pkts', 'accounting']
 
 ## IOSXR TriggerShutNoShutTrunkInterface implemented seperately since it
 ## doesn't need port_channel_member = False as in NXOS.
 
 
 class TriggerShutNoShutTrunkInterface(TriggerShutNoShut):
+    """Shut and unshut the dynamically learned interface(s) when switchport mode is trunk."""
+
+    __description__ = """Shut and unshut the dynamically learned interface(s) when switchport mode is trunk.
+
+       trigger_datafile:
+           Mandatory:
+               timeout:
+                   max_time (`int`): Maximum wait time for the trigger,
+                                   in second. Default: 180
+                   interval (`int`): Wait time between iteration when looping is needed,
+                                   in second. Default: 15
+           Optional:
+               tgn_timeout (`int`): Maximum wait time for all traffic threads to be
+                                    restored to the reference rate,
+                                    in second. Default: 60
+               tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
+                                  in second. Default: 10
+               timeout_recovery:
+                   Buffer recovery timeout make sure devices are recovered at the end
+                   of the trigger execution. Used when previous timeouts have been exhausted.
+
+                   max_time (`int`): Maximum wait time for the last step of the trigger,
+                                   in second. Default: 180
+                   interval (`int`): Wait time between iteration when looping is needed,
+                                   in second. Default: 15
+               static:
+                   The keys below are dynamically learnt by default.
+                   However, they can also be set to a custom value when provided in the trigger datafile.
+
+                   interface: `str`
+
+                   (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                         OR
+                         interface: 'Ethernet1/1/1' (Specific value)
+       steps:
+           1. Learn Interface Ops object and store the "up" interface(s)
+              if has any, otherwise, SKIP the trigger, then check the switchport mode to be "trunk"
+              if not, SKIP the trigger
+           2. Shut the learned interface(s) from step 1 with Interface Conf object
+           3. Verify the state of learned interface(s) from step 2 is "down"
+           4. Unshut the interface(s) with Interface Conf object
+           5. Learn Interface Ops again and verify it is the same as the Ops in step 1
+
+       """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>.*)', 'switchport_mode', 'trunk'],
-                                                       ['info', '(?P<name>.*)', 'enabled', True],
-                                                       ['info', '(?P<name>.*)', 'oper_status', 'up']],
+                                       'requirements':[['info', '(?P<interface>.*)', 'switchport_mode', 'trunk'],
+                                                       ['info', '(?P<interface>.*)', 'enabled', True],
+                                                       ['info', '(?P<interface>.*)', 'oper_status', 'up']],
                                        'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[['enabled', False]],
                                        'verify_conf':False,
-                                       'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                       'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>.*)', 'enabled', False],
-                                                       ['info', '(?P<name>.*)', 'oper_status', 'down']],
+                                       'requirements':[['info', '(?P<interface>.*)', 'enabled', False],
+                                                       ['info', '(?P<interface>.*)', 'oper_status', 'down']],
                                        'exclude': interface_exclude}},
-                      num_values={'name': 1})
+                      num_values={'interface': 1})
```

## genie/libs/sdk/triggers/shutnoshut/interface/nxos/shutnoshut.py

```diff
@@ -25,32 +25,77 @@
 pim_conf_exclude = ['__testbed__', 'devices', 'interfaces', 'parent']
 
 pim_exclude = ['maker', 'bsr_next_bootstrap', 'rp_candidate_next_advertisement',
                'expiration', 'up_time']
 
 
 class TriggerShutNoShutVlanInterface(TriggerShutNoShut):
+    """Shut and unshut the dynamically learned Vlan interface(s)"""
 
-     # Mapping of Information between Ops and Conf
-     # Also permit to dictate which key to verify
-     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
-                                        'requirements':[['info', '(?P<name>Vlan[0-9]+)', 'mtu', '(?P<mtu>.*)'],
-                                                        ['info', '(?P<name>.*)', 'enabled', True],
-                                                        ['info', '(?P<name>.*)', 'oper_status', 'up']],
+    __description__ = """Shut and unshut the dynamically learned Vlan interface(s).
+
+     trigger_datafile:
+         Mandatory:
+             timeout:
+                 max_time (`int`): Maximum wait time for the trigger,
+                                 in second. Default: 180
+                 interval (`int`): Wait time between iteration when looping is needed,
+                                 in second. Default: 15
+         Optional:
+             tgn_timeout (`int`): Maximum wait time for all traffic threads to be
+                                  restored to the reference rate,
+                                  in second. Default: 60
+             tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
+                                in second. Default: 10
+             timeout_recovery:
+                 Buffer recovery timeout make sure devices are recovered at the end
+                 of the trigger execution. Used when previous timeouts have been exhausted.
+
+                 max_time (`int`): Maximum wait time for the last step of the trigger,
+                                 in second. Default: 180
+                 interval (`int`): Wait time between iteration when looping is needed,
+                                 in second. Default: 15
+             static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+                mtu: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
+
+     steps:
+         1. Learn Interface Ops object and verify if has any "up" Vlan interface(s),
+            if has any, otherwise, SKIP the trigger
+         2. Shut the learned Vlan interface(s) from step 1 with Interface Conf object
+         3. Verify the state of learned Vlan interface(s) from step 2 is "down"
+         4. Unshut the Vlan interface(s) with Interface Conf object
+         5. Learn Interface Ops again and verify it is the same as the Ops in step 1
+
+    """
+
+    # Mapping of Information between Ops and Conf
+    # Also permit to dictate which key to verify
+    mapping = Mapping(requirements={'ops.interface.interface.Interface':{
+                                        'requirements':[['info', '(?P<interface>Vlan[0-9]+)', 'mtu', '(?P<mtu>.*)'],
+                                                        ['info', '(?P<interface>.*)', 'enabled', True],
+                                                        ['info', '(?P<interface>.*)', 'oper_status', 'up']],
                                         'exclude': interface_exclude}},
                        config_info={'conf.interface.Interface':{
                                         'requirements':[['enabled', False]],
                                         'verify_conf':False,
-                                        'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                        'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                                'attach': False}}}},
                        verify_ops={'ops.interface.interface.Interface':{
-                                        'requirements':[['info', '(?P<name>.*)', 'enabled', False],
-                                                        ['info', '(?P<name>.*)', 'oper_status', '(.*down)']],
+                                        'requirements':[['info', '(?P<interface>.*)', 'enabled', False],
+                                                        ['info', '(?P<interface>.*)', 'oper_status', '(.*down)']],
                                         'exclude': interface_exclude + ['ipv6']}},
-                       num_values={'name': 1, 'mtu': 1})
+                       num_values={'interface': 1, 'mtu': 1})
 
 
 class TriggerShutNoShutHsrpIpv4VlanInterface(TriggerShutNoShut):
     """Shut and unshut the dynamically learned Hsrp Ipv4 Vlan interface(s)."""
 
     __description__ = """Shut and unshut the dynamically learned Hsrp Ipv4 Vlan interface(s).
 
@@ -71,15 +116,23 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+               The keys below are dynamically learnt by default.
+               However, they can also be set to a custom value when provided in the trigger datafile.
+
+               interface: `str`
+
+               (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                     OR
+                     interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Interface Ops object and verify if has any "up" "ipv4" Vlan interface(s),
            and learn Hsrp Ops verify if has any "up" "ipv4" Vlan interface(s) that exists
            in learned Vlan interface(s) from Interface Ops. Store the filtered
            "up" "ipv4" Vlan interface(s) if has any, otherwise, SKIP the trigger
         2. Shut the learned Hsrp Ipv4 Vlan interface(s) from step 1 with Interface Conf object
         3. Verify the state of learned Hsrp Ipv4 Vlan interface(s) from step 2 is "down"
@@ -87,30 +140,30 @@
         5. Learn Interface Ops again and verify it is the same as the Ops in step 1
         
     """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface': {
-                                        'requirements': [['info', '(?P<name>Vlan[0-9]+)', 'oper_status', 'up'],
-                                                         ['info', '(?P<name>.*)', 'ipv4', '(?P<ipv4>.*)']],
+                                        'requirements': [['info', '(?P<interface>Vlan[0-9]+)', 'oper_status', 'up'],
+                                                         ['info', '(?P<interface>.*)', 'ipv4', '(?P<ipv4>.*)']],
                                         'exclude': interface_exclude + ['ipv6']},
                                     'ops.hsrp.hsrp.Hsrp': {
-                                        'requirements': [['info', '(?P<name>Vlan[0-9]+)', 'address_family','ipv4','(.*)']],
+                                        'requirements': [['info', '(?P<interface>Vlan[0-9]+)', 'address_family','ipv4','(.*)']],
                                         'exclude': hsrp_exclude }},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[['enabled', False]],
                                        'verify_conf':False,
-                                       'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                       'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>Vlan[0-9]+)', 'enabled', False],
-                                                       ['info', '(?P<name>Vlan[0-9]+)', 'oper_status', 'down']],
+                                       'requirements':[['info', '(?P<interface>Vlan[0-9]+)', 'enabled', False],
+                                                       ['info', '(?P<interface>Vlan[0-9]+)', 'oper_status', 'down']],
                                        'exclude': interface_exclude + ['ipv6']}},
-                      num_values={'name': 1})
+                      num_values={'interface': 1})
 
 
 class TriggerShutNoShutHsrpIpv6VlanInterface(TriggerShutNoShut):
     """Shut and Unshut the dynamically learned Hsrp Ipv6 Vlan interface(s)."""
     
     __description__ = """Shut and Unshut the dynamically learned Hsrp Ipv6 Vlan interface(s).
 
@@ -131,15 +184,23 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+               The keys below are dynamically learnt by default.
+               However, they can also be set to a custom value when provided in the trigger datafile.
+
+               interface: `str`
+
+               (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                     OR
+                     interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Interface Ops object and verify if has any "up" "ipv6" Vlan interface(s),
            and learn Hsrp Ops verify if has any "up" "ipv6" Vlan interface(s) that exists
            in learned Vlan interface(s) from Interface Ops. Store the filtered
            "up" "ipv6" Vlan interface(s) if has any, otherwise, SKIP the trigger
         2. Shut the learned Hsrp Ipv6 Vlan interface(s) from step 1 with Interface Conf object
         3. Verify the state of learned Hsrp Ipv6 Vlan interface(s) from step 2 is "down"
@@ -147,30 +208,30 @@
         5. Learn Interface Ops again and verify it is the same as the Ops in step 1
         
     """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface': {
-                                        'requirements': [['info', '(?P<name>Vlan[0-9]+)', 'oper_status', 'up'],
-                                                         ['info', '(?P<name>.*)', 'ipv6', '(?P<ipv6>.*)']],
+                                        'requirements': [['info', '(?P<interface>Vlan[0-9]+)', 'oper_status', 'up'],
+                                                         ['info', '(?P<interface>.*)', 'ipv6', '(?P<ipv6>.*)']],
                                         'exclude': interface_exclude + ['ipv4','status']},
                                     'ops.hsrp.hsrp.Hsrp': {
-                                        'requirements': [['info', '(?P<name>Vlan[0-9]+)', 'address_family','ipv6','(.*)']],
+                                        'requirements': [['info', '(?P<interface>Vlan[0-9]+)', 'address_family','ipv6','(.*)']],
                                         'exclude': hsrp_exclude }},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[['enabled', False]],
                                        'verify_conf':False,
-                                       'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                       'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>.*)', 'enabled', False],
-                                                       ['info', '(?P<name>.*)', 'oper_status', 'down']],
+                                       'requirements':[['info', '(?P<interface>.*)', 'enabled', False],
+                                                       ['info', '(?P<interface>.*)', 'oper_status', 'down']],
                                        'exclude': interface_exclude + ['ipv4','status']}},
-                      num_values={'name': 1})
+                      num_values={'interface': 1})
 
 
 class TriggerShutNoShutNveOverlayInterface(TriggerShutNoShut):
     """Shut and unshut the dynamically learned Nve onverlay interface(s)."""
 
     __description__ = """Shut and unshut the dynamically learned Nve onverlay interface(s).
 
@@ -191,45 +252,53 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+               The keys below are dynamically learnt by default.
+               However, they can also be set to a custom value when provided in the trigger datafile.
+
+               interface: `str`
+
+               (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                     OR
+                     interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn VxLan Ops object and verify if has any "up" Nve interface(s),
            otherwise, SKIP the trigger
         2. Shut the learned Nve interface(s) from step 1 with Interface Conf object
         3. Verify the state of learned Nve interface(s) from step 2 is "down"
         4. Unshut the Nve interface(s) with Interface Conf object
         5. Learn VxLan Ops again and verify it is the same as the Ops in step 1
         
     """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.vxlan.vxlan.Vxlan': {
-                                        'requirements': [['nve', '(?P<name>.*)', 'if_state', 'up']],
+                                        'requirements': [['nve', '(?P<interface>.*)', 'if_state', 'up']],
                                         'kwargs': {'attributes': [
                                                       'nve[(.*)][if_state]',
                                                       'nve[(.*)][vni][(.*)][vni]']},
                                         'exclude': nve_exclude}},
                       config_info={'conf.interface.Interface':{
                                         'requirements':[['enabled', False]],
                                         'verify_conf':False,
-                                        'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                        'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                                'attach': False}}}},
                       verify_ops={'ops.vxlan.vxlan.Vxlan':{
-                                        'requirements':[['nve', '(?P<name>.*)', 'if_state', 'down']],
+                                        'requirements':[['nve', '(?P<interface>.*)', 'if_state', 'down']],
                                         'kwargs': {'attributes': [
                                                       'nve[(.*)][if_state]',
                                                       'nve[(.*)][vni][(.*)][vni]']},
                                         'exclude': nve_exclude}},
-                      num_values={'name': 1})
+                      num_values={'interface': 1})
 
 
 class TriggerShutNoShutAutoRpInterface(TriggerShutNoShut):
     """Shut and unshut the dynamically learned pim auto-rp interface(s) under default vrf."""
 
     __description__ = """Shut and unshut the dynamically learned  pim auto-rp interface(s) under default vrf.
 
@@ -250,15 +319,23 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+               The keys below are dynamically learnt by default.
+               However, they can also be set to a custom value when provided in the trigger datafile.
+
+               interface: `str`
+
+               (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                     OR
+                     interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn PIM Ops object and verify if has any "up" pim auto-rp interface(s) under default vrf,
            store pim auto-rp interface(s) if has any, otherwise, SKIP the trigger
         2. Shut the learned pim auto-rp interface(s) from step 1 with Interface Conf object
         3. Verify the state of learned pim auto-rp interface(s) from step 2 is "down"
         4. Unshut the pim auto-rp interface(s) with Interface Conf object
         5. Learn PIM Ops again and verify it is the same as the Ops in step 1
@@ -266,31 +343,30 @@
     """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'conf.pim.Pim': {
                                         'requirements': [['device_attr', '{uut}', '_vrf_attr',
                                                           '(?P<vrf>^default$)', '_address_family_attr',
-                                                          '(?P<af>ipv4)', 'send_rp_announce_intf', '(?P<rp_intf>.*)']],
+                                                          '(?P<address_family>ipv4)', 'send_rp_announce_intf', '(?P<interface>.*)']],
                                         'kwargs': {'attributes': ['pim[vrf_attr][(.*)][address_family_attr][ipv4][send_rp_announce_intf]']},
                                         'exclude': pim_conf_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[['enabled', False]],
                                        'verify_conf':False,
-                                       'kwargs':{'mandatory':{'name': '(?P<rp_intf>.*)',
+                                       'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<rp_intf>.*)', 'enabled', False],
-                                                       ['info', '(?P<rp_intf>.*)', 'oper_status', 'down']],
-                                        'missing': False,
+                                       'requirements':[['info', '(?P<interface>.*)', 'enabled', False],
+                                                       ['info', '(?P<interface>.*)', 'oper_status', 'down']],
                                         'kwargs': {'attributes': [
                                                       'info[(.*)][enabled]',
                                                       'info[(.*)][oper_status]',]},
                                        'exclude': interface_exclude}},
-                      num_values={'rp_intf': 1, 'vrf': 1, 'af': 1})
+                      num_values={'interface': 1, 'vrf': 1, 'address_family': 1})
 
 
 class TriggerShutNoShutAutoRpVrfInterface(TriggerShutNoShut):
     """Shut and unshut the dynamically learned pim auto-rp interface(s) under non-default vrf."""
 
     __description__ = """Shut and unshut the dynamically learned  pim auto-rp interface(s) under non-default vrf.
 
@@ -311,15 +387,24 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+               The keys below are dynamically learnt by default.
+               However, they can also be set to a custom value when provided in the trigger datafile.
+
+               send_rp_announce_intf: `str`
+               vrf: `str`
+
+               (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                     OR
+                     interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn PIM Ops object and verify if has any "up" pim auto-rp interface(s) under non-default vrf,
            store pim auto-rp interface(s) if has any, otherwise, SKIP the trigger
         2. Shut the learned pim auto-rp interface(s) from step 1 with Interface Conf object
         3. Verify the state of learned pim auto-rp interface(s) from step 2 is "down"
         4. Unshut the pim auto-rp interface(s) with Interface Conf object
         5. Learn PIM Ops again and verify it is the same as the Ops in step 1
@@ -327,31 +412,30 @@
     """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'conf.pim.Pim': {
                                         'requirements': [['device_attr', '{uut}', '_vrf_attr',
                                                           '(?P<vrf>^(?!default)\w+$)', '_address_family_attr',
-                                                          '(?P<af>ipv4)', 'send_rp_announce_intf', '(?P<rp_intf>.*)']],
+                                                          '(?P<af>ipv4)', 'send_rp_announce_intf', '(?P<send_rp_announce_intf>.*)']],
                                         'kwargs': {'attributes': ['pim[vrf_attr][(.*)][address_family_attr][ipv4][send_rp_announce_intf]']},
                                         'exclude': pim_conf_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[['enabled', False]],
                                        'verify_conf':False,
-                                       'kwargs':{'mandatory':{'name': '(?P<rp_intf>.*)',
+                                       'kwargs':{'mandatory':{'name': '(?P<send_rp_announce_intf>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<rp_intf>.*)', 'enabled', False],
-                                                       ['info', '(?P<rp_intf>.*)', 'oper_status', 'down']],
-                                        'missing': False,
+                                       'requirements':[['info', '(?P<send_rp_announce_intf>.*)', 'enabled', False],
+                                                       ['info', '(?P<send_rp_announce_intf>.*)', 'oper_status', 'down']],
                                         'kwargs': {'attributes': [
                                                       'info[(.*)][enabled]',
                                                       'info[(.*)][oper_status]',]},
                                        'exclude': interface_exclude}},
-                      num_values={'rp_intf': 1, 'vrf': 1, 'af': 1})
+                      num_values={'send_rp_announce_intf': 1, 'vrf': 1, 'af': 1})
 
 
 # TODO: Enhance find to take (.*) after the first level
 class TriggerShutNoShutBsrRpInterface(TriggerShutNoShut):
     """Shut and unshut the dynamically learned pim bsr-candidate interface(s) under default vrf."""
 
     __description__ = """Shut and unshut the dynamically learned  pim bsr-candidate interface(s) under default vrf.
@@ -412,29 +496,27 @@
                                        'requirements':[['enabled', False]],
                                        'verify_conf':False,
                                        'kwargs':{'mandatory':{'name': '(?P<rp_intf>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
                                        'requirements':[['info', '(?P<rp_intf>.*)', 'enabled', False],
                                                        ['info', '(?P<rp_intf>.*)', 'oper_status', 'down']],
-                                        'missing': False,
                                         'kwargs': {'attributes': [
                                                       'info[(.*)][(ipv4|ipv6)][(.*)][ip]',
                                                       'info[(.*)][vrf]',
                                                       'info[(.*)][enabled]',
                                                       'info[(.*)][oper_status]',]},
                                        'exclude': interface_exclude},
                                   'ops.pim.pim.Pim':{
                                        'requirements':[['info', 'vrf', '(?P<vrf>^default$)',
                                                         'address_family','(?P<af>.*)', 'rp', 'bsr',
-                                                        'bsr'],
+                                                        NotExists('bsr')],
                                                        ['info', 'vrf', '(?P<vrf>^default$)',
                                                         'address_family','(?P<af>.*)', 'rp', 'bsr',
-                                                        'bsr_candidate']],
-                                        'missing': True,
+                                                        NotExists('bsr_candidate')]],
                                         'kwargs': {'attributes': [
                                                       'info[vrf][default][address_family][(.*)][rp][bsr][(.*)]']},
                                         'exclude': pim_exclude }},
                       num_values={'rp_intf': 1, 'vrf': 'all', 'rp_addr': 'all', 'af': 'all'})
 
 
 class TriggerShutNoShutBsrRpVrfInterface(TriggerShutNoShut):
@@ -499,29 +581,27 @@
                                        'requirements':[['enabled', False]],
                                        'verify_conf':False,
                                        'kwargs':{'mandatory':{'name': '(?P<rp_intf>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
                                        'requirements':[['info', '(?P<rp_intf>.*)', 'enabled', False],
                                                        ['info', '(?P<rp_intf>.*)', 'oper_status', 'down']],
-                                        'missing': False,
                                         'kwargs': {'attributes': [
                                                       'info[(.*)][(ipv4|ipv6)][(.*)][ip]',
                                                       'info[(.*)][vrf]',
                                                       'info[(.*)][enabled]',
                                                       'info[(.*)][oper_status]']},
                                        'exclude': interface_exclude},
                                   'ops.pim.pim.Pim':{
                                        'requirements':[['info', 'vrf', '(?P<vrf>^(?!default)\w+$)',
                                                         'address_family','(?P<af>.*)', 'rp', 'bsr',
-                                                        'bsr'],
+                                                        NotExists('bsr')],
                                                        ['info', 'vrf', '(?P<vrf>^(?!default)\w+$)',
                                                         'address_family','(?P<af>.*)', 'rp', 'bsr',
-                                                        'bsr_candidate']],
-                                        'missing': True,
+                                                        NotExists('bsr_candidate')]],
                                         'kwargs': {'attributes': [
                                                       'info[vrf][(.*)][address_family][(.*)][rp][bsr][(.*)]']},
                                         'exclude': pim_exclude }},
                       num_values={'rp_intf': 1, 'vrf': 'all', 'rp_addr': 'all', 'af': 'all'})
 
 
 class TriggerShutNoShutStaticRpInterface(TriggerShutNoShut):
@@ -585,26 +665,24 @@
                                        'requirements':[['enabled', False]],
                                        'verify_conf':False,
                                        'kwargs':{'mandatory':{'name': '(?P<rp_intf>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
                                        'requirements':[['info', '(?P<rp_intf>.*)', 'enabled', False],
                                                        ['info', '(?P<rp_intf>.*)', 'oper_status', 'down']],
-                                        'missing': False,
                                         'kwargs': {'attributes': [
                                                       'info[(.*)][(ipv4|ipv6)][(.*)][ip]',
                                                       'info[(.*)][vrf]',
                                                       'info[(.*)][enabled]',
                                                       'info[(.*)][oper_status]']},
                                        'exclude': interface_exclude},
                                   'ops.pim.pim.Pim':{
                                        'requirements':[['info', 'vrf', '(?P<vrf>^default$)',
                                                         'address_family','(?P<af>.*)', 'rp', 'static_rp',
-                                                        '(?P<static_rp>.*)']],
-                                        'missing': True,
+                                                        NotExists('(?P<static_rp>.*)')]],
                                         'kwargs': {'attributes': [
                                                       'info[vrf][default][address_family][(.*)][rp][static_rp][(.*)]']},
                                         'exclude': pim_exclude }},
                       num_values={'rp_intf': 1, 'vrf': 'all', 'rp_addr': 'all', 'af': 'all'})
 
 
 class TriggerShutNoShutStaticRpVrfInterface(TriggerShutNoShut):
@@ -668,26 +746,24 @@
                                        'requirements':[['enabled', False]],
                                        'verify_conf':False,
                                        'kwargs':{'mandatory':{'name': '(?P<rp_intf>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
                                        'requirements':[['info', '(?P<rp_intf>.*)', 'enabled', False],
                                                        ['info', '(?P<rp_intf>.*)', 'oper_status', 'down']],
-                                        'missing': False,
                                         'kwargs': {'attributes': [
                                                       'info[(.*)][(ipv4|ipv6)][(.*)][ip]',
                                                       'info[(.*)][vrf]',
                                                       'info[(.*)][enabled]',
                                                       'info[(.*)][oper_status]']},
                                        'exclude': interface_exclude},
                                   'ops.pim.pim.Pim':{
                                        'requirements':[['info', 'vrf', '(?P<vrf>^(?!default)\w+$)',
                                                         'address_family','(?P<af>.*)', 'rp', 'static_rp',
-                                                        '(?P<static_rp>.*)']],
-                                        'missing': True,
+                                                        NotExists('(?P<static_rp>.*)')]],
                                         'kwargs': {'attributes': [
                                                       'info[vrf][(.*)][address_family][(.*)][rp][static_rp][(.*)]']},
                                         'exclude': pim_exclude }},
                       num_values={'rp_intf': 1, 'vrf': 'all', 'rp_addr': 'all', 'af': 'all'})
 
 
 class TriggerShutNoShutPimNbrInterface(TriggerShutNoShut):
@@ -754,28 +830,26 @@
                                        'requirements':[['enabled', False]],
                                        'verify_conf':False,
                                        'kwargs':{'mandatory':{'name': '(?P<pim_intf>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
                                        'requirements':[['info', '(?P<pim_intf>.*)', 'enabled', False],
                                                        ['info', '(?P<pim_intf>.*)', 'oper_status', 'down']],
-                                        'missing': False,
                                         'kwargs': {'attributes': [
                                                       'info[(.*)][vrf]',
                                                       'info[(.*)][enabled]',
                                                       'info[(.*)][oper_status]']},
                                        'exclude': interface_exclude},
                                   'ops.pim.pim.Pim':{
                                        'requirements':[['info', 'vrf', '(?P<vrf>^default$)',
-                                                        'interfaces','(?P<pim_intf>.*)', 'address_family',
-                                                        '(?P<af>.*)', 'oper_status'],
+                                                        'interfaces', '(?P<pim_intf>.*)', 'address_family',
+                                                        '(?P<af>.*)', NotExists('neighbors')],
                                                        ['info', 'vrf', '(?P<vrf>^default$)',
-                                                        'interfaces','(?P<pim_intf>.*)', 'address_family',
-                                                        '(?P<af>.*)', 'neighbors', '(?P<address>.*)']],
-                                        'missing': True,
+                                                        'interfaces', '(?P<pim_intf>.*)', 'address_family',
+                                                        '(?P<af>.*)', 'oper_status', 'down']],
                                         'kwargs': {'attributes': [
                                                       'info[vrf][default][interfaces][(.*)][address_family][(.*)][oper_status]',
                                                       'info[vrf][default][interfaces][(.*)][address_family][(.*)][neighbors]']},
                                         'exclude': pim_exclude }},
                       num_values={'pim_intf': 1, 'vrf': 'all'})
 
 
@@ -843,28 +917,26 @@
                                        'requirements':[['enabled', False]],
                                        'verify_conf':False,
                                        'kwargs':{'mandatory':{'name': '(?P<pim_intf>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
                                        'requirements':[['info', '(?P<pim_intf>.*)', 'enabled', False],
                                                        ['info', '(?P<pim_intf>.*)', 'oper_status', 'down']],
-                                        'missing': False,
                                         'kwargs': {'attributes': [
                                                       'info[(.*)][vrf]',
                                                       'info[(.*)][enabled]',
                                                       'info[(.*)][oper_status]']},
                                        'exclude': interface_exclude},
                                   'ops.pim.pim.Pim':{
-                                       'requirements':[['info', 'vrf', '(?P<vrf>^(?!default)\w+$)',
-                                                        'interfaces','(?P<pim_intf>.*)', 'address_family',
-                                                        '(?P<af>.*)', 'oper_status'],
-                                                       ['info', 'vrf', '(?P<vrf>^(?!default)\w+$)',
-                                                        'interfaces','(?P<pim_intf>.*)', 'address_family',
-                                                        '(?P<af>.*)', 'neighbors', '(?P<address>.*)']],
-                                        'missing': True,
+                                       'requirements': [['info', 'vrf', '(?P<vrf>.*)',
+                                                        'interfaces', '(?P<pim_intf>.*)', 'address_family',
+                                                        '(?P<af>.*)', NotExists('neighbors')],
+                                                       ['info', 'vrf', '(?P<vrf>.*)',
+                                                        'interfaces', '(?P<pim_intf>.*)', 'address_family',
+                                                        '(?P<af>.*)', 'oper_status', 'down']],
                                         'kwargs': {'attributes': [
                                                       'info[vrf][(.*)][interfaces][(.*)][address_family][(.*)][oper_status]',
                                                       'info[vrf][(.*)][interfaces][(.*)][address_family][(.*)][neighbors]']},
                                         'exclude': pim_exclude }},
                       num_values={'pim_intf': 1, 'vrf': 'all'})
 
 class TriggerShutNoShutPortChannelInterface(TriggerShutNoShut):
```

## genie/libs/sdk/triggers/shutnoshut/msdp/nxos/shutnoshut.py

```diff
@@ -37,15 +37,24 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+               The keys below are dynamically learnt by default.
+               However, they can also be set to a custom value when provided in the trigger datafile.
 
+               vrf: `str`
+               peer: `str`
+
+               (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                     OR
+                     interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Vlan Ops object and store the Msdp 'established' peer(s)
            if has any, otherwise, SKIP the trigger
         2. Shut the learned Msdp peer(s) from step 1 with Msdp Conf object
         3. Verify the state of learned Msdp peer(s) from step 2 is "down"
         4. Unshut the Msdp peer(s) with Msdp Conf object
         5. Learn Msdp Ops again and verify it is the same as the Ops in step 1
```

## genie/libs/sdk/triggers/shutnoshut/vlan/iosxe/shutnoshut.py

```diff
@@ -31,35 +31,43 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+               The keys below are dynamically learnt by default.
+               However, they can also be set to a custom value when provided in the trigger datafile.
+
+               vlan: `str`
+
+               (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                     OR
+                     interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Vlan Ops object and store the Vlan instance(s)
            if has any, otherwise, SKIP the trigger
         2. Shut the learned Vlan instance(s) from step 1 with Vlan Conf object
         3. Verify the state of learned Vlan instance(s) from step 2 is "down"
         4. Unshut the Vlan instance(s) with Vlan Conf object
         5. Learn Vlan Ops again and verify it is the same as the Ops in step 1
 
     """
 
     mapping = Mapping(requirements={'ops.vlan.vlan.Vlan':{
-                                        'requirements':[['info','vlans','(?P<vlanid>^([2-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1][0][0][0-1]))$',\
-                                                         'vlan_id','(?P<vlanid>^([2-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1][0][0][0-1]))$']],
+                                        'requirements':[['info','vlans','(?P<vlan>^([2-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1][0][0][0-1]))$',\
+                                                         'vlan_id','(?P<vlan>^([2-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1][0][0][0-1]))$']],
                                         'kwargs': {'attributes': ['info']},
                                         'exclude': vlan_exclude }},
                       config_info={'conf.vlan.Vlan':{
-                                     'requirements':[['device_attr', '{uut}', 'vlan_attr', '(?P<vlanid>.*)','shutdown', True]],
+                                     'requirements':[['device_attr', '{uut}', 'vlan_attr', '(?P<vlan>.*)','shutdown', True]],
                                      'verify_conf':False,
-                                     'kwargs':{'mandatory':{'vlanid': '(?P<vlanid>.*)'}}}},
+                                     'kwargs':{'mandatory':{'vlanid': '(?P<vlan>.*)'}}}},
                       verify_ops={'ops.vlan.vlan.Vlan':{
-                                    'requirements': [['info','vlans','(?P<vlanid>.*)','shutdown', True],
-                                                     ['info', 'vlans', '(?P<vlanid>.*)', 'state', 'shutdown']],
+                                    'requirements': [['info','vlans','(?P<vlan>.*)','shutdown', True],
+                                                     ['info', 'vlans', '(?P<vlan>.*)', 'state', 'shutdown']],
                                     'kwargs':{'attributes':['info']},
                                     'exclude': vlan_exclude}},
-                      num_values={'vlanid': 1})
+                      num_values={'vlan': 1})
```

## genie/libs/sdk/triggers/shutnoshut/vlan/nxos/shutnoshut.py

```diff
@@ -31,35 +31,43 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+               The keys below are dynamically learnt by default.
+               However, they can also be set to a custom value when provided in the trigger datafile.
+
+               vlan: `str`
+
+               (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                     OR
+                     interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Vlan Ops object and store the Vlan instance(s)
            if has any, otherwise, SKIP the trigger
         2. Shut the learned Vlan instance(s) from step 1 with Vlan Conf object
         3. Verify the state of learned Vlan instance(s) from step 2 is "down"
         4. Unshut the Vlan instance(s) with Vlan Conf object
         5. Learn Vlan Ops again and verify it is the same as the Ops in step 1
 
     """
 
     mapping = Mapping(requirements={'ops.vlan.vlan.Vlan':{
-                                        'requirements':[['info','vlans','(?P<vlanid>^([2-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1][0][0][0-1]))$',\
-                                                         'vlan_id','(?P<vlanid>^([2-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1][0][0][0-1]))$']],
+                                        'requirements':[['info','vlans','(?P<vlan>^([2-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1][0][0][0-1]))$',\
+                                                         'vlan_id','(?P<vlan>^([2-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1][0][0][0-1]))$']],
                                         'kwargs': {'attributes': ['info']},
                                         'exclude': vlan_exclude }},
                       config_info={'conf.vlan.Vlan':{
-                                     'requirements':[['device_attr', '{uut}', 'vlan_attr', '(?P<vlanid>.*)','shutdown', True]],
+                                     'requirements':[['device_attr', '{uut}', 'vlan_attr', '(?P<vlan>.*)','shutdown', True]],
                                      'verify_conf':False,
-                                     'kwargs':{'mandatory':{'vlanid': '(?P<vlanid>.*)'}}}},
+                                     'kwargs':{'mandatory':{'vlanid': '(?P<vlan>.*)'}}}},
                       verify_ops={'ops.vlan.vlan.Vlan':{
-                                    'requirements': [['info','vlans','(?P<vlanid>.*)','shutdown', True],
-                                                     ['info', 'vlans', '(?P<vlanid>.*)', 'state', 'shutdown']],
+                                    'requirements': [['info','vlans','(?P<vlan>.*)','shutdown', True],
+                                                     ['info', 'vlans', '(?P<vlan>.*)', 'state', 'shutdown']],
                                     'kwargs':{'attributes':['info']},
                                     'exclude': vlan_exclude + ['interfaces']}},
-                      num_values={'vlanid': 1})
+                      num_values={'vlan': 1})
```

## genie/libs/sdk/triggers/shutnoshut/vxlan/nxos/shutnoshut.py

```diff
@@ -46,46 +46,54 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+               The keys below are dynamically learnt by default.
+               However, they can also be set to a custom value when provided in the trigger datafile.
+
+               nve_name: `str`
+
+               (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                     OR
+                     interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn VxLan Ops object and verify if has any "up" Nve interface(s),
            otherwise, SKIP the trigger
         2. Shut the learned Nve interface(s) from step 1 with Interface Conf object
         3. Verify the state of learned Nve interface(s) from step 2 is "down"
         4. Unshut the Nve interface(s) with Interface Conf object
         5. Learn VxLan Ops again and verify it is the same as the Ops in step 1
 
     """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.vxlan.vxlan.Vxlan': {
-                                                'requirements': [['nve', '(?P<name>.*)', 'if_state', 'up']],
+                                                'requirements': [['nve', '(?P<nve_name>.*)', 'if_state', 'up']],
                                                 'kwargs': {'attributes': [
                                                                 'nve[(.*)][if_state]',
                                                                 'nve[(.*)][vni][(.*)][vni]','l2route']},
                                                 'exclude': nve_exclude + ['peer_id','tx_id','total_memory','mac','prefix',
                                                                           'memory','objects','total_mem','total_obj']}},
                     config_info={'conf.interface.Interface': {
                                                 'requirements': [['enabled', False]],
                                                 'verify_conf': False,
-                                                'kwargs': {'mandatory': {'name': '(?P<name>.*)',
+                                                'kwargs': {'mandatory': {'name': '(?P<nve_name>.*)',
                                                                          'attach': False}}}},
                     verify_ops={'ops.vxlan.vxlan.Vxlan': {
-                                                'requirements': [['nve', '(?P<name>.*)', 'if_state', 'down']],
+                                                'requirements': [['nve', '(?P<nve_name>.*)', 'if_state', 'down']],
                                                 'kwargs': {'attributes': [
                                                     'nve[(.*)][if_state]',
                                                     'nve[(.*)][vni][(.*)][vni]','l2route']},
                                                 'exclude': nve_exclude + ['l2route']}},
-                    num_values={'name': 1})
+                    num_values={'nve_name': 1})
 
 
 class TriggerShutNoShutNveLoopbackInterface(TriggerShutNoShut):
     """Shut and unshut the dynamically learned Nve loopback interface(s)."""
 
     __description__ = """Shut and unshut the dynamically learned Nve loopback interface(s).
 
@@ -106,15 +114,24 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+               The keys below are dynamically learnt by default.
+               However, they can also be set to a custom value when provided in the trigger datafile.
+
+               nve_name: `str`
+               source_if: `str`
+
+               (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                     OR
+                     interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn VxLan Ops object and verify if has any "up" Nve interface(s),
            otherwise, SKIP the trigger
         2. Shut the learned Nve interface(s) from step 1 with Interface Conf object
         3. Verify the state of learned Nve interface(s) from step 2 is "down"
         4. Unshut the Nve interface(s) with Interface Conf object
         5. Learn VxLan Ops again and verify it is the same as the Ops in step 1
```

## genie/libs/sdk/triggers/unconfigconfig/unconfigconfig.py

```diff
@@ -115,17 +115,17 @@
                None
 
            Raises:
                pyATS Results
         '''
 
         try:
-            self.mapping.verify_missing_ops(device=uut,
-                                            abstract=abstract,
-                                            steps=steps)
+            self.mapping.verify_ops(device=uut,
+                                    abstract=abstract,
+                                    steps=steps)
         except Exception as e:
             self.failed('Failed to verify the '
                         'unconfigure feature', from_exception=e)
 
     @aetest.test
     def restore_configuration(self, uut, method, abstract, steps):
         '''Rollback the configuration
```

## genie/libs/sdk/triggers/unconfigconfig/bgp/unconfigconfig.py

```diff
@@ -1,10 +1,10 @@
 '''Implementation for bgp unconfigconfig triggers'''
 
-from ats.utils.objects import Not
+from ats.utils.objects import Not, NotExists
 
 # Genie Libs
 from genie.libs.sdk.libs.utils.mapping import Mapping
 from genie.libs.sdk.triggers.unconfigconfig.unconfigconfig import TriggerUnconfigConfig
 
 
 # Which key to exclude for BGP Ops comparison
@@ -47,15 +47,26 @@
                 Buffer recovery timeout when the previous timeout has been exhausted,
                 to make sure the devices are recovered before ending the trigger
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn BGP Ops object and store the BGP neighbor(s)
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned BGP neighbor(s) from step 1 
            with BGP Conf object
         4. Verify the BGP neighbor(s) from step 3 are no longer existed
@@ -75,16 +86,15 @@
                       config_info={'conf.bgp.Bgp':{
                                      'requirements':[['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
                                                       'neighbor_attr','(?P<neighbor>.*)']],
                                      'verify_conf':False,
                                      'kwargs':{'mandatory':{'bgp_id': '(?P<bgp_id>.*)'}}}},
                       verify_ops={'ops.bgp.bgp.Bgp':{
                                     'requirements': [['info', 'instance', '(?P<instance>.*)', 'vrf',
-                                                   '(?P<vrf>.*)', 'neighbor',
-                                                   '(?P<neighbor>.*)', '(?P<neighbor_info>.*)']],
+                                                   '(?P<vrf>.*)', NotExists('neighbor')]], # '(?P<neighbor>.*)', '(?P<neighbor_info>.*)'
                                     'kwargs':{'attributes':['info']},
                                     'exclude': bgp_exclude}},
                       num_values={'vrf':'all', 'instance':'all',
                                   'neighbor':'all'})
 
 
 class TriggerUnconfigConfigBgp(TriggerUnconfigConfig):
@@ -115,15 +125,23 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn BGP Ops object and store the BGP instance(s)
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned BGP instance(s) from step 1 
            with BGP Conf object
         4. Verify the BGP instance(s) from step 3 are no longer existed
@@ -138,11 +156,11 @@
                                         'kwargs':{'attributes':['info']},
                                         'exclude': bgp_exclude}},
                       config_info={'conf.bgp.Bgp':{
                                      'requirements':[['device_attr', '{uut}']],
                                      'verify_conf':False,
                                      'kwargs':{'mandatory':{'bgp_id': '(?P<bgp_id>.*)'}}}},
                       verify_ops={'ops.bgp.bgp.Bgp':{
-                                    'requirements': [['info', 'instance']],
+                                    'requirements': [['info', NotExists('instance')]],
                                     'kwargs':{'attributes':['info']},
                                     'exclude': bgp_exclude}},
                       num_values={'bgp_id':'all', 'instance':'all'})
```

## genie/libs/sdk/triggers/unconfigconfig/bgp/nxos/unconfigconfig.py

```diff
@@ -8,15 +8,15 @@
 
 # ATS
 from ats import aetest
 from ats.utils.objects import Not, NotExists
 
 # Genie Libs
 from genie.libs.sdk.libs.utils.mapping import Mapping
-from genie.libs.sdk.libs.utils.triggeractions import Configure
+from genie.libs.sdk.libs.utils.triggeractions import Configure, verify_ops_or_logic
 from genie.libs.sdk.libs.utils.mapping import Mapping, Different
 from genie.libs.sdk.triggers.unconfigconfig.unconfigconfig import TriggerUnconfigConfig
 
 # ipaddress
 from ipaddress import IPv4Address, IPv6Address
 
 
@@ -28,14 +28,16 @@
                'bgp_table_version', 'holdtime', 'keepalive_interval',
                'route_reflector_client', 'capability',
                'distance_internal_as', 'bgp_neighbor_counters', 'memory_usage',
                'total_entries', 'routing_table_version', 'total_memory',
                'path', 'prefixes', 'cluster_id', 'distance_extern_as']
 
 trm_exclude = ['maker', 'keepalives', 'total', 'up_time', 'total_bytes',]
+
+
 class TriggerUnconfigConfigBgpNeighborSendCommunity(TriggerUnconfigConfig):
     """Unconfigure send-community under BGP and
         reapply the whole configurations for learned BGP."""
 
     __description__ = """Unconfigure send-community under BGP and reapply the
                     whole configurations for learned BGP
      trigger_datafile:
@@ -61,48 +63,61 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                address_family: `str`
+                send_community: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn BGP Ops object and store the BGP instance(s)
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure send-community under bgp pid from step 1
            with BGP Conf object
         4. Verify the send-comunity from step 3 are no longer existed
         5. Recover the device configurations to the one in step 2
         6. Learn BGP Ops again and verify it is the same as the Ops in step 1
 
     """
 
     mapping = Mapping(requirements={'ops.bgp.bgp.Bgp':{
                                           'requirements':[['info', 'instance', '(?P<instance>.*)','vrf', '(?P<vrf>.*)',
-                                                           'neighbor','(?P<neighbor>.*)','address_family','(?P<af>.*)',
+                                                           'neighbor','(?P<neighbor>.*)','address_family','(?P<address_family>.*)',
                                                            'send_community','(?P<send_community>.*)'],
                                                           ['info', 'instance', '(?P<instance>.*)', 'bgp_id', '(?P<bgp_id>.*)']],
                                           'all_keys':True,
                                           'kwargs':{'attributes': ['info']},
                                           'exclude': bgp_exclude}},
                       config_info={'conf.bgp.Bgp':{
                                      'requirements':[['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
                                                       'neighbor_attr','(?P<neighbor>.*)',
-                                                      'address_family_attr','(?P<af>.*)', 'nbr_af_send_community','(?P<send_community>.*)']],
+                                                      'address_family_attr','(?P<address_family>.*)', 'nbr_af_send_community','(?P<send_community>.*)']],
                                      'verify_conf':False,
                                      'kwargs':{'mandatory':{'bgp_id': '(?P<bgp_id>.*)'}}}},
                       verify_ops={'ops.bgp.bgp.Bgp':{
                                           'requirements':[['info', 'instance', '(?P<instance>.*)','vrf', '(?P<vrf>.*)',
-                                                           'neighbor','(?P<neighbor>.*)','address_family','(?P<af>.*)',
-                                                           'send_community']],
+                                                           'neighbor','(?P<neighbor>.*)','address_family','(?P<address_family>.*)',
+                                                           NotExists('send_community')]],
                                     'kwargs':{'attributes':['info']},
                                     'exclude': bgp_exclude}},
-                      num_values={'bgp_id':1, 'instance':1 , 'vrf':1, 'af':1, 'neighbor':1 })
+                      num_values={'bgp_id':1, 'instance':1 , 'vrf':1, 'address_family':1, 'neighbor':1 })
 
 
 class TriggerUnconfigConfigBgpNeighborSendCommunityExtended(TriggerUnconfigConfig):
     """Unconfigure send-community extended under a BGP neighbor and
        reapply the whole configurations of dynamically learned BGP pid"""
 
     __description__ = """Unconfigure send-community extended for a BGP neighbor and
@@ -131,47 +146,60 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                address_family: `str`
+                send_community: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn BGP Ops object and store the BGP instance(s)
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure send-community extended for a BGP neighbor of learned BGP pid from step 1
         4. Verify the send-community extended for BGP neighbor from step 3 are no longer existed
         5. Recover the device configurations to the one in step 2
         6. Learn BGP Ops again and verify it is the same as the Ops in step 1
 
     """
 
     mapping = Mapping(requirements={'ops.bgp.bgp.Bgp':{
                                           'requirements':[['info', 'instance', '(?P<instance>.*)','vrf', '(?P<vrf>.*)',
-                                                           'neighbor','(?P<neighbor>.*)','address_family','(?P<af>.*)',
+                                                           'neighbor','(?P<neighbor>.*)','address_family','(?P<address_family>.*)',
                                                            'send_community','(?P<send_community>(both|extended)+)$'],
                                                           ['info', 'instance', '(?P<instance>.*)', 'bgp_id', '(?P<bgp_id>.*)']],
                                           'all_keys':True,
                                           'kwargs':{'attributes': ['info']},
                                           'exclude': bgp_exclude}},
                       config_info={'conf.bgp.Bgp':{
                                      'requirements':[['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
                                                       'neighbor_attr','(?P<neighbor>.*)',
-                                                      'address_family_attr','(?P<af>.*)', 'nbr_af_send_community','(?P<send_community>.*)']],
+                                                      'address_family_attr','(?P<address_family>.*)', 'nbr_af_send_community','(?P<send_community>.*)']],
                                      'verify_conf':False,
                                      'kwargs':{'mandatory':{'bgp_id': '(?P<bgp_id>.*)'}}}},
                       verify_ops={'ops.bgp.bgp.Bgp':{
                                           'requirements':[['info', 'instance', '(?P<instance>.*)','vrf', '(?P<vrf>.*)',
-                                                           'neighbor','(?P<neighbor>.*)','address_family','(?P<af>.*)',
-                                                           'send_community']],
+                                                           'neighbor','(?P<neighbor>.*)','address_family','(?P<address_family>.*)',
+                                                           NotExists('send_community')]],
                                     'kwargs':{'attributes':['info']},
                                     'exclude': bgp_exclude}},
-                      num_values={'bgp_id':1, 'instance':1 , 'vrf':1, 'af':1, 'neighbor':1 })
+                      num_values={'bgp_id':1, 'instance':1 , 'vrf':1, 'address_family':1, 'neighbor':1 })
 
 class TriggerUnconfigConfigBgpNeighborSoftReconfiguration(TriggerUnconfigConfig):
     """Unconfigure soft-reconfiguration inbound for a BGP neighbor and
            reapply the whole configurations for learned BGP pid"""
 
     __description__ = """Unconfigure soft-reconfiguration inbound for a BGP neighbor and
            reapply the whole configurations for learned BGP pid
@@ -199,44 +227,56 @@
                     Buffer recovery timeout make sure devices are recovered at the end
                     of the trigger execution. Used when previous timeouts have been exhausted.
 
                     max_time (`int`): Maximum wait time for the last step of the trigger,
                                     in second. Default: 180
                     interval (`int`): Wait time between iteration when looping is needed,
                                     in second. Default: 15
-
+                static:
+                    The keys below are dynamically learnt by default.
+                    However, they can also be set to a custom value when provided in the trigger datafile.
+
+                    instance: `str`
+                    vrf: `str`
+                    neighbor: `str`
+                    address_family: `str`
+                    bgp_id: `int`
+
+                    (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                          OR
+                          interface: 'Ethernet1/1/1' (Specific value)
         steps:
             1. Learn BGP Ops object and store the BGP instance(s)
                if has any, otherwise, SKIP the trigger
             2. Save the current device configurations through "method" which user uses
             3. Unconfigure soft-reconfiguration inbound for a BGP neighbor of learned BGP pid from step 1
             4. Verify the soft-reconfiguration for BGP neighbor from step 3 are no longer existed
             5. Recover the device configurations to the one in step 2
             6. Learn BGP Ops again and verify it is the same as the Ops in step 1
     """
 
     mapping = Mapping(requirements={'ops.bgp.bgp.Bgp':{
                                           'requirements':[['info', 'instance', '(?P<instance>.*)','vrf', '(?P<vrf>.*)',
-                                                           'neighbor','(?P<neighbor>.*)','address_family','(?P<af>.*)',
+                                                           'neighbor','(?P<neighbor>.*)','address_family','(?P<address_family>.*)',
                                                            'soft_configuration',True ],
                                                           ['info', 'instance', '(?P<instance>.*)', 'bgp_id', '(?P<bgp_id>.*)']],
                                           'all_keys':True,
                                           'kwargs':{'attributes': ['info']},
                                           'exclude': bgp_exclude}},
                       config_info={'conf.bgp.Bgp':{
                                      'requirements': [['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
                                                       'neighbor_attr','(?P<neighbor>.*)',
-                                                      'address_family_attr','(?P<af>.*)',
+                                                      'address_family_attr','(?P<address_family>.*)',
                                                       'nbr_af_soft_reconfiguration',True]],
                                      'verify_conf':False,
                                      'kwargs':{'mandatory':{'bgp_id': '(?P<bgp_id>.*)'}}}},
                       verify_ops={'ops.bgp.bgp.Bgp':{
                                           'requirements':[['info', 'instance', '(?P<instance>.*)','vrf', '(?P<vrf>.*)',
-                                                           'neighbor','(?P<neighbor>.*)','address_family','(?P<af>.*)',
-                                                           'soft_configuration']],
+                                                           'neighbor','(?P<neighbor>.*)','address_family','(?P<address_family>.*)',
+                                                           NotExists('soft_configuration')]],
                                     'kwargs':{'attributes':['info']},
                                     'exclude': bgp_exclude}},
                       num_values={'bgp_id':1, 'instance':1 , 'vrf':1, 'neighbor':1 })
 
 
 class TriggerUnconfigConfigBgpKeepaliveHoldtime(TriggerUnconfigConfig):
     """Unconfigure keepalive interval and holdtime  and
@@ -268,15 +308,28 @@
                         Buffer recovery timeout make sure devices are recovered at the end
                         of the trigger execution. Used when previous timeouts have been exhausted.
 
                         max_time (`int`): Maximum wait time for the last step of the trigger,
                                         in second. Default: 180
                         interval (`int`): Wait time between iteration when looping is needed,
                                         in second. Default: 15
-
+                    static:
+                        The keys below are dynamically learnt by default.
+                        However, they can also be set to a custom value when provided in the trigger datafile.
+
+                        instance: `str`
+                        vrf: `str`
+                        neighbor: `str`
+                        keepalive_interval: `int`
+                        holdtime: `int`
+                        bgp_id: `int`
+
+                        (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                              OR
+                              interface: 'Ethernet1/1/1' (Specific value)
             steps:
                 1. Learn BGP Ops object and store the BGP instance(s)
                    if has any, otherwise, SKIP the trigger
                 2. Save the current device configurations through "method" which user uses
                 3. Unconfigure keepalive interval and holdtime for learned BGP pid from step 1
                 4. Verify the keepalive interval and holdtime for BGP pid from step 3 are no longer existed
                 5. Recover the device configurations to the one in step 2
@@ -303,16 +356,16 @@
                         ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)', 'keepalive_interval', '(?P<keepalive_interval>.*)'],
                         ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)', 'holdtime', '(?P<holdtime>.*)']],
                     'verify_conf': False,
                     'kwargs':{'mandatory':{'bgp_id': '(?P<bgp_id>.*)'}}}},
             verify_ops={\
                 'conf.bgp.Bgp': {
                     'requirements': [\
-                        ['device_attr', '{uut}', '_vrf_attr', '(?P<vrf>.*)', 'keepalive_interval'],
-                        ['device_attr', '{uut}', '_vrf_attr', '(?P<vrf>.*)', 'holdtime']],
+                        ['device_attr', '{uut}', '_vrf_attr', '(?P<vrf>.*)', NotExists('keepalive_interval')],
+                        ['device_attr', '{uut}', '_vrf_attr', '(?P<vrf>.*)', NotExists('holdtime')]],
                     'exclude': bgp_exclude}},
             num_values={'device': 1, 'bgp_id': 1, 'vrf': 1, 'instance': 1, 'neighbor': 1})
 
 
 class TriggerUnconfigConfigBgpFastExternalFallover(TriggerUnconfigConfig):
     """Unconfigure fast-external-fallover and reapply the whole configurations for learned BGP pid"""
 
@@ -342,15 +395,26 @@
                             Buffer recovery timeout make sure devices are recovered at the end
                             of the trigger execution. Used when previous timeouts have been exhausted.
 
                             max_time (`int`): Maximum wait time for the last step of the trigger,
                                             in second. Default: 180
                             interval (`int`): Wait time between iteration when looping is needed,
                                             in second. Default: 15
-
+                        static:
+                            The keys below are dynamically learnt by default.
+                            However, they can also be set to a custom value when provided in the trigger datafile.
+
+                            instance: `str`
+                            vrf: `str`
+                            neighbor: `str`
+                            bgp_id: `int`
+
+                            (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                                  OR
+                                  interface: 'Ethernet1/1/1' (Specific value)
                 steps:
                     1. Learn BGP Ops object and store the BGP instance(s)
                        if has any, otherwise, SKIP the trigger
                     2. Save the current device configurations through "method" which user uses
                     3. Unconfigure fast-external-fallover under learned BGP pid from step 1
                     4. Verify the fast-external-fallover under BGP pid from step 3 are no longer existed
                     5. Recover the device configurations to the one in step 2
@@ -372,19 +436,19 @@
                     'kwargs': {'attributes': ['info']},
                     'exclude': bgp_exclude}},
             config_info={\
                 'conf.bgp.Bgp': {
                     'requirements': [\
                         ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)', 'fast_external_fallover', True]],
                     'verify_conf': False,
-                    'kwargs': {'mandatory': {'bgp_id': [['info', 'instance', '(?P<instance>.*)', 'bgp_id', '(?P<bgp_id>.*)']]}}}},
+                    'kwargs': {'mandatory': {'bgp_id': '(?P<bgp_id>.*)'}}}},
             verify_ops={\
                 'conf.bgp.Bgp': {
                     'requirements': [\
-                        ['device_attr', '{uut}', '_vrf_attr', '(?P<vrf>.*)', 'fast_external_fallover']],
+                        ['device_attr', '{uut}', '_vrf_attr', '(?P<vrf>.*)', NotExists('fast_external_fallover')]],
                     'exclude': bgp_exclude}},
             num_values={'device': 1, 'bgp_id': 1, 'vrf': 1, 'instance': 1, 'neighbor': 1})
 
 
 class TriggerUnconfigConfigBgpGracefulRestart(TriggerUnconfigConfig):
     """Unconfigure graceful restart configured under BGP and then
     reapply the whole configuration of dynamically learned BGP instance(s)."""
@@ -415,51 +479,37 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     Steps:
         1. Learn BGP Ops object and store the BGP instance(s) if any,
            else SKIP the trigger
         2. Save the current device configurations using the "method" specified
            by user in Trigger YAML.
         3. Unconfigure the learned BGP instance(s) from step 1
            with BGP Conf object
         4. Verify the BGP instance(s) from step 3 no longer exists
         5. Recover the device configurations to the one in step 2
         6. Learn BGP Ops again and verify it is the same as the Ops in step 1
     """
 
-    @aetest.test
-    def verify_unconfigure(self, uut, abstract, steps):
-        '''Verify that the unconfiguration was done correctly and Ops state is
-           as expected.
-
-           Args:
-               uut (`obj`): Device object.
-               abstract (`obj`): Abstract object.
-               steps (`step obj`): aetest step object
-
-           Returns:
-               None
-
-           Raises:
-               pyATS Results
-        '''
-
-        try:
-            self.mapping.verify_ops(device=uut, abstract=abstract,
-                                            steps=steps)
-        except Exception as e:
-            self.failed('Failed to verify the '
-                        'unconfigure feature', from_exception=e)
-
     mapping = Mapping(\
                 requirements={\
                     'ops.bgp.bgp.Bgp':{
                         'requirements':[\
                             ['info', 'instance', '(?P<instance>.*)', 'bgp_id', '(?P<bgp_id>.*)']],
                         'kwargs':{'attributes':['info']},
                         'exclude': bgp_exclude},
@@ -510,15 +560,27 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                address_family: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     Steps:
         1. Learn BGP Ops object and store the BGP instance(s) if any,
            else SKIP the trigger
         2. Save the current device configurations using the "method" specified
            by user in Trigger YAML.
         3. Unconfigure the learned BGP instance(s) from step 1
            with BGP Conf object
@@ -542,15 +604,15 @@
                         'requirements':[\
                             ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)', 'neighbor_attr', '(?P<neighbor>.*)', 'address_family_attr', '(?P<address_family>.*)', 'nbr_af_default_originate', True]],
                         'verify_conf':False,
                         'kwargs':{'mandatory':{'bgp_id': '(?P<bgp_id>.*)'}}}},
                 verify_ops={\
                     'ops.bgp.bgp.Bgp':{
                         'requirements':[\
-                            ['info', 'instance', '(?P<instance>.*)', 'vrf', '(?P<vrf>.*)', 'neighbor', '(?P<neighbor>.*)', 'address_family', '(?P<address_family>.*)', 'default_originate']],
+                            ['info', 'instance', '(?P<instance>.*)', 'vrf', '(?P<vrf>.*)', 'neighbor', '(?P<neighbor>.*)', 'address_family', '(?P<address_family>.*)', NotExists('default_originate')]],
                         'kwargs':{'attributes':['info']},
                         'exclude': bgp_exclude}},
                 num_values={'instance':1, 'vrf':1, 'neighbor':1})
 
 
 class TriggerUnconfigConfigBgpNeighborNextHopSelf(TriggerUnconfigConfig):
     """Unconfigure next hop self configured under BGP neighbor and then
@@ -582,15 +644,27 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                address_family: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     Steps:
         1. Learn BGP Ops object and store the BGP instance(s) if any,
            else SKIP the trigger
         2. Save the current device configurations using the "method" specified
            by user in Trigger YAML.
         3. Unconfigure the learned BGP instance(s) from step 1
            with BGP Conf object
@@ -614,15 +688,15 @@
                         'requirements':[\
                             ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)', 'neighbor_attr', '(?P<neighbor>.*)', 'address_family_attr', '(?P<address_family>.*)', 'nbr_af_next_hop_self', True]],
                         'verify_conf':False,
                         'kwargs':{'mandatory':{'bgp_id': '(?P<bgp_id>.*)'}}}},
                 verify_ops={\
                     'ops.bgp.bgp.Bgp':{
                         'requirements':[\
-                            ['info', 'instance', '(?P<instance>.*)', 'vrf', '(?P<vrf>.*)', 'neighbor', '(?P<neighbor>.*)', 'address_family', '(?P<address_family>.*)', 'next_hop_self']],
+                            ['info', 'instance', '(?P<instance>.*)', 'vrf', '(?P<vrf>.*)', 'neighbor', '(?P<neighbor>.*)', 'address_family', '(?P<address_family>.*)', NotExists('next_hop_self')]],
                         'kwargs':{'attributes':['info']},
                         'exclude': bgp_exclude}},
                 num_values={'instance':1, 'vrf':1, 'neighbor':1})
 
 
 class TriggerUnconfigConfigBgpNeighborTransportConnectionModePassive(TriggerUnconfigConfig):
     """Unconfigure transportation connection mode (if passive) configured under
@@ -656,15 +730,26 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     Steps:
         1. Learn BGP Ops object and store the BGP instance(s) if any,
            else SKIP the trigger
         2. Save the current device configurations using the "method" specified
            by user in Trigger YAML.
         3. Unconfigure the learned BGP instance(s) from step 1
            with BGP Conf object
@@ -688,15 +773,15 @@
                         'requirements':[\
                             ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)', 'neighbor_attr', '(?P<neighbor>.*)', 'nbr_transport_connection_mode', 'passive']],
                         'verify_conf':False,
                         'kwargs':{'mandatory':{'bgp_id': '(?P<bgp_id>.*)'}}}},
                 verify_ops={\
                     'ops.bgp.bgp.Bgp':{
                         'requirements':[\
-                            ['info', 'instance', '(?P<instance>.*)', 'vrf', '(?P<vrf>.*)', 'neighbor', '(?P<neighbor>.*)', 'bgp_session_transport', 'connection', 'mode']],
+                            ['info', 'instance', '(?P<instance>.*)', 'vrf', '(?P<vrf>.*)', 'neighbor', '(?P<neighbor>.*)', 'bgp_session_transport', 'connection', NotExists('mode')]],
                         'kwargs':{'attributes':['info']},
                         'exclude': bgp_exclude}},
                 num_values={'instance':1, 'vrf':1, 'neighbor':1})
 
 
 class TriggerUnconfigConfigBgpNeighborPassword(TriggerUnconfigConfig):
     """Unconfigure the password configured under BGP neighbor and then
@@ -728,15 +813,27 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                password_text: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     Steps:
         1. Learn BGP Ops object and store the BGP instance(s) if any,
            else SKIP the trigger
         2. Save the current device configurations using the "method" specified
            by user in Trigger YAML.
         3. Unconfigure the learned BGP instance(s) from step 1
            with BGP Conf object
@@ -760,15 +857,15 @@
                         'requirements':[\
                             ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)', 'neighbor_attr', '(?P<neighbor>.*)', 'nbr_password_text', '(?P<password_text>.*)']],
                         'verify_conf':False,
                         'kwargs':{'mandatory':{'bgp_id': '(?P<bgp_id>.*)'}}}},
                 verify_ops={\
                     'ops.bgp.bgp.Bgp':{
                         'requirements':[\
-                            ['info', 'instance', '(?P<instance>.*)', 'vrf', '(?P<vrf>.*)', 'neighbor', '(?P<neighbor>.*)', 'nbr_password_text']],
+                            ['info', 'instance', '(?P<instance>.*)', 'vrf', '(?P<vrf>.*)', 'neighbor', '(?P<neighbor>.*)', NotExists('nbr_password_text')]],
                         'kwargs':{'attributes':['info']},
                         'exclude': bgp_exclude}},
                 num_values={'instance':1, 'vrf':1, 'neighbor':1})
 
 
 class TriggerUnconfigConfigBgpNeighborBfd(TriggerUnconfigConfig):
     """Unconfigure bfd configured under BGP neighbor and then
@@ -800,15 +897,26 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     Steps:
         1. Learn BGP Ops object and store the BGP instance(s) if any,
            else SKIP the trigger
         2. Save the current device configurations using the "method" specified
            by user in Trigger YAML.
         3. Unconfigure the learned BGP instance(s) from step 1
            with BGP Conf object
@@ -832,15 +940,15 @@
                         'requirements':[\
                             ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)', 'neighbor_attr', '(?P<neighbor>.*)', 'nbr_fall_over_bfd', True]],
                         'verify_conf':False,
                         'kwargs':{'mandatory':{'bgp_id': '(?P<bgp_id>.*)'}}}},
                 verify_ops={\
                     'ops.bgp.bgp.Bgp':{
                         'requirements':[\
-                            ['info', 'instance', '(?P<instance>.*)', 'vrf', '(?P<vrf>.*)', 'neighbor', '(?P<neighbor>.*)', 'fall_over_bfd']],
+                            ['info', 'instance', '(?P<instance>.*)', 'vrf', '(?P<vrf>.*)', 'neighbor', '(?P<neighbor>.*)', NotExists('fall_over_bfd')]],
                         'kwargs':{'attributes':['info']},
                         'exclude': bgp_exclude}},
                 num_values={'instance':1, 'vrf':1, 'neighbor':1})
 
 
 class TriggerUnconfigConfigBgpNeighborRouteReflectorClient(TriggerUnconfigConfig):
     """Unconfigure and reapply the whole configurations of dynamically
@@ -872,15 +980,27 @@
                 Buffer recovery timeout when the previous timeout has been exhausted,
                 to make sure the devices are recovered before ending the trigger
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                address_family: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn BGP Ops object and store the BGP neighbor(s) with route-reflector-client
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned BGP neighbor(s) route-reflector-client from step 1 
            with BGP Conf object
         4. Verify the BGP vrf(s) route_distinguisher from step 3 are no longer existed
@@ -937,15 +1057,15 @@
                                      'verify_conf':False,
                                      'kwargs':{'mandatory':{'bgp_id': '(?P<bgp_id>.*)'}}}},
                       verify_ops={'ops.bgp.bgp.Bgp':{
                                     'requirements': [['info', 'instance', '(?P<instance>.*)',
                                                      'vrf', '(?P<vrf>.*)', 'neighbor',
                                                      '(?P<neighbor>.*)', 'address_family',
                                                      '(?P<address_family>.*)',
-                                                     'route_reflector_client']],
+                                                     NotExists('route_reflector_client')]],
                                     'kwargs':{'attributes':['info']},
                                     'exclude': bgp_exclude}},
                       num_values={'vrf':'all', 'instance':'all', 'neighbor': 'all',
                                   'address_family':'all', 'rd': 'all'})
 
 
 class TriggerUnconfigConfigBgpNeighborIpv4(TriggerUnconfigConfig):
@@ -976,15 +1096,26 @@
                 Buffer recovery timeout when the previous timeout has been exhausted,
                 to make sure the devices are recovered before ending the trigger
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn BGP Ops object and store the BGP IPv4 neighbor(s)
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned BGP IPv4 neighbor(s) from step 1 
            with BGP Conf object
         4. Verify the BGP IPv4 neighbor(s) from step 3 are no longer existed
@@ -1003,19 +1134,24 @@
                                         'exclude': bgp_exclude}},
                       config_info={'conf.bgp.Bgp':{
                                      'requirements':[['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
                                                       'neighbor_attr','(?P<neighbor>^[\d\.]+$)']],
                                      'verify_conf':False,
                                      'kwargs':{'mandatory':{'bgp_id': '(?P<bgp_id>.*)'}}}},
                       verify_ops={'ops.bgp.bgp.Bgp':{
-                                    'requirements': [['info', 'instance', '(?P<instance>.*)', 'vrf',
-                                                   '(?P<vrf>.*)', 'neighbor',
-                                                   '(?P<neighbor>.*)']],
+                                    'requirements': [[partial(verify_ops_or_logic,
+                                                      requires=[['info', 'instance', '(?P<instance>.*)', 'vrf',
+                                                                 '(?P<vrf>.*)', 'neighbor',
+                                                                 NotExists('(?P<neighbor>.*)')],
+                                                                ['info', 'instance', '(?P<instance>.*)', 'vrf',
+                                                                 '(?P<vrf>.*)', NotExists('neighbor')],
+                                                               ])
+                                                    ]],
                                     'kwargs':{'attributes':['info']},
-                                    'exclude': bgp_exclude + ['vpnv4 unicast']}},
+                                    'exclude': bgp_exclude + ['vpnv4 unicast', 'distance_local']}},
                       num_values={'vrf':'all', 'instance':'all',
                                   'neighbor':'all'})
 
 
 class TriggerUnconfigConfigBgpNeighborIpv6(TriggerUnconfigConfig):
     """Unconfigure and reapply the whole configurations of dynamically learned BGP IPv6 neighbor(s)."""
 
@@ -1044,15 +1180,26 @@
                 Buffer recovery timeout when the previous timeout has been exhausted,
                 to make sure the devices are recovered before ending the trigger
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn BGP Ops object and store the BGP IPv6 neighbor(s)
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned BGP IPv6 neighbor(s) from step 1 
            with BGP Conf object
         4. Verify the BGP IPv6 neighbor(s) from step 3 are no longer existed
@@ -1073,15 +1220,15 @@
                                      'requirements':[['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
                                                       'neighbor_attr','(?P<neighbor>^[\w\:]+$)']],
                                      'verify_conf':False,
                                      'kwargs':{'mandatory':{'bgp_id': '(?P<bgp_id>.*)'}}}},
                       verify_ops={'ops.bgp.bgp.Bgp':{
                                     'requirements': [['info', 'instance', '(?P<instance>.*)', 'vrf',
                                                    '(?P<vrf>.*)', 'neighbor',
-                                                   '(?P<neighbor>.*)']],
+                                                   NotExists('(?P<neighbor>.*)')]],
                                     'kwargs':{'attributes':['info']},
                                     'exclude': bgp_exclude}},
                       num_values={'vrf':'all', 'instance':'all',
                                   'neighbor':'all'})
 
 
 class TriggerUnconfigConfigBgpNeighborIbgp(TriggerUnconfigConfig):
@@ -1112,15 +1259,26 @@
                 Buffer recovery timeout when the previous timeout has been exhausted,
                 to make sure the devices are recovered before ending the trigger
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn BGP Ops object and store the iBGP neighbor(s)
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned iBGP neighbor(s) from step 1 
            with BGP Conf object
         4. Verify the iBGP neighbor(s) from step 3 are no longer existed
@@ -1145,17 +1303,22 @@
                       config_info={'conf.bgp.Bgp':{
                                      'requirements':[['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
                                                         'neighbor_attr','(?P<neighbor>.*)']
                                       ],
                                      'verify_conf':False,
                                      'kwargs':{'mandatory':{'bgp_id': '(?P<bgp_id>.*)'}}}},
                       verify_ops={'ops.bgp.bgp.Bgp':{
-                                    'requirements': [['info', 'instance', '(?P<instance>.*)', 'vrf',
-                                                   '(?P<vrf>.*)', 'neighbor',
-                                                   '(?P<neighbor>.*)', '(.*)']],
+                                    'requirements': [[partial(verify_ops_or_logic,
+                                                      requires=[['info', 'instance', '(?P<instance>.*)', 'vrf',
+                                                                 '(?P<vrf>.*)', 'neighbor',
+                                                                 NotExists('(?P<neighbor>.*)')],
+                                                                ['info', 'instance', '(?P<instance>.*)', 'vrf',
+                                                                 '(?P<vrf>.*)', NotExists('neighbor')],
+                                                               ])
+                                                    ]],
                                     'kwargs':{'attributes':['info']},
                                     'exclude': bgp_exclude}},
                       num_values={'vrf':1, 'instance':1,
                                   'neighbor':1, 'bgp_id': 1})
 
 
 class TriggerUnconfigConfigBgpRouterId(TriggerUnconfigConfig):
@@ -1186,15 +1349,26 @@
                 Buffer recovery timeout when the previous timeout has been exhausted,
                 to make sure the devices are recovered before ending the trigger
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn BGP Conf object and store the BGP instance(s)
            if has bgp_id configured, otherwise, SKIP the trigger.
            And learn BGP ops object for verifying in step 4 and 6
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned BGP instance(s) bgp-id from step 1 
            with BGP Conf object
@@ -1217,20 +1391,20 @@
                       config_info={'conf.bgp.Bgp':{
                                      'requirements':[['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
                                                       'router_id', '(?P<router_id>.*)']],
                                      'verify_conf':False,
                                      'kwargs':{'mandatory':{'bgp_id': '(?P<bgp_id>.*)'}}}},
                       verify_ops={'ops.bgp.bgp.Bgp':{
                                     'requirements': [['info', 'instance', '(?P<instance>.*)', 'vrf',
-                                                   '(?P<vrf>.*)', NotExists('router_id')]],
+                                                   '(?P<vrf>.*)', 'router_id', '(.*)']], # will still pick up some loopback interace ip 
                                     'kwargs':{'attributes':['info']},
                                     'exclude': bgp_exclude},
                                   'conf.bgp.Bgp':{
                                     'requirements': [['device_attr', '{uut}', '_vrf_attr',
-                                                      '(?P<vrf>.*)', 'router_id', '(?P<router_id>.*)']],
+                                                      '(?P<vrf>.*)', NotExists('router_id')]], # no router_id should exists in conf
                                     'kwargs':{'attributes':['info']},
                                     'exclude': bgp_exclude}},
                       num_values={'vrf':'all', 'instance':'all',
                                   'router_id':'all'})
     
 
 class TriggerUnconfigConfigBgpNeighborVrf(TriggerUnconfigConfig):
@@ -1261,15 +1435,26 @@
                 Buffer recovery timeout when the previous timeout has been exhausted,
                 to make sure the devices are recovered before ending the trigger
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn BGP Ops object and store the BGP IPv6 neighbor(s)
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned BGP IPv6 neighbor(s) from step 1 
            with BGP Conf object
         4. Verify the BGP IPv6 neighbor(s) from step 3 are no longer existed
@@ -1287,16 +1472,22 @@
                                         'kwargs':{'attributes':['info']},
                                         'exclude': bgp_exclude}},
                       config_info={'conf.bgp.Bgp':{
                                      'requirements':[['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>^(?!default).*)']],
                                      'verify_conf':False,
                                      'kwargs':{'mandatory':{'bgp_id': '(?P<bgp_id>.*)'}}}},
                       verify_ops={'ops.bgp.bgp.Bgp':{
-                                    'requirements': [['info', 'instance', '(?P<instance>.*)', 'vrf',
-                                                   '(?P<vrf>.*)']],
+                                    'requirements': [[partial(verify_ops_or_logic,
+                                                      requires=[['info', 'instance', '(?P<instance>.*)', NotExists('vrf')],
+                                                                ['info', 'instance', '(?P<instance>.*)', 'vrf',
+                                                                 NotExists('(?P<vrf>.*)')],
+                                                                ['info', 'instance', '(?P<instance>.*)', 'vrf',
+                                                                 '(?P<vrf>.*)', NotExists('neighbor')]
+                                                               ])
+                                                    ]],
                                     'kwargs':{'attributes':['info']},
                                     'exclude': bgp_exclude}},
                       num_values={'vrf':'all', 'instance':'all',
                                   'neighbor':'all'})
 
 
 class TriggerUnconfigConfigBgpNeighborAsOverride(TriggerUnconfigConfig):
@@ -1329,14 +1520,27 @@
                 Buffer recovery timeout when the previous timeout has been exhausted,
                 to make sure the devices are recovered before ending the trigger
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                address_family: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn BGP Ops object and store the BGP neighbors(s)
            if has as_override enabled, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned BGP neighbors(s) as_override from step 1 
            with BGP Conf object
@@ -1388,15 +1592,15 @@
                                       ]],
                                      'verify_conf':False,
                                      'kwargs':{'mandatory':{'bgp_id': '(?P<bgp_id>.*)'}}}},
                       verify_ops={'ops.bgp.bgp.Bgp':{
                                     'requirements': [['info', 'instance', '(?P<instance>.*)',
                                                       'vrf', '(?P<vrf>.*)', 'neighbor', '(?P<neighbor>.*)',
                                                       'address_family', '(?P<address_family>.*)',
-                                                      'as_override']],
+                                                      NotExists('as_override')]],
                                     'kwargs':{'attributes':['info']},
                                     'exclude': bgp_exclude}},
                       num_values={'vrf':'all', 'instance':'all',
                                   'address_family':'all', 'neighbor': 'all'})
 
 
 class TriggerUnconfigConfigBgpNeighborEbgp(TriggerUnconfigConfig):
@@ -1427,15 +1631,26 @@
                 Buffer recovery timeout when the previous timeout has been exhausted,
                 to make sure the devices are recovered before ending the trigger
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn BGP Ops object and store the EBGP neighbor(s)
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned EBGP neighbor(s) from step 1 
            with BGP Conf object
         4. Verify the BGP IPv6 neighbor(s) from step 3 are no longer existed
@@ -1457,17 +1672,21 @@
                                         'exclude': bgp_exclude}},
                       config_info={'conf.bgp.Bgp':{
                                      'requirements':[['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>^(?!default).*)',
                                                       'neighbor_attr','(?P<neighbor>.*)']],
                                      'verify_conf':False,
                                      'kwargs':{'mandatory':{'bgp_id': '(?P<bgp_id>.*)'}}}},
                       verify_ops={'ops.bgp.bgp.Bgp':{
-                                    'requirements': [['info', 'instance', '(?P<instance>.*)', 'vrf',
-                                                   '(?P<vrf>.*)', 'neighbor',
-                                                   '(?P<neighbor>.*)']],
+                                    'requirements': [[partial(verify_ops_or_logic,
+                                                      requires=[['info', 'instance', '(?P<instance>.*)', 'vrf',
+                                                                 '(?P<vrf>.*)', 'neighbor', NotExists('(?P<neighbor>.*)')],
+                                                                ['info', 'instance', '(?P<instance>.*)', 'vrf',
+                                                                 '(?P<vrf>.*)', NotExists('neighbor')]
+                                                               ])
+                                                    ]],
                                     'kwargs':{'attributes':['info']},
                                     'exclude': bgp_exclude + ['vpnv4 unicast']}},
                       num_values={'vrf':'all', 'instance':'all',
                                   'neighbor':'all'})
 
 
 class TriggerUnconfigConfigBgpVpnRd(TriggerUnconfigConfig):
@@ -1500,15 +1719,28 @@
                 Buffer recovery timeout when the previous timeout has been exhausted,
                 to make sure the devices are recovered before ending the trigger
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+           static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                address_family: `str`
+                rd: `str`
+                default_vrf: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn BGP Ops object and store the BGP vrf(s) with route_distinguisher
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned BGP vrf(s) route-distinguisher from step 1 
            with BGP Conf object
         4. Verify the BGP vrf(s) route_distinguisher from step 3 are no longer existed
@@ -1521,42 +1753,45 @@
                                           'requirements':[['table', 'instance', '(?P<instance>.*)',
                                                            'vrf', '(?P<vrf>.*)', 'address_family',
                                                            '(?P<address_family>.*)', 'route_distinguisher',
                                                            '(?P<rd>.*)'],
                                                            ['table', 'instance', '(?P<instance>.*)',
                                                            'vrf', '(?P<vrf>.*)', 'address_family',
                                                            '(?P<address_family>.*)', 'default_vrf',
-                                                           '(?P<name>.*)']],
+                                                           '(?P<default_vrf>.*)']],
                                         'kwargs':{'attributes':['table', 'info']},
                                         'exclude': bgp_exclude},
                                     'ops.vrf.vrf.Vrf':{
-                                          'requirements':[['info', 'vrfs', '(?P<name>^(?!default).*)',
+                                          'requirements':[['info', 'vrfs', '(?P<default_vrf>^(?!default).*)',
                                                            'route_distinguisher', '(?P<rd>.*)']],
                                         'kwargs':{'attributes':['info']},
                                         'exclude': ['maker']}},
                       config_info={'conf.vrf.Vrf':{
                                      'requirements':[['device_attr', '{uut}', 'rd', '(?P<rd>.*)']],
                                      'verify_conf':False,
-                                     'kwargs':{'mandatory':{'name': '(?P<name>.*)'}}}},
+                                     'kwargs':{'mandatory':{'name': '(?P<default_vrf>.*)'}}}},
                       verify_ops={'ops.bgp.bgp.Bgp':{
-                                    'requirements': [['table', 'instance', '(?P<instance>.*)',
-                                                     'vrf', '(?P<vrf>.*)', 'address_family',
-                                                     '(?P<address_family>.*)', 'route_distinguisher'],
-                                                     ['table', 'instance', '(?P<instance>.*)',
-                                                     'vrf', '(?P<vrf>.*)', 'address_family',
-                                                     '(?P<address_family>.*)', 'default_vrf']],
+                                    'requirements': [[partial(verify_ops_or_logic,
+                                                      requires=[['table', 'instance', '(?P<instance>.*)',
+                                                                 'vrf', '(?P<vrf>.*)', 'address_family',
+                                                                 '(?P<address_family>.*)', NotExists('default_vrf')],
+                                                                ['table', 'instance', '(?P<instance>.*)',
+                                                                 'vrf', '(?P<vrf>.*)', 'address_family',
+                                                                 NotExists('(?P<address_family>.*)')]
+                                                               ])
+                                                    ]],
                                     'kwargs':{'attributes':['table', 'info']},
-                                    'exclude': bgp_exclude + ['label_allocation_mode']},
+                                    'exclude': bgp_exclude + ['label_allocation_mode', 'vpnv4 unicast', 'vpnv6 unicast']},
                                   'ops.vrf.vrf.Vrf':{
-                                        'requirements':[['info', 'vrfs', '(?P<name>.*)',
-                                                         'route_distinguisher']],
+                                        'requirements':[['info', 'vrfs', '(?P<default_vrf>.*)',
+                                                         'route_distinguisher', '0:0']],
                                       'kwargs':{'attributes':['info']},
                                       'exclude': ['maker']}},
                       num_values={'vrf': 'all', 'instance':1, 
-                                  'address_family': 'all', 'rd': 1, 'name': 1})
+                                  'address_family': 'all', 'rd': 1, 'default_vrf': 1})
 
 
 class TriggerUnconfigConfigBgpL2vpnCapability(TriggerUnconfigConfig):
     """Unconfigure and reapply the whole configurations of dynamically
     learned BGP l2vpn evpn address-family."""
 
     __description__ = """Unconfigure and reapply the whole configurations of dynamically
@@ -1585,15 +1820,26 @@
                 Buffer recovery timeout when the previous timeout has been exhausted,
                 to make sure the devices are recovered before ending the trigger
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn BGP Ops object and store the BGP l2vpn evpn address-family
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned BGP l2vpn evpn address-family from step 1 
            with BGP Conf object
         4. Verify the BGP l2vpn evpn address-family from step 3 are no longer existed
@@ -1621,17 +1867,25 @@
                         'requirements':[\
                             ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
                              'neighbor_attr', '(?P<neighbor>.*)', 'address_family_attr', '(?P<address_family>.*)']],
                         'verify_conf':False,
                         'kwargs':{'mandatory':{'bgp_id': '(?P<bgp_id>.*)'}}}},
                 verify_ops={\
                     'ops.bgp.bgp.Bgp':{
-                        'requirements':[\
-                            ['info', 'instance', '(?P<instance>.*)', 'vrf', '(?P<vrf>.*)',
-                             'neighbor', '(?P<neighbor>.*)', 'address_family', '(?P<address_family>^l2vpn +evpn$)']],
+                        'requirements':[[partial(verify_ops_or_logic,
+                                          requires=[['info', 'instance', '(?P<instance>.*)', 'vrf', '(?P<vrf>.*)',
+                                                     'neighbor', '(?P<neighbor>.*)', 'address_family',
+                                                     NotExists('(?P<address_family>.*)')],
+                                                    ['info', 'instance', '(?P<instance>.*)', 'vrf', '(?P<vrf>.*)',
+                                                     'neighbor', NotExists('(?P<neighbor>.*)')],
+                                                    ['info', 'instance', '(?P<instance>.*)', 'vrf', '(?P<vrf>.*)',
+                                                     'neighbor', '(?P<neighbor>.*)', 'address_family',
+                                                     NotExists('(?P<address_family>^l2vpn +evpn$)')]
+                                                   ])
+                                        ]],
                         'kwargs':{'attributes':['info[instance][(.*)][bgp_id]',
                                     'info[list_of_vrfs]',
                                     'info[instance][(.*)][vrf][(.*)][neighbor]'
                                        '[(.*)][address_family][(.*)][session_state]']},
                         'exclude': bgp_exclude}},
                 num_values={'instance':1, 'vrf':1, 'neighbor':1 , 'address_family': 1})
 
@@ -1666,15 +1920,27 @@
                 Buffer recovery timeout when the previous timeout has been exhausted,
                 to make sure the devices are recovered before ending the trigger
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                neighbor: `str`
+                address_family: `str`
+                bgp_id: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn BGP Ops object and store the BGP l2vpn evpn address-family evpn rewrite-evpn-rt-asn
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned rewrite-evpn-rt-asn from step 1
            with BGP Conf object
         4. Verify the evpn rewrite-evpn-rt-asn under bgp l2vpn evpn address-family from step 3
@@ -1718,23 +1984,20 @@
                     'conf.bgp.Bgp': {
                         'requirements': [ \
                             ['device_attr', '{uut}', '_vrf_attr', '(?P<vrf>.*)', '_neighbor_attr',
                              '(?P<neighbor>.*)', '_address_family_attr', '(?P<af>.*)', NotExists('nbr_af_rewrite_evpn_rt_asn')]],
                         'exclude': bgp_exclude},
                     'ops.bgp.bgp.Bgp':{
                         'requirements':[\
-                            [['info', 'instance', '(?P<instance>.*)', 'vrf', '(?P<vrf>.*)',
+                            ['info', 'instance', '(?P<instance>.*)', 'vrf', '(?P<vrf>.*)',
                              'neighbor', '(?P<neighbor>.*)', 'address_family', '(?P<address_family>^l2vpn +evpn$)', 'session_state', 'established']],
-                            [['info', 'instance', '(?P<instance>.*)', 'vrf', \
-                             '(?P<vrf>.*)', 'neighbor', '(?P<neighbor>.*)', 'remote_as', '(.*)']]],
                         'kwargs':{'attributes':['info[instance][(.*)][bgp_id]',
                                     'info[list_of_vrfs]',
                                     'info[instance][(.*)][vrf][(.*)][neighbor][(.*)][address_family][(.*)][session_state]',
                                     'info[instance][(.*)][vrf][(.*)][neighbor][(.*)][remote_as]']},
-                        'missing': True,
                         'exclude': bgp_exclude}},
                 num_values={'instance':1, 'vrf':1, 'neighbor':1 , 'address_family': 1})
 
 class TriggerUnconfigConfigBgpAddressFamilyIpv4Mvpn(TriggerUnconfigConfig):
     """Unconfigure and reapply the whole configurations of dynamically
         learned BGP ipv4 mvpn address-family."""
 
@@ -1764,15 +2027,27 @@
                     Buffer recovery timeout when the previous timeout has been exhausted,
                     to make sure the devices are recovered before ending the trigger
 
                     max_time (`int`): Maximum wait time for the last step of the trigger,
                                     in second. Default: 180
                     interval (`int`): Wait time between iteration when looping is needed,
                                     in second. Default: 15
-
+                static:
+                    The keys below are dynamically learnt by default.
+                    However, they can also be set to a custom value when provided in the trigger datafile.
+
+                    instance: `str`
+                    vrf: `str`
+                    neighbor: `str`
+                    address_family: `str`
+                    bgp_id: `int`
+
+                    (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                          OR
+                          interface: 'Ethernet1/1/1' (Specific value)
         steps:
             1. Learn BGP Ops object and store the BGP ipv4 mvpn address-family
                if has any, otherwise, SKIP the trigger
             2. Save the current device configurations through "method" which user uses
             3. Unconfigure the learned ipv4 mvpn addrres-family from step 1
                with BGP Conf object
             4. Verify the ipv4 mvpn address-family under router bgp from step 3
@@ -1798,15 +2073,14 @@
                         ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)', 'address_family_attr', '(?P<af>.*)']],
                     'verify_conf': False,
                     'kwargs': {'mandatory': {'bgp_id': '(?P<bgp_id>.*)'}}}},
             verify_ops={ \
                 'conf.bgp.Bgp': {
                     'requirements': [ \
                         ['device_attr', '{uut}', '_vrf_attr', '(?P<vrf>.*)', '_address_family_attr', '(?P<af>(?!ipv4 mvpn).*)']],
-                    'missing': False,
                     'exclude': trm_exclude }},
 
             num_values={'instance': 1, 'vrf': 1, 'neighbor': 'all', 'af':1})
 
 
 class TriggerUnconfigConfigBgpNeighborAddressFamilyIpv4Mvpn(TriggerUnconfigConfig):
     """Unconfigure and reapply the whole configurations of dynamically
@@ -1838,15 +2112,26 @@
                         Buffer recovery timeout when the previous timeout has been exhausted,
                         to make sure the devices are recovered before ending the trigger
 
                         max_time (`int`): Maximum wait time for the last step of the trigger,
                                         in second. Default: 180
                         interval (`int`): Wait time between iteration when looping is needed,
                                         in second. Default: 15
-
+                    static:
+                        The keys below are dynamically learnt by default.
+                        However, they can also be set to a custom value when provided in the trigger datafile.
+
+                        instance: `str`
+                        vrf: `str`
+                        neighbor: `str`
+                        bgp_id: `int`
+
+                        (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                              OR
+                              interface: 'Ethernet1/1/1' (Specific value)
             steps:
                 1. Learn BGP Ops object and store the ipv4 mvpn address-family under BGP neighbors
                    if has any, otherwise, SKIP the trigger
                 2. Save the current device configurations through "method" which user uses
                 3. Unconfigure the learned ipv4 mvpn addrres-family under BGP neighbors from step 1
                    with BGP Conf object
                 4. Verify the ipv4 mvpn address-family under BGP neighbors from step 3
@@ -1877,15 +2162,14 @@
                 'verify_conf': False,
                 'kwargs': {'mandatory': {'bgp_id': '(?P<bgp_id>.*)'}}}},
         verify_ops={ \
 	    'conf.bgp.Bgp': {
                 'requirements': [ \
                     ['device_attr', '{uut}', '_vrf_attr', '(?P<vrf>.*)', '_neighbor_attr',
                      '(?P<neighbor>.*)', '_address_family_attr', Not('ipv4 mvpn')]],
-                'missing': True,
                 'exclude': trm_exclude},
             'ops.bgp.bgp.Bgp': {
                 'requirements': [ \
                     ['info', 'instance', '(?P<instance>.*)', 'vrf', '(?P<vrf>.*)', 'neighbor', '(?P<neighbor>.*)',
                      'address_family', NotExists('ipv4 mvpn'), NotExists('(.*)') ],
                     ['info', 'instance', '(?P<instance>.*)', 'vrf', '(?P<vrf>.*)', 'neighbor', '(?P<neighbor>.*)',
                       'bgp_negotiated_capabilities', 'ipv4_mvpn', Not('advertised')]],
```

## genie/libs/sdk/triggers/unconfigconfig/igmp/nxos/unconfigconfig.py

```diff
@@ -6,15 +6,15 @@
 # ats
 from ats import aetest
 from ats.utils.objects import Not, NotExists
 
 # Genie Libs
 from genie.libs.sdk.libs.utils.mapping import Mapping
 from genie.libs.sdk.triggers.unconfigconfig.unconfigconfig import TriggerUnconfigConfig
-from genie.libs.sdk.libs.utils.triggeractions import configure_add_attributes
+from genie.libs.sdk.libs.utils.triggeractions import configure_add_attributes, verify_ops_or_logic
 from genie.libs.conf.igmp.igmp_group import IgmpGroup
 
 # Which key to exclude for Igmp Ops comparison
 igmp_exclude = ['maker', 'expire', 'up_time']
 
 
 class TriggerUnconfigConfigIgmpEnable(TriggerUnconfigConfig):
@@ -47,15 +47,24 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                interface: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Igmp Ops object and store the enabled PIM interface(s)
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned Igmp interface(s)'s enable from step 1 
            with Igmp Conf object
         4. Verify the Igmp interface(s)'s enable from step 3
@@ -66,35 +75,34 @@
     """
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={
                           'ops.igmp.igmp.Igmp':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'enable', True]],
+                                     '(?P<interface>.*)', 'enable', True]],
                                 'all_keys': True,
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)][interfaces][(.*)]']},
                                 'exclude': igmp_exclude}},
                       config_info={'conf.igmp.Igmp':{
                                        'requirements':[
                                          ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
-                                          'interface_attr', '(?P<igmp_intf>.*)', 'enable', True]],
+                                          'interface_attr', '(?P<interface>.*)', 'enable', True]],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={
                           'ops.igmp.igmp.Igmp':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)']],
-                                'missing': True,
+                                     NotExists('(?P<interface>.*)')]],
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)][interfaces][(.*)]']},
                                 'exclude': igmp_exclude}},
-                      num_values={'vrf': 1, 'igmp_intf': 1})
+                      num_values={'vrf': 1, 'interface': 1})
 
 
 class TriggerUnconfigConfigIgmpVersion(TriggerUnconfigConfig):
     """Unconfigure and reapply the whole configurations of dynamically
     learned enabled Igmp interface(s)'s version."""
 
     __description__ = """Unconfigure and reapply the whole configurations
@@ -123,15 +131,25 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                interface: `str`
+                version: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Igmp Ops object and store the enabled PIM interface(s)'s version
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned Igmp interface(s)'s version from step 1 
            with Igmp Conf object
         4. Verify the Igmp interface(s)'s version from step 3
@@ -142,38 +160,37 @@
     """
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={
                           'ops.igmp.igmp.Igmp':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'enable', True],
+                                     '(?P<interface>.*)', 'enable', True],
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'version', '(?P<version>^(?!2).*)']],
+                                     '(?P<interface>.*)', 'version', '(?P<version>^(?!2).*)']],
                                 'all_keys': True,
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)]']},
                                 'exclude': igmp_exclude}},
                       config_info={'conf.igmp.Igmp':{
                                        'requirements':[
                                          ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
-                                          'interface_attr', '(?P<igmp_intf>.*)', 'version',
+                                          'interface_attr', '(?P<interface>.*)', 'version',
                                           '(?P<version>.*)']],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={
                           'ops.igmp.igmp.Igmp':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'version', 2]],
-                                'missing': False,
+                                     '(?P<interface>.*)', 'version', 2]],
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)]']},
                                 'exclude': igmp_exclude}},
-                      num_values={'vrf': 1, 'igmp_intf': 1})
+                      num_values={'vrf': 1, 'interface': 1})
 
 
 class TriggerUnconfigConfigIgmpJoinGroup(TriggerUnconfigConfig):
     """Unconfigure and reapply the whole configurations of dynamically
     learned enabled Igmp interface(s)'s join-groups."""
 
     __description__ = """Unconfigure and reapply the whole configurations
@@ -202,15 +219,27 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                interface: `str`
+                source: `str`
+                group: `str`
+                join_group: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Igmp Ops object and store the enabled PIM interface(s)'s join-groups
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned Igmp interface(s)'s join-groups from step 1 
            with Igmp Conf object
         4. Verify the Igmp interface(s)'s join-groups from step 3
@@ -222,50 +251,70 @@
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={
                           'ops.igmp.igmp.Igmp':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'join_group', '(?P<join_group>.*)',
+                                     '(?P<interface>.*)', 'join_group', '(?P<join_group>.*)',
                                      'group', '(?P<group>.*)'],
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'join_group', '(?P<join_group>.*)',
+                                     '(?P<interface>.*)', 'join_group', '(?P<join_group>.*)',
                                      'source', '(?P<source>\*)']],
                                 'all_keys': True,
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)][interfaces][(.*)][join_group][(.*)]',
                                     'info[vrfs][(.*)][interfaces][(.*)][static_group][(.*)]',
                                     'info[vrfs][(.*)][interfaces][(.*)][group][(.*)]']},
                                 'exclude': igmp_exclude}},
                       config_info={'conf.igmp.Igmp':{
                                        'requirements':[
                                          [partial(configure_add_attributes,  # callable configuration
                                             add_obj=IgmpGroup,
                                             base=[['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
-                                                  'interface_attr', '(?P<igmp_intf>.*)']],
+                                                  'interface_attr', '(?P<interface>.*)']],
                                             add_attribute=[['join_group', '(?P<group>.*)'],
                                                            ['join_group_source_addr', '(?P<source>.*)'],],
                                             add_method='add_groups',
                                         )]],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={
                           'ops.igmp.igmp.Igmp':{
-                                'requirements':[\
-                                    ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'join_group', '(?P<join_group>.*)'],
-                                    ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'group', '(?P<group>.*)']],
+                                'requirements': [[partial(verify_ops_or_logic,
+                                                      requires=[['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', 'join_group',
+                                                                 NotExists('(?P<join_group>.*)')],
+                                                                ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', NotExists('join_group')],
+                                                                ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', 'join_group',
+                                                                 '(?P<join_group>.*)', '(.*)']
+                                                               ])
+                                                  ],
+                                                  [partial(verify_ops_or_logic,
+                                                      requires=[['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', 'group', NotExists('(?P<group>.*)')],
+                                                                ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', NotExists('group')],
+                                                                ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', 'group', '(?P<group>.*)',
+                                                                 NotExists('source')],
+                                                                ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', 'group', '(?P<group>.*)',
+                                                                 'source', NotExists('(?P<source>\*)')]
+                                                               ])
+                                                  ],
+                                                ],
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)][interfaces][(.*)][join_group][(.*)]',
                                     'info[vrfs][(.*)][interfaces][(.*)][static_group][(.*)]',
                                     'info[vrfs][(.*)][interfaces][(.*)][group][(.*)]']},
                                 'exclude': igmp_exclude}},
-                      num_values={'vrf': 1, 'igmp_intf': 1, 'join_group': 1, 'group': 1, 'source': 1})
+                      num_values={'vrf': 1, 'interface': 1, 'join_group': 1, 'group': 1, 'source': 1})
 
 
 class TriggerUnconfigConfigIgmpStaticGroup(TriggerUnconfigConfig):
     """Unconfigure and reapply the whole configurations of dynamically
     learned enabled Igmp interface(s)'s static-groups."""
 
     __description__ = """Unconfigure and reapply the whole configurations
@@ -294,15 +343,27 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                interface: `str`
+                source: `str`
+                group: `str`
+                static_group: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Igmp Ops object and store the enabled PIM interface(s)'s static-groups
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned Igmp interface(s)'s static-groups from step 1 
            with Igmp Conf object
         4. Verify the Igmp interface(s)'s static-groups from step 3
@@ -313,47 +374,65 @@
     """
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={
                           'ops.igmp.igmp.Igmp':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'static_group', '(?P<static_group>.*)',
+                                     '(?P<interface>.*)', 'static_group', '(?P<static_group>.*)',
                                      'group', '(?P<group>.*)'],
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'static_group', '(?P<static_group>.*)',
+                                     '(?P<interface>.*)', 'static_group', '(?P<static_group>.*)',
                                      'source', '(?P<source>\*)']],
                                 'all_keys': True,
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)][interfaces][(.*)][join_group]',
                                     'info[vrfs][(.*)][interfaces][(.*)][static_group]',
                                     'info[vrfs][(.*)][interfaces][(.*)][group]']},
                                 'exclude': igmp_exclude}},
                       config_info={'conf.igmp.Igmp':{
                                        'requirements':[
                                          [partial(configure_add_attributes,  # callable configuration
                                             add_obj=IgmpGroup,
                                             base=[['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
-                                                  'interface_attr', '(?P<igmp_intf>.*)']],
+                                                  'interface_attr', '(?P<interface>.*)']],
                                             add_attribute=[['static_group', '(?P<group>.*)'],
                                                            ['static_group_source_addr', '(?P<source>.*)'],],
                                             add_method='add_groups',
                                         )]],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={
                           'ops.igmp.igmp.Igmp':{
-                                'requirements':[\
-                                    ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'static_group', '(?P<static_group>.*)'],
-                                    ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'group', '(?P<group>.*)'],
-                                    ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<igmp_intf>.*)', 'static_group', '(?P<static_group>.*)',
-                                     'source', '(?P<source>.*)']],
+                                'requirements': [[partial(verify_ops_or_logic,
+                                                      requires=[['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', 'static_group',
+                                                                 NotExists('(?P<static_group>.*)')],
+                                                                ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', NotExists('static_group')],
+                                                                ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', 'static_group',
+                                                                 '(?P<static_group>.*)', '(.*)']
+                                                               ])
+                                                  ],
+                                                  [partial(verify_ops_or_logic,
+                                                      requires=[['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', 'group', NotExists('(?P<group>.*)')],
+                                                                ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', NotExists('group')],
+                                                                ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', 'group', '(?P<group>.*)',
+                                                                 NotExists('source')],
+                                                                ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', 'group', '(?P<group>.*)',
+                                                                 'source', NotExists('(?P<source>\*)')]
+                                                               ])
+                                                  ],
+                                                ],
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)][interfaces][(.*)][join_group]',
                                     'info[vrfs][(.*)][interfaces][(.*)][static_group]',
                                     'info[vrfs][(.*)][interfaces][(.*)][group]']},
                                 'exclude': igmp_exclude}},
-                      num_values={'vrf': 1, 'igmp_intf': 1, 'static_group': 1, 'group': 1})
+                      num_values={'vrf': 1, 'interface': 1, 'static_group': 1, 'group': 1})
 
+
```

## genie/libs/sdk/triggers/unconfigconfig/interface/unconfigconfig.py

```diff
@@ -2,14 +2,15 @@
 
 # Genie Libs
 from genie.libs.sdk.libs.utils.mapping import Mapping
 from genie.libs.sdk.triggers.unconfigconfig.unconfigconfig import TriggerUnconfigConfig
 
 # import ats
 from ats import aetest
+from ats.utils.objects import Not, NotExists
 
 # Which key to exclude for Interface Ops comparison
 interface_exclude = ['maker', 'last_change','in_rate','in_rate_pkts',
                      'out_rate', 'out_rate_pkts', 'in_octets',
                      'in_pkts', 'in_unicast_pkts', 'out_octets',
                      'out_pkts', 'out_unicast_pkts', 'out_multicast_pkts',
                      'in_multicast_pkts', 'last_clear', 'in_broadcast_pkts',
@@ -48,14 +49,23 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn Interface Ops object and store the "up" Loopback interface(s)
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned Loopback interface(s) from step 1 
            with Interface Conf object
@@ -66,57 +76,28 @@
     """
 
     loopback_exclude = interface_exclude + ['oper_status', 'enabled', 'status']
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>(Loopback||Lo|loopback)[0-9]+)', 'oper_status', 'up']],
+                                       'requirements':[['info', '(?P<interface>(Loopback||Lo|loopback)[0-9]+)', 'oper_status', 'up']],
                                        'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[],
                                        'verify_conf':False,
-                                       'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                       'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>.*)']],
+                                       'requirements':[['info', NotExists('(?P<interface>.*)')]],
                                        'exclude': loopback_exclude}},
-                      num_values={'name':1})
+                      num_values={'interface':1})
 
 
-# for physical interfaces, the interface won't be removed, only can be defaulted.
-# all keys and values will return to default value when physical interfaces being unconfigured
-class TriggerUnconfigConfigPhysicalInterface(TriggerUnconfigConfig):
-    '''Trigger class for UnconfigConfig physical interfaces action'''
-
-    @aetest.test
-    def verify_unconfigure(self, uut, abstract, steps):
-        '''Verify that the unconfiguration was done correctly and Ops state is 
-           as expected.
-
-           Args:
-               uut (`obj`): Device object.
-               abstract (`obj`): Abstract object.
-               steps (`step obj`): aetest step object
-
-           Returns:
-               None
-
-           Raises:
-               pyATS Results
-        '''
-
-        try:
-            self.mapping.verify_ops(device=uut, abstract=abstract, steps=steps)
-        except Exception as e:
-            self.failed('Failed to verify the '
-                        'unconfigure feature', from_exception=e)
-
-
-class TriggerUnconfigConfigPhysicalTrunkInterface(TriggerUnconfigConfigPhysicalInterface):
+class TriggerUnconfigConfigPhysicalTrunkInterface(TriggerUnconfigConfig):
     """Unconfigure and reapply the whole configurations of dynamically learned
     physical (non-Loopback, non-Vlan, non-Null, non-Tunnel, non-subinterface etc.) "trunk" interface(s)."""
 
     __description__ = """Unconfigure and reapply the whole configurations of dynamically learned
     physical (non-Loopback, non-Vlan, non-Null, non-Tunnel, non-subinterface etc.) "trunk" interface(s).
 
     trigger_datafile:
@@ -142,15 +123,23 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Interface Ops object and store the "up" physical "trunk" interface(s)
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned physical interface(s) from step 1 
            with Interface Conf object
         4. Verify the physical interface(s) from step 3 are "down",
@@ -159,33 +148,33 @@
         6. Learn Interface Ops again and verify it is the same as the Ops in step 1
 
     """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>[E|e]thernet[\d\/\.]+)',
+                                       'requirements':[['info', '(?P<interface>[E|e]thernet[\d\/\.]+)',
                                                         'switchport_mode', 'trunk'],
-                                                        ['info', '(?P<name>[E|e]thernet[\d\/\.]+)',
+                                                        ['info', '(?P<interface>[E|e]thernet[\d\/\.]+)',
                                                         'port_channel', 'port_channel_member', False]],
                                        'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[],
                                        'verify_conf':False,
-                                       'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                       'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>.*)', 'oper_status', '(.*)'],
-                                                       ['info', '(?P<name>.*)', 'enabled', False],
-                                                       ['info', '(?P<name>.*)', 'port_channel',
+                                       'requirements':[['info', '(?P<interface>.*)', 'oper_status', '(.*)'],
+                                                       ['info', '(?P<interface>.*)', 'enabled', False],
+                                                       ['info', '(?P<interface>.*)', 'port_channel',
                                                         'port_channel_member', False],
-                                                       ['info', '(?P<name>.*)', 'mac_address', '([\w\.]+)'],
-                                                       ['info', '(?P<name>.*)', '(.*)']],
+                                                       ['info', '(?P<interface>.*)', 'mac_address', '([\w\.]+)'],
+                                                       ['info', '(?P<interface>.*)', '(.*)']],
                                        'exclude': interface_exclude + ['(Vlan.*)']}},
-                      num_values={'name':1})
+                      num_values={'interface':1})
 
 
 class TriggerUnconfigConfigVirtualTrunkInterface(TriggerUnconfigConfig):
     """Unconfigure and reapply the whole configurations of dynamically learned
     virtual "trunk" (port-channel) interface(s)."""
 
     __description__ = """Unconfigure and reapply the whole configurations of dynamically learned
@@ -214,15 +203,23 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Interface Ops object and store the "up" virtual "trunk" interface(s)
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned virtual interface(s) from step 1 
            with Interface Conf object
         4. Verify the virtual interface(s) from step 3 are no longer existed
@@ -230,26 +227,26 @@
         6. Learn Interface Ops again and verify it is the same as the Ops in step 1
 
     """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>[p|P]ort-channel[\d\.]+)',
+                                       'requirements':[['info', '(?P<interface>[p|P]ort-channel[\d\.]+)',
                                                         'switchport_mode', 'trunk']],
                                        'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[],
                                        'verify_conf':False,
-                                       'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                       'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>.*)', '(.*)']],
+                                       'requirements':[['info', NotExists('(?P<interface>.*)')]],
                                        'exclude': interface_exclude}},
-                      num_values={'name':1})
+                      num_values={'interface':1})
 
 
 class TriggerUnconfigConfigEthernetInterface(TriggerUnconfigConfig):
     """Unconfigure and reapply the whole configurations of dynamically learned Ethernet interface(s)."""
 
     __description__ = """Unconfigure and reapply the whole configurations of dynamically learned Ethernet interface(s).
 
@@ -276,15 +273,23 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Interface Ops object and store the "up" Ethernet interface(s)
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned Ethernet interface(s) from step 1 
            with Interface Conf object
         4. Verify the configurations are all gone for the learned Ethernet interface(s)
@@ -304,38 +309,40 @@
 
         # See if the modified_item exists in the list of name
         if modified_item in name:
             return True
         return False
 
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
-                                        'requirements':[['info', '(?P<name>(GigabitEthernet|gigabitEthernet|Ethernet|ethernet)[0-9\/]+$)',
+                                        'requirements':[['info', '(?P<interface>(GigabitEthernet|gigabitEthernet|Ethernet|ethernet)[0-9\/]+$)',
                                                          'enabled', True],
-                                                        ['info', '(?P<name>(GigabitEthernet|gigabitEthernet|Ethernet|ethernet)[0-9\/]+$)',
+                                                        ['info', '(?P<interface>(GigabitEthernet|gigabitEthernet|Ethernet|ethernet)[0-9\/]+$)',
                                                          'port_channel', 'port_channel_member', False],
-                                                        ['info', '(?P<name>(GigabitEthernet|gigabitEthernet|Ethernet|ethernet)[0-9\/]+$)',
+                                                        ['info', '(?P<interface>(GigabitEthernet|gigabitEthernet|Ethernet|ethernet)[0-9\/]+$)',
                                                          'oper_status', 'up']],
                                         'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                         'requirements':[],
                                         'verify_conf':False,
-                                        'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                        'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                                'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                        'requirements':[['info', '(?P<name>.*)','access_vlan'],
-                                                        ['info', '(?P<name>.*)','switchport_enable'],
-                                                        ['info', '(?P<name>.*)','switchport_mode'],
-                                                        ['info', '(?P<name>.*)','trunk_vlans'],
-                                                        ['info', '(?P<name>.*)','vrf'],
-                                                        ['info', '(?P<name>.*)','duplex_mode'],
-                                                        ['info', '(?P<name>.*)','mac_address'],
-                                                        ['info', '(?P<name>.*)','oper_status']],
+                                        'requirements':[['info', '(?P<interface>.*)', 'vrf', 'default'],
+                                                        ['info', '(?P<interface>.*)', 'enabled', False],
+                                                        ['info', '(?P<interface>.*)', 'oper_status', 'down'],
+                                                        ['info', '(?P<interface>.*)', 'delay', '(\d+)'],
+                                                        ['info', '(?P<interface>.*)', 'bandwidth', '(\d+)'],
+                                                        ['info', '(?P<interface>.*)', 'encapsulation', 'encapsulation', '(\S+)'],
+                                                        ['info', '(?P<interface>.*)', 'mac_address', '(\S+)'],
+                                                        ['info', '(?P<interface>.*)', 'medium', '(\S+)'],
+                                                        ['info', '(?P<interface>.*)', 'mtu', '(\d+)'],
+                                                        ['info', '(?P<interface>.*)', 'port_channel', 'port_channel_member', False]],
                                         'exclude': interface_exclude +\
                                                    [remove_related_subinterface, '(Vlan.*)']}},
-                      num_values={'name': 1})
+                      num_values={'interface': 1})
 
 
 class TriggerUnconfigConfigEthernetInterfaceSub(TriggerUnconfigConfig):
     """Unconfigure and reapply the whole configurations of dynamically learned Ethernet SubInterface(s)."""
 
     __description__ = """Unconfigure and reapply the whole configurations of dynamically learned Ethernet SubInterface(s).
 
@@ -362,42 +369,50 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+           static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Interface Ops object and store the "up" Ethernet SubInterface(s)
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned Ethernet SubInterface(s) from step 1 
            with Interface Conf object
         4. Verify the learned Ethernet SubInterface(s) are no longer existed
         5. Recover the device configurations to the one in step 2
         6. Learn Interface Ops again and verify it is the same as the Ops in step 1
 
     """
 
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
-                                        'requirements':[['info', '(?P<name>(GigabitEthernet|gigabitEthernet|Ethernet|ethernet)[0-9\/]+\.[0-9]+)',
+                                        'requirements':[['info', '(?P<interface>(GigabitEthernet|gigabitEthernet|Ethernet|ethernet)[0-9\/]+\.[0-9]+)',
                                                          'enabled', True],
-                                                        ['info', '(?P<name>(GigabitEthernet|gigabitEthernet|Ethernet|ethernet)[0-9\/]+\.[0-9]+)',
+                                                        ['info', '(?P<interface>(GigabitEthernet|gigabitEthernet|Ethernet|ethernet)[0-9\/]+\.[0-9]+)',
                                                          'oper_status', 'up']],
                                         'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                         'requirements':[],
                                         'verify_conf':False,
-                                        'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                        'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                                'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                        'requirements':[['info', '(?P<name>.*)','enabled', True]],
+                                        'requirements':[['info', NotExists('(?P<interface>.*)')]],
                                         'exclude': interface_exclude + ['(Vlan.*)']}},
-                      num_values={'name': 1})
+                      num_values={'interface': 1})
 
 
 class TriggerUnconfigConfigVlanInterface(TriggerUnconfigConfig):
     """Unconfigure and reapply the whole configurations of dynamically learned Vlan interface(s)."""
     
     __description__ = """Unconfigure and reapply the whole configurations of dynamically learned Vlan interface(s).
 
@@ -424,15 +439,23 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Interface Ops object and store the "up" Vlan interface(s)
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned Vlan interface(s) from step 1 
            with Interface Conf object
         4. Verify the learned Vlan interface(s) are no longer existed
@@ -442,19 +465,19 @@
     """
 
     vlan_exclude = interface_exclude + ['oper_status']
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>(Vlan|vlan)[0-9]+)', 'oper_status', 'up']],
+                                       'requirements':[['info', '(?P<interface>(Vlan|vlan)[0-9]+)', 'oper_status', 'up']],
                                        'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[],
                                        'verify_conf':False,
-                                       'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                       'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>.*)']],
+                                       'requirements':[['info', NotExists('(?P<interface>.*)')]],
                                        'exclude': vlan_exclude}},
-                      num_values={'name':1})
+                      num_values={'interface':1})
```

## genie/libs/sdk/triggers/unconfigconfig/interface/iosxe/unconfigconfig.py

```diff
@@ -3,147 +3,323 @@
 # Genie Libs
 from genie.libs.sdk.libs.utils.mapping import Mapping
 from genie.libs.sdk.triggers.unconfigconfig.unconfigconfig import TriggerUnconfigConfig
 from genie.libs.sdk.triggers.unconfigconfig.interface.unconfigconfig import \
     TriggerUnconfigConfigEthernetInterface as UncfgCfgInterface
 
 # import ats
-from ats import aetest
+from ats.utils.objects import Not, NotExists
 
 # Which key to exclude for Interface Ops comparison
 interface_exclude = ['maker', 'last_change','in_rate','in_rate_pkts',
                      'out_rate', 'out_rate_pkts', 'in_octets',
                      'in_pkts', 'in_unicast_pkts', 'out_octets',
                      'out_pkts', 'out_unicast_pkts', 'out_multicast_pkts',
                      'in_multicast_pkts', 'last_clear', 'in_broadcast_pkts',
                      'out_broadcast_pkts', 'bandwidth', 'load_interval',
                      'port_speed', 'in_crc_errors', 'in_errors',
                      'in_discards', '(Tunnel.*)', 'accounting']
 
 
 
-# for physical interfaces, the interface won't be removed, only can be defaulted.
-# all keys and values will return to default value when physical interfaces being unconfigured
-class TriggerUnconfigConfigPhysicalInterface(TriggerUnconfigConfig):
-    '''Trigger class for UnconfigConfig physical interfaces action'''
-
-    @aetest.test
-    def verify_unconfigure(self, uut, abstract, steps):
-        '''Verify that the unconfiguration was done correctly and Ops state is 
-           as expected.
-
-           Args:
-               uut (`obj`): Device object.
-               abstract (`obj`): Abstract object.
-               steps (`step obj`): aetest step object
-
-           Returns:
-               None
-
-           Raises:
-               pyATS Results
-        '''
-
-        try:
-            self.mapping.verify_ops(device=uut, abstract=abstract,
-                                    steps=steps)
-        except Exception as e:
-            self.failed('Failed to verify the '
-                        'unconfigure feature\n{e}'.format(e=str(e)))
+class TriggerUnconfigConfigPhysicalTrunkInterface(TriggerUnconfigConfig):
+    """Unconfigure and reapply the whole configurations of dynamically learned physical trunk interface(s)."""
 
+    __description__ = """Unconfigure and reapply the whole configurations of dynamically learned physical trunk interface(s).
 
-class TriggerUnconfigConfigPhysicalTrunkInterface(TriggerUnconfigConfigPhysicalInterface):
+    trigger_datafile:
+        Mandatory:
+            timeout:
+                max_time (`int`): Maximum wait time for the trigger,
+                                in second. Default: 180
+                interval (`int`): Wait time between iteration when looping is needed,
+                                in second. Default: 15
+                method (`str`): Method to recover the device configuration,
+                              Support methods:
+                                'checkpoint': Rollback the configuration by
+                                              checkpoint (nxos),
+                                              archive file (iosxe),
+                                              load the saved running-config file on disk (iosxr)
+        Optional:
+            tgn_timeout (`int`): Maximum wait time for all traffic threads to be
+                                 restored to the reference rate,
+                                 in second. Default: 60
+            tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
+                               in second. Default: 10
+            timeout_recovery:
+                Buffer recovery timeout make sure devices are recovered at the end
+                of the trigger execution. Used when previous timeouts have been exhausted.
+
+                max_time (`int`): Maximum wait time for the last step of the trigger,
+                                in second. Default: 180
+                interval (`int`): Wait time between iteration when looping is needed,
+                                in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+                port_channel_int: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
+    steps:
+        1. Learn Interface Ops object and store the "up" physical trunk interface(s)
+           if has any, otherwise, SKIP the trigger
+        2. Save the current device configurations through "method" which user uses
+        3. Unconfigure the learned physical trunk interface(s) from step 1
+           with Interface Conf object
+        4. Verify the learned physical trunk interface(s) are "down"
+        5. Recover the device configurations to the one in step 2
+        6. Learn Interface Ops again and verify it is the same as the Ops in step 1
+
+    """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>\w+Ethernet[\d\/\.]+)',
+                                       'requirements':[['info', '(?P<interface>\w+Ethernet[\d\/\.]+)',
                                                         'switchport_mode', 'trunk'],
-                                                       ['info', '(?P<name>\w+Ethernet[\d\/\.]+)',
-                                                        'port_channel', 'port_channel_int', '(?P<port_int>.*)']],
+                                                       ['info', '(?P<interface>\w+Ethernet[\d\/\.]+)',
+                                                        'port_channel', 'port_channel_int', '(?P<port_channel_int>.*)']],
                                        'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[],
                                        'verify_conf':False,
-                                       'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                       'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>.*)', 'oper_status', 'down'],
-                                                       ['info', '(?P<name>.*)', 'enabled', False],
-                                                       ['info', '(?P<name>.*)', 'port_channel',
+                                       'requirements':[['info', '(?P<interface>.*)', 'oper_status', 'down'],
+                                                       ['info', '(?P<interface>.*)', 'enabled', False],
+                                                       ['info', '(?P<interface>.*)', 'port_channel',
                                                         'port_channel_member', False],
-                                                       ['info', '(?P<name>.*)', 'mac_address', '([\w\.]+)'],
-                                                       ['info', '(?P<name>.*)', '(.*)'],
-                                                       ['info', '(?P<port_int>.*)', 'port_channel', 'port_channel_member_intfs', '(.*)'],
+                                                       ['info', '(?P<interface>.*)', 'mac_address', '([\w\.]+)'],
+                                                       ['info', '(?P<interface>.*)', '(.*)'],
+                                                       ['info', '(?P<port_channel_int>.*)', 'port_channel', 'port_channel_member_intfs', '(.*)'],
                                                        ['info', '(Port-channel.*)', 'mac_address', '(.*)'],
                                                        ['info', '(Port-channel.*)', 'phys_address', '(.*)']],
                                        'exclude': interface_exclude}},
-                      num_values={'name':1})
+                      num_values={'interface':1})
 
 
 
 class TriggerUnconfigConfigEthernetInterface(UncfgCfgInterface):
+    """Unconfigure and reapply the whole configurations of dynamically learned ethernet interface(s)."""
+
+    __description__ = """Unconfigure and reapply the whole configurations of dynamically learned ethernet interface(s).
+
+    trigger_datafile:
+        Mandatory:
+            timeout:
+                max_time (`int`): Maximum wait time for the trigger,
+                                in second. Default: 180
+                interval (`int`): Wait time between iteration when looping is needed,
+                                in second. Default: 15
+                method (`str`): Method to recover the device configuration,
+                              Support methods:
+                                'checkpoint': Rollback the configuration by
+                                              checkpoint (nxos),
+                                              archive file (iosxe),
+                                              load the saved running-config file on disk (iosxr)
+        Optional:
+            tgn_timeout (`int`): Maximum wait time for all traffic threads to be
+                                 restored to the reference rate,
+                                 in second. Default: 60
+            tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
+                               in second. Default: 10
+            timeout_recovery:
+                Buffer recovery timeout make sure devices are recovered at the end
+                of the trigger execution. Used when previous timeouts have been exhausted.
+
+                max_time (`int`): Maximum wait time for the last step of the trigger,
+                                in second. Default: 180
+                interval (`int`): Wait time between iteration when looping is needed,
+                                in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
+    steps:
+        1. Learn Interface Ops object and store the "up" ethernet interface(s)
+           if has any, otherwise, SKIP the trigger
+        2. Save the current device configurations through "method" which user uses
+        3. Unconfigure the learned ethernet interface(s) from step 1
+           with Interface Conf object
+        4. Verify the learned ethernet interface(s) are "down"
+        5. Recover the device configurations to the one in step 2
+        6. Learn Interface Ops again and verify it is the same as the Ops in step 1
+
+    """
 
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
-                                        'requirements':[['info', '(?P<name>\w+Ethernet[0-9\/]+$)', 'enabled', True],
-                                                        ['info', '(?P<name>.*)', 'port_channel', 'port_channel_member', False],
-                                                        ['info', '(?P<name>.*)', 'oper_status', 'up']],
+                                        'requirements':[['info', '(?P<interface>\w+Ethernet[0-9\/]+$)', 'enabled', True],
+                                                        ['info', '(?P<interface>.*)', 'port_channel', 'port_channel_member', False],
+                                                        ['info', '(?P<interface>.*)', 'oper_status', 'up']],
                                         'exclude': interface_exclude,
                                         'include_management_interface': False}},
                       config_info={'conf.interface.Interface':{
                                         'requirements':[],
                                         'verify_conf':False,
-                                        'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                        'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                                'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                        'requirements':[['info', '(?P<name>.*)','access_vlan'],
-                                                        ['info', '(?P<name>.*)','switchport_enable'],
-                                                        ['info', '(?P<name>.*)','switchport_mode'],
-                                                        ['info', '(?P<name>.*)','trunk_vlans'],
-                                                        ['info', '(?P<name>.*)','vrf'],
-                                                        ['info', '(?P<name>.*)','enabled'],
-                                                        ['info', '(?P<name>.*)','duplex_mode'],
-                                                        ['info', '(?P<name>.*)','mac_address'],
-                                                        ['info', '(?P<name>.*)','oper_status']],
+                                        'requirements':[['info', '(?P<interface>.*)', NotExists('access_vlan')],
+                                                        ['info', '(?P<interface>.*)', NotExists('switchport_enable')],
+                                                        ['info', '(?P<interface>.*)', NotExists('switchport_mode')],
+                                                        ['info', '(?P<interface>.*)', NotExists('trunk_vlans')],
+                                                        ['info', '(?P<interface>.*)', NotExists('vrf')],
+                                                        ['info', '(?P<interface>.*)', 'enabled', False],
+                                                        ['info', '(?P<interface>.*)', NotExists('duplex_mode')],
+                                                        ['info', '(?P<interface>.*)', NotExists('mac_address')],
+                                                        ['info', '(?P<interface>.*)', 'oper_status', '(.*down.*)']],
                                         'exclude': interface_exclude +\
                                                    [UncfgCfgInterface.remove_related_subinterface]}},
-                      num_values={'name': 1})
+                      num_values={'interface': 1})
 
 
 class TriggerUnconfigConfigEthernetInterfaceSub(TriggerUnconfigConfig):
+    """Unconfigure and reapply the whole configurations of dynamically learned
+        Giga/giga/Ethernet/ethernet interface(s)."""
+
+    __description__ = """Unconfigure and reapply the whole configurations of dynamically learned
+                        Giga/giga/Ethernet/ethernet interface(s).
 
+    trigger_datafile:
+        Mandatory:
+            timeout:
+                max_time (`int`): Maximum wait time for the trigger,
+                                in second. Default: 180
+                interval (`int`): Wait time between iteration when looping is needed,
+                                in second. Default: 15
+                method (`str`): Method to recover the device configuration,
+                              Support methods:
+                                'checkpoint': Rollback the configuration by
+                                              checkpoint (nxos),
+                                              archive file (iosxe),
+                                              load the saved running-config file on disk (iosxr)
+        Optional:
+            tgn_timeout (`int`): Maximum wait time for all traffic threads to be
+                                 restored to the reference rate,
+                                 in second. Default: 60
+            tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
+                               in second. Default: 10
+            timeout_recovery:
+                Buffer recovery timeout make sure devices are recovered at the end
+                of the trigger execution. Used when previous timeouts have been exhausted.
+
+                max_time (`int`): Maximum wait time for the last step of the trigger,
+                                in second. Default: 180
+                interval (`int`): Wait time between iteration when looping is needed,
+                                in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
+    steps:
+        1. Learn Interface Ops object and store the "up" GigabitEthernet|gigabitEthernet|Ethernet|ethernet interface(s)
+           if has any, otherwise, SKIP the trigger
+        2. Save the current device configurations through "method" which user uses
+        3. Unconfigure the learned GigabitEthernet|gigabitEthernet|Ethernet|ethernet interface(s) from step 1
+           with Interface Conf object
+        4. Verify the learned those interface(s) are "down"
+        5. Recover the device configurations to the one in step 2
+        6. Learn Interface Ops again and verify it is the same as the Ops in step 1
+
+    """
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
-                                        'requirements':[['info', '(?P<name>(GigabitEthernet|gigabitEthernet|Ethernet|ethernet)[0-9\/]+\.[0-9]+)',
+                                        'requirements':[['info', '(?P<interface>(GigabitEthernet|gigabitEthernet|Ethernet|ethernet)[0-9\/]+\.[0-9]+)',
                                                          'enabled', True],
-                                                        ['info', '(?P<name>(GigabitEthernet|gigabitEthernet|Ethernet|ethernet)[0-9\/]+\.[0-9]+)',
+                                                        ['info', '(?P<interface>(GigabitEthernet|gigabitEthernet|Ethernet|ethernet)[0-9\/]+\.[0-9]+)',
                                                          'oper_status', 'up']],
                                         'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                         'requirements':[],
                                         'verify_conf':False,
-                                        'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                        'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                                'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                        'requirements':[['info', '(?P<name>.*)','enabled', False]],
+                                        'requirements':[['info', '(?P<interface>.*)','enabled', False]],
                                         'exclude': interface_exclude}},
-                      num_values={'name': 1})
+                      num_values={'interface': 1})
 
 
 class TriggerUnconfigConfigVirtualTrunkInterface(TriggerUnconfigConfig):
+    """Unconfigure and reapply the whole configurations of dynamically learned virtual trunk interface(s)."""
+
+    __description__ = """Unconfigure and reapply the whole configurations of dynamically learned virtual trunk interface(s).
+
+        trigger_datafile:
+            Mandatory:
+                timeout:
+                    max_time (`int`): Maximum wait time for the trigger,
+                                    in second. Default: 180
+                    interval (`int`): Wait time between iteration when looping is needed,
+                                    in second. Default: 15
+                    method (`str`): Method to recover the device configuration,
+                                  Support methods:
+                                    'checkpoint': Rollback the configuration by
+                                                  checkpoint (nxos),
+                                                  archive file (iosxe),
+                                                  load the saved running-config file on disk (iosxr)
+            Optional:
+                tgn_timeout (`int`): Maximum wait time for all traffic threads to be
+                                     restored to the reference rate,
+                                     in second. Default: 60
+                tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
+                                   in second. Default: 10
+                timeout_recovery:
+                    Buffer recovery timeout make sure devices are recovered at the end
+                    of the trigger execution. Used when previous timeouts have been exhausted.
+
+                    max_time (`int`): Maximum wait time for the last step of the trigger,
+                                    in second. Default: 180
+                    interval (`int`): Wait time between iteration when looping is needed,
+                                    in second. Default: 15
+                static:
+                    The keys below are dynamically learnt by default.
+                    However, they can also be set to a custom value when provided in the trigger datafile.
+
+                    interface: `str`
+
+                    (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                          OR
+                          interface: 'Ethernet1/1/1' (Specific value)
+        steps:
+            1. Learn Interface Ops object and store the "up" port-channel interface(s)
+               if has any, otherwise, SKIP the trigger
+            2. Save the current device configurations through "method" which user uses
+            3. Unconfigure the learned port-channel interface(s) from step 1
+               with Interface Conf object
+            4. Verify the learned port-channel interface(s) no longer exists
+            5. Recover the device configurations to the one in step 2
+            6. Learn Interface Ops again and verify it is the same as the Ops in step 1
+
+        """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>[p|P]ort-channel[\d\.]+)',
+                                       'requirements':[['info', '(?P<interface>[p|P]ort-channel[\d\.]+)',
                                                         'switchport_mode', 'trunk'],
-                                                       ['info', '(?P<name>[p|P]ort-channel[\d\.]+)',
+                                                       ['info', '(?P<interface>[p|P]ort-channel[\d\.]+)',
                                                         'port_channel', 'port_channel_member', False]],
                                        'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[],
                                        'verify_conf':False,
-                                       'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                       'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<name>.*)', '(.*)']],
+                                       'requirements':[['info', NotExists('(?P<interface>.*)')]],
                                        'exclude': interface_exclude}},
-                      num_values={'name':1})
+                      num_values={'interface':1})
```

## genie/libs/sdk/triggers/unconfigconfig/interface/iosxr/unconfigconfig.py

```diff
@@ -1,15 +1,15 @@
 '''IOSXR Implementation for Interface unconfigconfig triggers'''
 
 # Genie Libs
 from genie.libs.sdk.libs.utils.mapping import Mapping
 from genie.libs.sdk.triggers.unconfigconfig.unconfigconfig import TriggerUnconfigConfig
 
 # import ats
-from ats import aetest
+from ats.utils.objects import Not, NotExists
 
 # Which key to exclude for Interface Ops comparison
 interface_exclude = ['maker', 'last_change','in_rate','in_rate_pkts',
                      'out_rate', 'out_rate_pkts', 'in_octets',
                      'in_pkts', 'in_unicast_pkts', 'out_octets',
                      'out_pkts', 'out_unicast_pkts', 'out_multicast_pkts',
                      'in_multicast_pkts', 'last_clear', 'in_broadcast_pkts',
@@ -17,30 +17,81 @@
                      'in_discards', 'accounting']
 
 ## IOSXR TriggerUnconfigConfigEthernetInterface implemented seperately since it
 ## doesn't need port_channel_member = False as in NXOS.
 
 
 class TriggerUnconfigConfigEthernetInterface(TriggerUnconfigConfig):
+    """Unconfigure and reapply the whole configurations of dynamically learned ethernet interface(s)."""
+
+    __description__ = """Unconfigure and reapply the whole configurations of dynamically learned ethernet interface(s).
+
+        trigger_datafile:
+            Mandatory:
+                timeout:
+                    max_time (`int`): Maximum wait time for the trigger,
+                                    in second. Default: 180
+                    interval (`int`): Wait time between iteration when looping is needed,
+                                    in second. Default: 15
+                    method (`str`): Method to recover the device configuration,
+                                  Support methods:
+                                    'checkpoint': Rollback the configuration by
+                                                  checkpoint (nxos),
+                                                  archive file (iosxe),
+                                                  load the saved running-config file on disk (iosxr)
+            Optional:
+                tgn_timeout (`int`): Maximum wait time for all traffic threads to be
+                                     restored to the reference rate,
+                                     in second. Default: 60
+                tgn_delay (`int`): Wait time between each poll to verify if traffic is resumed,
+                                   in second. Default: 10
+                timeout_recovery:
+                    Buffer recovery timeout make sure devices are recovered at the end
+                    of the trigger execution. Used when previous timeouts have been exhausted.
+
+                    max_time (`int`): Maximum wait time for the last step of the trigger,
+                                    in second. Default: 180
+                    interval (`int`): Wait time between iteration when looping is needed,
+                                    in second. Default: 15
+                static:
+                    The keys below are dynamically learnt by default.
+                    However, they can also be set to a custom value when provided in the trigger datafile.
+
+                    interface: `str`
+
+                    (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                          OR
+                          interface: 'Ethernet1/1/1' (Specific value)
+        steps:
+            1. Learn Interface Ops object and store the "up" ethernet interface(s)
+               if has any, otherwise, SKIP the trigger
+            2. Save the current device configurations through "method" which user uses
+            3. Unconfigure the learned ethernet interface(s) from step 1
+               with Interface Conf object
+            4. Verify the learned ethernet interface(s) are "down"
+            5. Recover the device configurations to the one in step 2
+            6. Learn Interface Ops again and verify it is the same as the Ops in step 1
+
+        """
 
     mapping = Mapping(requirements={'ops.interface.interface.Interface':{
-                                        'requirements':[['info', '(?P<name>(GigabitEthernet|gigabitEthernet|TenGigE|HundredGigE)[0-9\/]+)',
+                                        'requirements':[['info', '(?P<interface>(GigabitEthernet|gigabitEthernet|TenGigE|HundredGigE)[0-9\/]+)',
                                                          'enabled', True],
-                                                        ['info', '(?P<name>(GigabitEthernet|gigabitEthernet|TenGigE|HundredGigE)[0-9\/]+)',
+                                                        ['info', '(?P<interface>(GigabitEthernet|gigabitEthernet|TenGigE|HundredGigE)[0-9\/]+)',
                                                          'oper_status', 'up']],
                                         'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                         'requirements':[],
                                         'verify_conf':False,
-                                        'kwargs':{'mandatory':{'name': '(?P<name>.*)',
+                                        'kwargs':{'mandatory':{'name': '(?P<interface>.*)',
                                                                'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                        'requirements':[['info', '(?P<name>.*)','access_vlan'],
-                                                        ['info', '(?P<name>.*)','switchport_enable'],
-                                                        ['info', '(?P<name>.*)','switchport_mode'],
-                                                        ['info', '(?P<name>.*)','trunk_vlans'],
-                                                        ['info', '(?P<name>.*)','vrf'],
-                                                        ['info', '(?P<name>.*)','duplex_mode'],
-                                                        ['info', '(?P<name>.*)','mac_address'],
-                                                        ['info', '(?P<name>.*)','oper_status']],
+                                        'requirements':[['info', '(?P<interface>.*)', NotExists('access_vlan')],
+                                                        ['info', '(?P<interface>.*)', NotExists('switchport_enable')],
+                                                        ['info', '(?P<interface>.*)', NotExists('switchport_mode')],
+                                                        ['info', '(?P<interface>.*)', NotExists('trunk_vlans')],
+                                                        ['info', '(?P<interface>.*)', NotExists('vrf')],
+                                                        ['info', '(?P<interface>.*)', NotExists('duplex_mode')],
+                                                        ['info', '(?P<interface>.*)', NotExists('mac_address')],
+                                                        ['info', '(?P<interface>.*)', 'oper_status', '(.*down.*)']],
                                         'exclude': interface_exclude}},
-                      num_values={'name': 1})
+                      num_values={'interface': 1})
```

## genie/libs/sdk/triggers/unconfigconfig/interface/nxos/unconfigconfig.py

```diff
@@ -1,12 +1,16 @@
 '''NXOS Implementation for Interface unconfigconfig triggers'''
 
+# python
+from functools import partial
+
 # Genie Libs
 from genie.libs.sdk.libs.utils.mapping import Mapping
 from genie.libs.sdk.triggers.unconfigconfig.unconfigconfig import TriggerUnconfigConfig
+from genie.libs.sdk.libs.utils.triggeractions import verify_ops_or_logic
 # ATS
 from ats.utils.objects import NotExists, Not
 
 interface_exclude = ['maker', 'last_change','in_rate','in_rate_pkts',
                      'out_rate', 'out_rate_pkts', 'in_octets',
                      'in_pkts', 'in_unicast_pkts', 'out_octets',
                      'out_pkts', 'out_unicast_pkts', 'out_multicast_pkts',
@@ -91,15 +95,15 @@
                                                                                      'totalnetworks']}},
                       config_info={'conf.interface.Interface':{
                                         'requirements':[],
                                         'verify_conf':False,
                                         'kwargs':{'mandatory':{'name': '(?P<name>.*)',
                                                                'attach': False}}}},
                       verify_ops={'ops.vxlan.vxlan.Vxlan':{
-                                        'requirements':[['nve', '(?P<name>.*)']],
+                                        'requirements':[[NotExists('nve')]], # enh to support or() could be [['nve', NotExists('(?P<name>.*)')]]
                                         'kwargs': {'attributes': [
                                                       'nve[(.*)][if_state]',
                                                       'nve[(.*)][vni][(.*)][vni]','l2route','bgp_l2vpn_evpn']},
                                         'exclude': nve_exclude + ['l2route','bgp_l2vpn_evpn']}},
                       num_values={'name': 1})
 
 
@@ -150,15 +154,15 @@
                                         'exclude': pim_conf_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[],
                                        'verify_conf':False,
                                        'kwargs':{'mandatory':{'name': '(?P<rp_intf>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<rp_intf>.*)']],
+                                       'requirements':[['info', NotExists('(?P<rp_intf>.*)')]],
                                        'kwargs': {'attributes': ['info[(.*)][enabled]']},
                                        'exclude': interface_exclude}},
                       num_values={'rp_intf': 1})
 
 
 class TriggerUnconfigConfigAutoRpVrfInterface(TriggerUnconfigConfig):
     """Unconfigure and reapply the dynamically learned pim auto-rp interface(s) under non-default vrf."""
@@ -208,15 +212,15 @@
                                         'exclude': pim_conf_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[],
                                        'verify_conf':False,
                                        'kwargs':{'mandatory':{'name': '(?P<rp_intf>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<rp_intf>.*)']],
+                                       'requirements':[['info', NotExists('(?P<rp_intf>.*)')]],
                                        'kwargs': {'attributes': ['info[(.*)][enabled]']},
                                        'exclude': interface_exclude}},
                       num_values={'rp_intf': 1})
 
 
 class TriggerUnconfigConfigBsrRpInterface(TriggerUnconfigConfig):
     """Unconfigure and reapply the dynamically learned pim bsr-candidate interface(s) under default vrf."""
@@ -277,28 +281,28 @@
                                         'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[],
                                        'verify_conf':False,
                                        'kwargs':{'mandatory':{'name': '(?P<rp_intf>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<rp_intf>.*)']],
+                                       'requirements':[['info', NotExists('(?P<rp_intf>.*)')]],
                                         'kwargs': {'attributes': [
                                                       'info[(.*)][(ipv4|ipv6)][(.*)][ip]',
                                                       'info[(.*)][vrf]',
                                                       'info[(.*)][enabled]',
                                                       'info[(.*)][oper_status]']},
                                        'exclude': interface_exclude},
                                   'ops.pim.pim.Pim':{
                                        'requirements':[['info', 'vrf', '(?P<vrf>^default$)',
                                                         'address_family','(?P<af>.*)', 'rp', 'bsr',
-                                                        'bsr'],
+                                                        NotExists('bsr')],
                                                        ['info', 'vrf', '(?P<vrf>^default$)',
                                                         'address_family','(?P<af>.*)', 'rp', 'bsr',
-                                                        'bsr_candidate']],
+                                                        NotExists('bsr_candidate')]],
                                         'kwargs': {'attributes': [
                                                       'info[vrf][default][address_family][(.*)][rp][bsr][(.*)]']},
                                         'exclude': pim_exclude }},
                       num_values={'rp_intf': 1, 'vrf': 'all', 'rp_addr': 'all', 'af': 'all'})
 
 
 class TriggerUnconfigConfigBsrRpVrfInterface(TriggerUnconfigConfig):
@@ -362,28 +366,28 @@
                                         'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[],
                                        'verify_conf':False,
                                        'kwargs':{'mandatory':{'name': '(?P<rp_intf>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<rp_intf>.*)']],
+                                       'requirements':[['info', NotExists('(?P<rp_intf>.*)')]],
                                         'kwargs': {'attributes': [
                                                       'info[(.*)][(ipv4|ipv6)][(.*)][ip]',
                                                       'info[(.*)][vrf]',
                                                       'info[(.*)][enabled]',
                                                       'info[(.*)][oper_status]']},
                                        'exclude': interface_exclude},
                                   'ops.pim.pim.Pim':{
                                        'requirements':[['info', 'vrf', '(?P<vrf>^(?!default)\w+$)',
                                                         'address_family','(?P<af>.*)', 'rp', 'bsr',
-                                                        'bsr'],
+                                                        NotExists('bsr')],
                                                        ['info', 'vrf', '(?P<vrf>^(?!default)\w+$)',
                                                         'address_family','(?P<af>.*)', 'rp', 'bsr',
-                                                        'bsr_candidate']],
+                                                        NotExists('bsr_candidate')]],
                                         'kwargs': {'attributes': [
                                                       'info[vrf][(.*)][address_family][(.*)][rp][bsr][(.*)]']},
                                         'exclude': pim_exclude }},
                       num_values={'rp_intf': 1, 'vrf': 'all', 'rp_addr': 'all', 'af': 'all'})
 
 
 class TriggerUnconfigConfigStaticRpInterface(TriggerUnconfigConfig):
@@ -445,24 +449,33 @@
                                         'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[],
                                        'verify_conf':False,
                                        'kwargs':{'mandatory':{'name': '(?P<rp_intf>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<rp_intf>.*)']],
+                                       'requirements':[['info', NotExists('(?P<rp_intf>.*)')]],
                                         'kwargs': {'attributes': [
                                                       'info[(.*)][(ipv4|ipv6)][(.*)][ip]',
                                                       'info[(.*)][vrf]',
                                                       'info[(.*)][oper_status]']},
                                        'exclude': interface_exclude},
                                   'ops.pim.pim.Pim':{
-                                       'requirements':[['info', 'vrf', '(?P<vrf>^default$)',
-                                                        'address_family','(?P<af>.*)', 'rp', 'static_rp',
-                                                        '(?P<rp_addr>.*)']],
+                                       'requirements': [[partial(verify_ops_or_logic,
+                                                            requires=[['info', 'vrf', '(?P<vrf>^default$)',
+                                                                       'address_family','(?P<af>.*)', 'rp', 'static_rp',
+                                                                       NotExists('(?P<rp_addr>.*)')],
+                                                                      ['info', 'vrf', '(?P<vrf>^default$)',
+                                                                       'address_family','(?P<af>.*)', 'rp', NotExists('static_rp')],
+                                                                      ['info', 'vrf', '(?P<vrf>^default$)',
+                                                                       'address_family','(?P<af>.*)', 'rp', 'static_rp',
+                                                                       '(?P<rp_addr>.*)', '(?P<rp_rest>.*)'],
+                                                               ])
+                                                  ],
+                                                ],
                                         'kwargs': {'attributes': [
                                                       'info[vrf][default][address_family][(.*)][rp][static_rp][(.*)]']},
                                         'exclude': pim_exclude }},
                       num_values={'rp_intf': 1, 'vrf': 'all', 'rp_addr': 'all', 'af': 'all'})
 
 
 class TriggerUnconfigConfigStaticRpVrfInterface(TriggerUnconfigConfig):
@@ -524,24 +537,33 @@
                                         'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[],
                                        'verify_conf':False,
                                        'kwargs':{'mandatory':{'name': '(?P<rp_intf>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<rp_intf>.*)']],
+                                       'requirements':[['info', NotExists('(?P<rp_intf>.*)')]],
                                         'kwargs': {'attributes': [
                                                       'info[(.*)][(ipv4|ipv6)][(.*)][ip]',
                                                       'info[(.*)][vrf]',
                                                       'info[(.*)][oper_status]']},
                                        'exclude': interface_exclude},
                                   'ops.pim.pim.Pim':{
-                                       'requirements':[['info', 'vrf', '(?P<vrf>^(?!default)\w+$)',
-                                                        'address_family','(?P<af>.*)', 'rp', 'static_rp',
-                                                        '(?P<rp_addr>.*)']],
+                                       'requirements':[[partial(verify_ops_or_logic,
+                                                            requires=[['info', 'vrf', '(?P<vrf>^(?!default)\w+$)',
+                                                                       'address_family','(?P<af>.*)', 'rp', 'static_rp',
+                                                                       NotExists('(?P<rp_addr>.*)')],
+                                                                      ['info', 'vrf', '(?P<vrf>^(?!default)\w+$)',
+                                                                       'address_family','(?P<af>.*)', 'rp', NotExists('static_rp')],
+                                                                      ['info', 'vrf', '(?P<vrf>.*)',
+                                                                       'address_family','(?P<af>.*)', 'rp', 'static_rp',
+                                                                       '(?P<rp_addr>.*)', '(?P<rp_rest>.*)'],
+                                                               ])
+                                                  ],
+                                                ],
                                         'kwargs': {'attributes': [
                                                       'info[vrf][(.*)][address_family][(.*)][rp][static_rp][(.*)]']},
                                         'exclude': pim_exclude }},
                       num_values={'rp_intf': 1, 'vrf': 'all', 'rp_addr': 'all', 'af': 'all'})
 
 
 class TriggerUnconfigConfigPimNbrInterface(TriggerUnconfigConfig):
@@ -603,26 +625,22 @@
                                         'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[],
                                        'verify_conf':False,
                                        'kwargs':{'mandatory':{'name': '(?P<pim_intf>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<pim_intf>.*)']],
+                                       'requirements':[['info', NotExists('(?P<pim_intf>.*)')]],
                                         'kwargs': {'attributes': [
                                                       'info[(.*)][vrf]',
                                                       'info[(.*)][oper_status]']},
                                        'exclude': interface_exclude},
                                   'ops.pim.pim.Pim':{
                                        'requirements':[['info', 'vrf', '(?P<vrf>^default$)',
-                                                        'interfaces','(?P<pim_intf>.*)', 'address_family',
-                                                        '(?P<af>.*)', 'oper_status', 'down'],
-                                                       ['info', 'vrf', '(?P<vrf>^default$)',
-                                                        'interfaces','(?P<pim_intf>.*)', 'address_family',
-                                                        '(?P<af>.*)', 'neighbors', '(?P<address>.*)']],
+                                                        'interfaces',NotExists('(?P<pim_intf>.*)')]],
                                         'kwargs': {'attributes': [
                                                       'info[vrf][default][interfaces][(.*)][address_family][(.*)][oper_status]',
                                                       'info[vrf][default][interfaces][(.*)][address_family][(.*)][neighbors]']},
                                         'exclude': pim_exclude }},
                       num_values={'pim_intf': 1, 'vrf': 1})
 
 
@@ -686,24 +704,20 @@
                                         'exclude': interface_exclude}},
                       config_info={'conf.interface.Interface':{
                                        'requirements':[],
                                        'verify_conf':False,
                                        'kwargs':{'mandatory':{'name': '(?P<pim_intf>.*)',
                                                               'attach': False}}}},
                       verify_ops={'ops.interface.interface.Interface':{
-                                       'requirements':[['info', '(?P<pim_intf>.*)']],
+                                       'requirements':[['info', NotExists('(?P<pim_intf>.*)')]],
                                         'kwargs': {'attributes': [
                                                       'info[(.*)][vrf]',
                                                       'info[(.*)][oper_status]']},
                                        'exclude': interface_exclude},
                                   'ops.pim.pim.Pim':{
                                        'requirements':[['info', 'vrf', '(?P<vrf>^(?!default)\w+$)',
-                                                        'interfaces','(?P<pim_intf>.*)', 'address_family',
-                                                        '(?P<af>.*)', 'oper_status', 'down'],
-                                                       ['info', 'vrf', '(?P<vrf>^(?!default)\w+$)',
-                                                        'interfaces','(?P<pim_intf>.*)', 'address_family',
-                                                        '(?P<af>.*)', 'neighbors', '(?P<address>.*)']],
+                                                        'interfaces', NotExists('(?P<pim_intf>.*)')]],
                                         'kwargs': {'attributes': [
                                                       'info[vrf][(.*)][interfaces][(.*)][address_family][(.*)][oper_status]',
                                                       'info[vrf][(.*)][interfaces][(.*)][address_family][(.*)][neighbors]']},
                                         'exclude': pim_exclude }},
                       num_values={'pim_intf': 1, 'vrf': 'all'})
```

## genie/libs/sdk/triggers/unconfigconfig/mld/nxos/unconfigconfig.py

```diff
@@ -1,20 +1,19 @@
 '''NXOS Implementation for Mld unconfigconfig triggers'''
 
 # python
 from functools import partial
 
 # ats
-from ats import aetest
 from ats.utils.objects import Not, NotExists
 
 # Genie Libs
 from genie.libs.sdk.libs.utils.mapping import Mapping
 from genie.libs.sdk.triggers.unconfigconfig.unconfigconfig import TriggerUnconfigConfig
-from genie.libs.sdk.libs.utils.triggeractions import configure_add_attributes
+from genie.libs.sdk.libs.utils.triggeractions import configure_add_attributes, verify_ops_or_logic
 from genie.libs.conf.mld.mld_group import MldGroup
 
 # Which key to exclude for Mld Ops comparison
 mld_exclude = ['maker', 'expire', 'up_time']
 
 
 class TriggerUnconfigConfigMldEnable(TriggerUnconfigConfig):
@@ -47,15 +46,24 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+                vrf: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Mld Ops object and store the enabled Mld interface(s)
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned Mld interface(s)'s enable from step 1 
            with Mld Conf object
         4. Verify the Mld interface(s)'s enable from step 3
@@ -66,35 +74,34 @@
     """
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={
                           'ops.mld.mld.Mld':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'enable', True]],
+                                     '(?P<interface>.*)', 'enable', True]],
                                 'all_keys': True,
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)][interfaces][(.*)]']},
                                 'exclude': mld_exclude}},
                       config_info={'conf.mld.Mld':{
                                        'requirements':[
                                          ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
-                                          'interface_attr', '(?P<mld_intf>.*)', 'enable', True]],
+                                          'interface_attr', '(?P<interface>.*)', 'enable', True]],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={
                           'ops.mld.mld.Mld':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)']],
-                                'missing': True,
+                                     NotExists('(?P<interface>.*)')]],
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)][interfaces][(.*)]']},
                                 'exclude': mld_exclude}},
-                      num_values={'vrf': 1, 'mld_intf': 1})
+                      num_values={'vrf': 1, 'interface': 1})
 
 
 class TriggerUnconfigConfigMldVersion(TriggerUnconfigConfig):
     """Unconfigure and reapply the whole configurations of dynamically
     learned enabled Mld interface(s)'s version."""
 
     __description__ = """Unconfigure and reapply the whole configurations
@@ -123,15 +130,25 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+                vrf: `str`
+                version: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Mld Ops object and store the enabled Mld interface(s)'s version
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned Mld interface(s)'s version from step 1 
            with Mld Conf object
         4. Verify the Mld interface(s)'s version from step 3
@@ -142,38 +159,37 @@
     """
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={
                           'ops.mld.mld.Mld':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'enable', True],
+                                     '(?P<interface>.*)', 'enable', True],
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'version', '(?P<version>^(?!2).*)']],
+                                     '(?P<interface>.*)', 'version', '(?P<version>^(?!2).*)']],
                                 'all_keys': True,
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)]']},
                                 'exclude': mld_exclude}},
                       config_info={'conf.mld.Mld':{
                                        'requirements':[
                                          ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
-                                          'interface_attr', '(?P<mld_intf>.*)', 'version',
+                                          'interface_attr', '(?P<interface>.*)', 'version',
                                           '(?P<version>.*)']],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={
                           'ops.mld.mld.Mld':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'version', 2]],
-                                'missing': False,
+                                     '(?P<interface>.*)', 'version', 2]],
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)]']},
                                 'exclude': mld_exclude}},
-                      num_values={'vrf': 1, 'mld_intf': 1})
+                      num_values={'vrf': 1, 'interface': 1})
 
 
 class TriggerUnconfigConfigMldJoinGroup(TriggerUnconfigConfig):
     """Unconfigure and reapply the whole configurations of dynamically
     learned enabled Mld interface(s)'s join-groups."""
 
     __description__ = """Unconfigure and reapply the whole configurations
@@ -202,15 +218,27 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+                vrf: `str`
+                group: `str`
+                join_group: `str`
+                source: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Mld Ops object and store the enabled Mld interface(s)'s join-groups
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned Mld interface(s)'s join-groups from step 1 
            with Mld Conf object
         4. Verify the Mld interface(s)'s join-groups from step 3
@@ -222,50 +250,70 @@
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={
                           'ops.mld.mld.Mld':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'join_group', '(?P<join_group>.*)',
+                                     '(?P<interface>.*)', 'join_group', '(?P<join_group>.*)',
                                      'group', '(?P<group>.*)'],
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'join_group', '(?P<join_group>.*)',
+                                     '(?P<interface>.*)', 'join_group', '(?P<join_group>.*)',
                                      'source', '(?P<source>\*)']],
                                 'all_keys': True,
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)][interfaces][(.*)][join_group][(.*)]',
                                     'info[vrfs][(.*)][interfaces][(.*)][static_group][(.*)]',
                                     'info[vrfs][(.*)][interfaces][(.*)][group][(.*)]']},
                                 'exclude': mld_exclude}},
                       config_info={'conf.mld.Mld':{
                                        'requirements':[
                                          [partial(configure_add_attributes,  # callable configuration
                                             add_obj=MldGroup,
                                             base=[['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
-                                                  'interface_attr', '(?P<mld_intf>.*)']],
+                                                  'interface_attr', '(?P<interface>.*)']],
                                             add_attribute=[['join_group', '(?P<group>.*)'],
                                                            ['join_group_source_addr', '(?P<source>.*)'],],
                                             add_method='add_groups',
                                         )]],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={
                           'ops.mld.mld.Mld':{
-                                'requirements':[\
-                                    ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'join_group', '(?P<join_group>.*)'],
-                                    ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'group', '(?P<group>.*)']],
+                                'requirements': [[partial(verify_ops_or_logic,
+                                                      requires=[['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', 'join_group',
+                                                                 NotExists('(?P<join_group>.*)')],
+                                                                ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', NotExists('join_group')],
+                                                                ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', 'join_group',
+                                                                 '(?P<join_group>.*)', '(.*)']
+                                                               ])
+                                                  ],
+                                                  [partial(verify_ops_or_logic,
+                                                      requires=[['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', 'group', NotExists('(?P<group>.*)')],
+                                                                ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', NotExists('group')],
+                                                                ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', 'group', '(?P<group>.*)',
+                                                                 'source', NotExists('(?P<source>\*)')],
+                                                                ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', 'group', '(?P<group>.*)',
+                                                                 NotExists('source')]
+                                                               ])
+                                                  ],
+                                                ],
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)][interfaces][(.*)][join_group][(.*)]',
                                     'info[vrfs][(.*)][interfaces][(.*)][static_group][(.*)]',
                                     'info[vrfs][(.*)][interfaces][(.*)][group][(.*)]']},
-                                'exclude': mld_exclude}},
-                      num_values={'vrf': 1, 'mld_intf': 1, 'join_group': 1, 'group': 1, 'source': 1})
+                                'exclude': mld_exclude + ['static_group']}},
+                      num_values={'vrf': 1, 'interface': 1, 'join_group': 1, 'group': 1, 'source': 1})
 
 
 class TriggerUnconfigConfigMldStaticGroup(TriggerUnconfigConfig):
     """Unconfigure and reapply the whole configurations of dynamically
     learned enabled Mld interface(s)'s static-groups."""
 
     __description__ = """Unconfigure and reapply the whole configurations
@@ -294,14 +342,27 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                interface: `str`
+                vrf: `str`
+                group: `str`
+                static_group: `str`
+                source: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
 
     steps:
         1. Learn Mld Ops object and store the enabled Mld interface(s)'s static-groups
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned Mld interface(s)'s static-groups from step 1 
            with Mld Conf object
@@ -313,47 +374,64 @@
     """
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={
                           'ops.mld.mld.Mld':{
                                 'requirements':[\
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'static_group', '(?P<static_group>.*)',
+                                     '(?P<interface>.*)', 'static_group', '(?P<static_group>.*)',
                                      'group', '(?P<group>.*)'],
                                     ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'static_group', '(?P<static_group>.*)',
+                                     '(?P<interface>.*)', 'static_group', '(?P<static_group>.*)',
                                      'source', '(?P<source>\*)']],
                                 'all_keys': True,
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)][interfaces][(.*)][join_group]',
                                     'info[vrfs][(.*)][interfaces][(.*)][static_group]',
                                     'info[vrfs][(.*)][interfaces][(.*)][group]']},
                                 'exclude': mld_exclude + ['last_reporter']}},
                       config_info={'conf.mld.Mld':{
                                        'requirements':[
                                          [partial(configure_add_attributes,  # callable configuration
                                             add_obj=MldGroup,
                                             base=[['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
-                                                  'interface_attr', '(?P<mld_intf>.*)']],
+                                                  'interface_attr', '(?P<interface>.*)']],
                                             add_attribute=[['static_group', '(?P<group>.*)'],
                                                            ['static_group_source_addr', '(?P<source>.*)'],],
                                             add_method='add_groups',
                                         )]],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={
                           'ops.mld.mld.Mld':{
-                                'requirements':[\
-                                    ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'static_group', '(?P<static_group>.*)'],
-                                    ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'group', '(?P<group>.*)'],
-                                    ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<mld_intf>.*)', 'static_group', '(?P<static_group>.*)',
-                                     'source', '(?P<source>.*)']],
+                                'requirements': [[partial(verify_ops_or_logic,
+                                                      requires=[['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', 'static_group',
+                                                                 NotExists('(?P<static_group>.*)')],
+                                                                ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', NotExists('static_group')],
+                                                                ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', 'static_group',
+                                                                 '(?P<static_group>.*)', '(.*)']
+                                                               ])
+                                                  ],
+                                                  [partial(verify_ops_or_logic,
+                                                      requires=[['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', 'group', NotExists('(?P<group>.*)')],
+                                                                ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', NotExists('group')],
+                                                                ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', 'group', '(?P<group>.*)',
+                                                                 'source', NotExists('(?P<source>\*)')],
+                                                                ['info', 'vrfs', '(?P<vrf>.*)', 'interfaces',
+                                                                 '(?P<interface>.*)', 'group', '(?P<group>.*)',
+                                                                 NotExists('source')]
+                                                               ])
+                                                  ],
+                                                ],
                                 'kwargs':{'attributes': [
                                     'info[vrfs][(.*)][interfaces][(.*)][join_group]',
                                     'info[vrfs][(.*)][interfaces][(.*)][static_group]',
                                     'info[vrfs][(.*)][interfaces][(.*)][group]']},
                                 'exclude': mld_exclude + ['last_reporter']}},
-                      num_values={'vrf': 1, 'mld_intf': 1, 'static_group': 1, 'group': 1})
+                      num_values={'vrf': 1, 'interface': 1, 'static_group': 1, 'group': 1})
```

## genie/libs/sdk/triggers/unconfigconfig/msdp/nxos/unconfigconfig.py

```diff
@@ -1,13 +1,16 @@
 '''NXOS Implementation for Msdp unconfigconfig triggers'''
 
 # Genie Libs
 from genie.libs.sdk.libs.utils.mapping import Mapping
 from genie.libs.sdk.triggers.unconfigconfig.unconfigconfig import TriggerUnconfigConfig
 
+# import ats
+from ats.utils.objects import Not, NotExists
+
 # Which key to exclude for Msdp Ops comparison
 msdp_exclude = ['maker', 'elapsed_time', 'discontinuity_time',
            'keepalive', 'total', 'up_time', 'expire', 'remote',
            'last_message_received', 'num_of_comparison', 'rpf_failure',
            'total_accept_count', 'total_reject_count', 'notification']
 
 
@@ -41,15 +44,25 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+                                in second. Default: 15
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Msdp Ops object and store the "established" MSDP peer(s)
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned MSDP peer(s) from step 1 
            with Msdp Conf object
         4. Verify the MSDP peer(s) from step 3 are no longer existed
@@ -70,15 +83,15 @@
                                        'requirements':[
                                          ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
                                           'peer_attr', '(?P<peer>.*)']],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={'ops.msdp.msdp.Msdp':{
                                     'requirements':[\
-                                      ['info', 'vrf', '(?P<vrf>.*)', 'peer', '(?P<peer>.*)']],
+                                      ['info', 'vrf', '(?P<vrf>.*)', 'peer', NotExists('(?P<peer>.*)')]],
                                     'kwargs':{'attributes': ['info[vrf][(.*)][peer][(.*)]']},
                                     'exclude': msdp_exclude}},
                       num_values={'vrf': 1, 'peer':1})
 
 
 class TriggerUnconfigConfigMsdpSaFilterIn(TriggerUnconfigConfig):
     """Unconfigure and reapply the whole configurations of dynamically
@@ -110,15 +123,25 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+                sa_filter_in: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Msdp Ops object and store the "established" MSDP peer(s) sa-filter in
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned MSDP peer(s) sa-filter in from step 1 
            with Msdp Conf object
         4. Verify the MSDP peer(s) sa-filter in from step 3 are no longer existed
@@ -143,15 +166,15 @@
                                          ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
                                           'peer_attr', '(?P<peer>.*)', 'sa_filter_in','(?P<sa_filter_in>.*)']],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={'ops.msdp.msdp.Msdp':{
                                     'requirements':[\
                                       ['info', 'vrf', '(?P<vrf>.*)', 'peer', '(?P<peer>.*)', 
-                                       'sa_filter', 'in', '(?P<sa_filter_in>.*)']],
+                                       'sa_filter', NotExists('in')]], # , '(?P<sa_filter_in>.*)'
                                     'kwargs':{'attributes': ['info[vrf][(.*)][peer][(.*)][session_state]',
                                                              'info[vrf][(.*)][peer][(.*)][sa_filter]']},
                                     'exclude': msdp_exclude}},
                       num_values={'vrf': 1, 'peer':1})
 
 
 class TriggerUnconfigConfigMsdpSaFilterOut(TriggerUnconfigConfig):
@@ -184,15 +207,25 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+                sa_filter_out: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Msdp Ops object and store the "established" MSDP peer(s) sa-filter out
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned MSDP peer(s) sa-filter out from step 1 
            with Msdp Conf object
         4. Verify the MSDP peer(s) sa-filter out from step 3 are no longer existed
@@ -217,15 +250,15 @@
                                          ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
                                           'peer_attr', '(?P<peer>.*)', 'sa_filter_out','(?P<sa_filter_out>.*)']],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={'ops.msdp.msdp.Msdp':{
                                     'requirements':[\
                                       ['info', 'vrf', '(?P<vrf>.*)', 'peer', '(?P<peer>.*)', 
-                                       'sa_filter', 'out', '(?P<sa_filter_out>.*)']],
+                                       'sa_filter', NotExists('out')]], # , '(?P<sa_filter_out>.*)'
                                     'kwargs':{'attributes': ['info[vrf][(.*)][peer][(.*)][session_state]',
                                                              'info[vrf][(.*)][peer][(.*)][sa_filter]']},
                                     'exclude': msdp_exclude}},
                       num_values={'vrf': 1, 'peer':1})
 
 
 class TriggerUnconfigConfigMsdpSaLimit(TriggerUnconfigConfig):
@@ -258,15 +291,25 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+                sa_limit: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Msdp Ops object and store the "established" MSDP peer(s) sa-limit
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned MSDP peer(s) sa-limit from step 1 
            with Msdp Conf object
         4. Verify the MSDP peer(s) sa-limit from step 3 are no longer existed
@@ -291,15 +334,15 @@
                                          ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
                                           'peer_attr', '(?P<peer>.*)', 'sa_limit','(?P<sa_limit>\d+)']],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={'ops.msdp.msdp.Msdp':{
                                     'requirements':[\
                                       ['info', 'vrf', '(?P<vrf>.*)', 'peer',
-                                       '(?P<peer>.*)', 'sa_limit', '(?P<sa_limit>.*)']],
+                                       '(?P<peer>.*)', 'sa_limit', 'unlimited']],
                                     'kwargs':{'attributes': [
                                                   'info[vrf][(.*)][peer][(.*)][session_state]',
                                                   'info[vrf][(.*)][peer][(.*)][sa_limit]']},
                                     'exclude': msdp_exclude}},
                       num_values={'vrf': 1, 'peer':1})
 
 
@@ -333,15 +376,25 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+                mesh_group: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Msdp Ops object and store the 'established' MSDP peer(s) mesh group
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned MSDP peer(s) mesh group from step 1 
            with Msdp Conf object
         4. Verify the MSDP peer(s) mesh group from step 3 are no longer existed
@@ -366,15 +419,15 @@
                                          ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
                                           'peer_attr', '(?P<peer>.*)', 'mesh_group','(?P<mesh_group>.*)']],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={'ops.msdp.msdp.Msdp':{
                                     'requirements':[\
                                       ['info', 'vrf', '(?P<vrf>.*)', 'peer',
-                                       '(?P<peer>.*)', 'mesh_group', '(?P<mesh_group>.*)']],
+                                       '(?P<peer>.*)', NotExists('mesh_group')]], # , '(?P<mesh_group>.*)'
                                     'kwargs':{'attributes': [
                                                   'info[vrf][(.*)][peer][(.*)][session_state]',
                                                   'info[vrf][(.*)][peer][(.*)][mesh_group]']},
                                     'exclude': msdp_exclude}},
                       num_values={'vrf': 1, 'peer':1})
 
 
@@ -408,15 +461,26 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+                originator_id: `str`
+                originating_rp: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Msdp Ops object and store the MSDP originator-id
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned MSDP originator-id from step 1 
            with Msdp Conf object
         4. Verify the MSDP originator-id from step 3 are no longer existed
@@ -446,15 +510,15 @@
                                          ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
                                           'originating_rp', '(?P<originating_rp>.*)']],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={'conf.msdp.Msdp':{
                                     'requirements':[\
                                         ['device_attr', '{uut}', '_vrf_attr', '(?P<vrf>.*)',
-                                         'originating_rp', '(?P<originating_rp>.*)']],
+                                         NotExists('originating_rp')]], # , '(?P<originating_rp>.*)'
                                     'kwargs':{'attributes': [
                                                   'info[vrf][(.*)][originating_rp]',
                                                   'info[vrf][(.*)][peer][(.*)][session_state]']},
                                     'exclude': msdp_exclude}},
                       num_values={'vrf': 1, 'peer':1})
 
 
@@ -488,15 +552,26 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+                keepalive_interval: `int`
+                holdtime_interval: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Msdp Ops object and store the MSDP peer(s)
            keepalive&holdtime interval if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned MSDP peer(s) keepalive&holdtime interval from step 1 
            with Msdp Conf object
         4. Verify the MSDP peer(s) keepalive&holdtime interval from step 3 are no longer existed
@@ -542,15 +617,14 @@
                                           ['info', 'vrf', '(?P<vrf>.*)', 'peer', '(?P<peer>.*)',
                                            'timer', 'keepalive_interval', 60], # change to default value
                                           ['info', 'vrf', '(?P<vrf>.*)', 'peer', '(?P<peer>.*)',
                                            'timer', 'holdtime_interval', 90]], # change to default value
                                     'kwargs':{'attributes': [
                                                   'info[vrf][(.*)][peer][(.*)][session_state]',
                                                   'info[vrf][(.*)][peer][(.*)][timer]']},
-                                    'missing': False,
                                     'exclude': msdp_exclude}},
                       num_values={'vrf': 1, 'peer':1})
 
 
 class TriggerUnconfigConfigMsdpReconnectInterval(TriggerUnconfigConfig):
     """Unconfigure and reapply the whole configurations of dynamically
     learned MSDP reconnect interval."""
@@ -581,15 +655,25 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+                connect_retry_interval: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Msdp Ops object and store the MSDP reconnect interval
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned MSDP reconnect interval from step 1 
            with Msdp Conf object
         4. Verify the MSDP reconnect interval from step 3 are no longer existed
@@ -624,15 +708,14 @@
                       verify_ops={'ops.msdp.msdp.Msdp':{
                                     'requirements':[\
                                       ['info', 'vrf', '(?P<vrf>.*)', 'peer', '(?P<peer>.*)', 'timer',
                                        'connect_retry_interval', 10]], # change to default value
                                     'kwargs':{'attributes': [
                                                   'info[vrf][(.*)][peer][(.*)][session_state]',
                                                   'info[vrf][(.*)][peer][(.*)][timer]']},
-                                    'missing': False,
                                     'exclude': msdp_exclude}},
                       num_values={'vrf': 1, 'peer': 'all'})
 
 
 class TriggerUnconfigConfigMsdpDescription(TriggerUnconfigConfig):
     """Unconfigure and reapply the whole configurations of dynamically
     learned MSDP peer(s) description."""
@@ -663,15 +746,25 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                peer: `str`
+                connect_retry_interval: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Msdp Ops object and store the MSDP peer(s) description
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned MSDP peer(s) description from step 1 
            with Msdp Conf object
         4. Verify the MSDP peer(s) description from step 3 are no longer existed
@@ -702,13 +795,13 @@
                                          ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
                                           'peer_attr', '(?P<peer>.*)', 'description','(?P<description>.*)']],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={'ops.msdp.msdp.Msdp':{
                                     'requirements':[\
                                       ['info', 'vrf', '(?P<vrf>.*)', 'peer',
-                                       '(?P<peer>.*)', 'description', '(?P<description>.*)']],
+                                       '(?P<peer>.*)', NotExists('description')]], # , '(?P<description>.*)'
                                     'kwargs':{'attributes': [
                                                   'info[vrf][(.*)][peer][(.*)][session_state]',
                                                   'info[vrf][(.*)][peer][(.*)][description]']},
                                     'exclude': msdp_exclude}},
                       num_values={'vrf': 1, 'peer': 1})
```

## genie/libs/sdk/triggers/unconfigconfig/pim/nxos/unconfigconfig.py

```diff
@@ -1,9 +1,13 @@
 '''NXOS Implementation for Pim unconfigconfig triggers'''
 
+# ats
+from ats.utils.objects import NotExists
+
+
 # Genie Libs
 from genie.libs.sdk.libs.utils.mapping import Mapping
 from genie.libs.sdk.triggers.unconfigconfig.unconfigconfig import TriggerUnconfigConfig
 
 # Which key to exclude for Pim Ops comparison
 pim_exclude = ['maker', ]
 
@@ -38,15 +42,26 @@
                 Buffer recovery timeout make sure devices are recovered at the end
                 of the trigger execution. Used when previous timeouts have been exhausted.
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vrf: `str`
+                interface: `str`
+                address_family: `str`
+                neighbor_filter: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Pim Ops object and store the "up" PIM interface(s)'s neighbor-filter
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned PIM interface(s)'s neighbor-filter from step 1 
            with Pim Conf object
         4. Verify the PIM interface(s)'s neighbor-filter from step 3
@@ -57,35 +72,35 @@
     """
     # Mapping of Information between Ops and Conf
     # Also permit to dictate which key to verify
     mapping = Mapping(requirements={
                           'ops.pim.pim.Pim':{
                                 'requirements':[\
                                     ['info', 'vrf', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<pim_intf>.*)', 'address_family', '(?P<af>.*)',
+                                     '(?P<interface>.*)', 'address_family', '(?P<address_family>.*)',
                                      'neighbor_filter', '(?P<neighbor_filter>.*)'],
                                     ['info', 'vrf', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<pim_intf>.*)', 'address_family', '(?P<af>.*)',
+                                     '(?P<interface>.*)', 'address_family', '(?P<address_family>.*)',
                                      'oper_status', 'up']],
                                 'kwargs':{'attributes': [
                                     'info[vrf][(.*)][interfaces][(.*)][address_family][(.*)][oper_status]',
                                     'info[vrf][(.*)][interfaces][(.*)][address_family][(.*)][neighbor_filter]']},
                                 'exclude': pim_exclude}},
                       config_info={'conf.pim.Pim':{
                                        'requirements':[
                                          ['device_attr', '{uut}', 'vrf_attr', '(?P<vrf>.*)',
-                                          'address_family_attr', '(?P<af>.*)', 'interface_attr',
-                                          '(?P<pim_intf>.*)', 'neighbor_filter', '(?P<neighbor_filter>.*)']],
+                                          'address_family_attr', '(?P<address_family>.*)', 'interface_attr',
+                                          '(?P<interface>.*)', 'neighbor_filter', '(?P<neighbor_filter>.*)']],
                                        'verify_conf':False,
                                        'kwargs':{}}},
                       verify_ops={
                           'ops.pim.pim.Pim':{
                                 'requirements':[\
                                     ['info', 'vrf', '(?P<vrf>.*)', 'interfaces',
-                                     '(?P<pim_intf>.*)', 'address_family', '(?P<af>.*)',
-                                     'neighbor_filter', '(?P<neighbor_filter>.*)']],
+                                     '(?P<interface>.*)', 'address_family', '(?P<address_family>.*)',
+                                     NotExists('neighbor_filter')]],
                                 'kwargs':{'attributes': [
                                     'info[vrf][(.*)][interfaces][(.*)][address_family][(.*)][oper_status]',
                                     'info[vrf][(.*)][interfaces][(.*)][address_family][(.*)][neighbor_filter]']},
                                 'exclude': pim_exclude}},
-                      num_values={'vrf': 1, 'af': 1, 'pim_intf': 1})
+                      num_values={'vrf': 1, 'address_family': 1, 'interface': 1})
```

## genie/libs/sdk/triggers/unconfigconfig/trm/nxos/unconfigconfig.py

```diff
@@ -1,15 +1,17 @@
 '''Implementation for TRM unconfigconfig triggers'''
+# python
+from functools import partial
 
 # Genie Libs
 from genie.libs.sdk.libs.utils.mapping import Mapping
 from genie.libs.sdk.triggers.unconfigconfig.unconfigconfig import TriggerUnconfigConfig
 from collections import OrderedDict
 from ats.utils.objects import NotExists
-from ats import aetest
+from genie.libs.sdk.libs.utils.triggeractions import verify_ops_or_logic
 
 
 # Which key to exclude for TRM Ops comparison
 trm_exclude = ['maker']
 
 
 class TriggerUnconfigConfigRouteTargetMvpn(TriggerUnconfigConfig):
@@ -40,67 +42,76 @@
                     Buffer recovery timeout when the previous timeout has been exhausted,
                     to make sure the devices are recovered before ending the trigger
 
                     max_time (`int`): Maximum wait time for the last step of the trigger,
                                     in second. Default: 180
                     interval (`int`): Wait time between iteration when looping is needed,
                                     in second. Default: 15
-
+                static:
+                    The keys below are dynamically learnt by default.
+                    However, they can also be set to a custom value when provided in the trigger datafile.
+
+                    vrf: `str`
+                    address_family: `str`
+                    rt: `str`
+                    rt_type: `str`
+
+                    (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                          OR
+                          interface: 'Ethernet1/1/1' (Specific value)
         steps:
             1. Learn Vrf Conf object and check rt_mvpn is available
                if has any, otherwise, SKIP the trigger
             2. Save the current device configurations through "method" which user uses
             3. Unconfigure the rt_mvpn with Vrf Conf object
             4. Verify the mvpn from step 3 are no longer existed
             5. Recover the device configurations to the one in step 2
             6. Learn Vrf Conf obj again and verify it is the same as the Ops in step 1
 
         """
     mapping = Mapping( \
         requirements={ \
             'conf.vrf.Vrf': {
                 'requirements': [ \
-                    ['device_attr', '{uut}', 'address_family_attr', '(?P<af>.*)', '_route_target_attr', '(?P<rt>.*)', \
+                    ['device_attr', '{uut}', 'address_family_attr', '(?P<address_family>.*)', '_route_target_attr', '(?P<rt>.*)', \
                       'rt_type', '(?P<rt_type>.*)'],
-                    ['device_attr', '{uut}', 'address_family_attr', '(?P<af>.*)', '_route_target_attr', '(?P<rt>.*)',
+                    ['device_attr', '{uut}', 'address_family_attr', '(?P<address_family>.*)', '_route_target_attr', '(?P<rt>.*)',
                       '_protocol_attr', '(?P<protocol_name>^(mvpn).*)', 'rt_mvpn', True],
                     ['device_attr', '{uut}', 'vrf_name', '(?P<vrf>.*)']],
                 'exclude': trm_exclude,
                 'all_keys': True,
                 'kwargs': {'attributes': ['vrf[vrf][(.*)]']}},
             'ops.vrf.vrf.Vrf':{
                  'requirements': [ \
                      ['info', 'vrfs', '(?P<vrf>.*)', '(.*)']],
                  'all_keys': False,
                  'kwargs': {'attributes': ['info']},
                  'exclude': trm_exclude}},
         config_info={ \
             'conf.vrf.Vrf': {
                 'requirements': [ \
-                    ['device_attr', '{uut}', 'address_family_attr', '(?P<af>.*)', 'route_target_attr', '(?P<rt>.*)', \
+                    ['device_attr', '{uut}', 'address_family_attr', '(?P<address_family>.*)', 'route_target_attr', '(?P<rt>.*)', \
                      'rt_type', '(?P<rt_type>.*)'],
-                    ['device_attr', '{uut}', 'address_family_attr', '(?P<af>.*)', 'route_target_attr', '(?P<rt>.*)',\
+                    ['device_attr', '{uut}', 'address_family_attr', '(?P<address_family>.*)', 'route_target_attr', '(?P<rt>.*)',\
                      'protocol_attr', '(?P<protocol_name>.*)', 'rt_mvpn', False]],
                 'verify_conf': False,
                 'kwargs': {'mandatory': {'name': '(?P<vrf>.*)'}}}},
         verify_ops={ \
             'conf.vrf.Vrf': {
                 'requirements': [ \
-                    ['device_attr', '{uut}', 'address_family_attr', '(?P<af>.*)', '_route_target_attr','(?P<rt>.*)',
-                     '_protocol_attr', '(?P<protocol_name>(?!mvpn).*)', '(.*)']],
+                    ['device_attr', '{uut}', 'address_family_attr', '(?P<address_family>.*)', '_route_target_attr','(?P<rt>.*)',
+                     '_protocol_attr', NotExists('(?P<protocol_name>(?!mvpn).*)')]], # , '(.*)'
                 'exclude': trm_exclude,
-                'kwargs': {'attributes': ['vrf[vrf][(.*)]']},
-                'missing': True},
+                'kwargs': {'attributes': ['vrf[vrf][(.*)]']}},
             'ops.vrf.vrf.Vrf':{
                 'requirements': [ \
                     ['info', 'vrfs', '(?P<vrf>.*)', '(.*)']],
                 'kwargs': {'attributes': ['info']},
-                'missing': False,
                 'exclude': trm_exclude}},
-        num_values={'protocol_name': 1, 'vrf': 1, 'rt': 1, 'rt_type': 1, 'af': 1})
+        num_values={'protocol_name': 1, 'vrf': 1, 'rt': 1, 'rt_type': 1, 'address_family': 1})
 
 class TriggerUnconfigConfigRouteTargetEvpn(TriggerUnconfigConfig):
     """Unconfigure route-target evpn and reapply the whole configurations of dynamically learned Conf Vrf."""
 
     __description__ = """Unconfigure route-target evpn and reapply the whole configurations of dynamically learned Vrf.
 
         trigger_datafile:
@@ -126,65 +137,81 @@
                     Buffer recovery timeout when the previous timeout has been exhausted,
                     to make sure the devices are recovered before ending the trigger
 
                     max_time (`int`): Maximum wait time for the last step of the trigger,
                                     in second. Default: 180
                     interval (`int`): Wait time between iteration when looping is needed,
                                     in second. Default: 15
-
+                static:
+                    The keys below are dynamically learnt by default.
+                    However, they can also be set to a custom value when provided in the trigger datafile.
+
+                    vrf: `str`
+                    address_family: `str`
+                    rt: `str`
+                    rt_type: `str`
+
+                    (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                          OR
+                          interface: 'Ethernet1/1/1' (Specific value)
         steps:
             1. Learn Vrf Conf object and check rt_evpn is available
                if has any, otherwise, SKIP the trigger
             2. Save the current device configurations through "method" which user uses
             3. Unconfigure the rt_evpn with Vrf Conf object
             4. Verify the evpn from step 3 are no longer existed
             5. Recover the device configurations to the one in step 2
             6. Learn Vrf Conf obj again and verify it is the same as the Ops in step 1
 
         """
     mapping = Mapping( \
         requirements= {\
             'conf.vrf.Vrf': {
                 'requirements': [ \
-                    ['device_attr', '{uut}', 'address_family_attr', '(?P<af>.*)', '_route_target_attr', '(?P<rt>.*)', \
+                    ['device_attr', '{uut}', 'address_family_attr', '(?P<address_family>.*)', '_route_target_attr', '(?P<rt>.*)', \
                      'rt_type', '(?P<rt_type>.*)'],
-                    ['device_attr', '{uut}', 'address_family_attr', '(?P<af>.*)', '_route_target_attr', '(?P<rt>.*)',
+                    ['device_attr', '{uut}', 'address_family_attr', '(?P<address_family>.*)', '_route_target_attr', '(?P<rt>.*)',
                       '_protocol_attr', '(?P<protocol_name>^(evpn).*)', 'rt_evpn', True],
                     ['device_attr', '{uut}', 'vrf_name', '(?P<vrf>.*)']],
                 'exclude': trm_exclude,
                 'all_keys': True },
             'ops.vrf.vrf.Vrf':{
                  'requirements': [ \
                      ['info', 'vrfs', '(?P<vrf>.*)', '(.*)']],
                  'kwargs': {'attributes': ['info']},
                  'exclude': trm_exclude}},
         config_info={ \
             'conf.vrf.Vrf': {
                 'requirements': [ \
-                    ['device_attr', '{uut}', 'address_family_attr', '(?P<af>.*)', 'route_target_attr', '(?P<rt>.*)', \
+                    ['device_attr', '{uut}', 'address_family_attr', '(?P<address_family>.*)', 'route_target_attr', '(?P<rt>.*)', \
                      'rt_type', '(?P<rt_type>.*)'],
-                    ['device_attr', '{uut}', 'address_family_attr', '(?P<af>.*)', 'route_target_attr', '(?P<rt>.*)', \
+                    ['device_attr', '{uut}', 'address_family_attr', '(?P<address_family>.*)', 'route_target_attr', '(?P<rt>.*)', \
                      'protocol_attr', 'evpn', 'rt_evpn', False]
                 ],
                 'verify_conf': False,
                 'kwargs': {'mandatory': {'name': '(?P<vrf>.*)'}}}},
         verify_ops={ \
             'conf.vrf.Vrf': {
-                'requirements': [ \
-                    ['device_attr', '{uut}', 'address_family_attr', '(?P<af>.*)', '_route_target_attr','(?P<rt>.*)',
-                     '_protocol_attr', '(?P<protocol_name>(?!evpn).*)', '(.*)']],
-                'exclude': trm_exclude,
-                'missing': True},
+                'requirements': [[partial(verify_ops_or_logic,
+                                      requires=[['device_attr', '{uut}', 'address_family_attr',
+                                                 '(?P<address_family>.*)', '_route_target_attr','(?P<rt>.*)',
+                                                 '_protocol_attr', NotExists('(?P<protocol_name>(?!evpn).*)')],
+                                                ['device_attr', '{uut}', 'address_family_attr',
+                                                 '(?P<address_family>.*)', '_route_target_attr','(?P<rt>.*)',
+                                                 NotExists('_protocol_attr')],
+                                               ])
+                                  ]
+                                ],
+                'exclude': trm_exclude},
             'ops.vrf.vrf.Vrf':{
                 'requirements': [ \
                     ['info', 'vrfs', '(?P<vrf>.*)', '(.*)']],
                 'kwargs': {'attributes': ['info']},
-                'missing': False,
                 'exclude': trm_exclude}},
-        num_values={'protocol_name': 1, 'vrf': 1, 'rt': 1, 'af': 1})
+        num_values={'protocol_name': 1, 'vrf': 1, 'rt': 1, 'address_family': 1})
 
 class TriggerUnconfigConfigAdvertiseEvpnMulticast(TriggerUnconfigConfig):
     """Unconfigure advertise evpn multisite and reapply the whole configurations of dynamically learned Conf Vxlan."""
 
     __description__ = """Unconfigure advertise evpn multisite and reapply the whole configurations of dynamically learned Vxlan.
 
         trigger_datafile:
@@ -236,11 +263,10 @@
             'conf.vxlan.Vxlan': {
                 'requirements': [['device_attr', '{uut}', 'advertise_evpn_multicast', True]],
                 'verify_conf': False,
                 'kwargs': {}}},
         verify_ops={ \
             'conf.vxlan.Vxlan': {
                 'requirements': [ \
-                    ['device_attr', '{uut}', NotExists('advertise_evpn_multicast')]],
-                'missing': False,
+                    [NotExists('device_attr')]],
                 'exclude': trm_exclude}},
         num_values={})
```

## genie/libs/sdk/triggers/unconfigconfig/vlan/iosxe/unconfigconfig.py

```diff
@@ -1,13 +1,16 @@
 '''Implementation for vlan unconfigconfig triggers'''
 
 # Genie Libs
 from genie.libs.sdk.libs.utils.mapping import Mapping
 from genie.libs.sdk.triggers.unconfigconfig.vlan.unconfigconfig import TriggerUnconfigConfig
 
+# ats
+from ats.utils.objects import NotExists
+
 # Which key to exclude for Vlan Ops comparison
 vlan_exclude = ['maker']
 
 class TriggerUnconfigConfigVlan(TriggerUnconfigConfig):
     """Unconfigure and reapply the whole configurations of dynamically learned vlan(s)."""
     
     __description__ = """Unconfigure and reapply the whole configurations of dynamically learned vlan(s).
@@ -35,33 +38,41 @@
                 Buffer recovery timeout when the previous timeout has been exhausted,
                 to make sure the devices are recovered before ending the trigger
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vlan: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Vlan Ops object and store the "unshut" vlan(s) if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned vlan with Vlan Conf object
         4. Verify the vlan(s) from step 3 are no longer existed
         5. Recover the device configurations to the one in step 2
         6. Learn Vlan Ops again and verify it is the same as the Ops in step 1
 
     """
 
     mapping = Mapping(requirements={'ops.vlan.vlan.Vlan':{
-                                        'requirements':[['info','vlans','(?P<vlanid>^([2-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1][0][0][0-1]))$'\
-                                                            ,'vlan_id','(?P<vlanid>^([2-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1][0][0][0-1]))$'],
-                                                        ['info','vlans','(?P<vlanid>.*)','shutdown',False]],
+                                        'requirements':[['info','vlans','(?P<vlan>^([2-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1][0][0][0-1]))$'\
+                                                            ,'vlan_id','(?P<vlan>^([2-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1][0][0][0-1]))$'],
+                                                        ['info','vlans','(?P<vlan>.*)','shutdown',False]],
                                         'kwargs': {'attributes': ['info']},
                                         'exclude': vlan_exclude}},
                       config_info={'conf.vlan.Vlan':{
-                                     'requirements':[['device_attr', '{uut}', 'vlan_attr', '(?P<vlanid>.*)']],
+                                     'requirements':[['device_attr', '{uut}', 'vlan_attr', '(?P<vlan>.*)']],
                                      'verify_conf':False,
-                                     'kwargs':{'mandatory':{'vlanid': '(?P<vlanid>.*)'}}}},
+                                     'kwargs':{'mandatory':{'vlanid': '(?P<vlan>.*)'}}}},
                       verify_ops={'ops.vlan.vlan.Vlan':{
-                                    'requirements': [['info','vlans','(?P<vlanid>.*)','vlan_id' ,'(?P<vlanid>.*)']],
+                                    'requirements': [['info','vlans','(?P<vlan>.*)','vlan_id', NotExists('(?P<vlan>.*)')]],
                                     'kwargs':{'attributes':['info']},
                                     'exclude': vlan_exclude}},
-                      num_values={'vlanid':1})
+                      num_values={'vlan':1})
```

## genie/libs/sdk/triggers/unconfigconfig/vlan/nxos/unconfigconfig.py

```diff
@@ -1,14 +1,13 @@
 '''Implementation for vlan unconfigconfig triggers'''
 
 # Genie Libs
 from genie.libs.sdk.libs.utils.mapping import Mapping
 from genie.libs.sdk.triggers.unconfigconfig.unconfigconfig import TriggerUnconfigConfig
 from ats.utils.objects import NotExists
-from ats import aetest
 
 # Which key to exclude for Vlan Ops comparison
 vlan_exclude = ['maker']
 
 class TriggerUnconfigConfigVlan(TriggerUnconfigConfig):
     """Unconfigure and reapply the whole configurations of dynamically learned vlan(s)."""
     
@@ -37,40 +36,48 @@
                 Buffer recovery timeout when the previous timeout has been exhausted,
                 to make sure the devices are recovered before ending the trigger
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                vlan: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                     OR
+                     interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Vlan Ops object and store the "unshut" vlan(s) if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the learned vlan with Vlan Conf object
         4. Verify the vlan(s) from step 3 are no longer existed
         5. Recover the device configurations to the one in step 2
         6. Learn Vlan Ops again and verify it is the same as the Ops in step 1
 
     """
 
     mapping = Mapping(requirements={'ops.vlan.vlan.Vlan':{
-                                        'requirements':[['info','vlans','(?P<vlanid>^([2-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1][0][0][0-1]))$'\
-                                                            ,'vlan_id','(?P<vlanid>^([2-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1][0][0][0-1]))$'],
-                                                        ['info','vlans','(?P<vlanid>.*)','shutdown',False]],
+                                        'requirements':[['info','vlans','(?P<vlan>^([2-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1][0][0][0-1]))$'\
+                                                            ,'vlan_id','(?P<vlan>^([2-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1][0][0][0-1]))$'],
+                                                        ['info','vlans','(?P<vlan>.*)','shutdown',False]],
                                         'kwargs': {'attributes': ['info']},
                                         'exclude': vlan_exclude}},
                       config_info={'conf.vlan.Vlan':{
-                                     'requirements':[['device_attr', '{uut}', 'vlan_attr', '(?P<vlanid>.*)']],
+                                     'requirements':[['device_attr', '{uut}', 'vlan_attr', '(?P<vlan>.*)']],
                                      'verify_conf':False,
-                                     'kwargs':{'mandatory':{'vlanid': '(?P<vlanid>.*)'}}}},
+                                     'kwargs':{'mandatory':{'vlanid': '(?P<vlan>.*)'}}}},
                       verify_ops={'ops.vlan.vlan.Vlan':{
-                                    'requirements': [['info','vlans','(?P<vlanid>.*)','vlan_id' ,'(?P<vlanid>.*)']],
+                                    'requirements': [['info','vlans','(?P<vlan>.*)','vlan_id', NotExists('(?P<vlan>.*)')]],
                                     'kwargs':{'attributes':['info']},
                                     'exclude': vlan_exclude}},
-                      num_values={'vlanid':1})
+                      num_values={'vlan':1})
 
 
 
 class TriggerUnconfigConfigVlanVnsegment(TriggerUnconfigConfig):
     """Unconfigure and reapply the whole configurations of dynamically learned vlan(s)."""
 
     __description__ = """Unconfigure and reapply the whole configurations of dynamically learned vlan(s).
@@ -98,35 +105,43 @@
                     Buffer recovery timeout when the previous timeout has been exhausted,
                     to make sure the devices are recovered before ending the trigger
 
                     max_time (`int`): Maximum wait time for the last step of the trigger,
                                     in second. Default: 180
                     interval (`int`): Wait time between iteration when looping is needed,
                                     in second. Default: 15
-
+                static:
+                    The keys below are dynamically learnt by default.
+                    However, they can also be set to a custom value when provided in the trigger datafile.
+
+                    vlan: `str`
+                    vn_segment_id: `int`
+                    (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                         OR
+                         interface: 'Ethernet1/1/1' (Specific value)
         steps:
             1. Learn Vlan Ops object and store the "unshut" vlan(s) if has any, otherwise, SKIP the trigger
             2. Save the current device configurations through "method" which user uses
             3. Unconfigure the learned vn_segment_id with Vlan Conf object
             4. Verify the vlan(s) from step 3 are no longer existed
             5. Recover the device configurations to the one in step 2
             6. Learn Vlan Ops again and verify it is the same as the Ops in step 1
 
         """
 
     # Mapping of Information between Ops and Conf
     # Also permit to dictates which key to verify
     mapping = Mapping(requirements={'ops.vlan.vlan.Vlan':{
-                                          'requirements':[['info','vlans','(?P<vlan>.*)','vn_segment_id','(?P<vn_segment>.*)']],
+                                          'requirements':[['info','vlans','(?P<vlan>.*)','vn_segment_id','(?P<vn_segment_id>.*)']],
                                           'kwargs':{'attributes':['info[vlans][(.*)][vn_segment_id]']},
                                           'all_keys':True,
                                           'exclude': vlan_exclude}},
                       config_info={'conf.vlan.Vlan':{
                                      'requirements':[['device_attr','{uut}','vlan_attr','(?P<vlan>.*)',
-                                                      'vn_segment_id','(?P<vn_segment>.*)']],
+                                                      'vn_segment_id','(?P<vn_segment_id>.*)']],
                                      'verify_conf':False,
                                      'kwargs':{}}},
                       verify_ops={'ops.vlan.vlan.Vlan':{
                                     'requirements':[['info','vlans',NotExists('(?P<vlan>.*)')]],
                                     'kwargs':{'attributes':['info[vlans][(.*)][vn_segment_id]']},
                                     'exclude': vlan_exclude}},
                       num_values={'vlan':1})
```

## genie/libs/sdk/triggers/unconfigconfig/vxlan/nxos/unconfigconfig.py

```diff
@@ -11,15 +11,15 @@
 
 # Which key to exclude for Vxlan Ops comparison
 vxlan_base_exclude = ['maker','up_time']
 evpn_exclude =['bytesrecvd','bytesent','elapsedtime','keepalive','tableversion',
                'keepaliverecvd','keepalivesent','lastread','totalnetworks',
                'lastwrite','msgrecvd','msgsent','updatesrecvd','rtrefreshsent',
                'totalpaths','numberattrs','updatesent','neighbortableversion',
-               'memoryused','byteattrs','bytessent','updatessent']
+               'memoryused','byteattrs','bytessent','updatessent', 'openssent']
 
 interface_exclude = ['maker', 'last_change','in_rate','in_rate_pkts',
                      'out_rate', 'out_rate_pkts', 'in_octets',
                      'in_pkts', 'in_unicast_pkts', 'out_octets',
                      'out_pkts', 'out_unicast_pkts', 'out_multicast_pkts',
                      'in_multicast_pkts', 'last_clear', 'in_broadcast_pkts',
                      'out_broadcast_pkts']
@@ -28,14 +28,16 @@
                      'keepaliverecvd','keepalivesent','lastread','lastwrite',
                      'msgrecvd','msgsent','neighbortableversion',
                      'tableversion','rtrefreshsent','updatesrecvd','updatessent',
                      'bytessent','bytesrecvd','localport','connsdropped',
                      'connsestablished','opensrecvd','openssent','prefixversion']
 
 l2vpn_exclude = ['bytesattrs','memoryused','numberattrs','bestpathnr','totalnetworks','totalpaths','total_memory','prefixreceived']
+
+
 class TriggerUnconfigConfigEvpn(TriggerUnconfigConfig):
     """Unconfigure evpn and reapply the whole configurations of dynamically learned Vxlan(s)."""
     
     __description__ = """Unconfigure evpn and reapply the whole configurations of dynamically learned Vxlan(s).
 
     trigger_datafile:
         Mandatory:
@@ -60,42 +62,55 @@
                 Buffer recovery timeout when the previous timeout has been exhausted,
                 to make sure the devices are recovered before ending the trigger
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+           static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                instance: `str`
+                vrf: `str`
+                address_family: `str`
+                rd: `str`
+                rd_vniid: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                     OR
+                     interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Vxlan Ops object and store the vni id under bgp_l2vpn_evpn
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the Evpn with Vxlan Conf object
         4. Verify the evpn from step 3 are no longer existed
         5. Recover the device configurations to the one in step 2
         6. Learn Vxlan Ops again and verify it is the same as the Ops in step 1
 
     """
 
     mapping = Mapping(requirements={'ops.vxlan.vxlan.Vxlan':{
                                         'requirements': [['bgp_l2vpn_evpn', 'instance', '(?P<instance>.*)','vrf',
-                                                      '(?P<vrf>.*)', 'address_family', '(?P<af>.*)','rd','(?P<rd>.*)',
+                                                      '(?P<vrf>.*)', 'address_family', '(?P<address_family>.*)','rd','(?P<rd>.*)',
                                                       'rd_vniid','(?P<rd_vniid>.*)']],
                                         'kwargs': {'attributes': ['bgp_l2vpn_evpn']},
                                         'all_keys': True,
-                                        'exclude': vxlan_base_exclude + evpn_exclude + ['prefixversion','pathnr','bestpathnr','advertisedto'] }},
+                                        'exclude': vxlan_base_exclude + evpn_exclude + ['prefixversion','pathnr','bestpathnr',
+                                                                                        'advertisedto','prefix'] }},
                       config_info={'conf.vxlan.Vxlan':{
                                         'requirements':[['device_attr', '{uut}', 'evpn_attr','(.*)']],
                                         'verify_conf':False,
                                         'kwargs':{}}},
                       verify_ops={'ops.vxlan.vxlan.Vxlan':{
-                                        'requirements': [['bgp_l2vpn_evpn', NotExists('instance')]],
+                                        'requirements': [['bgp_l2vpn_evpn', 'instance', '(.*)']],
                                         'kwargs': {'attributes': ['bgp_l2vpn_evpn']},
                                         'exclude': vxlan_base_exclude + evpn_exclude }},
-                      num_values={'instance':1 , 'vrf':1 , 'af':1 , 'rd':1})
+                      num_values={'instance':1 , 'vrf':1 , 'address_family':1 , 'rd':1})
 
 
 class TriggerUnconfigConfigEvpnVni(TriggerUnconfigConfig):
     """Unconfigure evpn vni and reapply the whole configurations of dynamically learned Vxlan(s)."""
 
     __description__ = """Unconfigure evpn and reapply the whole configurations of dynamically learned Vxlan(s).
 
@@ -122,15 +137,24 @@
                     Buffer recovery timeout when the previous timeout has been exhausted,
                     to make sure the devices are recovered before ending the trigger
 
                     max_time (`int`): Maximum wait time for the last step of the trigger,
                                     in second. Default: 180
                     interval (`int`): Wait time between iteration when looping is needed,
                                     in second. Default: 15
-
+               static:
+                    The keys below are dynamically learnt by default.
+                    However, they can also be set to a custom value when provided in the trigger datafile.
+
+                    nve_name: `str`
+                    nve_vni: `str`
+
+                    (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                         OR
+                         interface: 'Ethernet1/1/1' (Specific value)
         steps:
             1. Learn Vxlan Ops object and store the vni state under nve
                if has any, otherwise, SKIP the trigger
             2. Save the current device configurations through "method" which user uses
             3. Unconfigure the Evpn with Vxlan Conf object
             4. Verify the evpn from step 3 are no longer existed
             5. Recover the device configurations to the one in step 2
@@ -184,43 +208,52 @@
                 Buffer recovery timeout when the previous timeout has been exhausted,
                 to make sure the devices are recovered before ending the trigger
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                nve_name: `str`
+                evpn_multisite_border_gateway: `int`
+                delay_restore_time: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                     OR
+                     interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Vxlan Ops object and store the evpn msite bgw delay restore time under nve
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the evpn msite bgw delay restore time with Vxlan Conf object
         4. Verify the evpn msite bgw delay restore time from step 3 are no longer existed
         5. Recover the device configurations to the one in step 2
         6. Learn Vxlan Ops again and verify it is the same as the Ops in step 1
 
     """
 
     mapping = Mapping(requirements={'ops.vxlan.vxlan.Vxlan': {
-                                                'requirements': [[['nve', 'evpn_multisite_border_gateway', '(?P<border_gateway>.*)']],
+                                                'requirements': [[['nve', 'evpn_multisite_border_gateway', '(?P<evpn_multisite_border_gateway>.*)']],
                                                                  [['nve', '(?P<nve_name>.*)','multisite_convergence_time',
                                                                   '(?P<delay_restore_time>.*)']]],
                                                 'kwargs': {'attributes': ['nve']},
                                                 'exclude': vxlan_base_exclude + ['uptime','prefixversion','pathnr','bestpathnr']}},
                       config_info={'conf.vxlan.Vxlan': {
-                                                'requirements': [['device_attr','{uut}', 'evpn_msite_attr', '(?P<border_gateway>.*)',\
+                                                'requirements': [['device_attr','{uut}', 'evpn_msite_attr', '(?P<evpn_multisite_border_gateway>.*)',\
                                                                   'evpn_msite_bgw_delay_restore_time', '(?P<delay_restore_time>.*)']],
                                                 'verify_conf': False,
                                                 'kwargs': {}}},
                       verify_ops={'ops.vxlan.vxlan.Vxlan': {
                                                 'requirements': [['nve', '(?P<nve_name>.*)', 'multisite_convergence_time', 180]],
                                                 'kwargs': {'attributes': ['nve']},
-                                                'missing': False,
                                                 'exclude': vxlan_base_exclude + ['uptime']}},
-                      num_values={'nve_name': 1,'border_gateway': 1})
+                      num_values={'nve_name': 1,'evpn_multisite_border_gateway': 1})
 
 
 class TriggerUnconfigConfigEvpnMsiteDciTracking(TriggerUnconfigConfig):
     """Unconfigure evpn msite dci tracking and reapply
             the whole configurations of dynamically learned Vxlan(s)."""
 
     __description__ = """Unconfigure evpn msite dci tracking and reapply
@@ -249,45 +282,54 @@
                     Buffer recovery timeout when the previous timeout has been exhausted,
                     to make sure the devices are recovered before ending the trigger
 
                     max_time (`int`): Maximum wait time for the last step of the trigger,
                                     in second. Default: 180
                     interval (`int`): Wait time between iteration when looping is needed,
                                     in second. Default: 15
-
+                static:
+                    The keys below are dynamically learnt by default.
+                    However, they can also be set to a custom value when provided in the trigger datafile.
+
+                    nve_name: `str`
+                    dci_link: `str`
+
+                    (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                         OR
+                         interface: 'Ethernet1/1/1' (Specific value)
         steps:
             1. Learn Vxlan Ops object and store the evpn msite dci tracking under nve
                if has any, otherwise, SKIP the trigger
             2. Save the current device configurations through "method" which user uses
             3. Unconfigure the evpn msite dci tracking with Interface Conf object
             4. Verify the evpn msite dci tracking from step 3 are no longer existed
             5. Recover the device configurations to the one in step 2
             6. Learn Vxlan Ops again and verify it is the same as the Ops in step 1
         """
 
     mapping = Mapping(requirements={'ops.vxlan.vxlan.Vxlan': {
-                                                'requirements': [[['nve', 'multisite', 'dci_links', '(?P<if_name>.*)', 'if_state', 'up']],
+                                                'requirements': [[['nve', 'multisite', 'dci_links', '(?P<dci_link>.*)', 'if_state', 'up']],
                                                                  [['nve', '(?P<nve_name>.*)',\
                                                                   'multisite_bgw_if_oper_state', 'up']]],
                                                 'kwargs': {'attributes': ['nve[(.*)][vni][(.*)][vni]',
                                                                           'nve[(.*)][multisite_bgw_if_oper_state]',
                                                                           'nve[multisite]']},
                                                 'exclude': vxlan_base_exclude}},
                       config_info={'conf.interface.Interface': {
                                                 'requirements': [['evpn_multisite_dci_tracking',True]],
                                                 'verify_conf': False,
-                                                'kwargs': {'mandatory': {'name': '(?P<if_name>.*)', 'attach': False}}}},
+                                                'kwargs': {'mandatory': {'name': '(?P<dci_link>.*)', 'attach': False}}}},
                       verify_ops={'ops.vxlan.vxlan.Vxlan': {
-                                                'requirements': [['nve','multisite',NotExists('dci_links')],
-                                                                 ['nve', '(?P<nve_name>.*)', 'multisite_bgw_if_oper_state', 'up']],
+                                                'requirements': [['nve','multisite', NotExists('dci_links')],
+                                                                 ['nve', '(?P<nve_name>.*)', 'multisite_bgw_if_oper_state', 'down']],
                                                 'kwargs': {'attributes': ['nve[(.*)][vni][(.*)][vni]',
                                                                           'nve[(.*)][multisite_bgw_if_oper_state]',
                                                                           'nve[multisite]']},
                                                 'exclude': vxlan_base_exclude}},
-                      num_values={'if_name': 'all','nve_name': 1 })
+                      num_values={'dci_link': 'all','nve_name': 1 })
 
 class TriggerUnconfigConfigEvpnMsiteFabricTracking(TriggerUnconfigConfig):
     """Unconfigure evpn msite fabric tracking and reapply
                 the whole configurations of dynamically learned Vxlan(s)."""
 
     __description__ = """Unconfigure evpn msite Fabric tracking and reapply
                                 the whole configurations of dynamically learned Vxlan(s).
@@ -315,48 +357,57 @@
                 Buffer recovery timeout when the previous timeout has been exhausted,
                 to make sure the devices are recovered before ending the trigger
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                nve_name: `str`
+                fabric_link: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                     OR
+                     interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Vxlan Ops object and store the evpn msite fabric tracking under nve
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the evpn msite fabric tracking with Interface Conf object
         4. Verify the evpn msite fabric tracking from step 3 are no longer existed
         5. Recover the device configurations to the one in step 2
         6. Learn Vxlan Ops again and verify it is the same as the Ops in step 1
     """
 
     mapping = Mapping(requirements={'ops.vxlan.vxlan.Vxlan': {
-                                                'requirements': [[['nve', 'multisite', 'fabric_links', '(?P<if_name>.*)', 'if_state', 'up']],
+                                                'requirements': [[['nve', 'multisite', 'fabric_links', '(?P<fabric_link>.*)', 'if_state', 'up']],
                                                                  [['nve', '(?P<nve_name>.*)', \
                                                                    'multisite_bgw_if_oper_state', 'up']]],
                                                 'kwargs': {'attributes': ['nve[(.*)][vni][(.*)][vni]',
                                                                           'nve[(.*)][multisite_bgw_if_oper_state]',
                                                                           'nve[multisite]',
                                                                           'bgp_l2vpn_evpn']},
                                                 'exclude': vxlan_base_exclude + multisite_exclude +['fd','resetreason','resettime','prefixreceived',
                                                                                                     'bestpathnr','pathnr','advertisedto']}},
                       config_info={'conf.interface.Interface': {
                                                 'requirements': [['evpn_multisite_fabric_tracking',True]],
                                                 'verify_conf': False,
-                                                'kwargs': {'mandatory': {'name': '(?P<if_name>.*)', 'attach': False}}}},
+                                                'kwargs': {'mandatory': {'name': '(?P<fabric_link>.*)', 'attach': False}}}},
                       verify_ops={'ops.vxlan.vxlan.Vxlan': {
                                                 'requirements': [['nve','multisite',NotExists('fabric_links')],
-                                                                ['nve', '(?P<nve_name>.*)', 'multisite_bgw_if_oper_state', 'up']],
+                                                                ['nve', '(?P<nve_name>.*)', 'multisite_bgw_if_oper_state', 'down']],
                                                 'kwargs': {'attributes': ['nve[(.*)][vni][(.*)][vni]',
                                                                           'nve[(.*)][multisite_bgw_if_oper_state]',
                                                                           'nve[multisite]',
                                                                           'bgp_l2vpn_evpn']},
                                                 'exclude': vxlan_base_exclude +['bgp_l2vpn_evpn']}},
-                      num_values={'if_name': 'all', 'nve_name': 1})
+                      num_values={'fabric_link': 'all', 'nve_name': 1})
 
 class TriggerUnconfigConfigNveAdvertiseVirtualRmac(TriggerUnconfigConfig):
     """Unconfigure virtual rmac advertised and reapply
        the whole configurations of dynamically learned Vxlan(s)."""
 
     __description__ = """Unconfigure virtual rmac advertised and reapply
                           the whole configurations of dynamically learned Vxlan(s).
@@ -384,15 +435,23 @@
                 Buffer recovery timeout when the previous timeout has been exhausted,
                 to make sure the devices are recovered before ending the trigger
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                nve_name: `str`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                     OR
+                     interface: 'Ethernet1/1/1' (Specific value)
     steps:
         1. Learn Vxlan Ops object and store the virtual rmac advertised under nve
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the virtual rmac advertised with Interface Conf object
         4. Verify the virtual rmac advertised from step 3 are no longer existed
         5. Recover the device configurations to the one in step 2
@@ -414,15 +473,14 @@
                                                 'kwargs': {'mandatory': {'name': '(?P<nve_name>.*)', 'attach': False}}}},
                       verify_ops={'ops.vxlan.vxlan.Vxlan': {
                                                 'requirements': [['nve', '(?P<nve_name>.*)','if_state','up'],
                                                                  ['nve','(?P<nve_name>.*)','adv_vmac',False]],
                                                 'kwargs': {'attributes': ['nve[(.*)][adv_vmac]',
                                                                           'nve[(.*)][if_state]',
                                                                           'nve[(.*)][vni]','l2route','bgp_l2vpn_evpn']},
-                                                'missing': False,
                                                 'exclude': vxlan_base_exclude + ['l2route','bgp_l2vpn_evpn']}},
                       num_values={'nve_name': 1})
 
 class TriggerUnconfigConfigNveVniAssociateVrf(TriggerUnconfigConfig):
     """Unconfigure nvi associated vrf and reapply
          the whole configurations of dynamically learned Vxlan(s)."""
 
@@ -452,15 +510,24 @@
               Buffer recovery timeout when the previous timeout has been exhausted,
               to make sure the devices are recovered before ending the trigger
 
               max_time (`int`): Maximum wait time for the last step of the trigger,
                               in second. Default: 180
               interval (`int`): Wait time between iteration when looping is needed,
                               in second. Default: 15
-
+          static:
+              The keys below are dynamically learnt by default.
+              However, they can also be set to a custom value when provided in the trigger datafile.
+
+              nve_name: `str`
+              nve_vni: `str`
+
+              (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                    OR
+                    interface: 'Ethernet1/1/1' (Specific value)
     steps:
       1. Learn Vxlan Ops object and store the nvi associated vrf under nve
          if has any, otherwise, SKIP the trigger
       2. Save the current device configurations through "method" which user uses
       3. Unconfigure the nvi associated vrf with Interface Conf object
       4. Verify the nvi associated vrf from step 3 are no longer existed
       5. Recover the device configurations to the one in step 2
@@ -475,15 +542,15 @@
                                                 'all_keys':True,
                                                 'exclude': vxlan_base_exclude }},
                       config_info={'conf.interface.Interface': {
                                                 'requirements': [['nve_vni','(?P<nve_vni>.*)']],
                                                 'verify_conf': False,
                                                 'kwargs': {'mandatory': {'name': '(?P<nve_name>.*)', 'attach': False}}}},
                       verify_ops={'ops.vxlan.vxlan.Vxlan': {
-                                                'requirements': [['nve', '(?P<nve_name>.*)','vni',NotExists('(?P<nve_vni>.*)')]],
+                                                'requirements': [['nve', '(?P<nve_name>.*)','vni', NotExists('(?P<nve_vni>.*)')]],
                                                 'kwargs': {'attributes': ['nve[(.*)][vni][(.*)]']},
                                                 'exclude': vxlan_base_exclude}},
                       num_values={'nve_name': 1, 'nve_vni':1})
 
 class TriggerUnconfigConfigNveSourceInterfaceLoopback(TriggerUnconfigConfig):
     """Unconfigure nve source interface and reapply the whole configurations of dynamically learned Vxlan(s)."""
 
@@ -512,15 +579,24 @@
                  Buffer recovery timeout when the previous timeout has been exhausted,
                  to make sure the devices are recovered before ending the trigger
 
                  max_time (`int`): Maximum wait time for the last step of the trigger,
                                  in second. Default: 180
                  interval (`int`): Wait time between iteration when looping is needed,
                                  in second. Default: 15
-
+             static:
+                 The keys below are dynamically learnt by default.
+                 However, they can also be set to a custom value when provided in the trigger datafile.
+
+                  nve_name: `str`
+                  source_if: `str`
+
+                  (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                        OR
+                        interface: 'Ethernet1/1/1' (Specific value)
        steps:
          1. Learn Vxlan Ops object and store the nve source interface under nve
             if has any, otherwise, SKIP the trigger
          2. Save the current device configurations through "method" which user uses
          3. Unconfigure the nve source interface with Interface Conf object
          4. Verify the nve source interface from step 3 are no longer existed
          5. Recover the device configurations to the one in step 2
@@ -594,28 +670,40 @@
             Buffer recovery timeout when the previous timeout has been exhausted,
             to make sure the devices are recovered before ending the trigger
 
             max_time (`int`): Maximum wait time for the last step of the trigger,
                             in second. Default: 180
             interval (`int`): Wait time between iteration when looping is needed,
                             in second. Default: 15
-
+        static:
+            The keys below are dynamically learnt by default.
+            However, they can also be set to a custom value when provided in the trigger datafile.
+
+            instance: `str`
+            vrf: `str`
+            address_family: `str`
+            rd: `str`
+            rd_vniid: `str`
+
+            (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                  OR
+                  interface: 'Ethernet1/1/1' (Specific value)
     steps:
     1. Learn Vxlan Ops object and store the vni id under bgp_l2vpn_evpn
        if has any, otherwise, SKIP the trigger
     2. Save the current device configurations through "method" which user uses
     3. Unconfigure the nv overlay evpn interface with Vxlan Conf object
     4. Verify the nv overlay evpn from step 3 are no longer existed
     5. Recover the device configurations to the one in step 2
     6. Learn Vxlan Ops again and verify it is the same as the Ops in step 1
     """
 
     mapping = Mapping(requirements={'ops.vxlan.vxlan.Vxlan': {
                                             'requirements': [['bgp_l2vpn_evpn', 'instance', '(?P<instance>.*)', 'vrf',
-                                                          '(?P<vrf>.*)', 'address_family', '(?P<af>.*)', 'rd', '(?P<rd>.*)',
+                                                          '(?P<vrf>.*)', 'address_family', '(?P<address_family>.*)', 'rd', '(?P<rd>.*)',
                                                           'rd_vniid', '(?P<rd_vniid>.*)']],
                                             'kwargs': {'attributes': ['bgp_l2vpn_evpn[instance][(.*)][vrf][(.*)]'
                                                                       '[address_family][(.*)][rd]','l2route']},
                                             'all_keys': True,
                                             'exclude': vxlan_base_exclude + ['sent_to','prefixversion','pathnr',
                                                                              'bestpathnr','advertisedto','client_nfn',
                                                                              'prefix','memory','objects','total_mem',
@@ -624,15 +712,15 @@
                                             'requirements': [['device_attr', '{uut}', 'enabled_nv_overlay_evpn', True]],
                                             'verify_conf': False,
                                             'kwargs': {}}},
                         verify_ops={'ops.vxlan.vxlan.Vxlan': {
                                             'requirements': [[NotExists('bgp_l2vpn_evpn'), '']],
                                             'kwargs': {'attributes': ['bgp_l2vpn_evpn[instance][(.*)][vrf][(.*)][address_family][(.*)][rd]','l2route']},
                                             'exclude': vxlan_base_exclude +['bgp_l2vpn_evpn','l2route']}},
-                        num_values={'instance': 1, 'vrf': 1, 'af': 1, 'rd': 'all','rd_vniid': 'all'})
+                        num_values={'instance': 1, 'vrf': 1, 'address_family': 1, 'rd': 'all','rd_vniid': 'all'})
 
 class TriggerUnconfigConfigNveVniMcastGroup(TriggerUnconfigConfig):
     """Unconfigure mcast group and reapply the whole configurations of dynamically learned Vxlan(s)."""
 
     __description__ = """Unconfigure mcast group and reapply the whole configurations of dynamically learned Vxlan(s).
 
     trigger_datafile:
@@ -658,47 +746,34 @@
             Buffer recovery timeout when the previous timeout has been exhausted,
             to make sure the devices are recovered before ending the trigger
 
             max_time (`int`): Maximum wait time for the last step of the trigger,
                             in second. Default: 180
             interval (`int`): Wait time between iteration when looping is needed,
                             in second. Default: 15
-
+        static:
+            The keys below are dynamically learnt by default.
+            However, they can also be set to a custom value when provided in the trigger datafile.
+
+            nve_name: `str`
+            nve_vni: `str`
+            mcast: `str`
+
+            (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                  OR
+                  interface: 'Ethernet1/1/1' (Specific value)
     steps:
     1. Learn Vxlan Ops object and store the mcast group under nve
        if has any, otherwise, SKIP the trigger
     2. Save the current device configurations through "method" which user uses
     3. Unconfigure the mcast group with Interface Conf object
     4. Verify the mcast from step 3 are no longer existed
     5. Recover the device configurations to the one in step 2
     6. Learn Vxlan Ops again and verify it is the same as the Ops in step 1
     """
-    @aetest.test
-    def verify_unconfigure(self, uut, abstract, steps):
-        '''Verify that the unconfiguration was done correctly and Ops state is
-           as expected.
-
-           Args:
-               uut (`obj`): Device object.
-               abstract (`obj`): Abstract object.
-               steps (`step obj`): aetest step object
-
-           Returns:
-               None
-
-           Raises:
-               pyATS Results
-        '''
-
-        try:
-            self.mapping.verify_ops(device=uut, abstract=abstract,
-                                    steps=steps)
-        except Exception as e:
-            self.failed('Failed to verify the '
-                        'unconfigure feature', from_exception=e)
 
     mapping = Mapping(requirements={'ops.vxlan.vxlan.Vxlan':{
                                          'requirements':[['nve', '(?P<nve_name>.*)', 'vni', '(?P<nve_vni>.*)', 'mcast', '(?P<mcast>.*)'],
                                                          ['nve', '(?P<nve_name>.*)', 'vni', '(?P<nve_vni>.*)', 'vni_state', 'up'],
                                                          ['nve', '(?P<nve_name>.*)', 'vni', '(?P<nve_vni>.*)', 'type', '(?P<type>L2.*)']],
                                          'kwargs':{'attributes':['nve[(.*)][vni]']},
                                          'all_keys': True,
@@ -707,16 +782,16 @@
                                         'requirements': [['nve_vni','(?P<nve_vni>.*)'],
                                                          ['nve_vni_mcast_group','(?P<mcast>.*)'],
                                                          ['nve_vni_associate_vrf',False]],
                                         'verify_conf': False,
                                         'kwargs': {'mandatory': {'name': '(?P<nve_name>.*)', 'attach': False}}}},
                       verify_ops={'ops.vxlan.vxlan.Vxlan':{
                                          'requirements':[['nve', '(?P<nve_name>.*)', 'vni', '(?P<nve_vni>.*)', 'mcast', 'unconfigured'],
-                                                         ['nve', '(?P<nve_name>.*)', 'vni', '(?P<nve_vni>.*)', 'vni_state',
-                                                         'down']],
+                                                         ['nve', '(?P<nve_name>.*)', 'vni', '(?P<nve_vni>.*)', 'vni_state', 'down'],
+                                                         ['nve', '(?P<nve_name>.*)', 'vni', '(?P<nve_vni>.*)', NotExists('repl_ip')]],
                                          'kwargs':{'attributes':['nve[(.*)][vni]']},
                                          'all_keys': True,
                                          'exclude': vxlan_base_exclude}},
                       num_values={'nve_name':1 , 'nve_vni':1 , 'mcast':1})
 
 class TriggerUnconfigConfigNveVniMultisiteIngressReplication(TriggerUnconfigConfig):
     """Unconfig multisite ingress replication under vxlan and then restore the
@@ -749,15 +824,24 @@
                        Buffer recovery timeout make sure devices are recovered at the
                        end of the trigger execution. Used when previous timeouts have
                        been exhausted.
                        max_time (`int`): Maximum wait time for the last step of the
                                          trigger in seconds. Default: 180
                        interval (`int`): Wait time between iteration when looping is
                                          needed in seconds. Default: 15
-
+                   static:
+                        The keys below are dynamically learnt by default.
+                        However, they can also be set to a custom value when provided in the trigger datafile.
+
+                        nve_name: `str`
+                        nve_vni: `str`
+
+                        (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                              OR
+                              interface: 'Ethernet1/1/1' (Specific value)
            Steps:
                1. Learn Vxlan Ops configured on device. SKIP the trigger if there
                   is no vxlan configured on the device.
                2. Save the current device configurations using "method" specified.
                3. Add multisite ingress replication that using Genie Vxlan Conf.
                4. Verify the newly multisite ingress replication under Vxlan is reflected in
                   device configuration.
@@ -815,38 +899,46 @@
                 Buffer recovery timeout when the previous timeout has been exhausted,
                 to make sure the devices are recovered before ending the trigger
 
                 max_time (`int`): Maximum wait time for the last step of the trigger,
                                 in second. Default: 180
                 interval (`int`): Wait time between iteration when looping is needed,
                                 in second. Default: 15
-
+            static:
+                The keys below are dynamically learnt by default.
+                However, they can also be set to a custom value when provided in the trigger datafile.
+
+                evpn_multisite_border_gateway: `int`
+
+                (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                      OR
+                      interface: 'Ethernet1/1/1' (Specific value)
       steps:
         1. Learn Vxlan Ops object and store the evpn msite bgw under nve
            if has any, otherwise, SKIP the trigger
         2. Save the current device configurations through "method" which user uses
         3. Unconfigure the evpn msite bgw with Vxlan Conf object
         4. Verify the evpn msite bgw from step 3 are no longer existed
         5. Recover the device configurations to the one in step 2
         6. Learn Vxlan Ops again and verify it is the same as the Ops in step 1
       """
     mapping = Mapping(requirements={'ops.vxlan.vxlan.Vxlan': {
-                                        'requirements': [['nve', 'evpn_multisite_border_gateway', '(?P<border_gateway>.*)']],
+                                        'requirements': [['nve', 'evpn_multisite_border_gateway', '(?P<evpn_multisite_border_gateway>.*)']],
                                         'kwargs': {'attributes': ['nve','l2route']},
                                         'all_keys': True,
                                         'exclude': vxlan_base_exclude + ['uptime','peer_id','tx_id','flags']}},
                         config_info={'conf.vxlan.Vxlan': {
-                                        'requirements': [['device_attr', '{uut}', 'evpn_msite_attr', '(?P<border_gateway>.*)']],
+                                        'requirements': [['device_attr', '{uut}', 'evpn_msite_attr', '(?P<evpn_multisite_border_gateway>.*)']],
                                         'verify_conf': False,
                                         'kwargs': {}}},
                         verify_ops={'ops.vxlan.vxlan.Vxlan': {
                                         'requirements': [['nve', NotExists('evpn_multisite_border_gateway')]],
                                         'kwargs': {'attributes': ['nve','l2route']},
                                         'exclude': vxlan_base_exclude + ['l2route','uptime']}},
-                        num_values={'border_gateway': 1 })
+                        num_values={'evpn_multisite_border_gateway': 1 })
 
 
 class TriggerUnconfigConfigNveMultisiteBgwInterface(TriggerUnconfigConfig):
     """Unconfigure multisite bgw interface and reapply the whole
             configurations of dynamically learned Vxlan(s)."""
 
     __description__ = """Unconfigure multisite bgw interface and reapply the whole configurations of
@@ -875,15 +967,24 @@
                     Buffer recovery timeout when the previous timeout has been exhausted,
                     to make sure the devices are recovered before ending the trigger
 
                     max_time (`int`): Maximum wait time for the last step of the trigger,
                                     in second. Default: 180
                     interval (`int`): Wait time between iteration when looping is needed,
                                     in second. Default: 15
-
+                static:
+                    The keys below are dynamically learnt by default.
+                    However, they can also be set to a custom value when provided in the trigger datafile.
+
+                    nve_name: `str`
+                    multisite_bgw_if: `str`
+
+                    (e.g) interface: '(?P<interface>Ethernet1*)' (Regex supported)
+                          OR
+                          interface: 'Ethernet1/1/1' (Specific value)
           steps:
             1. Learn Vxlan Ops object and store the multisite bgw interface under nve.
                if has any, otherwise, SKIP the trigger
             2. Save the current device configurations through "method" which user uses
             3. Unconfigure the multisite bgw interface with Vxlan Conf object
             4. Verify the multisite bgw interface from step 3 are no longer existed
             5. Recover the device configurations to the one in step 2
```

## Comparing `genie.libs.sdk-3.1.8-py3.5-nspkg.pth` & `genie.libs.sdk-3.1.9-py3.4-nspkg.pth`

 * *Files identical despite different names*

## Comparing `genie.libs.sdk-3.1.8.data/data/genie_yamls/__init__.py` & `genie.libs.sdk-3.1.9.data/data/genie_yamls/__init__.py`

 * *Files identical despite different names*

## Comparing `genie.libs.sdk-3.1.8.data/data/genie_yamls/pts_datafile.yaml` & `genie.libs.sdk-3.1.9.data/data/genie_yamls/pts_datafile.yaml`

 * *Files 0% similar despite different names*

```diff
@@ -205,15 +205,15 @@
         pkg: genie.libs.ops
         class: stp.stp.Stp
     devices: ['uut']
 
 static_routing:
     source:
         pkg: genie.libs.ops
-        class: static_routing.static_routing.StaticRoute
+        class: static_routing.static_routing.StaticRouting
     devices: ['uut']
 
 routing:
     source:
         pkg: genie.libs.ops
         class: routing.routing.Routing
     devices: ['uut']
```

## Comparing `genie.libs.sdk-3.1.8.data/data/genie_yamls/subsection_datafile.yaml` & `genie.libs.sdk-3.1.9.data/data/genie_yamls/subsection_datafile.yaml`

 * *Files identical despite different names*

## Comparing `genie.libs.sdk-3.1.8.data/data/genie_yamls/trigger_datafile.yaml` & `genie.libs.sdk-3.1.9.data/data/genie_yamls/trigger_datafile.yaml`

 * *Files identical despite different names*

## Comparing `genie.libs.sdk-3.1.8.data/data/genie_yamls/verification_datafile.yaml` & `genie.libs.sdk-3.1.9.data/data/genie_yamls/verification_datafile.yaml`

 * *Files identical despite different names*

## Comparing `genie.libs.sdk-3.1.8.data/data/genie_yamls/ios/trigger_datafile_ios.yaml` & `genie.libs.sdk-3.1.9.data/data/genie_yamls/ios/trigger_datafile_ios.yaml`

 * *Files identical despite different names*

## Comparing `genie.libs.sdk-3.1.8.data/data/genie_yamls/ios/verification_datafile_ios.yaml` & `genie.libs.sdk-3.1.9.data/data/genie_yamls/ios/verification_datafile_ios.yaml`

 * *Files identical despite different names*

## Comparing `genie.libs.sdk-3.1.8.data/data/genie_yamls/iosxe/trigger_datafile_iosxe.yaml` & `genie.libs.sdk-3.1.9.data/data/genie_yamls/iosxe/trigger_datafile_iosxe.yaml`

 * *Files identical despite different names*

## Comparing `genie.libs.sdk-3.1.8.data/data/genie_yamls/iosxe/verification_datafile_iosxe.yaml` & `genie.libs.sdk-3.1.9.data/data/genie_yamls/iosxe/verification_datafile_iosxe.yaml`

 * *Files identical despite different names*

## Comparing `genie.libs.sdk-3.1.8.data/data/genie_yamls/iosxr/trigger_datafile_xr.yaml` & `genie.libs.sdk-3.1.9.data/data/genie_yamls/iosxr/trigger_datafile_xr.yaml`

 * *Files identical despite different names*

## Comparing `genie.libs.sdk-3.1.8.data/data/genie_yamls/iosxr/verification_datafile_xr.yaml` & `genie.libs.sdk-3.1.9.data/data/genie_yamls/iosxr/verification_datafile_xr.yaml`

 * *Files identical despite different names*

## Comparing `genie.libs.sdk-3.1.8.data/data/genie_yamls/junos/verification_datafile_junos.yaml` & `genie.libs.sdk-3.1.9.data/data/genie_yamls/junos/verification_datafile_junos.yaml`

 * *Files identical despite different names*

## Comparing `genie.libs.sdk-3.1.8.data/data/genie_yamls/nxos/trigger_datafile_nxos.yaml` & `genie.libs.sdk-3.1.9.data/data/genie_yamls/nxos/trigger_datafile_nxos.yaml`

 * *Files identical despite different names*

## Comparing `genie.libs.sdk-3.1.8.data/data/genie_yamls/nxos/verification_datafile_nxos.yaml` & `genie.libs.sdk-3.1.9.data/data/genie_yamls/nxos/verification_datafile_nxos.yaml`

 * *Files identical despite different names*

## Comparing `genie.libs.sdk-3.1.8.data/data/genie_yamls/tools/verification_generator/datafiles_maker.py` & `genie.libs.sdk-3.1.9.data/data/genie_yamls/tools/verification_generator/datafiles_maker.py`

 * *Files identical despite different names*

## Comparing `genie.libs.sdk-3.1.8.data/data/genie_yamls/tools/verification_generator/differ.py` & `genie.libs.sdk-3.1.9.data/data/genie_yamls/tools/verification_generator/differ.py`

 * *Files identical despite different names*

## Comparing `genie.libs.sdk-3.1.8.data/data/genie_yamls/tools/verification_generator/parsers.yaml` & `genie.libs.sdk-3.1.9.data/data/genie_yamls/tools/verification_generator/parsers.yaml`

 * *Files identical despite different names*

## Comparing `genie.libs.sdk-3.1.8.dist-info/METADATA` & `genie.libs.sdk-3.1.9.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: genie.libs.sdk
-Version: 3.1.8
+Version: 3.1.9
 Summary: Genie libs sdk: Libraries containing all Triggers and Verifications
 Home-page: https://developer.cisco.com/site/pyats/
 Author: Cisco Systems Inc.
 Author-email: pyats-support-ext@cisco.com
 License: Apache 2.0
 Keywords: genie pyats test automation
 Platform: UNKNOWN
```

## Comparing `genie.libs.sdk-3.1.8.dist-info/RECORD` & `genie.libs.sdk-3.1.9.dist-info/RECORD`

 * *Files 2% similar despite different names*

```diff
@@ -1,26 +1,27 @@
-genie.libs.sdk-3.1.8-py3.5-nspkg.pth,sha256=ObYoD8sL3pc4avNcQOL6mdv2IdNlOmFr3c3nD1iDADQ,1676
-genie/libs/sdk/__init__.py,sha256=J2DZzxpoCanjW4prs910ybK5ZP3C7Unvnp-Z09wmnTs,1128
+genie.libs.sdk-3.1.9-py3.4-nspkg.pth,sha256=ObYoD8sL3pc4avNcQOL6mdv2IdNlOmFr3c3nD1iDADQ,1676
+genie/libs/sdk/__init__.py,sha256=WyoE_kR8ye2HtWHJy4V7p3zADAPqYwAGY8HF0431eTg,1128
 genie/libs/sdk/libs/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/libs/abstracted_libs/__init__.py,sha256=OGo69LZc5Q_jmfC7pguzCyZLD-9y-8EmUXGOQgr7VkM,26
 genie/libs/sdk/libs/abstracted_libs/configure_snapshot_command.py,sha256=x63Jr5L_HoPtL7fkTjXecZZh4YE5yR18QbejdssFXIw,1002
 genie/libs/sdk/libs/abstracted_libs/ha.py,sha256=9Dxn_6ejPxm_M7DTE0-shX4DrHPS4R3o1o09jgNRBVs,10315
 genie/libs/sdk/libs/abstracted_libs/init_exec_commands.py,sha256=jULA4BCwb7EDPvoSr6WJpiLJ2arAYiZN7F5xjjefBk4,1019
 genie/libs/sdk/libs/abstracted_libs/management_interface.py,sha256=ChT7PxLj0CtThsf7dSdzz6IABa-2WlGmUu1iCsbAEr8,1853
 genie/libs/sdk/libs/abstracted_libs/processors.py,sha256=tPJXLR-oC1QbliUuhnZwOwkmQW6d-WIcKWAKSqYcP3c,31603
+genie/libs/sdk/libs/abstracted_libs/restore.py,sha256=ZxU2SbnF7J-Tv6Qw1fKLGZuiIc28RZGFEmU4kWPYbF0,1369
 genie/libs/sdk/libs/abstracted_libs/subsection.py,sha256=AnYjatT0sG8yup1TWMOoxo0Yh5clWXalHw3my9uzWrM,12327
 genie/libs/sdk/libs/abstracted_libs/ios/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
 genie/libs/sdk/libs/abstracted_libs/ios/init_exec_commands.py,sha256=pYCUkcd45B8inwlMOzci1TCf4CT59UP7x7Cs3_ILY8k,1016
 genie/libs/sdk/libs/abstracted_libs/ios/management_interface.py,sha256=wmDvWTVd4mf-SpU-dfKS-AvEMF-LWy4gRtpMXIvvs2k,1641
 genie/libs/sdk/libs/abstracted_libs/iosxe/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
 genie/libs/sdk/libs/abstracted_libs/iosxe/ha.py,sha256=q8ElApBzmFuTZQHX8qy_cv3EZOfuvybp0KNhFsJlvtE,680
 genie/libs/sdk/libs/abstracted_libs/iosxe/init_exec_commands.py,sha256=cFBBxObiaS3hbiHmXIH2J33xuBDBOdtvMLtnYDOu0JI,1018
 genie/libs/sdk/libs/abstracted_libs/iosxe/management_interface.py,sha256=BCSr4QLQZS17aomQhc6GQleCgmyAlGTyzy3PmuBV2A4,1653
 genie/libs/sdk/libs/abstracted_libs/iosxe/processors.py,sha256=8UV7F3lHJVSGQrquLxm00-oWH5WuaId8Z7me5u9vBrA,5567
-genie/libs/sdk/libs/abstracted_libs/iosxe/restore.py,sha256=RXCact7_z6CrcoglXX_4V0xcM9nRQkMLSFcsBUhUTmg,11394
+genie/libs/sdk/libs/abstracted_libs/iosxe/restore.py,sha256=u1isa52gM7WRH7IeaLQaHShmzxWuqcOEhWeKu3gh8IA,11230
 genie/libs/sdk/libs/abstracted_libs/iosxe/subsection.py,sha256=krMuFgalNejPysCaEvknYyPg5uq7wdhSn9oDuMRCYDw,23667
 genie/libs/sdk/libs/abstracted_libs/iosxe/asr1k/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
 genie/libs/sdk/libs/abstracted_libs/iosxe/asr1k/ha.py,sha256=GGJj1EDo2wSAFLihVud_Y62j0I9UmLuFSWL-rAk216Y,20020
 genie/libs/sdk/libs/abstracted_libs/iosxe/asr1k/subsection.py,sha256=VBuNgI-G0dl-B1oiTpZYYeAN0qJ7d34YhrwOWT8da4A,3186
 genie/libs/sdk/libs/abstracted_libs/iosxe/c3850/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
 genie/libs/sdk/libs/abstracted_libs/iosxe/c3850/ha.py,sha256=3J07p2a4cg_UZTGt4oP4Y3VFcQTCbWdseXrY44Alvow,1056
 genie/libs/sdk/libs/abstracted_libs/iosxe/c3850/subsection.py,sha256=x_RjeMtNEOMfkhpzZ_sIvwh3Wax9XtzYObPMh3oIPHM,3111
@@ -45,63 +46,63 @@
 genie/libs/sdk/libs/abstracted_libs/nxos/subsection.py,sha256=a3SqHlT4sr2FrpnP7cK8IO4082U6AbuPmEXAg-tFeVk,1316
 genie/libs/sdk/libs/abstracted_libs/nxos/n7k/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
 genie/libs/sdk/libs/abstracted_libs/nxos/n7k/ha.py,sha256=Kby7HMMyVdV6oQJsJ8AYHqpT187oZ0CwEKwUAEbBMIY,1498
 genie/libs/sdk/libs/abstracted_libs/nxos/n7k/subsection.py,sha256=9gVjL5a8iErFDwMBRIzB2VtdXTBpj5fts7P-PgPY3GM,3134
 genie/libs/sdk/libs/abstracted_libs/nxos/n9k/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
 genie/libs/sdk/libs/abstracted_libs/nxos/n9k/subsection.py,sha256=IG7hLzhoLAknJUjNncXldnSuBU_HY0iVXMkBGq0hAs8,2487
 genie/libs/sdk/libs/utils/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-genie/libs/sdk/libs/utils/common.py,sha256=vAaVidmBFw6_n6w0qdaLkdZyhl1o9R4NTafsIFmSUyU,11848
-genie/libs/sdk/libs/utils/mapping.py,sha256=WWKe66rmx2TlEwAWh2_MRClKIZbfuOaQ2_jaPKEc9kk,59108
+genie/libs/sdk/libs/utils/common.py,sha256=oWWFVrH-oxkYlsTRJpcvEAQLexwU-xrivnrOTi-oqHA,33489
+genie/libs/sdk/libs/utils/mapping.py,sha256=gI9k9kSlYFnQ_Mb_p5kpHsd4H5KM6htx_f0IrTmLXcA,61253
 genie/libs/sdk/libs/utils/normalize.py,sha256=60RB_q45pFL_kNdVC4BU2VtncydAeM_6mwvFtLs5JMI,20100
-genie/libs/sdk/libs/utils/triggeractions.py,sha256=PTyepJ2kioxVxZTGGXAW6vkdJ_id3Ydzsa6gjehHNg8,12396
+genie/libs/sdk/libs/utils/triggeractions.py,sha256=LnOh9zZaIKjFn773aDxvgzot_mpKt6E82KYUEvTVPlA,13702
 genie/libs/sdk/triggers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/addremove/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/addremove/addremove.py,sha256=W3_q1pJZcIQbBcyGbMEjlq7sMXzDr43WP2Een0faaaw,5942
 genie/libs/sdk/triggers/addremove/acl/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/addremove/acl/addremove.py,sha256=w2bnVRMzUL1N4zHkDKVmXw_ozFfribg2_bMjn1Hul70,420
 genie/libs/sdk/triggers/addremove/acl/iosxe/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/addremove/acl/iosxe/addremove.py,sha256=_YD5LGFGCMjJ9i6RFRSpBq8W6ZVo0OBThUyUdyoVSi4,29414
+genie/libs/sdk/triggers/addremove/acl/iosxe/addremove.py,sha256=TSupNoViL9aGMeZqLFs_XUharzWc9Jft36F8HTD3H4E,30674
 genie/libs/sdk/triggers/addremove/bgp/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-genie/libs/sdk/triggers/addremove/bgp/addremove.py,sha256=5sLcGRLX850Tes6yECqaiwGBEzzgWVuQOXX86atWwus,12955
+genie/libs/sdk/triggers/addremove/bgp/addremove.py,sha256=pwyVDPgK21pKMQCrKCd655_4pXOuHQTxKBZ9YxLvfiM,14355
 genie/libs/sdk/triggers/addremove/bgp/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/addremove/bgp/nxos/addremove.py,sha256=3PxaCKMrgNVjXYGwuQP6HNMYHjQLseKcdRfCh7jKSJQ,138570
+genie/libs/sdk/triggers/addremove/bgp/nxos/addremove.py,sha256=_6YHiMvqFCPmq8R5k9dqlzyxhr2TwErzZ_pSwAGB4No,152410
 genie/libs/sdk/triggers/addremove/igmp/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/addremove/igmp/addremove.py,sha256=owMkdeht8pG81lVWcZmdJebJni5Q-csbnwHfg2kPqG8,386
 genie/libs/sdk/triggers/addremove/igmp/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/addremove/igmp/nxos/addremove.py,sha256=_BsIXT8pM6P9EJRJtlAVbRAGo6a9Lcfy1YOABqza4MA,28001
+genie/libs/sdk/triggers/addremove/igmp/nxos/addremove.py,sha256=Qa217_ywCtluBjPygO9e042gw53YiBr7hMWsfF-iYNo,29761
 genie/libs/sdk/triggers/addremove/lag/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/addremove/lag/addremove.py,sha256=mSP_nD9tsAcyYbd-gOjXfvDNLHIJ3AHLmft5wg3OfWo,405
 genie/libs/sdk/triggers/addremove/lag/iosxe/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/addremove/lag/iosxe/addremove.py,sha256=B2LCbeIhDox0V0BCtIHhXAfGUi-rTpflbDQ4FITY3kQ,25243
+genie/libs/sdk/triggers/addremove/lag/iosxe/addremove.py,sha256=q9K-cmm_0dSv7nwepvwJM4DXmipVyqGtGVnVsdJCkYU,26615
 genie/libs/sdk/triggers/addremove/mld/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/addremove/mld/addremove.py,sha256=bTYB1t25claF9x7DEmkyufWb90XVJlTgCRm8I_4c5ww,381
 genie/libs/sdk/triggers/addremove/mld/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/addremove/mld/nxos/addremove.py,sha256=t0xAvQieVK6iZEb0khiFkId7G73XbBU2eOzHqkoDfMk,28181
+genie/libs/sdk/triggers/addremove/mld/nxos/addremove.py,sha256=z3RZgkvK740T1zGBrlVvQkGHXguvp_JHUhKXui08tCY,29915
 genie/libs/sdk/triggers/addremove/msdp/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/addremove/msdp/addremove.py,sha256=q3B5EmLsaCOAQd7oSGRfi32YOiAPHraCtLRtPmoIHoc,718
 genie/libs/sdk/triggers/addremove/msdp/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/addremove/msdp/nxos/addremove.py,sha256=GTD4AZmkjuaEsMwKcK9mmPVd0nlP4rYMIvTng19PpbM,48935
+genie/libs/sdk/triggers/addremove/msdp/nxos/addremove.py,sha256=qgnM2UsROjCfeWL_Pmb82y9RA21pvN6AuSB3XvVcT-E,52754
 genie/libs/sdk/triggers/addremove/pim/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/addremove/pim/addremove.py,sha256=nAWBvPWPwwrreuRcpiEb57YiGOupl-ktoN-8-patJlU,202
 genie/libs/sdk/triggers/addremove/pim/nxos/__init__.py,sha256=rvPOsFHryY1JWdcRhihSEaFCNai4rkztqb7RVB3I9Lg,257
-genie/libs/sdk/triggers/addremove/pim/nxos/addremove.py,sha256=Rs23jBLpw4n8z4uPZ_hTUzGNT9PA7hDgRraOWF4Pp1k,5426
+genie/libs/sdk/triggers/addremove/pim/nxos/addremove.py,sha256=UAF7UxwestrU3DSYP9XI0N1t_RGXpOCPMtBN8rkZvrA,5962
 genie/libs/sdk/triggers/addremove/routing/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/addremove/routing/addremove.py,sha256=haTHY45VeVvLlGRTMhgTx-Ubwm5KQPQjTRSmTBtO454,299
 genie/libs/sdk/triggers/addremove/routing/iosxe/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/addremove/routing/iosxe/addremove.py,sha256=4uAo7jhgkLlyuhybnJIYVvdWyO0MkvOtC2b7p7ky4JI,13808
+genie/libs/sdk/triggers/addremove/routing/iosxe/addremove.py,sha256=LIswrPO-BDRR3KzX_rgwleCzDThhzCsMjNvSUrNxzp4,14643
 genie/libs/sdk/triggers/addremove/trm/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/addremove/trm/addremove.py,sha256=93tkvSjoY6tg6e1VbUjWDJE_Tvgd4GEadoXqZDOdp1o,51
 genie/libs/sdk/triggers/addremove/trm/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/addremove/trm/nxos/addremove.py,sha256=fEBGvPXYIn-O0iDE9Clmq-TQcfxXHEgyx0UI_uu1-3o,13443
+genie/libs/sdk/triggers/addremove/trm/nxos/addremove.py,sha256=Ow9iF8dJwgUmQ3P1GDu56VkT3jwuE9zG_Mx_ELX8Uxk,14531
 genie/libs/sdk/triggers/addremove/vxlan/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/addremove/vxlan/addremove.py,sha256=rMSAIQd4dc_KmMQSVQgu3MoGrXmb2bRpONulVwFg3z0,138
 genie/libs/sdk/triggers/addremove/vxlan/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/addremove/vxlan/nxos/addremove.py,sha256=cwMKwEU1xvt5ITMNpo8Eg1NIfylF2NhG1sx7zWK3KiQ,27040
+genie/libs/sdk/triggers/addremove/vxlan/nxos/addremove.py,sha256=p3i00T5su4YEX7O5dHz6TtZ-ubCr87ORaSbKifcDfV4,29463
 genie/libs/sdk/triggers/clear/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-genie/libs/sdk/triggers/clear/clear.py,sha256=D7wehczIvmTC_f-LgEA_QkVdZGul7YpYH3HKHplCiBQ,5705
+genie/libs/sdk/triggers/clear/clear.py,sha256=iLBYsqM6ZIihzGUBkd89SNObXQu6L02AJXzwC0eT6do,5680
 genie/libs/sdk/triggers/clear/bgp/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/clear/bgp/clear.py,sha256=DQOIWM8Y7LIjOJLKEP_MFpZpvkzXr2LlU2566J3JvOA,26523
 genie/libs/sdk/triggers/clear/bgp/iosxr/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
 genie/libs/sdk/triggers/clear/bgp/iosxr/clear.py,sha256=FxVyCo8R_2rUBUrx1rFvFeDxGeUEo7jejlRO8IBZ8Q8,1775
 genie/libs/sdk/triggers/clear/bgp/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
 genie/libs/sdk/triggers/clear/bgp/nxos/clear.py,sha256=Wqs1FkxEkpmew52K2h6w6C8t1ELCbfkIuX_v1_qTjE0,20065
 genie/libs/sdk/triggers/clear/interface/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
@@ -132,117 +133,117 @@
 genie/libs/sdk/triggers/clear/routing/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
 genie/libs/sdk/triggers/clear/routing/nxos/clear.py,sha256=yqoh7o69Zh6fEdKMbDFJ2YACPd9a4I6jZ-uklkBWHlA,14872
 genie/libs/sdk/triggers/disableenable/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/disableenable/disableenable.py,sha256=BMSWnW6mIVX8WvY__EBwCygxQ8JGc6z1eVLwR_qWD54,6394
 genie/libs/sdk/triggers/disableenable/disableenablereqhandler.py,sha256=hy8HtkqBLtrdIHMlJXJYIdLTlWxjNWGrgIv2CoAVZ2c,7589
 genie/libs/sdk/triggers/disableenable/bgp/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/disableenable/bgp/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/disableenable/bgp/nxos/disableenable.py,sha256=5kRnIfI5S161iH6emaia5QCM3PEwhLaPC22kMsciLa8,5143
+genie/libs/sdk/triggers/disableenable/bgp/nxos/disableenable.py,sha256=1xE0dVY1sp1gQs-CgT_f2a1ceKZWQJwmOyGMG7kIw-c,5560
 genie/libs/sdk/triggers/disableenable/hsrp/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/disableenable/hsrp/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/disableenable/hsrp/nxos/disableenable.py,sha256=slLQ5eXEHHPnmLkzF7t-8I9AUJyiPLA7wbcvJmB90Fo,3840
+genie/libs/sdk/triggers/disableenable/hsrp/nxos/disableenable.py,sha256=UlGofLox4JTZpwIAJ7_cY5fehxkGm3Xe2v1gX0rMSlM,4367
 genie/libs/sdk/triggers/disableenable/mcast/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/disableenable/mcast/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/disableenable/mcast/nxos/disableenable.py,sha256=M_wiDy5cOboKxlIA33wSyLI68gfyQ0Zn4ICopHBQZ8M,7265
+genie/libs/sdk/triggers/disableenable/mcast/nxos/disableenable.py,sha256=X6Xf7YF5euJ32vRkdQHm-_OWs1EsgI-YFkGCv_-RsJo,8094
 genie/libs/sdk/triggers/disableenable/trm/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/disableenable/trm/nxos/__init__.py,sha256=c7USJ8y2GbHl63zgrU5JxjAemX-GZXRZxnKU2ilarX8,255
 genie/libs/sdk/triggers/disableenable/trm/nxos/disableenable.py,sha256=GaewzbB4PRZqOumY9RAy76U6M3qFhl-hkgjgflFwPMo,3814
 genie/libs/sdk/triggers/disableenable/vlan/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/disableenable/vlan/nxos/__init__.py,sha256=c7USJ8y2GbHl63zgrU5JxjAemX-GZXRZxnKU2ilarX8,255
 genie/libs/sdk/triggers/disableenable/vlan/nxos/disableenable.py,sha256=txdecpMihjtETj0lO5Nel-falvSwaFvLSjkIvwLBSAU,7071
 genie/libs/sdk/triggers/disableenable/vxlan/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/disableenable/vxlan/nxos/__init__.py,sha256=c7USJ8y2GbHl63zgrU5JxjAemX-GZXRZxnKU2ilarX8,255
-genie/libs/sdk/triggers/disableenable/vxlan/nxos/disableenable.py,sha256=JB1WJSKh7dUCSbbVS1DW4BggJoVYj2qu_eLb-xNpVVA,8003
+genie/libs/sdk/triggers/disableenable/vxlan/nxos/disableenable.py,sha256=EnqwTIpO959E1TSudcNGwzGkN2meFP1Rk3hT1Ye22as,8207
 genie/libs/sdk/triggers/ha/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-genie/libs/sdk/triggers/ha/ha.py,sha256=uHXuC9HHwEK50xf1uzrQ3diC82gqhQIm0G-7Oiuww-c,17963
+genie/libs/sdk/triggers/ha/ha.py,sha256=fHgLQKH-jDMiqShsdTqrJ0aeRC9kVIwF3RIDLCg_tNQ,17924
 genie/libs/sdk/triggers/ha/issu/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/ha/issu/iosxe/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
 genie/libs/sdk/triggers/ha/issu/iosxe/issu.py,sha256=mW3pW55J5ApIj-kYTZ_-6vGNwxkWJs59_BoGn-4L1LQ,862
 genie/libs/sdk/triggers/ha/issu/iosxe/asr1k/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/ha/issu/iosxe/asr1k/issu.py,sha256=08NMlwrxWrd51ivZbxZo52J9l52jovcH0BYwPqo37mY,2022
+genie/libs/sdk/triggers/ha/issu/iosxe/asr1k/issu.py,sha256=yRFdc8Df5O0tUCrRvwLg-LxayXwzTu8bZUBdZjOg4RQ,3481
 genie/libs/sdk/triggers/ha/reload/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/ha/reload/iosxe/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
 genie/libs/sdk/triggers/ha/reload/iosxe/reload.py,sha256=hKiIdrSq1sDPcGVxyBcOPpm7q5XYJ-pG8IPjeRn7U-Q,3802
 genie/libs/sdk/triggers/ha/reload/iosxe/asr1k/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/ha/reload/iosxe/asr1k/reload.py,sha256=yKpzVSiKjvZg9p4iP9-Tj49PWqBtL789gcUHiRm3tXM,12779
+genie/libs/sdk/triggers/ha/reload/iosxe/asr1k/reload.py,sha256=Fts8K5-UVn6DyHC9iGaevbD3rTWzItCb8Kp7EOs4zUQ,13167
 genie/libs/sdk/triggers/ha/reload/iosxe/c3850/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/ha/reload/iosxe/c3850/reload.py,sha256=wpiX9ICC19CHixnC3eGU1HOZGrGkHw4C_gUu1DiYlRo,15628
+genie/libs/sdk/triggers/ha/reload/iosxe/c3850/reload.py,sha256=Xrli5xjc5mrXMi6U3LsyER4UBHuyrFOkxoh_NI_M0t4,16884
 genie/libs/sdk/triggers/ha/reload/iosxe/csr1000v/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/ha/reload/iosxe/csr1000v/reload.py,sha256=fhrQxVuTPTE_yR96SNEHByQwCnmqRWVPuR2V4mwrteM,3415
+genie/libs/sdk/triggers/ha/reload/iosxe/csr1000v/reload.py,sha256=4JVi9PPGDkQ3imnSQhPTajiEbnf-7oZdeIg5cA05kJA,3888
 genie/libs/sdk/triggers/ha/reload/iosxr/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
 genie/libs/sdk/triggers/ha/reload/iosxr/reload.py,sha256=xBoijmEvfUuH0w9Ve-Gum1RTQ2F5P1Iif5V_rcsmwPk,14385
 genie/libs/sdk/triggers/ha/reload/iosxr/iosxrv/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
 genie/libs/sdk/triggers/ha/reload/iosxr/iosxrv/reload.py,sha256=T00Nd_sfpeL8C07hpbLkQYo8n8DPdcLvuvZ0B2VowvY,1884
 genie/libs/sdk/triggers/ha/reload/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/ha/reload/nxos/reload.py,sha256=K51f3P7xIKg9UfU3X0gkYRv_STEpXFo2hMGStxwOfic,19641
+genie/libs/sdk/triggers/ha/reload/nxos/reload.py,sha256=3nm8swoMtdi9zFhKn0MX0yddl3C3mMQRvjLLp1e0b5A,19649
 genie/libs/sdk/triggers/ha/reload/nxos/n9k/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
 genie/libs/sdk/triggers/ha/reload/nxos/n9k/reload.py,sha256=6MtX-gv8nYuLc9Wvp_9qSORmMlpOOByZWq4d1x7EPUE,2870
 genie/libs/sdk/triggers/ha/switchover/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/ha/switchover/iosxe/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
 genie/libs/sdk/triggers/ha/switchover/iosxe/switchover.py,sha256=lxNC46J0YfVUQHMBx2Kvi-bjD1wZKtHx8W-VKuh-mSE,923
 genie/libs/sdk/triggers/ha/switchover/iosxe/asr1k/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/ha/switchover/iosxe/asr1k/switchover.py,sha256=ZR0XUu07dysspsEXFggmEzABvGfUN9QERdke9p3zn5U,3911
+genie/libs/sdk/triggers/ha/switchover/iosxe/asr1k/switchover.py,sha256=oSI3fzvZPmAxDIMw9Js7NaMIcT2lBPtfxSk7VkjXljc,4334
 genie/libs/sdk/triggers/ha/switchover/iosxe/c3850/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/ha/switchover/iosxe/c3850/switchover.py,sha256=tYH3ELROoDj_S-Mb1lxtSmi3aoqa0ilC5zo03VKqTyk,7072
+genie/libs/sdk/triggers/ha/switchover/iosxe/c3850/switchover.py,sha256=zbEtLieLzaeO7FJ_Ej-mx7_pnGgmxwsUxysesWFe0f8,7527
 genie/libs/sdk/triggers/ha/switchover/iosxr/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/ha/switchover/iosxr/switchover.py,sha256=V9zB_nqqZZ5k6H1aI--OMYWLKvsmjiT8PxTlTGTxPNQ,5306
+genie/libs/sdk/triggers/ha/switchover/iosxr/switchover.py,sha256=5YoQ2OOnKtCuAmYFjWQCp3zj4e-4n4uCr-PFxmU-6lQ,5842
 genie/libs/sdk/triggers/ha/switchover/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/ha/switchover/nxos/switchover.py,sha256=OU5eJ3Vq1BV1XJkEoY90eSsHu5O9erd-z0bbqD-Tc3E,4165
+genie/libs/sdk/triggers/ha/switchover/nxos/switchover.py,sha256=w-JizC0C3vletZOoivQ2N3sc3b5B6Ts2ffptW0ayM0c,4614
 genie/libs/sdk/triggers/modify/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/modify/modify.py,sha256=ZQizZATChkE2s_MbZz1BdkRVGBrkCdlIFaH_T1DfGmo,5497
 genie/libs/sdk/triggers/modify/bgp/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-genie/libs/sdk/triggers/modify/bgp/modify.py,sha256=1ntCObrMDAkHRkXPhX7MjfTGSoX-dWjWnutkGpK8lL4,20857
+genie/libs/sdk/triggers/modify/bgp/modify.py,sha256=dL2kEGr6GRGt_yhZpP7Q657S4WmyWXwN_HOS_O79bNM,22396
 genie/libs/sdk/triggers/modify/bgp/iosxe/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/modify/bgp/iosxe/modify.py,sha256=1-fonhxpvkq_zwaRcxZn3164oNgVM1-O4qQPTHTTswY,9616
+genie/libs/sdk/triggers/modify/bgp/iosxe/modify.py,sha256=D7p4iMxd4AjE-icyJcy5mhoec86HoGYvtLl1EYLMUVA,22822
 genie/libs/sdk/triggers/modify/bgp/iosxr/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/modify/bgp/iosxr/modify.py,sha256=zZZjOaU6VPSJPmmrp6Kbxci1zgxd6TkJVIiqzBcG8dE,5380
+genie/libs/sdk/triggers/modify/bgp/iosxr/modify.py,sha256=HfC7U4h7OiuJZ8yaWkFAGK3Efy0aw59yTWjbQ1pl6Pk,11624
 genie/libs/sdk/triggers/modify/bgp/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/modify/bgp/nxos/modify.py,sha256=7_uXRzsVogqicfVua_0OsvNKnrkEh_SzqxZMlWjcu1Q,51732
+genie/libs/sdk/triggers/modify/bgp/nxos/modify.py,sha256=xZIoieG0vmpVh7iZFJTUPzYoClpNGyRQVQn0anMRFxI,57387
 genie/libs/sdk/triggers/modify/dot1x/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/modify/dot1x/modify.py,sha256=xzgvnFh8-HEsw45CtPnf5Lp5ZpIY3oCrNWJ8KfVzJM0,196
 genie/libs/sdk/triggers/modify/dot1x/iosxe/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/modify/dot1x/iosxe/modify.py,sha256=qXjggIKRGgJF5ep8VgkZ9DZW-riP5P9yy8jmwP3WJ6I,8262
+genie/libs/sdk/triggers/modify/dot1x/iosxe/modify.py,sha256=9ww-ND7lTdN-H4zY8BEdLheRTEqKvLgVMmnb3UYCVnI,8764
 genie/libs/sdk/triggers/modify/hsrp/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-genie/libs/sdk/triggers/modify/hsrp/modify.py,sha256=WzP3KHz0YS-6jPBcVcNRJfKdnaPRwyQGpBfa1Y0gUdQ,12654
+genie/libs/sdk/triggers/modify/hsrp/modify.py,sha256=adXEeAyjipc7THRmENTV-CWK_ahultQrWPmDOhcar84,13707
 genie/libs/sdk/triggers/modify/igmp/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/modify/igmp/modify.py,sha256=c5kRfGyJgvclH5j_WWqtk1z_8GtOqOV-xe89NPQgbvo,180
 genie/libs/sdk/triggers/modify/igmp/nxos/__init__.py,sha256=rvPOsFHryY1JWdcRhihSEaFCNai4rkztqb7RVB3I9Lg,257
-genie/libs/sdk/triggers/modify/igmp/nxos/modify.py,sha256=y-7KhUW4-fadWs3Rwbn24p-_CVM40As_kVlgvWhyFxg,4771
+genie/libs/sdk/triggers/modify/igmp/nxos/modify.py,sha256=st90hPH7tnhFyqvqwsLHuqaPLxsyk8lE2vkVev7Kpn8,5138
 genie/libs/sdk/triggers/modify/interface/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-genie/libs/sdk/triggers/modify/interface/modify.py,sha256=xO1jNT95Q4QfeBHT-j29Owuav57CuZ1Qv03K465MDZ0,27099
+genie/libs/sdk/triggers/modify/interface/modify.py,sha256=L_llLpn9mPqy9scTAAXMJIKRqLWXIw5A1jgGNV9QoUA,27984
 genie/libs/sdk/triggers/modify/interface/iosxe/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/modify/interface/iosxe/modify.py,sha256=UWGx0Wv6lwFsDRyUn4LLVDg_ehyDDIdn59_ZDtaAh_o,3880
+genie/libs/sdk/triggers/modify/interface/iosxe/modify.py,sha256=D5H6I-NvnuFDu7AN-3qdfTf7r9h6JFjrcV6O1XhN10w,10111
 genie/libs/sdk/triggers/modify/interface/iosxr/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/modify/interface/iosxr/modify.py,sha256=aCYJpj3YhuMQN_WZIWWegcIans2vxtPyyp7Qw1Ym7i8,2338
+genie/libs/sdk/triggers/modify/interface/iosxr/modify.py,sha256=tzt9RRaVhU4PQk4MrDovt9H57HQ-HJ4ZLNzRT9zZBXo,5387
 genie/libs/sdk/triggers/modify/lldp/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/modify/lldp/modify.py,sha256=m-BIjCbxI7IX10ppnp9c1MCaWFmrV0IrJq4hLIf8QYE,4488
 genie/libs/sdk/triggers/modify/mld/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/modify/mld/modify.py,sha256=c5kRfGyJgvclH5j_WWqtk1z_8GtOqOV-xe89NPQgbvo,180
 genie/libs/sdk/triggers/modify/mld/nxos/__init__.py,sha256=rvPOsFHryY1JWdcRhihSEaFCNai4rkztqb7RVB3I9Lg,257
-genie/libs/sdk/triggers/modify/mld/nxos/modify.py,sha256=NgRG0PuxondAOx3Wt9Hw6RNEbBDb_4uG5BchG_dcJNs,4744
+genie/libs/sdk/triggers/modify/mld/nxos/modify.py,sha256=yCGm8ztiuWR0XE5de_b9A9ULbgU6SkxEvCv5ZAKKx3Q,5087
 genie/libs/sdk/triggers/modify/msdp/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/modify/msdp/modify.py,sha256=LWiaVhKhPtA5faaIQpudGLSgswvbrKI59o9H_xmCDTU,727
 genie/libs/sdk/triggers/modify/msdp/nxos/__init__.py,sha256=rvPOsFHryY1JWdcRhihSEaFCNai4rkztqb7RVB3I9Lg,257
-genie/libs/sdk/triggers/modify/msdp/nxos/modify.py,sha256=IuHyweiHyg0uqqoRcfobscs9TdcGe0n8Q9uUaGN6Y-I,53843
+genie/libs/sdk/triggers/modify/msdp/nxos/modify.py,sha256=_FpvN7gz1wCB9CRhAbeF86cq3O5I3nsqEfTuwMQZsr8,58380
 genie/libs/sdk/triggers/modify/pim/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/modify/pim/modify.py,sha256=PYFLBOjAZx-zIBwg-tnWeJnHR8z4nJbLSg79vYvImEg,184
 genie/libs/sdk/triggers/modify/pim/nxos/__init__.py,sha256=rvPOsFHryY1JWdcRhihSEaFCNai4rkztqb7RVB3I9Lg,257
-genie/libs/sdk/triggers/modify/pim/nxos/modify.py,sha256=w1YaPPBsfr_qr6QkS5g97cIxdfm6ClsC2awElK9ReY4,5476
+genie/libs/sdk/triggers/modify/pim/nxos/modify.py,sha256=lOqqJa7kibn-pX5O5pZpMY1GFLkZtZZ3qCZN8TK1Fec,6051
 genie/libs/sdk/triggers/modify/stp/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/modify/stp/modify.py,sha256=fYapzlNb_YjAGPCNb7n_8g0O5kX7OfDwngNqXh8-5XQ,280
 genie/libs/sdk/triggers/modify/stp/iosxe/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/modify/stp/iosxe/modify.py,sha256=3pAk1HRwEJWa_fNlgCZ_8V1jUnQv3plrM5NXvr8gJeM,15013
+genie/libs/sdk/triggers/modify/stp/iosxe/modify.py,sha256=joTxbi_6i34E5o2jqjOcNPCnaP_z_VD4UWXYxUkB_bM,15922
 genie/libs/sdk/triggers/modify/vlan/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/modify/vlan/modify.py,sha256=QiQySV6nLDqjLGRs8RrBa0HetvVuHyQG5GOO7Jqc0oc,111
 genie/libs/sdk/triggers/modify/vlan/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/modify/vlan/nxos/modify.py,sha256=8Y6TBvK9wg4VA56s7eJgIB1BHjHcorrEFRKNX8zkcH0,5409
+genie/libs/sdk/triggers/modify/vlan/nxos/modify.py,sha256=52uo0utXJoB5suzCDbZZ-gQmE6jSo2DcZ29xrkqqGpg,5832
 genie/libs/sdk/triggers/modify/vxlan/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/modify/vxlan/modify.py,sha256=5LX1pLW5ShDbwkRcoz0PbYFkBBTr5QSmVUDV6Ujqzb8,132
 genie/libs/sdk/triggers/modify/vxlan/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/modify/vxlan/nxos/modify.py,sha256=17Mvgzmj6kqvg7KKWndCdnct4RvZTsqCwZuqH-NO4_M,33227
+genie/libs/sdk/triggers/modify/vxlan/nxos/modify.py,sha256=jr_kT3eyI5nxxsgKloYcPwn4oPuiVA6PCxyQ1w42_vU,35894
 genie/libs/sdk/triggers/processrestart/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/processrestart/processrestart.py,sha256=d6FHEW9VPNVHkxMtZYhmIF05W07wcQ94iPapP3Dc5X0,4087
 genie/libs/sdk/triggers/processrestart/aclmgr/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/processrestart/aclmgr/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
 genie/libs/sdk/triggers/processrestart/aclmgr/nxos/processrestart.py,sha256=OnT83CgAnUHdY9qVQ_0DliAp0RHI-2c7S3nCJL6jyHY,3647
 genie/libs/sdk/triggers/processrestart/bfd/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/processrestart/bfd/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
@@ -352,126 +353,126 @@
 genie/libs/sdk/triggers/processrestart/vlan_mgr/nxos/processrestart.py,sha256=CukbrDcPQ38NJbCDZmCR1n5hwV_zpRv-L97EvNHHrtA,3679
 genie/libs/sdk/triggers/processrestart/vpc/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/processrestart/vpc/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
 genie/libs/sdk/triggers/processrestart/vpc/nxos/processrestart.py,sha256=IYaWNI7NKRxJ0ibbG9OJ3GEwSO9ayiMhIECUP6zpPZU,3572
 genie/libs/sdk/triggers/shutnoshut/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/shutnoshut/shutnoshut.py,sha256=GE8uTgu5U1eL47tsg9xl6eWbZMWiYe9gQuMUAeKPVCI,4441
 genie/libs/sdk/triggers/shutnoshut/bgp/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-genie/libs/sdk/triggers/shutnoshut/bgp/shutnoshut.py,sha256=KPE6xGv5iFTMdHDbmByegV7sew19Lqx-zveLLq-dFlE,14052
+genie/libs/sdk/triggers/shutnoshut/bgp/shutnoshut.py,sha256=32fflpdDSjmMpDgxtDQGiO98Edc9ullGYVg6dCarRk8,15586
 genie/libs/sdk/triggers/shutnoshut/bgp/iosxe/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/shutnoshut/bgp/iosxe/shutnoshut.py,sha256=99srCDQcuKWZHPPkvLPSGkbUM9nwL1HBr_x3P8E3N9A,2451
+genie/libs/sdk/triggers/shutnoshut/bgp/iosxe/shutnoshut.py,sha256=rTO7KFopE1bVnEgu2QqkTuGtcev9_xvEFC1RHx2ZNVw,4823
 genie/libs/sdk/triggers/shutnoshut/bgp/iosxr/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/shutnoshut/bgp/iosxr/shutnoshut.py,sha256=S8pxpWoV40lRsekoKA0Zy5FGq86bmtzJzTRdrbxULCk,4012
+genie/libs/sdk/triggers/shutnoshut/bgp/iosxr/shutnoshut.py,sha256=TwGlB_PyU7m_V6mhcs0H3hoc9T7vcuJkt4o5t_o3L_0,5590
 genie/libs/sdk/triggers/shutnoshut/bgp/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
 genie/libs/sdk/triggers/shutnoshut/interface/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-genie/libs/sdk/triggers/shutnoshut/interface/shutnoshut.py,sha256=a2PAiePuxk76TPEm0NYd60Kv0JGaYLg6od6QxCyaISM,14043
+genie/libs/sdk/triggers/shutnoshut/interface/shutnoshut.py,sha256=ZnIwz8nPplCucZ8FqAe1syWSlh5iO7-3hDNoDDlzGEY,15752
 genie/libs/sdk/triggers/shutnoshut/interface/iosxe/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/shutnoshut/interface/iosxe/shutnoshut.py,sha256=KSlAQNm3EcZTXkL-K-qqQTPZs4NV2K0WF8aKj9vx5qQ,28431
+genie/libs/sdk/triggers/shutnoshut/interface/iosxe/shutnoshut.py,sha256=i9QMq1x7a2Lb5DkmgT9knwLE8DLdVO7Qlv-WeJfni0U,44787
 genie/libs/sdk/triggers/shutnoshut/interface/iosxr/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/shutnoshut/interface/iosxr/shutnoshut.py,sha256=Rk5Jm_AODzywXI3jjGzZNP6z_RI1KeaYlHXcmfhiNKE,2166
+genie/libs/sdk/triggers/shutnoshut/interface/iosxr/shutnoshut.py,sha256=G_s8f8j_UP20eEpCEV2LR2DLr2YYGU_trTH79QLUiow,4613
 genie/libs/sdk/triggers/shutnoshut/interface/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/shutnoshut/interface/nxos/shutnoshut.py,sha256=KtNacpxhJB57-kfNb8kRifmHMQdxlmZwGN2d1-v75r8,59829
+genie/libs/sdk/triggers/shutnoshut/interface/nxos/shutnoshut.py,sha256=eMeIQgI3qudsk2pRxAjGfUeLEKmnIw5oixmtieQ42FQ,63521
 genie/libs/sdk/triggers/shutnoshut/msdp/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/shutnoshut/msdp/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/shutnoshut/msdp/nxos/shutnoshut.py,sha256=GhyfMy_LNjb_2lYm1dMt2HMvQ4CImiS5bixUtALx2Q4,3900
+genie/libs/sdk/triggers/shutnoshut/msdp/nxos/shutnoshut.py,sha256=DuwS4QhsWrnN0tplN-9Z1_eE-eikOub43h3ea11fxzw,4308
 genie/libs/sdk/triggers/shutnoshut/vlan/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/shutnoshut/vlan/shutnoshut.py,sha256=jVWhYOQaU6LHiaxtLmOSbi65I7UsZWsBpZGXL4CXlsM,266
 genie/libs/sdk/triggers/shutnoshut/vlan/iosxe/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/shutnoshut/vlan/iosxe/shutnoshut.py,sha256=D5-AABoNOg7VpUorfljrkmSluJAlHFIVxJqV0wXJgOA,3360
+genie/libs/sdk/triggers/shutnoshut/vlan/iosxe/shutnoshut.py,sha256=rpTNepdYdVlLf4TS_s3kd2faRedmbK88-SS3e6EofUY,3728
 genie/libs/sdk/triggers/shutnoshut/vlan/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/shutnoshut/vlan/nxos/shutnoshut.py,sha256=iSwZ8w72n_vYKFhAiHTQsq2-aRV1-97wobmmSj7o3fg,3376
+genie/libs/sdk/triggers/shutnoshut/vlan/nxos/shutnoshut.py,sha256=jnP_8WJH_XsqH6WqlZk5NI61igz554DQzPFdSjZgsV4,3744
 genie/libs/sdk/triggers/shutnoshut/vxlan/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/shutnoshut/vxlan/shutnoshut.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/shutnoshut/vxlan/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/shutnoshut/vxlan/nxos/shutnoshut.py,sha256=aeMhoRlV4x9_HVMuIg7StKEJooG2DhM5fpe3aN05YMc,9009
+genie/libs/sdk/triggers/shutnoshut/vxlan/nxos/shutnoshut.py,sha256=bfqv1Kce5gJuEz_HZTfQyOPq24DYm6ucvYzR4D2AT6M,9829
 genie/libs/sdk/triggers/sleep/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/sleep/sleep.py,sha256=R-LJhHK_kqyJcukn8-wn-tpwX_pA0CLrWcIVBgSUNYw,886
 genie/libs/sdk/triggers/template/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/template/addremove.py,sha256=-aeaXPQNRKXV2VGLsdJZucukL_dZOnbr12kuG9-4L-w,1313
 genie/libs/sdk/triggers/template/checkcommands.py,sha256=FzaHLY0Y0G8b3gLmIQX69su2goSBd0DVLbLvj_5NXB0,954
 genie/libs/sdk/triggers/template/clear.py,sha256=Ql4ye6YP9TGtczRVuH94N2k-iTKgMTw3E0uucnNsVTY,655
 genie/libs/sdk/triggers/template/disableenable.py,sha256=nJWxUe6b6wz_wxi-mzVXIAggUi0Z42J-T-k9yzi5IKE,2847
 genie/libs/sdk/triggers/template/ha.py,sha256=o_x9g3Ao6PfoGJXGDpZFqQR5f1jcBvYyiOUf7BS73MY,2722
 genie/libs/sdk/triggers/template/modify.py,sha256=yjneArnOVZ8ZhhP39rao51O2ewiSFLENEp3IAm-TtUg,1394
 genie/libs/sdk/triggers/template/processrestart.py,sha256=lPC3Z_5pRz2bT8I9GVQ_lf0IPggHq2MzDiTqR6PtBKg,769
 genie/libs/sdk/triggers/template/shutnoshut.py,sha256=LPQGDv-cKDIQ-SHoYohayYXcNiNZXGHXyNeIh1fz0-g,1262
 genie/libs/sdk/triggers/template/sleep.py,sha256=Zs3kdf0z25LBHe1AUliI_PeBJHhwHDPIw44T6SbGsVM,328
 genie/libs/sdk/triggers/template/unconfigconfig.py,sha256=l_oNPjmlPiSI5nTiSsqsv-_UhAXlgPEG0-uKjCNXqJ0,1425
 genie/libs/sdk/triggers/unconfigconfig/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-genie/libs/sdk/triggers/unconfigconfig/unconfigconfig.py,sha256=jebv2biRoGpmtSnImh-mmebVhFQw7mtkT0t8QeutUTY,5784
+genie/libs/sdk/triggers/unconfigconfig/unconfigconfig.py,sha256=a_029eKhIixjsvTLWrhXvu_pHaD9TJjFwVE1U5EXQHw,5760
 genie/libs/sdk/triggers/unconfigconfig/bgp/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-genie/libs/sdk/triggers/unconfigconfig/bgp/unconfigconfig.py,sha256=6MToDgR-VucF9HmH3BznTtjbCpXYzKbtY6wN4HSr1gc,8410
+genie/libs/sdk/triggers/unconfigconfig/bgp/unconfigconfig.py,sha256=PSFh76boIfGK6JYUGqB7FxblAN6cbO81DvAtE4zv5ks,9264
 genie/libs/sdk/triggers/unconfigconfig/bgp/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/unconfigconfig/bgp/nxos/unconfigconfig.py,sha256=sl1GhJ6619cwipGWalYU5X1w6BfaCyK-R77SjOyEf3A,112324
+genie/libs/sdk/triggers/unconfigconfig/bgp/nxos/unconfigconfig.py,sha256=0hN2AGh3zmgEaqFyZNhrxy_emODlC5phwzZM8vKoUmY,127165
 genie/libs/sdk/triggers/unconfigconfig/igmp/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/unconfigconfig/igmp/unconfigconfig.py,sha256=KlkWJjGTmtVSoGHmOpxykOtHkNNHoRhwulwmrnDEAFk,234
 genie/libs/sdk/triggers/unconfigconfig/igmp/nxos/__init__.py,sha256=rvPOsFHryY1JWdcRhihSEaFCNai4rkztqb7RVB3I9Lg,257
-genie/libs/sdk/triggers/unconfigconfig/igmp/nxos/unconfigconfig.py,sha256=CPhQibuaRJI3QZDx4Zc6KuT01aVMD3UplhetvK5w7xk,20436
+genie/libs/sdk/triggers/unconfigconfig/igmp/nxos/unconfigconfig.py,sha256=0EmJKfDubKVWYwU8o3XJk5E4e2CXXFW0lVfiWL5irBA,25980
 genie/libs/sdk/triggers/unconfigconfig/interface/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-genie/libs/sdk/triggers/unconfigconfig/interface/unconfigconfig.py,sha256=Nf_nnfH15TKIipV7kXAq9eXiiP_an9_HRjccN42OwOs,25955
+genie/libs/sdk/triggers/unconfigconfig/interface/unconfigconfig.py,sha256=2D_MmMItI8_VpdvgNCDdKJ-brUGQBWmwGzPCIrNrorc,27862
 genie/libs/sdk/triggers/unconfigconfig/interface/iosxe/__init__.py,sha256=rvPOsFHryY1JWdcRhihSEaFCNai4rkztqb7RVB3I9Lg,257
-genie/libs/sdk/triggers/unconfigconfig/interface/iosxe/unconfigconfig.py,sha256=ZsD0HnliWnuT1qG0gqzy5hofzTE3Rb3NqUuHZZJrc-Y,9059
+genie/libs/sdk/triggers/unconfigconfig/interface/iosxe/unconfigconfig.py,sha256=S6r6NzwbxBIHmNUsifku0_Gwrvz953l6HzcE2dXxiTQ,19872
 genie/libs/sdk/triggers/unconfigconfig/interface/iosxr/__init__.py,sha256=rvPOsFHryY1JWdcRhihSEaFCNai4rkztqb7RVB3I9Lg,257
-genie/libs/sdk/triggers/unconfigconfig/interface/iosxr/unconfigconfig.py,sha256=HIgQDgx1khu1UiLGyX4IpJuvKhxsRogLo_dr6neQB5g,2890
+genie/libs/sdk/triggers/unconfigconfig/interface/iosxr/unconfigconfig.py,sha256=0SK5jZyiGyyaVkFG0wRsPWy2NoDVr28bQlS28Hhpzig,6028
 genie/libs/sdk/triggers/unconfigconfig/interface/nxos/__init__.py,sha256=rvPOsFHryY1JWdcRhihSEaFCNai4rkztqb7RVB3I9Lg,257
-genie/libs/sdk/triggers/unconfigconfig/interface/nxos/unconfigconfig.py,sha256=hkyiRye9OG4PK9fPiouajuQ8wRvrTl1AFE3Ln4eV7iA,45993
+genie/libs/sdk/triggers/unconfigconfig/interface/nxos/unconfigconfig.py,sha256=kCOb2eljgUuYYi5rRZVfvNCrl-6Fms-FL7Kbac1C6AA,47270
 genie/libs/sdk/triggers/unconfigconfig/mld/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/unconfigconfig/mld/unconfigconfig.py,sha256=0SJZj2OrdTuX_L9EKN-7opozZG164PyD7PSHcr48s8U,226
 genie/libs/sdk/triggers/unconfigconfig/mld/nxos/__init__.py,sha256=rvPOsFHryY1JWdcRhihSEaFCNai4rkztqb7RVB3I9Lg,257
-genie/libs/sdk/triggers/unconfigconfig/mld/nxos/unconfigconfig.py,sha256=qzIoNT1ou_KJ5v9eVhDzo6letbSBkzHjourV3yMZnF0,20374
+genie/libs/sdk/triggers/unconfigconfig/mld/nxos/unconfigconfig.py,sha256=izy9TuSh67iEhU9oG3952WZ1hTHTKCZ7yqUubcctjm0,25935
 genie/libs/sdk/triggers/unconfigconfig/msdp/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/unconfigconfig/msdp/unconfigconfig.py,sha256=9DIZ_jAtnHh9_Wl_tDtlXTY9qxvBUWEA46xXr8APnd8,830
 genie/libs/sdk/triggers/unconfigconfig/msdp/nxos/__init__.py,sha256=rvPOsFHryY1JWdcRhihSEaFCNai4rkztqb7RVB3I9Lg,257
-genie/libs/sdk/triggers/unconfigconfig/msdp/nxos/unconfigconfig.py,sha256=iIPkGimrvdJAEdLaXWqydIPSoedl41i0cSaJ_03jN98,43046
+genie/libs/sdk/triggers/unconfigconfig/msdp/nxos/unconfigconfig.py,sha256=Z3lqG05LxzkZtScz6ZcmJGZlNIhgbsuVxqD1hd3rXmk,47250
 genie/libs/sdk/triggers/unconfigconfig/pim/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/unconfigconfig/pim/unconfigconfig.py,sha256=EzBBZaN63ICkguqQaZbT3dFeE2KYtqlTgadva2z5Fzo,233
 genie/libs/sdk/triggers/unconfigconfig/pim/nxos/__init__.py,sha256=rvPOsFHryY1JWdcRhihSEaFCNai4rkztqb7RVB3I9Lg,257
-genie/libs/sdk/triggers/unconfigconfig/pim/nxos/unconfigconfig.py,sha256=a7gjapPmxrrXy38-r3r0fiQYNx4dt9ZCkN7_klMd8uk,5204
+genie/libs/sdk/triggers/unconfigconfig/pim/nxos/unconfigconfig.py,sha256=UHvS-4OyjHL--epbMk7I3hnIofhHzXHt0O8IX741wmE,5798
 genie/libs/sdk/triggers/unconfigconfig/trm/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/unconfigconfig/trm/unconfigconfig.py,sha256=-WKg_YaRnXmdEX10U10ImqrMkWRXCasFIsnbV6h_fck,53
 genie/libs/sdk/triggers/unconfigconfig/trm/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/unconfigconfig/trm/nxos/unconfigconfig.py,sha256=RXOh_vzSoN4XsjbvMXj157br8knyEmPhmPaK6jJyu9c,13230
+genie/libs/sdk/triggers/unconfigconfig/trm/nxos/unconfigconfig.py,sha256=jpD-z7RuAg-gHxKz_3nQvWW6cwuid9Ff8pTgF8HdHRM,14856
 genie/libs/sdk/triggers/unconfigconfig/vlan/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/unconfigconfig/vlan/unconfigconfig.py,sha256=H8wF5uk-5VafPG5vgNk2Eno5g8tc7F3Y7RmiPkxss8A,2652
 genie/libs/sdk/triggers/unconfigconfig/vlan/iosxe/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/unconfigconfig/vlan/iosxe/unconfigconfig.py,sha256=YQqaqeZ1AbUshn7-2ncxlQHac9L5hJBAIRDZaSg2dBQ,3892
+genie/libs/sdk/triggers/unconfigconfig/vlan/iosxe/unconfigconfig.py,sha256=yXguYh0iMlGBbsGyIjtu_fZlMQyubjvoxhRNo2oQLH0,4322
 genie/libs/sdk/triggers/unconfigconfig/vlan/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/unconfigconfig/vlan/nxos/unconfigconfig.py,sha256=OKJEDKsJP_uVDFXbyzsavWCSqHcOBsCjsaXecHmEvt8,7687
+genie/libs/sdk/triggers/unconfigconfig/vlan/nxos/unconfigconfig.py,sha256=RBq08h1dSw1As_e_mlA9H-daWqOcMqDQiejA7BMPOGU,8505
 genie/libs/sdk/triggers/unconfigconfig/vxlan/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/unconfigconfig/vxlan/unconfigconfig.py,sha256=DDZunNLTpUGmBUK5MSvcztf3zroxev1VQydgXhR-LPA,302
 genie/libs/sdk/triggers/unconfigconfig/vxlan/nxos/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie/libs/sdk/triggers/unconfigconfig/vxlan/nxos/unconfigconfig.py,sha256=8BIpaQMoFTCmEiwSJvjbXeIWvuxstY0SHjXtku2-c2I,57717
+genie/libs/sdk/triggers/unconfigconfig/vxlan/nxos/unconfigconfig.py,sha256=IX8sdNzEZH4LU1fWfXyvD7Dg2b3TtWjINlpLNrD01Yo,63027
 genie/libs/sdk/triggers/xe_sanity/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/xe_sanity/configurations.py,sha256=r2AJY8SByQpn4D8BhL6E68QMx8g8TSZlCLYgPUD93KM,65291
 genie/libs/sdk/triggers/xe_sanity/checkcommands/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/xe_sanity/checkcommands/checkcommands.py,sha256=J1J6B3JxsVE0TSdyQCw7p1r9W24M09sdZGsOGswySmI,322
 genie/libs/sdk/triggers/xe_sanity/checkcommands/iosxe/__init__.py,sha256=B7GvaT0CwM5aCN-yZ0Xb82YWSfIUqiyg_pwx3-Ysl-8,184
 genie/libs/sdk/triggers/xe_sanity/checkcommands/iosxe/checkcommands.py,sha256=fr0-7_NnRdulNt6gLS_8ZZFTDTVMC5N33ZhMhvYtjBk,32870
 genie/libs/sdk/triggers/xe_sanity/checkcommands/libs/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/triggers/xe_sanity/checkcommands/libs/iosxe/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
 genie/libs/sdk/triggers/xe_sanity/checkcommands/libs/iosxe/checkcommands.py,sha256=5a_Pst13ovnKU26QJo7IABvTZsZQWEUmyJq7bPmPpOQ,10217
 genie/libs/sdk/verifications/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/verifications/ospf/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 genie/libs/sdk/verifications/ospf/iosxe/__init__.py,sha256=3UsKKx5M1W3I3XyKcHkiF9FYGt-NusoGgnSCDqP2RjA,256
-genie.libs.sdk-3.1.8.data/data/genie_yamls/__init__.py,sha256=RGoi0g8hft9NvLZEgX4RpZQ8nQALVjnx1FiyVbx85j4,990
-genie.libs.sdk-3.1.8.data/data/genie_yamls/pts_datafile.yaml,sha256=OhvV0zzJYOs_uuQtRqYnxeBREqIoiprzatRRLaOPLPE,6136
-genie.libs.sdk-3.1.8.data/data/genie_yamls/subsection_datafile.yaml,sha256=mP0fOoTkpF02BW8kIeENhIP-DaQmkGVJaO0Cm8OCdDk,1241
-genie.libs.sdk-3.1.8.data/data/genie_yamls/trigger_datafile.yaml,sha256=NX7-oDCFXkktagPKsPN5ZcFB86eU9A8TGLXl5OJEEPE,64550
-genie.libs.sdk-3.1.8.data/data/genie_yamls/verification_datafile.yaml,sha256=WfU2bMSqH9n8ix8jIr39F66Y6nKX7iOhz7ryuen1ZLs,78843
-genie.libs.sdk-3.1.8.data/data/genie_yamls/ios/trigger_datafile_ios.yaml,sha256=9HOQo15D5z2QgQ9oSwEYWByiBGPB52i2CrVU32fPBtk,683
-genie.libs.sdk-3.1.8.data/data/genie_yamls/ios/verification_datafile_ios.yaml,sha256=No4K6klXQ9-1a2hlYvBL1DRvKy5-D9iT9RH-Ku2WhlM,1803
-genie.libs.sdk-3.1.8.data/data/genie_yamls/iosxe/trigger_datafile_iosxe.yaml,sha256=Y3FRni2H6YdW7surNuNEQExT6spBU0LkzE2cE6amFhI,12379
-genie.libs.sdk-3.1.8.data/data/genie_yamls/iosxe/verification_datafile_iosxe.yaml,sha256=i61BGEqdw9k8Rrme_jnIaFdNu-PsIkWppOFtrh_98WM,15358
-genie.libs.sdk-3.1.8.data/data/genie_yamls/iosxr/trigger_datafile_xr.yaml,sha256=E5sSAj99r__KuVCYYSWvoxverR5FoCSNlU5soRJwKJk,6365
-genie.libs.sdk-3.1.8.data/data/genie_yamls/iosxr/verification_datafile_xr.yaml,sha256=bpim5bLb_vWDueUO2cbrLf2gy5V2ORhN7xA5AM1nDQI,15374
-genie.libs.sdk-3.1.8.data/data/genie_yamls/junos/trigger_datafile_junos.yaml,sha256=CraR3-XBNEofAlCydSJIGn0U3GRVZMMvOB3RT2q6XVs,172
-genie.libs.sdk-3.1.8.data/data/genie_yamls/junos/verification_datafile_junos.yaml,sha256=FhNhRhMj2M0wN2rmx6_JZQ1vf-nyTlewGAGJtcSQbfw,617
-genie.libs.sdk-3.1.8.data/data/genie_yamls/nxos/trigger_datafile_nxos.yaml,sha256=kRe8E6juiO-rBeCEcnJsptrkj2qRnR5Qn9czg32LWqs,85023
-genie.libs.sdk-3.1.8.data/data/genie_yamls/nxos/verification_datafile_nxos.yaml,sha256=khSNj4jCVLGzDVUspPQSX9EvoIJH4OROk_LmLi27w9o,36037
-genie.libs.sdk-3.1.8.data/data/genie_yamls/tools/verification_generator/datafiles_maker.py,sha256=5hKqQv8CZ2kujFFeK2fQHVyD8mWaBEO1-T8WQLMiWOc,17544
-genie.libs.sdk-3.1.8.data/data/genie_yamls/tools/verification_generator/differ.py,sha256=9XADBVB-m5i1NIOLTahOXXLn6r-ToZh7SMOPAmfNan0,906
-genie.libs.sdk-3.1.8.data/data/genie_yamls/tools/verification_generator/parsers.yaml,sha256=5_MxgEgB304I4c8acuz1B9n4immH99f2Ss6cE5COyEQ,5792
-genie.libs.sdk-3.1.8.dist-info/METADATA,sha256=ZiUS2nlIOxKk62_q_jmxTuoSVbydEAauctBp14u3koE,3210
-genie.libs.sdk-3.1.8.dist-info/RECORD,,
-genie.libs.sdk-3.1.8.dist-info/WHEEL,sha256=NzFAKnL7g-U64xnS1s5e3mJnxKpOTeOtlXdFwS9yNXI,92
-genie.libs.sdk-3.1.8.dist-info/namespace_packages.txt,sha256=k0OxVAETbf7Ou2EqqjuxO-JdrIdJtxZsUDHdrIkrOFE,17
-genie.libs.sdk-3.1.8.dist-info/top_level.txt,sha256=EW4swMMBmuGW5VFCUGsl828kVUhrmMZJGHXfzmOidSg,6
+genie.libs.sdk-3.1.9.data/data/genie_yamls/__init__.py,sha256=RGoi0g8hft9NvLZEgX4RpZQ8nQALVjnx1FiyVbx85j4,990
+genie.libs.sdk-3.1.9.data/data/genie_yamls/pts_datafile.yaml,sha256=v2H5Vu3ES4uDxe_0EyEH9Y25TfDm5s1RjTugSIWH_Nk,6138
+genie.libs.sdk-3.1.9.data/data/genie_yamls/subsection_datafile.yaml,sha256=mP0fOoTkpF02BW8kIeENhIP-DaQmkGVJaO0Cm8OCdDk,1241
+genie.libs.sdk-3.1.9.data/data/genie_yamls/trigger_datafile.yaml,sha256=NX7-oDCFXkktagPKsPN5ZcFB86eU9A8TGLXl5OJEEPE,64550
+genie.libs.sdk-3.1.9.data/data/genie_yamls/verification_datafile.yaml,sha256=WfU2bMSqH9n8ix8jIr39F66Y6nKX7iOhz7ryuen1ZLs,78843
+genie.libs.sdk-3.1.9.data/data/genie_yamls/ios/trigger_datafile_ios.yaml,sha256=9HOQo15D5z2QgQ9oSwEYWByiBGPB52i2CrVU32fPBtk,683
+genie.libs.sdk-3.1.9.data/data/genie_yamls/ios/verification_datafile_ios.yaml,sha256=No4K6klXQ9-1a2hlYvBL1DRvKy5-D9iT9RH-Ku2WhlM,1803
+genie.libs.sdk-3.1.9.data/data/genie_yamls/iosxe/trigger_datafile_iosxe.yaml,sha256=Y3FRni2H6YdW7surNuNEQExT6spBU0LkzE2cE6amFhI,12379
+genie.libs.sdk-3.1.9.data/data/genie_yamls/iosxe/verification_datafile_iosxe.yaml,sha256=i61BGEqdw9k8Rrme_jnIaFdNu-PsIkWppOFtrh_98WM,15358
+genie.libs.sdk-3.1.9.data/data/genie_yamls/iosxr/trigger_datafile_xr.yaml,sha256=E5sSAj99r__KuVCYYSWvoxverR5FoCSNlU5soRJwKJk,6365
+genie.libs.sdk-3.1.9.data/data/genie_yamls/iosxr/verification_datafile_xr.yaml,sha256=bpim5bLb_vWDueUO2cbrLf2gy5V2ORhN7xA5AM1nDQI,15374
+genie.libs.sdk-3.1.9.data/data/genie_yamls/junos/trigger_datafile_junos.yaml,sha256=CraR3-XBNEofAlCydSJIGn0U3GRVZMMvOB3RT2q6XVs,172
+genie.libs.sdk-3.1.9.data/data/genie_yamls/junos/verification_datafile_junos.yaml,sha256=FhNhRhMj2M0wN2rmx6_JZQ1vf-nyTlewGAGJtcSQbfw,617
+genie.libs.sdk-3.1.9.data/data/genie_yamls/nxos/trigger_datafile_nxos.yaml,sha256=kRe8E6juiO-rBeCEcnJsptrkj2qRnR5Qn9czg32LWqs,85023
+genie.libs.sdk-3.1.9.data/data/genie_yamls/nxos/verification_datafile_nxos.yaml,sha256=khSNj4jCVLGzDVUspPQSX9EvoIJH4OROk_LmLi27w9o,36037
+genie.libs.sdk-3.1.9.data/data/genie_yamls/tools/verification_generator/datafiles_maker.py,sha256=5hKqQv8CZ2kujFFeK2fQHVyD8mWaBEO1-T8WQLMiWOc,17544
+genie.libs.sdk-3.1.9.data/data/genie_yamls/tools/verification_generator/differ.py,sha256=9XADBVB-m5i1NIOLTahOXXLn6r-ToZh7SMOPAmfNan0,906
+genie.libs.sdk-3.1.9.data/data/genie_yamls/tools/verification_generator/parsers.yaml,sha256=5_MxgEgB304I4c8acuz1B9n4immH99f2Ss6cE5COyEQ,5792
+genie.libs.sdk-3.1.9.dist-info/METADATA,sha256=kc5464tYLnmqmuK8UOCIQYRzdjBe2j4v3FgqEyJmu7Y,3210
+genie.libs.sdk-3.1.9.dist-info/RECORD,,
+genie.libs.sdk-3.1.9.dist-info/WHEEL,sha256=FRuHuBX28RTgsOL603qIpbSc2WeDgbsFBWKj9XFOCpg,92
+genie.libs.sdk-3.1.9.dist-info/namespace_packages.txt,sha256=k0OxVAETbf7Ou2EqqjuxO-JdrIdJtxZsUDHdrIkrOFE,17
+genie.libs.sdk-3.1.9.dist-info/top_level.txt,sha256=EW4swMMBmuGW5VFCUGsl828kVUhrmMZJGHXfzmOidSg,6
```


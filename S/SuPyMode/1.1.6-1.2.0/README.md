# Comparing `tmp/SuPyMode-1.1.6-cp312-cp312-win_amd64.whl.zip` & `tmp/SuPyMode-1.2.0-cp312-cp312-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,156 +1,144 @@
-Zip file size: 3122146 bytes, number of entries: 154
--rw-rw-rw-  2.0 fat        7 b- defN 24-Feb-07 21:23 SuPyMode/VERSION
--rw-rw-rw-  2.0 fat     1726 b- defN 24-Feb-07 21:23 SuPyMode/__debug__.py
--rw-rw-rw-  2.0 fat       38 b- defN 24-Feb-07 21:23 SuPyMode/__init__.py
--rw-rw-rw-  2.0 fat    25526 b- defN 24-Feb-07 21:23 SuPyMode/profiles.py
--rw-rw-rw-  2.0 fat    10053 b- defN 24-Feb-07 21:23 SuPyMode/solver.py
--rw-rw-rw-  2.0 fat     8645 b- defN 24-Feb-07 21:23 SuPyMode/supermode.py
--rw-rw-rw-  2.0 fat    39037 b- defN 24-Feb-07 21:23 SuPyMode/superset.py
--rw-rw-rw-  2.0 fat    13700 b- defN 24-Feb-07 21:23 SuPyMode/workflow.py
--rw-rw-rw-  2.0 fat      215 b- defN 24-Feb-07 21:29 SuPyMode/__pycache__/__init__.cpython-311.pyc
--rw-rw-rw-  2.0 fat    32063 b- defN 24-Feb-07 21:29 SuPyMode/__pycache__/profiles.cpython-311.pyc
--rw-rw-rw-  2.0 fat    11879 b- defN 24-Feb-07 21:29 SuPyMode/__pycache__/solver.cpython-311.pyc
--rw-rw-rw-  2.0 fat    11812 b- defN 24-Feb-07 21:29 SuPyMode/__pycache__/supermode.cpython-311.pyc
--rw-rw-rw-  2.0 fat    48753 b- defN 24-Feb-07 21:29 SuPyMode/__pycache__/superset.cpython-311.pyc
--rw-rw-rw-  2.0 fat    14777 b- defN 24-Feb-07 21:29 SuPyMode/__pycache__/workflow.cpython-311.pyc
--rw-rw-rw-  2.0 fat  1513984 b- defN 24-Feb-07 21:27 SuPyMode/binary/CppSolver.cp311-win_amd64.pyd
--rw-rw-rw-  2.0 fat  1515520 b- defN 24-Feb-07 21:40 SuPyMode/binary/CppSolver.cp312-win_amd64.pyd
--rw-rw-rw-  2.0 fat  1093632 b- defN 24-Feb-07 21:27 SuPyMode/binary/ModelParameters.cp311-win_amd64.pyd
--rw-rw-rw-  2.0 fat  1092096 b- defN 24-Feb-07 21:40 SuPyMode/binary/ModelParameters.cp312-win_amd64.pyd
--rw-rw-rw-  2.0 fat  1141248 b- defN 24-Feb-07 21:27 SuPyMode/binary/SuperMode.cp311-win_amd64.pyd
--rw-rw-rw-  2.0 fat  1140736 b- defN 24-Feb-07 21:40 SuPyMode/binary/SuperMode.cp312-win_amd64.pyd
--rw-rw-rw-  2.0 fat        2 b- defN 24-Feb-07 21:23 SuPyMode/binary/__init__.py
--rw-rw-rw-  2.0 fat      159 b- defN 24-Feb-07 21:29 SuPyMode/binary/__pycache__/__init__.cpython-311.pyc
--rw-rw-rw-  2.0 fat        0 b- defN 24-Feb-07 21:23 SuPyMode/python_debuging/__init__.py
--rw-rw-rw-  2.0 fat    11485 b- defN 24-Feb-07 21:23 SuPyMode/python_debuging/eigen_solver.py
--rw-rw-rw-  2.0 fat    13021 b- defN 24-Feb-07 21:23 SuPyMode/python_debuging/mode_solver.py
--rw-rw-rw-  2.0 fat      253 b- defN 24-Feb-07 21:23 SuPyMode/representation/__init__.py
--rw-rw-rw-  2.0 fat     2684 b- defN 24-Feb-07 21:23 SuPyMode/representation/adiabatic.py
--rw-rw-rw-  2.0 fat     4205 b- defN 24-Feb-07 21:23 SuPyMode/representation/base.py
--rw-rw-rw-  2.0 fat     2192 b- defN 24-Feb-07 21:23 SuPyMode/representation/beating_length.py
--rw-rw-rw-  2.0 fat     1423 b- defN 24-Feb-07 21:23 SuPyMode/representation/beta.py
--rw-rw-rw-  2.0 fat     1418 b- defN 24-Feb-07 21:23 SuPyMode/representation/eigen_value.py
--rw-rw-rw-  2.0 fat    11075 b- defN 24-Feb-07 21:23 SuPyMode/representation/field.py
--rw-rw-rw-  2.0 fat     1448 b- defN 24-Feb-07 21:23 SuPyMode/representation/index.py
--rw-rw-rw-  2.0 fat     2451 b- defN 24-Feb-07 21:23 SuPyMode/representation/normalized_coupling.py
--rw-rw-rw-  2.0 fat      583 b- defN 24-Feb-07 21:29 SuPyMode/representation/__pycache__/__init__.cpython-311.pyc
--rw-rw-rw-  2.0 fat     3783 b- defN 24-Feb-07 21:29 SuPyMode/representation/__pycache__/adiabatic.cpython-311.pyc
--rw-rw-rw-  2.0 fat     7632 b- defN 24-Feb-07 21:29 SuPyMode/representation/__pycache__/base.cpython-311.pyc
--rw-rw-rw-  2.0 fat     3290 b- defN 24-Feb-07 21:29 SuPyMode/representation/__pycache__/beating_length.cpython-311.pyc
--rw-rw-rw-  2.0 fat     2471 b- defN 24-Feb-07 21:29 SuPyMode/representation/__pycache__/beta.cpython-311.pyc
--rw-rw-rw-  2.0 fat     2497 b- defN 24-Feb-07 21:29 SuPyMode/representation/__pycache__/eigen_value.cpython-311.pyc
--rw-rw-rw-  2.0 fat    13763 b- defN 24-Feb-07 21:29 SuPyMode/representation/__pycache__/field.cpython-311.pyc
--rw-rw-rw-  2.0 fat     2513 b- defN 24-Feb-07 21:29 SuPyMode/representation/__pycache__/index.cpython-311.pyc
--rw-rw-rw-  2.0 fat     3561 b- defN 24-Feb-07 21:29 SuPyMode/representation/__pycache__/normalized_coupling.cpython-311.pyc
--rw-rw-rw-  2.0 fat        0 b- defN 24-Feb-07 21:23 SuPyMode/tools/__init__.py
--rw-rw-rw-  2.0 fat     1315 b- defN 24-Feb-07 21:23 SuPyMode/tools/directories.py
--rw-rw-rw-  2.0 fat     1780 b- defN 24-Feb-07 21:23 SuPyMode/tools/mode_label.py
--rw-rw-rw-  2.0 fat     4775 b- defN 24-Feb-07 21:23 SuPyMode/tools/special.py
--rw-rw-rw-  2.0 fat     5858 b- defN 24-Feb-07 21:23 SuPyMode/tools/utils.py
--rw-rw-rw-  2.0 fat      158 b- defN 24-Feb-07 21:29 SuPyMode/tools/__pycache__/__init__.cpython-311.pyc
--rw-rw-rw-  2.0 fat     1903 b- defN 24-Feb-07 21:29 SuPyMode/tools/__pycache__/directories.cpython-311.pyc
--rw-rw-rw-  2.0 fat     3274 b- defN 24-Feb-07 21:29 SuPyMode/tools/__pycache__/mode_label.cpython-311.pyc
--rw-rw-rw-  2.0 fat     8282 b- defN 24-Feb-07 21:29 SuPyMode/tools/__pycache__/utils.cpython-311.pyc
--rw-rw-rw-  2.0 fat     4073 b- defN 24-Feb-07 21:23 SuPyMode/validation_data/SBB_figure_4_16_a/LP01-LP02.csv
--rw-rw-rw-  2.0 fat     3640 b- defN 24-Feb-07 21:23 SuPyMode/validation_data/SBB_figure_4_16_a/LP01-LP21.csv
--rw-rw-rw-  2.0 fat     3552 b- defN 24-Feb-07 21:23 SuPyMode/validation_data/SBB_figure_4_16_a/LP01-LP41.csv
--rw-rw-rw-  2.0 fat     3435 b- defN 24-Feb-07 21:23 SuPyMode/validation_data/SBB_figure_4_16_a/LP11-LP12.csv
--rw-rw-rw-  2.0 fat     3871 b- defN 24-Feb-07 21:23 SuPyMode/validation_data/SBB_figure_4_16_a/LP11-LP31.csv
--rw-rw-rw-  2.0 fat     3351 b- defN 24-Feb-07 21:23 SuPyMode/validation_data/SBB_figure_4_16_a/LP11-LP51.csv
--rw-rw-rw-  2.0 fat    11801 b- defN 24-Feb-07 21:23 SuPyMode/validation_data/SBB_figure_4_16_b/LP01-LP02.csv
--rw-rw-rw-  2.0 fat     3180 b- defN 24-Feb-07 21:23 SuPyMode/validation_data/SBB_figure_4_16_b/LP01-LP21.csv
--rw-rw-rw-  2.0 fat     9766 b- defN 24-Feb-07 21:23 SuPyMode/validation_data/SBB_figure_4_16_b/LP01-LP41.csv
--rw-rw-rw-  2.0 fat     5278 b- defN 24-Feb-07 21:23 SuPyMode/validation_data/SBB_figure_4_16_b/LP11-LP12.csv
--rw-rw-rw-  2.0 fat     6584 b- defN 24-Feb-07 21:23 SuPyMode/validation_data/SBB_figure_4_16_b/LP11-LP31.csv
--rw-rw-rw-  2.0 fat     9280 b- defN 24-Feb-07 21:23 SuPyMode/validation_data/SBB_figure_4_16_b/LP11-LP51.csv
--rw-rw-rw-  2.0 fat      694 b- defN 24-Feb-07 21:23 docs/examples/basic/plot_alpha_profile_0.py
--rw-rw-rw-  2.0 fat      685 b- defN 24-Feb-07 21:23 docs/examples/basic/plot_alpha_profile_1.py
--rw-rw-rw-  2.0 fat     3117 b- defN 24-Feb-07 21:23 docs/examples/basic/plot_workflow_01.py
--rw-rw-rw-  2.0 fat     3195 b- defN 24-Feb-07 21:23 docs/examples/basic/plot_workflow_02.py
--rw-rw-rw-  2.0 fat     3326 b- defN 24-Feb-07 21:23 docs/examples/basic/plot_workflow_03.py
--rw-rw-rw-  2.0 fat     3244 b- defN 24-Feb-07 21:23 docs/examples/basic/plot_workflow_04.py
--rw-rw-rw-  2.0 fat     3615 b- defN 24-Feb-07 21:23 docs/examples/basic/plot_workflow_05.py
--rw-rw-rw-  2.0 fat     3699 b- defN 24-Feb-07 21:23 docs/examples/basic/plot_workflow_06.py
--rw-rw-rw-  2.0 fat     3321 b- defN 24-Feb-07 21:23 docs/examples/basic/plot_workflow_07.py
--rw-rw-rw-  2.0 fat     3300 b- defN 24-Feb-07 21:23 docs/examples/basic/plot_workflow_08.py
--rw-rw-rw-  2.0 fat     3588 b- defN 24-Feb-07 21:23 docs/examples/validation/plot_beta_DCF.py
--rw-rw-rw-  2.0 fat     3581 b- defN 24-Feb-07 21:23 docs/examples/validation/plot_beta_SMF28.py
--rw-rw-rw-  2.0 fat     3683 b- defN 24-Feb-07 21:23 docs/examples/validation/plot_normalized_coupling_DCF.py
--rw-rw-rw-  2.0 fat     3672 b- defN 24-Feb-07 21:23 docs/examples/validation/plot_normalized_coupling_SMF28.py
--rw-rw-rw-  2.0 fat     4485 b- defN 24-Feb-07 21:23 docs/source/conf.py
--rw-rw-rw-  2.0 fat       23 b- defN 24-Feb-07 21:23 extern/eigen/debug/gdb/__init__.py
--rw-rw-rw-  2.0 fat     9931 b- defN 24-Feb-07 21:23 extern/eigen/debug/gdb/printers.py
--rw-rw-rw-  2.0 fat     2437 b- defN 24-Feb-07 21:23 extern/eigen/scripts/relicense.py
--rw-rw-rw-  2.0 fat     2853 b- defN 24-Feb-07 21:23 extern/pybind11/noxfile.py
--rw-rw-rw-  2.0 fat     5005 b- defN 24-Feb-07 21:23 extern/pybind11/setup.py
--rw-rw-rw-  2.0 fat     2940 b- defN 24-Feb-07 21:23 extern/pybind11/docs/benchmark.py
--rw-rw-rw-  2.0 fat    11942 b- defN 24-Feb-07 21:23 extern/pybind11/docs/conf.py
--rw-rw-rw-  2.0 fat      446 b- defN 24-Feb-07 21:23 extern/pybind11/pybind11/__init__.py
--rw-rw-rw-  2.0 fat     1606 b- defN 24-Feb-07 21:23 extern/pybind11/pybind11/__main__.py
--rw-rw-rw-  2.0 fat      245 b- defN 24-Feb-07 21:23 extern/pybind11/pybind11/_version.py
--rw-rw-rw-  2.0 fat     1244 b- defN 24-Feb-07 21:23 extern/pybind11/pybind11/commands.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-Feb-07 21:23 extern/pybind11/pybind11/py.typed
--rw-rw-rw-  2.0 fat    17992 b- defN 24-Feb-07 21:23 extern/pybind11/pybind11/setup_helpers.py
--rw-rw-rw-  2.0 fat     5840 b- defN 24-Feb-07 21:23 extern/pybind11/tests/conftest.py
--rw-rw-rw-  2.0 fat      953 b- defN 24-Feb-07 21:23 extern/pybind11/tests/env.py
--rw-rw-rw-  2.0 fat      560 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_async.py
--rw-rw-rw-  2.0 fat     7352 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_buffers.py
--rw-rw-rw-  2.0 fat    17771 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_builtin_casters.py
--rw-rw-rw-  2.0 fat     6796 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_call_policies.py
--rw-rw-rw-  2.0 fat     7180 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_callbacks.py
--rw-rw-rw-  2.0 fat     5896 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_chrono.py
--rw-rw-rw-  2.0 fat    15686 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_class.py
--rw-rw-rw-  2.0 fat      622 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_const_name.py
--rw-rw-rw-  2.0 fat     1607 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_constants_and_functions.py
--rw-rw-rw-  2.0 fat     4928 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_copy_move.py
--rw-rw-rw-  2.0 fat     4114 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_custom_type_casters.py
--rw-rw-rw-  2.0 fat     1139 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_custom_type_setup.py
--rw-rw-rw-  2.0 fat     2487 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_docstring_options.py
--rw-rw-rw-  2.0 fat    29962 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_eigen_matrix.py
--rw-rw-rw-  2.0 fat     9702 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_eigen_tensor.py
--rw-rw-rw-  2.0 fat     9338 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_enum.py
--rw-rw-rw-  2.0 fat     1193 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_eval.py
--rw-rw-rw-  2.0 fat      123 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_eval_call.py
--rw-rw-rw-  2.0 fat    14586 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_exceptions.py
--rw-rw-rw-  2.0 fat    17007 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_factory_constructors.py
--rw-rw-rw-  2.0 fat     8749 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_gil_scoped.py
--rw-rw-rw-  2.0 fat     7435 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_iostream.py
--rw-rw-rw-  2.0 fat    15281 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_kwargs_and_defaults.py
--rw-rw-rw-  2.0 fat     8311 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_local_bindings.py
--rw-rw-rw-  2.0 fat    18963 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_methods_and_attributes.py
--rw-rw-rw-  2.0 fat     4079 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_modules.py
--rw-rw-rw-  2.0 fat    12367 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_multiple_inheritance.py
--rw-rw-rw-  2.0 fat    23560 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_numpy_array.py
--rw-rw-rw-  2.0 fat    14712 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_numpy_dtypes.py
--rw-rw-rw-  2.0 fat     9924 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_numpy_vectorize.py
--rw-rw-rw-  2.0 fat     1905 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_opaque_types.py
--rw-rw-rw-  2.0 fat     4483 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_operator_overloading.py
--rw-rw-rw-  2.0 fat     2813 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_pickling.py
--rw-rw-rw-  2.0 fat      894 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_python_multiple_inheritance.py
--rw-rw-rw-  2.0 fat    26013 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_pytypes.py
--rw-rw-rw-  2.0 fat     8924 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_sequences_and_iterators.py
--rw-rw-rw-  2.0 fat     9845 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_smart_ptr.py
--rw-rw-rw-  2.0 fat    12688 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_stl.py
--rw-rw-rw-  2.0 fat    10150 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_stl_binders.py
--rw-rw-rw-  2.0 fat      769 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_tagbased_polymorphic.py
--rw-rw-rw-  2.0 fat      868 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_thread.py
--rw-rw-rw-  2.0 fat     3364 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_type_caster_pyobject_ptr.py
--rw-rw-rw-  2.0 fat      156 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_union.py
--rw-rw-rw-  2.0 fat     1175 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_unnamed_namespace_a.py
--rw-rw-rw-  2.0 fat      148 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_unnamed_namespace_b.py
--rw-rw-rw-  2.0 fat      343 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_vector_unique_ptr_member.py
--rw-rw-rw-  2.0 fat    13371 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_virtual_functions.py
--rw-rw-rw-  2.0 fat     8774 b- defN 24-Feb-07 21:23 extern/pybind11/tests/extra_python_package/test_files.py
--rw-rw-rw-  2.0 fat     4304 b- defN 24-Feb-07 21:23 extern/pybind11/tests/extra_setuptools/test_setuphelper.py
--rw-rw-rw-  2.0 fat      206 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_cmake_build/test.py
--rw-rw-rw-  2.0 fat      251 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_embed/test_interpreter.py
--rw-rw-rw-  2.0 fat      291 b- defN 24-Feb-07 21:23 extern/pybind11/tests/test_embed/test_trampoline.py
--rw-rw-rw-  2.0 fat     1156 b- defN 24-Feb-07 21:23 extern/pybind11/tools/codespell_ignore_lines_from_errors.py
--rw-rw-rw-  2.0 fat     1067 b- defN 24-Feb-07 21:23 extern/pybind11/tools/libsize.py
--rw-rw-rw-  2.0 fat     2135 b- defN 24-Feb-07 21:23 extern/pybind11/tools/make_changelog.py
--rw-rw-rw-  2.0 fat     1093 b- defN 24-Feb-07 21:40 SuPyMode-1.1.6.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     5698 b- defN 24-Feb-07 21:40 SuPyMode-1.1.6.dist-info/METADATA
--rw-rw-rw-  2.0 fat      102 b- defN 24-Feb-07 21:40 SuPyMode-1.1.6.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       60 b- defN 24-Feb-07 21:40 SuPyMode-1.1.6.dist-info/top_level.txt
--rw-rw-r--  2.0 fat    15198 b- defN 24-Feb-07 21:40 SuPyMode-1.1.6.dist-info/RECORD
-154 files, 8432848 bytes uncompressed, 3097480 bytes compressed:  63.3%
+Zip file size: 3863015 bytes, number of entries: 142
+-rw-rw-rw-  2.0 fat        7 b- defN 24-May-29 17:34 SuPyMode/VERSION
+-rw-rw-rw-  2.0 fat       52 b- defN 24-May-29 17:34 SuPyMode/__init__.py
+-rw-rw-rw-  2.0 fat     1165 b- defN 24-May-29 17:34 SuPyMode/directories.py
+-rw-rw-rw-  2.0 fat     5219 b- defN 24-May-29 17:34 SuPyMode/mode_label.py
+-rw-rw-rw-  2.0 fat    31102 b- defN 24-May-29 17:34 SuPyMode/profiles.py
+-rw-rw-rw-  2.0 fat     9049 b- defN 24-May-29 17:34 SuPyMode/solver.py
+-rw-rw-rw-  2.0 fat     4775 b- defN 24-May-29 17:34 SuPyMode/special.py
+-rw-rw-rw-  2.0 fat    10578 b- defN 24-May-29 17:34 SuPyMode/supermode.py
+-rw-rw-rw-  2.0 fat    41698 b- defN 24-May-29 17:34 SuPyMode/superset.py
+-rw-rw-rw-  2.0 fat     9808 b- defN 24-May-29 17:34 SuPyMode/utils.py
+-rw-rw-rw-  2.0 fat    14653 b- defN 24-May-29 17:34 SuPyMode/workflow.py
+-rw-rw-rw-  2.0 fat  1485312 b- defN 24-May-29 17:37 SuPyMode/binary/CppSolver.cp311-win_amd64.pyd
+-rw-rw-rw-  2.0 fat  1483776 b- defN 24-May-29 17:42 SuPyMode/binary/CppSolver.cp312-win_amd64.pyd
+-rw-rw-rw-  2.0 fat  1078272 b- defN 24-May-29 17:37 SuPyMode/binary/Example.cp311-win_amd64.pyd
+-rw-rw-rw-  2.0 fat  1078272 b- defN 24-May-29 17:42 SuPyMode/binary/Example.cp312-win_amd64.pyd
+-rw-rw-rw-  2.0 fat  1122816 b- defN 24-May-29 17:37 SuPyMode/binary/ModelParameters.cp311-win_amd64.pyd
+-rw-rw-rw-  2.0 fat  1123328 b- defN 24-May-29 17:42 SuPyMode/binary/ModelParameters.cp312-win_amd64.pyd
+-rw-rw-rw-  2.0 fat  1157120 b- defN 24-May-29 17:37 SuPyMode/binary/SuperMode.cp311-win_amd64.pyd
+-rw-rw-rw-  2.0 fat  1156608 b- defN 24-May-29 17:42 SuPyMode/binary/SuperMode.cp312-win_amd64.pyd
+-rw-rw-rw-  2.0 fat        2 b- defN 24-May-29 17:34 SuPyMode/binary/__init__.py
+-rw-rw-rw-  2.0 fat      253 b- defN 24-May-29 17:34 SuPyMode/representation/__init__.py
+-rw-rw-rw-  2.0 fat     3964 b- defN 24-May-29 17:34 SuPyMode/representation/adiabatic.py
+-rw-rw-rw-  2.0 fat     4205 b- defN 24-May-29 17:34 SuPyMode/representation/base.py
+-rw-rw-rw-  2.0 fat     3473 b- defN 24-May-29 17:34 SuPyMode/representation/beating_length.py
+-rw-rw-rw-  2.0 fat     2762 b- defN 24-May-29 17:34 SuPyMode/representation/beta.py
+-rw-rw-rw-  2.0 fat     2501 b- defN 24-May-29 17:34 SuPyMode/representation/eigen_value.py
+-rw-rw-rw-  2.0 fat    12984 b- defN 24-May-29 17:34 SuPyMode/representation/field.py
+-rw-rw-rw-  2.0 fat     2667 b- defN 24-May-29 17:34 SuPyMode/representation/index.py
+-rw-rw-rw-  2.0 fat     3831 b- defN 24-May-29 17:34 SuPyMode/representation/normalized_coupling.py
+-rw-rw-rw-  2.0 fat        0 b- defN 24-May-29 17:34 SuPyMode/tools/__init__.py
+-rw-rw-rw-  2.0 fat     4775 b- defN 24-May-29 17:34 SuPyMode/tools/special.py
+-rw-rw-rw-  2.0 fat     8943 b- defN 24-May-29 17:34 SuPyMode/tools/utils.py
+-rw-rw-rw-  2.0 fat     4073 b- defN 24-May-29 17:34 SuPyMode/validation_data/SBB_figure_4_16_a/LP01-LP02.csv
+-rw-rw-rw-  2.0 fat     3640 b- defN 24-May-29 17:34 SuPyMode/validation_data/SBB_figure_4_16_a/LP01-LP21.csv
+-rw-rw-rw-  2.0 fat     3552 b- defN 24-May-29 17:34 SuPyMode/validation_data/SBB_figure_4_16_a/LP01-LP41.csv
+-rw-rw-rw-  2.0 fat     3435 b- defN 24-May-29 17:34 SuPyMode/validation_data/SBB_figure_4_16_a/LP11-LP12.csv
+-rw-rw-rw-  2.0 fat     3871 b- defN 24-May-29 17:34 SuPyMode/validation_data/SBB_figure_4_16_a/LP11-LP31.csv
+-rw-rw-rw-  2.0 fat     3351 b- defN 24-May-29 17:34 SuPyMode/validation_data/SBB_figure_4_16_a/LP11-LP51.csv
+-rw-rw-rw-  2.0 fat    11801 b- defN 24-May-29 17:34 SuPyMode/validation_data/SBB_figure_4_16_b/LP01-LP02.csv
+-rw-rw-rw-  2.0 fat     3180 b- defN 24-May-29 17:34 SuPyMode/validation_data/SBB_figure_4_16_b/LP01-LP21.csv
+-rw-rw-rw-  2.0 fat     9766 b- defN 24-May-29 17:34 SuPyMode/validation_data/SBB_figure_4_16_b/LP01-LP41.csv
+-rw-rw-rw-  2.0 fat     5278 b- defN 24-May-29 17:34 SuPyMode/validation_data/SBB_figure_4_16_b/LP11-LP12.csv
+-rw-rw-rw-  2.0 fat     6584 b- defN 24-May-29 17:34 SuPyMode/validation_data/SBB_figure_4_16_b/LP11-LP31.csv
+-rw-rw-rw-  2.0 fat     9280 b- defN 24-May-29 17:34 SuPyMode/validation_data/SBB_figure_4_16_b/LP11-LP51.csv
+-rw-rw-rw-  2.0 fat     1129 b- defN 24-May-29 17:34 developments/gradient_tests_2.py
+-rw-rw-rw-  2.0 fat     4038 b- defN 24-May-29 17:34 developments/validation.py
+-rw-rw-rw-  2.0 fat     4045 b- defN 24-May-29 17:34 developments/validation_2.py
+-rw-rw-rw-  2.0 fat      718 b- defN 24-May-29 17:34 docs/examples/basic/plot_alpha_profile_0.py
+-rw-rw-rw-  2.0 fat      757 b- defN 24-May-29 17:34 docs/examples/basic/plot_alpha_profile_1.py
+-rw-rw-rw-  2.0 fat     3117 b- defN 24-May-29 17:34 docs/examples/basic/plot_workflow_01.py
+-rw-rw-rw-  2.0 fat     3195 b- defN 24-May-29 17:34 docs/examples/basic/plot_workflow_02.py
+-rw-rw-rw-  2.0 fat     3644 b- defN 24-May-29 17:34 docs/examples/basic/plot_workflow_03.py
+-rw-rw-rw-  2.0 fat     3244 b- defN 24-May-29 17:34 docs/examples/basic/plot_workflow_04.py
+-rw-rw-rw-  2.0 fat     3615 b- defN 24-May-29 17:34 docs/examples/basic/plot_workflow_05.py
+-rw-rw-rw-  2.0 fat     3699 b- defN 24-May-29 17:34 docs/examples/basic/plot_workflow_06.py
+-rw-rw-rw-  2.0 fat     3321 b- defN 24-May-29 17:34 docs/examples/basic/plot_workflow_07.py
+-rw-rw-rw-  2.0 fat     3300 b- defN 24-May-29 17:34 docs/examples/basic/plot_workflow_08.py
+-rw-rw-rw-  2.0 fat     3580 b- defN 24-May-29 17:34 docs/examples/validation/plot_beta_DCF.py
+-rw-rw-rw-  2.0 fat     3573 b- defN 24-May-29 17:34 docs/examples/validation/plot_beta_SMF28.py
+-rw-rw-rw-  2.0 fat     3743 b- defN 24-May-29 17:34 docs/examples/validation/plot_normalized_coupling_DCF.py
+-rw-rw-rw-  2.0 fat     3912 b- defN 24-May-29 17:34 docs/examples/validation/plot_normalized_coupling_SMF28.py
+-rw-rw-rw-  2.0 fat     5878 b- defN 24-May-29 17:34 docs/examples/validation/plot_validation.py
+-rw-rw-rw-  2.0 fat     1726 b- defN 24-May-29 17:34 docs/legacy/__debug__.py
+-rw-rw-rw-  2.0 fat        0 b- defN 24-May-29 17:34 docs/legacy/python_debuging/__init__.py
+-rw-rw-rw-  2.0 fat    11485 b- defN 24-May-29 17:34 docs/legacy/python_debuging/eigen_solver.py
+-rw-rw-rw-  2.0 fat    13021 b- defN 24-May-29 17:34 docs/legacy/python_debuging/mode_solver.py
+-rw-rw-rw-  2.0 fat     4479 b- defN 24-May-29 17:34 docs/source/conf.py
+-rw-rw-rw-  2.0 fat       23 b- defN 24-May-29 17:34 extern/eigen/debug/gdb/__init__.py
+-rw-rw-rw-  2.0 fat     9931 b- defN 24-May-29 17:34 extern/eigen/debug/gdb/printers.py
+-rw-rw-rw-  2.0 fat     2437 b- defN 24-May-29 17:34 extern/eigen/scripts/relicense.py
+-rw-rw-rw-  2.0 fat     2853 b- defN 24-May-29 17:34 extern/pybind11/noxfile.py
+-rw-rw-rw-  2.0 fat     5005 b- defN 24-May-29 17:34 extern/pybind11/setup.py
+-rw-rw-rw-  2.0 fat     2940 b- defN 24-May-29 17:34 extern/pybind11/docs/benchmark.py
+-rw-rw-rw-  2.0 fat    11942 b- defN 24-May-29 17:34 extern/pybind11/docs/conf.py
+-rw-rw-rw-  2.0 fat      446 b- defN 24-May-29 17:34 extern/pybind11/pybind11/__init__.py
+-rw-rw-rw-  2.0 fat     1606 b- defN 24-May-29 17:34 extern/pybind11/pybind11/__main__.py
+-rw-rw-rw-  2.0 fat      245 b- defN 24-May-29 17:34 extern/pybind11/pybind11/_version.py
+-rw-rw-rw-  2.0 fat     1244 b- defN 24-May-29 17:34 extern/pybind11/pybind11/commands.py
+-rw-rw-rw-  2.0 fat        0 b- defN 24-May-29 17:34 extern/pybind11/pybind11/py.typed
+-rw-rw-rw-  2.0 fat    17992 b- defN 24-May-29 17:34 extern/pybind11/pybind11/setup_helpers.py
+-rw-rw-rw-  2.0 fat     5840 b- defN 24-May-29 17:34 extern/pybind11/tests/conftest.py
+-rw-rw-rw-  2.0 fat      953 b- defN 24-May-29 17:34 extern/pybind11/tests/env.py
+-rw-rw-rw-  2.0 fat      560 b- defN 24-May-29 17:34 extern/pybind11/tests/test_async.py
+-rw-rw-rw-  2.0 fat     7352 b- defN 24-May-29 17:34 extern/pybind11/tests/test_buffers.py
+-rw-rw-rw-  2.0 fat    17771 b- defN 24-May-29 17:34 extern/pybind11/tests/test_builtin_casters.py
+-rw-rw-rw-  2.0 fat     6796 b- defN 24-May-29 17:34 extern/pybind11/tests/test_call_policies.py
+-rw-rw-rw-  2.0 fat     7180 b- defN 24-May-29 17:34 extern/pybind11/tests/test_callbacks.py
+-rw-rw-rw-  2.0 fat     5896 b- defN 24-May-29 17:34 extern/pybind11/tests/test_chrono.py
+-rw-rw-rw-  2.0 fat    15686 b- defN 24-May-29 17:34 extern/pybind11/tests/test_class.py
+-rw-rw-rw-  2.0 fat      622 b- defN 24-May-29 17:34 extern/pybind11/tests/test_const_name.py
+-rw-rw-rw-  2.0 fat     1607 b- defN 24-May-29 17:34 extern/pybind11/tests/test_constants_and_functions.py
+-rw-rw-rw-  2.0 fat     4928 b- defN 24-May-29 17:34 extern/pybind11/tests/test_copy_move.py
+-rw-rw-rw-  2.0 fat     4114 b- defN 24-May-29 17:34 extern/pybind11/tests/test_custom_type_casters.py
+-rw-rw-rw-  2.0 fat     1139 b- defN 24-May-29 17:34 extern/pybind11/tests/test_custom_type_setup.py
+-rw-rw-rw-  2.0 fat     2487 b- defN 24-May-29 17:34 extern/pybind11/tests/test_docstring_options.py
+-rw-rw-rw-  2.0 fat    29962 b- defN 24-May-29 17:34 extern/pybind11/tests/test_eigen_matrix.py
+-rw-rw-rw-  2.0 fat     9702 b- defN 24-May-29 17:34 extern/pybind11/tests/test_eigen_tensor.py
+-rw-rw-rw-  2.0 fat     9338 b- defN 24-May-29 17:34 extern/pybind11/tests/test_enum.py
+-rw-rw-rw-  2.0 fat     1193 b- defN 24-May-29 17:34 extern/pybind11/tests/test_eval.py
+-rw-rw-rw-  2.0 fat      123 b- defN 24-May-29 17:34 extern/pybind11/tests/test_eval_call.py
+-rw-rw-rw-  2.0 fat    14586 b- defN 24-May-29 17:34 extern/pybind11/tests/test_exceptions.py
+-rw-rw-rw-  2.0 fat    17007 b- defN 24-May-29 17:34 extern/pybind11/tests/test_factory_constructors.py
+-rw-rw-rw-  2.0 fat     8749 b- defN 24-May-29 17:34 extern/pybind11/tests/test_gil_scoped.py
+-rw-rw-rw-  2.0 fat     7435 b- defN 24-May-29 17:34 extern/pybind11/tests/test_iostream.py
+-rw-rw-rw-  2.0 fat    15281 b- defN 24-May-29 17:34 extern/pybind11/tests/test_kwargs_and_defaults.py
+-rw-rw-rw-  2.0 fat     8311 b- defN 24-May-29 17:34 extern/pybind11/tests/test_local_bindings.py
+-rw-rw-rw-  2.0 fat    18963 b- defN 24-May-29 17:34 extern/pybind11/tests/test_methods_and_attributes.py
+-rw-rw-rw-  2.0 fat     4079 b- defN 24-May-29 17:34 extern/pybind11/tests/test_modules.py
+-rw-rw-rw-  2.0 fat    12367 b- defN 24-May-29 17:34 extern/pybind11/tests/test_multiple_inheritance.py
+-rw-rw-rw-  2.0 fat    23560 b- defN 24-May-29 17:34 extern/pybind11/tests/test_numpy_array.py
+-rw-rw-rw-  2.0 fat    14712 b- defN 24-May-29 17:34 extern/pybind11/tests/test_numpy_dtypes.py
+-rw-rw-rw-  2.0 fat     9924 b- defN 24-May-29 17:34 extern/pybind11/tests/test_numpy_vectorize.py
+-rw-rw-rw-  2.0 fat     1905 b- defN 24-May-29 17:34 extern/pybind11/tests/test_opaque_types.py
+-rw-rw-rw-  2.0 fat     4483 b- defN 24-May-29 17:34 extern/pybind11/tests/test_operator_overloading.py
+-rw-rw-rw-  2.0 fat     2813 b- defN 24-May-29 17:34 extern/pybind11/tests/test_pickling.py
+-rw-rw-rw-  2.0 fat      894 b- defN 24-May-29 17:34 extern/pybind11/tests/test_python_multiple_inheritance.py
+-rw-rw-rw-  2.0 fat    26013 b- defN 24-May-29 17:34 extern/pybind11/tests/test_pytypes.py
+-rw-rw-rw-  2.0 fat     8924 b- defN 24-May-29 17:34 extern/pybind11/tests/test_sequences_and_iterators.py
+-rw-rw-rw-  2.0 fat     9845 b- defN 24-May-29 17:34 extern/pybind11/tests/test_smart_ptr.py
+-rw-rw-rw-  2.0 fat    12688 b- defN 24-May-29 17:34 extern/pybind11/tests/test_stl.py
+-rw-rw-rw-  2.0 fat    10150 b- defN 24-May-29 17:34 extern/pybind11/tests/test_stl_binders.py
+-rw-rw-rw-  2.0 fat      769 b- defN 24-May-29 17:34 extern/pybind11/tests/test_tagbased_polymorphic.py
+-rw-rw-rw-  2.0 fat      868 b- defN 24-May-29 17:34 extern/pybind11/tests/test_thread.py
+-rw-rw-rw-  2.0 fat     3364 b- defN 24-May-29 17:34 extern/pybind11/tests/test_type_caster_pyobject_ptr.py
+-rw-rw-rw-  2.0 fat      156 b- defN 24-May-29 17:34 extern/pybind11/tests/test_union.py
+-rw-rw-rw-  2.0 fat     1175 b- defN 24-May-29 17:34 extern/pybind11/tests/test_unnamed_namespace_a.py
+-rw-rw-rw-  2.0 fat      148 b- defN 24-May-29 17:34 extern/pybind11/tests/test_unnamed_namespace_b.py
+-rw-rw-rw-  2.0 fat      343 b- defN 24-May-29 17:34 extern/pybind11/tests/test_vector_unique_ptr_member.py
+-rw-rw-rw-  2.0 fat    13371 b- defN 24-May-29 17:34 extern/pybind11/tests/test_virtual_functions.py
+-rw-rw-rw-  2.0 fat     8774 b- defN 24-May-29 17:34 extern/pybind11/tests/extra_python_package/test_files.py
+-rw-rw-rw-  2.0 fat     4304 b- defN 24-May-29 17:34 extern/pybind11/tests/extra_setuptools/test_setuphelper.py
+-rw-rw-rw-  2.0 fat      206 b- defN 24-May-29 17:34 extern/pybind11/tests/test_cmake_build/test.py
+-rw-rw-rw-  2.0 fat      251 b- defN 24-May-29 17:34 extern/pybind11/tests/test_embed/test_interpreter.py
+-rw-rw-rw-  2.0 fat      291 b- defN 24-May-29 17:34 extern/pybind11/tests/test_embed/test_trampoline.py
+-rw-rw-rw-  2.0 fat     1156 b- defN 24-May-29 17:34 extern/pybind11/tools/codespell_ignore_lines_from_errors.py
+-rw-rw-rw-  2.0 fat     1067 b- defN 24-May-29 17:34 extern/pybind11/tools/libsize.py
+-rw-rw-rw-  2.0 fat     2135 b- defN 24-May-29 17:34 extern/pybind11/tools/make_changelog.py
+-rw-rw-rw-  2.0 fat     1093 b- defN 24-May-29 17:42 SuPyMode-1.2.0.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     5624 b- defN 24-May-29 17:42 SuPyMode-1.2.0.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      102 b- defN 24-May-29 17:42 SuPyMode-1.2.0.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       73 b- defN 24-May-29 17:42 SuPyMode-1.2.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat    13695 b- defN 24-May-29 17:42 SuPyMode-1.2.0.dist-info/RECORD
+142 files, 10502567 bytes uncompressed, 3840907 bytes compressed:  63.4%
```

## zipnote {}

```diff
@@ -1,53 +1,50 @@
 Filename: SuPyMode/VERSION
 Comment: 
 
-Filename: SuPyMode/__debug__.py
-Comment: 
-
 Filename: SuPyMode/__init__.py
 Comment: 
 
-Filename: SuPyMode/profiles.py
+Filename: SuPyMode/directories.py
 Comment: 
 
-Filename: SuPyMode/solver.py
+Filename: SuPyMode/mode_label.py
 Comment: 
 
-Filename: SuPyMode/supermode.py
+Filename: SuPyMode/profiles.py
 Comment: 
 
-Filename: SuPyMode/superset.py
+Filename: SuPyMode/solver.py
 Comment: 
 
-Filename: SuPyMode/workflow.py
+Filename: SuPyMode/special.py
 Comment: 
 
-Filename: SuPyMode/__pycache__/__init__.cpython-311.pyc
+Filename: SuPyMode/supermode.py
 Comment: 
 
-Filename: SuPyMode/__pycache__/profiles.cpython-311.pyc
+Filename: SuPyMode/superset.py
 Comment: 
 
-Filename: SuPyMode/__pycache__/solver.cpython-311.pyc
+Filename: SuPyMode/utils.py
 Comment: 
 
-Filename: SuPyMode/__pycache__/supermode.cpython-311.pyc
+Filename: SuPyMode/workflow.py
 Comment: 
 
-Filename: SuPyMode/__pycache__/superset.cpython-311.pyc
+Filename: SuPyMode/binary/CppSolver.cp311-win_amd64.pyd
 Comment: 
 
-Filename: SuPyMode/__pycache__/workflow.cpython-311.pyc
+Filename: SuPyMode/binary/CppSolver.cp312-win_amd64.pyd
 Comment: 
 
-Filename: SuPyMode/binary/CppSolver.cp311-win_amd64.pyd
+Filename: SuPyMode/binary/Example.cp311-win_amd64.pyd
 Comment: 
 
-Filename: SuPyMode/binary/CppSolver.cp312-win_amd64.pyd
+Filename: SuPyMode/binary/Example.cp312-win_amd64.pyd
 Comment: 
 
 Filename: SuPyMode/binary/ModelParameters.cp311-win_amd64.pyd
 Comment: 
 
 Filename: SuPyMode/binary/ModelParameters.cp312-win_amd64.pyd
 Comment: 
@@ -57,26 +54,14 @@
 
 Filename: SuPyMode/binary/SuperMode.cp312-win_amd64.pyd
 Comment: 
 
 Filename: SuPyMode/binary/__init__.py
 Comment: 
 
-Filename: SuPyMode/binary/__pycache__/__init__.cpython-311.pyc
-Comment: 
-
-Filename: SuPyMode/python_debuging/__init__.py
-Comment: 
-
-Filename: SuPyMode/python_debuging/eigen_solver.py
-Comment: 
-
-Filename: SuPyMode/python_debuging/mode_solver.py
-Comment: 
-
 Filename: SuPyMode/representation/__init__.py
 Comment: 
 
 Filename: SuPyMode/representation/adiabatic.py
 Comment: 
 
 Filename: SuPyMode/representation/base.py
@@ -96,68 +81,23 @@
 
 Filename: SuPyMode/representation/index.py
 Comment: 
 
 Filename: SuPyMode/representation/normalized_coupling.py
 Comment: 
 
-Filename: SuPyMode/representation/__pycache__/__init__.cpython-311.pyc
-Comment: 
-
-Filename: SuPyMode/representation/__pycache__/adiabatic.cpython-311.pyc
-Comment: 
-
-Filename: SuPyMode/representation/__pycache__/base.cpython-311.pyc
-Comment: 
-
-Filename: SuPyMode/representation/__pycache__/beating_length.cpython-311.pyc
-Comment: 
-
-Filename: SuPyMode/representation/__pycache__/beta.cpython-311.pyc
-Comment: 
-
-Filename: SuPyMode/representation/__pycache__/eigen_value.cpython-311.pyc
-Comment: 
-
-Filename: SuPyMode/representation/__pycache__/field.cpython-311.pyc
-Comment: 
-
-Filename: SuPyMode/representation/__pycache__/index.cpython-311.pyc
-Comment: 
-
-Filename: SuPyMode/representation/__pycache__/normalized_coupling.cpython-311.pyc
-Comment: 
-
 Filename: SuPyMode/tools/__init__.py
 Comment: 
 
-Filename: SuPyMode/tools/directories.py
-Comment: 
-
-Filename: SuPyMode/tools/mode_label.py
-Comment: 
-
 Filename: SuPyMode/tools/special.py
 Comment: 
 
 Filename: SuPyMode/tools/utils.py
 Comment: 
 
-Filename: SuPyMode/tools/__pycache__/__init__.cpython-311.pyc
-Comment: 
-
-Filename: SuPyMode/tools/__pycache__/directories.cpython-311.pyc
-Comment: 
-
-Filename: SuPyMode/tools/__pycache__/mode_label.cpython-311.pyc
-Comment: 
-
-Filename: SuPyMode/tools/__pycache__/utils.cpython-311.pyc
-Comment: 
-
 Filename: SuPyMode/validation_data/SBB_figure_4_16_a/LP01-LP02.csv
 Comment: 
 
 Filename: SuPyMode/validation_data/SBB_figure_4_16_a/LP01-LP21.csv
 Comment: 
 
 Filename: SuPyMode/validation_data/SBB_figure_4_16_a/LP01-LP41.csv
@@ -186,14 +126,23 @@
 
 Filename: SuPyMode/validation_data/SBB_figure_4_16_b/LP11-LP31.csv
 Comment: 
 
 Filename: SuPyMode/validation_data/SBB_figure_4_16_b/LP11-LP51.csv
 Comment: 
 
+Filename: developments/gradient_tests_2.py
+Comment: 
+
+Filename: developments/validation.py
+Comment: 
+
+Filename: developments/validation_2.py
+Comment: 
+
 Filename: docs/examples/basic/plot_alpha_profile_0.py
 Comment: 
 
 Filename: docs/examples/basic/plot_alpha_profile_1.py
 Comment: 
 
 Filename: docs/examples/basic/plot_workflow_01.py
@@ -228,14 +177,29 @@
 
 Filename: docs/examples/validation/plot_normalized_coupling_DCF.py
 Comment: 
 
 Filename: docs/examples/validation/plot_normalized_coupling_SMF28.py
 Comment: 
 
+Filename: docs/examples/validation/plot_validation.py
+Comment: 
+
+Filename: docs/legacy/__debug__.py
+Comment: 
+
+Filename: docs/legacy/python_debuging/__init__.py
+Comment: 
+
+Filename: docs/legacy/python_debuging/eigen_solver.py
+Comment: 
+
+Filename: docs/legacy/python_debuging/mode_solver.py
+Comment: 
+
 Filename: docs/source/conf.py
 Comment: 
 
 Filename: extern/eigen/debug/gdb/__init__.py
 Comment: 
 
 Filename: extern/eigen/debug/gdb/printers.py
@@ -441,23 +405,23 @@
 
 Filename: extern/pybind11/tools/libsize.py
 Comment: 
 
 Filename: extern/pybind11/tools/make_changelog.py
 Comment: 
 
-Filename: SuPyMode-1.1.6.dist-info/LICENSE
+Filename: SuPyMode-1.2.0.dist-info/LICENSE
 Comment: 
 
-Filename: SuPyMode-1.1.6.dist-info/METADATA
+Filename: SuPyMode-1.2.0.dist-info/METADATA
 Comment: 
 
-Filename: SuPyMode-1.1.6.dist-info/WHEEL
+Filename: SuPyMode-1.2.0.dist-info/WHEEL
 Comment: 
 
-Filename: SuPyMode-1.1.6.dist-info/top_level.txt
+Filename: SuPyMode-1.2.0.dist-info/top_level.txt
 Comment: 
 
-Filename: SuPyMode-1.1.6.dist-info/RECORD
+Filename: SuPyMode-1.2.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## SuPyMode/VERSION

```diff
@@ -1 +1 @@
-1.1.6
+1.2.0
```

## SuPyMode/__init__.py

```diff
@@ -1 +1 @@
-from .tools.utils import load_superset
+from .utils import load_superset  # noqa: F401, W292
```

## SuPyMode/profiles.py

```diff
@@ -1,129 +1,175 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
 
+from typing import Tuple, Callable
 import numpy
 from scipy.interpolate import interp1d
 import matplotlib.pyplot as plt
 
 from SuPyMode import representation
 from MPSPlots.render2D import SceneList, Axis
 from matplotlib.animation import FuncAnimation, PillowWriter
 
 from dataclasses import dataclass, field
 
 
 @dataclass
 class TaperSection():
+    """
+    A class to represent a taper section in optical fiber simulations.
+
+    Attributes:
+        z_array (np.ndarray): The array of longitudinal positions along the taper (z-coordinates).
+        radius_array (np.ndarray): The array of taper radii corresponding to the z positions.
+        heating_length_initial (float, optional): The initial heating length of the taper section.
+        heating_length_final (float, optional): The final heating length of the taper section.
+
+    Properties:
+        z_initial (float): Returns the initial z position of the taper.
+        z_final (float): Returns the final z position of the taper.
+        radius_initial (float): Returns the initial radius at the start of the taper.
+        radius_final (float): Returns the radius at the end of the taper.
+        is_constant (bool): Determines if the taper's radius is constant throughout.
+        interpolation (callable): Provides an interpolation function for the radius over z.
+    """
+
     z_array: numpy.ndarray
     radius_array: numpy.ndarray
     heating_length_initial: float = None
     heating_length_final: float = None
 
     @property
     def z_initial(self) -> float:
+        """ Returns the initial z-coordinate of the taper section. """
         return self.z_array[0]
 
     @property
     def is_constant(self) -> float:
+        """ Checks if the taper section's radius remains constant over its length. """
         return self.radius_array[0] == self.radius_array[-1]
 
     @property
     def z_final(self) -> float:
+        """ Returns the final z-coordinate of the taper section. """
         return self.z_array[-1]
 
     @property
     def radius_initial(self) -> float:
+        """ Returns the initial radius of the taper section. """
         return self.radius_array[0]
 
     @property
     def radius_final(self) -> float:
+        """ Returns the final radius of the taper section. """
         return self.radius_array[-1]
 
     @property
     def interpolation(self):
+        """
+        Provides an interpolation function for radius as a function of z-coordinate.
+
+        Returns:
+            interp1d: An interpolator that estimates the radius at any z within the bounds
+                      of z_array, with extrapolation set to zero outside the bounds.
+        """
         return interp1d(
             x=self.z_array,
             y=self.radius_array,
             bounds_error=False,
             fill_value=0
         )
 
 
 @dataclass
 class AlphaProfile():
     r"""
-    Class represent the fiber structure coupler z-profile.
-    This particular class is set to a Gaussian profile.
+    Represents a Gaussian profile for an optical fiber coupler.
 
     Translation table from article to class:
         - :math:`rho_w` = radius_segment
         - :math:`rho_0` = initial_radius
         - :math:`l_w` = heating_length_segment
         - :math:`x_0` = stretching_length
+
+    Attributes:
+        initial_radius (float): Initial radius of the taper structure, defaults to 1.
+        n_point (int): Number of points for differential equation resolution, recommended 200+.
+        symmetric (bool): If true, the taper structure is considered symmetric about z.
+        label (str): Label for the profile, used in plotting.
+        add_end_of_taper_section (bool): If true, adds a constant section at the end of the taper.
+        line_color (str): Line color for plots, not part of the main data model.
+        line_style (str): Line style for plots, not part of the main data model.
     """
     initial_radius: float = 1
-    """ Initial radius of the taper structure """
     n_point: int = 200
-    """ Number of point for solving the differential equation for the ITR vs distance. Keep it high [200+]"""
     symmetric: bool = False
-    """ Bolean to defined if the taper structure is z-symmetric """
     label: str = 'profile'
-    """ Label of the profile, shown as label of plots """
     add_end_of_taper_section: bool = True
-    """ Define if constant section is added at end of taper """
     line_color: str = field(default='black', repr=False)
-    """ Color of the lines for the plots """
     line_style: str = field(default='--', repr=False)
-    """ Style of the lines for the plots """
 
     def __post_init__(self):
+        """
+        Initialize the section list after the dataclass fields are set. This method
+        prepares the profile object for further operations such as adding sections
+        or computing properties.
+        """
         self.section_list = []
 
     @property
     def first_section(self) -> TaperSection:
-        """ Returns the first taper section added to the profile """
+        """
+        Retrieves the first taper section added to the profile.
+
+        Returns:
+            TaperSection: The first taper section object in the section list.
+        """
         return self.section_list[0]
 
     @property
     def last_section(self) -> TaperSection:
-        """ Returns the last taper section added to the profile """
+        """
+        Retrieves the last taper section added to the profile.
+
+        Returns:
+            TaperSection: The last taper section object in the section list.
+        """
         return self.section_list[-1]
 
     def add_constant_segment(self, *, length: float, n_point: int = 100) -> None:
         """
-        Add the constant section following the last section which length is to be evaluated.
+        Adds a constant section at the specified length with a given number of points to the profile.
 
-        :param      length:   Length of the constant section to be added
-        :type       length:   float
-        :param      n_point:  The number of point where wo which evaluate that segment
-        :type       n_point:  int
+        Parameters:
+            length (float): Length of the constant section to be added.
+            n_point (int): Number of points along the section for detailed resolution, defaults to 100.
 
-        :returns:   No returns
-        :rtype:     None
+        Returns:
+            None
         """
         section = self.get_constant_custom_section(
             length=length,
             rho=self.last_radius,
             start_z=self.last_z,
             n_point=n_point
         )
 
         self.section_list.append(section)
 
     def add_end_of_taper_segment(self, *, n_point: int = 100) -> None:
         """
-        Add the constant section which length equal the final length of the
-        heating section.
+        Adds a constant segment at the end of the taper if the last section is not constant. This method
+        ensures the taper ends smoothly or extends as needed.
 
-        :param      n_point:  The number of point where wo which evaluate that segment
-        :type       n_point:  int
+        Parameters:
+            n_point (int): Number of points along the section, defaults to 100.
 
-        :returns:   No returns
-        :rtype:     None
+        Returns:
+            None
         """
         if self.last_section.is_constant:
             return
 
         length = self.last_section.heating_length_final / 2
 
         section = self.get_constant_custom_section(
@@ -138,81 +184,99 @@
     def get_constant_custom_section(
             self, *,
             length: float,
             radius: float,
             start_z: float = 0,
             n_point: int = 100) -> None:
         """
-        Add the constant section which length, radius and start position is to be provided
+        Creates a constant section with specified parameters and adds it to the profile.
 
-        :param      length:   Length of the constant section to be added
-        :type       length:   float
-        :param      radius:   Radius of the constant section to be added
-        :type       radius:   float
-        :param      start_z:  Initial z-position of the constant section to be added
-        :type       start_z:  float
-        :param      n_point:  The number of point where wo which evaluate that segment
-        :type       n_point:  int
+        Parameters:
+            length (float): Length of the constant section to be added.
+            radius (float): Radius of the section.
+            start_z (float): Starting z-position for the section, defaults to 0.
+            n_point (int): Number of points for resolution within the section, defaults to 100.
 
-        :returns:   No returns
-        :rtype:     None
+        Returns:
+            TaperSection: The newly created taper section.
         """
         z_array = numpy.linspace(start_z, length + start_z, n_point)
 
         radius_array = numpy.ones(n_point) * radius
 
         section = TaperSection(
             z_array=z_array,
             radius_array=radius_array,
         )
 
         return section
 
     def evaluate_adiabatic_factor(self, itr: numpy.ndarray) -> numpy.ndarray:
+        """
+        Evaluates the adiabatic factor for given inverse taper ratios (ITR).
+
+        Parameters:
+            itr (numpy.ndarray): Array of inverse taper ratios.
+
+        Returns:
+            numpy.ndarray: Array of adiabatic factors corresponding to the provided ITRs.
+        """
         interpolation = interp1d(
             x=self.itr_list,
             y=self.adiabatic,
             bounds_error=False,
             fill_value=numpy.nan
         )
 
         return interpolation(itr)
 
     def evaluate_distance_vs_itr(self, distance: numpy.ndarray) -> numpy.ndarray:
+        """
+        Evaluates the function of distance versus inverse taper ratio using interpolation.
+
+        Parameters:
+            distance (numpy.ndarray): Array of distances at which the ITR needs to be evaluated.
+
+        Returns:
+            numpy.ndarray: Array of ITRs at the specified distances.
+        """
         interpolation = interp1d(
             x=self.itr_list,
             y=self.distance,
             bounds_error=True,
         )
 
         return interpolation(distance)
 
     def compute_radius_from_segment(
             self, *,
             alpha: float,
             initial_heating_length: float,
             stretching_length: float,
             initial_radius: float,
-            distance: numpy.ndarray) -> tuple:
+            distance: numpy.ndarray) -> Tuple[numpy.ndarray, float, float]:
         """
-        Gets the radius as a fonction of the distance for a specific segment.
+        Computes the radius as a function of the distance for a specific segment,
+        applying a tapering formula based on the provided parameters.
 
-        :param      alpha:                  Alpha parameter which represent how the heating section changes in time
-        :type       alpha:                  float
-        :param      initial_heating_length: Initial length of the heating section
-        :type       initial_heating_length: float
-        :param      initial_radius:         The initial radius of the segment to be added
-        :type       initial_radius:         float
-        :param      stretching_length:      The total elongated lenght of the current segment to be added
-        :type       stretching_length:      float
-        :param      distance:               Array representing the z-distance.
-        :type       distance:               numpy.ndarray
+        Args:
+            alpha (float): Rate at which the heating section's influence changes over time.
+            initial_heating_length (float): Initial length of the heating section.
+            initial_radius (float): Radius at the start of the segment.
+            stretching_length (float): Total length over which the segment is elongated.
+            distance (numpy.ndarray): Array representing the z-distance.
+
+        Returns:
+            Tuple[numpy.ndarray, float, float]: A tuple containing:
+                - radius (numpy.ndarray): Computed radius at each point in 'distance'.
+                - final_radius (float): Radius at the end of the segment.
+                - final_heating_length (float): Total length of the heating section after stretching.
 
-        :returns:   The radius, final radius and final heating length
-        :rtype:     tuple
+        Raises:
+            ValueError: If input conditions are not physically or mathematically valid.
         """
         self.assert_conditions(
             alpha=alpha,
             stretching_length=stretching_length,
             initial_heating_length=initial_heating_length
         )
 
@@ -220,65 +284,66 @@
         term2 = (1 - alpha) * initial_heating_length
         term3 = -1 / (2 * alpha)
 
         radius = initial_radius * (1 + term0 / term2)**term3
         final_radius = initial_radius * (1 + alpha * stretching_length / initial_heating_length)**(-1 / (2 * alpha))
         final_heating_length = initial_heating_length + alpha * stretching_length
 
-        assert not numpy.any(radius < 0), "Negative radius value are not physical"
+        if numpy.any(radius <= 0):
+            raise ValueError("Computed radius values contain non-physical negative or zero values.")
 
         return radius, final_radius, final_heating_length
 
     def assert_conditions(
             self, *,
             alpha: float,
             stretching_length: float,
             initial_heating_length: float) -> None:
         """
-        Assert a few condition of viability of the proposed recipe.
+        Validates conditions for computing the taper segment.
 
-        :param      alpha:                   The alpha
-        :type       alpha:                   float
-        :param      stretching_length:       The stretching length
-        :type       stretching_length:       float
-        :param      initial_heating_length:  The initial heating length
-        :type       initial_heating_length:  float
+        Args:
+            alpha (float): Alpha parameter, non-zero to avoid division by zero.
+            stretching_length (float): Length over which the segment is elongated.
+            initial_heating_length (float): Initial length of the heating section.
 
-        :returns:   No returns
-        :rtype:     None
+        Raises:
+            ValueError: If any condition that ensures a physically viable profile is violated.
         """
-        assert initial_heating_length > 0, "The initial heat lenght initial_heating_length cannot be negative!"
+        if initial_heating_length <= 0:
+            raise ValueError("Initial heating length must be positive.")
+
+        if alpha == 0:
+            raise ValueError("Alpha must not be zero to avoid division by zero in formula.")
 
-        if alpha < 0:
-            assert stretching_length < initial_heating_length / abs(alpha), "Condition: x0 < initial_heating_length / |alpha| is not respected! see Birks article in the references!"
+        if alpha < 0 and stretching_length >= initial_heating_length / abs(alpha):
+            raise ValueError("Stretching length for negative alpha exceeds the physically viable limit.")
 
     def add_taper_custom_segment(
             self, *,
             alpha: float,
             initial_heating_length: float,
             initial_radius: float,
             stretching_length: float,
             start_z: float = 0,
             n_point: int = 100) -> None:
         """
-        Add a tapered section for a given alpha, initial_heating_length, initial_radius, stretching_length and starting z position
+        Adds a custom tapered section to the profile based on specified parameters. This method is useful for creating
+        detailed and specific taper geometries within the optical fiber.
 
-        :param      alpha:                  Alpha parameter which represent how the heating section changes in time
-        :type       alpha:                  float
-        :param      initial_heating_length: Initial length of the heating section
-        :type       initial_heating_length: float
-        :param      initial_radius:         The initial radius of the segment to be added
-        :type       initial_radius:         float
-        :param      stretching_length:      The total elongated lenght of the current segment to be added
-        :type       stretching_length:      float
-        :param      n_point:                The number of point where wo which evaluate that segment
-        :type       n_point:                int
+        Parameters:
+            alpha (float): Rate at which the heating section's influence changes over time.
+            initial_heating_length (float): Initial length of the heating section before any stretching.
+            initial_radius (float): Initial radius at the start of the taper segment.
+            stretching_length (float): Length over which the taper is stretched.
+            start_z (float): Starting z-coordinate for the taper segment, defaults to 0.
+            n_point (int): Number of points along the taper for resolution, defaults to 100.
 
-        :returns:   No returns
-        :rtype:     None
+        Returns:
+            None
         """
         alpha = 0.01 if alpha == 0 else alpha
 
         z_0 = (1 - alpha) * stretching_length / 2
 
         distance = numpy.linspace(0, z_0, n_point)
 
@@ -297,191 +362,182 @@
             radius_array=radius,
             heating_length_initial=initial_heating_length,
             heating_length_final=final_heating_length
         )
 
         self.section_list.append(section)
 
-    def compute_distance(self) -> numpy.ndarray:
-        """
-        Returns the distance array of the profile
-
-        :returns:   The distance.
-        :rtype:     numpy.ndarray
-        """
-        distance = numpy.linspace(0, self.last_z, self.n_point)
-
-        self._distance = distance
-
-    def compute_radius(self) -> numpy.ndarray:
-        """
-        Returns the array of radius [vs z-distance] for the taper structure
-
-        :returns:   The ITR array
-        :rtype:     numpy.ndarray
-        """
-        radius = self.compute_radius_from_segment_from_interpolation(self.distance)
-
-        self._radius = radius
-
-    def compute_itr_list(self) -> numpy.ndarray:
-        """
-        Returns the array of ITR value [vs z-distance] for the taper structure
-
-        :returns:   The ITR array
-        :rtype:     numpy.ndarray
-        """
-        itr_list = self.radius / self.initial_radius
-
-        self._itr_list = itr_list
-
-    def compute_adiabatic(self) -> numpy.ndarray:
+    def compute_adiabatic(self, distance: numpy.ndarray, radius: numpy.ndarray) -> numpy.ndarray:
         """
-        Returns the array of adiabatc factor [vs ITR] for the taper structure
+        Computes the adiabatic factor, a measure of how gradually a taper changes, which is crucial for ensuring minimal
+        light loss due to mode conversion.
 
         .. math::
             f_c = \frac{1}{\rho} \frac{d \rho}{d z}
 
-        :returns:   The adiabatic factor
-        :rtype:     numpy.ndarray
-        """
-        dz = numpy.gradient(self.distance, axis=0, edge_order=2)
+        Parameters:
+            distance (numpy.ndarray): Array of distances along the taper.
+            radius (numpy.ndarray): Array of radii corresponding to each distance.
 
-        ditr = numpy.gradient(numpy.log(self.radius), axis=0, edge_order=2)
+        Returns:
+            numpy.ndarray: Array of adiabatic factors for the given distances and radii.
+        """
+        dz = numpy.gradient(distance, axis=0, edge_order=2)
 
-        adiabatic = abs(ditr / dz)
+        ditr = numpy.gradient(numpy.log(radius), axis=0, edge_order=2)
 
-        self._adiabatic = adiabatic
+        return abs(ditr / dz)
 
-    def compute_taper_angle(self, symmetric: bool = None) -> numpy.ndarray:
+    def compute_taper_angle(self, distance: numpy.ndarray, radius: numpy.ndarray) -> numpy.ndarray:
         r"""
-        Returns the array of taper angle for the taper structure
+        Computes the taper angle for a given set of distances and corresponding radii in the taper structure. This angle
+        can provide insights into the performance and behavior of the taper under different conditions.
         From Tapered single-mode fibres and devices. Part 1: Adiabaticity criteria.
-        Compute the adiabatic factor defined as:
 
         .. math::
             f_c = \frac{d \rho}{d z} = \Omega
 
-        :returns:   The taper angle array
-        :rtype:     numpy.ndarray
-        """
-        d_z = numpy.gradient(self.distance, axis=0, edge_order=2)
 
-        d_rho = numpy.gradient(self.radius, axis=0, edge_order=2)
+        Parameters:
+            distance (numpy.ndarray): Array of distances along the taper.
+            radius (numpy.ndarray): Array of radii corresponding to each distance.
+
+        Returns:
+            numpy.ndarray: Array of taper angles calculated from the rate of change of the radius with respect to the distance.
+        """
+        d_z = numpy.gradient(distance, axis=0, edge_order=2)
 
-        taper_angle = abs(d_rho / d_z)
+        d_rho = numpy.gradient(radius, axis=0, edge_order=2)
 
-        self._taper_angle = taper_angle
+        return abs(d_rho / d_z)
 
     @property
     def smallest_itr(self) -> float:
         """
-        Returns the smallest itr of the taper structure
+        Retrieves the smallest inverse taper ratio (ITR) of the taper structure. The smallest ITR can indicate the
+        tightest part of the taper, which is critical for applications requiring precise control over light propagation.
 
-        :returns:   Smallest itr value
-        :rtype:     float
+        Returns:
+            float: The smallest ITR value found in the taper profile.
         """
         return self.itr_list.min()
 
     @property
     def last_z(self) -> float:
         """
-        Returns the last, or equivalently the largest propagation distance computed
+        Retrieves the last, or maximum, z-coordinate computed for the taper sections, which represents the end point
+        of the taper structure.
 
-        :returns:   The z-distance
-        :rtype:     float
+        Returns:
+            float: The last z-coordinate value in the taper structure.
         """
         if len(self.section_list) == 0:
             return 0
         else:
             return self.last_section.z_final
 
     @property
     def total_length(self) -> float:
         """
-        Returns the total length of the component comprising the taper and constants sections.
+        Computes the total length of the taper structure, including both taper and constant sections, providing an overall
+        size of the taper profile.
 
-        :returns:   { description_of_the_return_value }
-        :rtype:     float
+        Returns:
+            float: Total length of the taper structure.
         """
         return self.last_section.z_final
 
     @property
     def last_radius(self) -> float:
         """
-        Retunrs the radius value of the last z-position
+        Retrieves the radius at the last computed z-position, which represents the end radius of the taper structure.
 
-        :returns:   The radius value
-        :rtype:     float
+        Returns:
+            float: Radius at the last z-coordinate in the taper profile.
         """
         if len(self.section_list) == 0:
             return self.initial_radius
         else:
             return self.last_section.radius_final
 
     def initialize(self) -> None:
-        symmetric = self.symmetric
-
-        self.symmetric = False
+        """
+        Initializes or re-initializes the profile, typically called after making modifications to the taper sections. This method
+        recalculates and updates internal parameters to reflect the current state of the taper structure.
 
+        Returns:
+            None
+        """
         if self.add_end_of_taper_section:
             self.add_end_of_taper_segment()
 
-        self.compute_distance()
-        self.compute_radius()
-        self.compute_itr_list()
-        self.compute_taper_angle()
-        self.compute_adiabatic()
-
-        self.symmetric = symmetric
-
-    @property
-    def distance(self):
-        if self.symmetric:
-            return numpy.linspace(self._distance[0], 2 * self._distance[-1], 2 * self._distance.size - 1)
-
-        return self._distance
-
-    @property
-    def radius(self):
-        if self.symmetric:
-            return numpy.r_[self._radius, self._radius[-2::-1]]
-
-        return self._radius
-
-    @property
-    def itr_list(self):
-        if self.symmetric:
-            return numpy.r_[self._itr_list, self._itr_list[-2::-1]]
-
-        return self._itr_list
-
-    @property
-    def taper_angle(self):
-        if self.symmetric:
-            return numpy.r_[self._taper_angle, self._taper_angle[-2::-1]]
-
-        return self._taper_angle
+        distance = numpy.linspace(0, self.last_z, self.n_point)
+        radius = self.compute_radius_from_segment_from_interpolation(distance)
+        itr_list = radius / self.initial_radius
+        adiabatic = self.compute_adiabatic(distance=distance, radius=radius)
+        taper_angle = self.compute_taper_angle(distance=distance, radius=radius)
 
-    @property
-    def adiabatic(self):
         if self.symmetric:
-            return numpy.r_[self._adiabatic, self._adiabatic[-2::-1]]
-
-        return self._adiabatic
+            self._distance = numpy.linspace(distance[0], 2 * distance[-1], 2 * distance.size - 1)
+            self._itr_list = numpy.r_[itr_list, itr_list[-2::-1]]
+            self._radius = numpy.r_[radius, radius[-2::-1]]
+            self._adiabatic = numpy.r_[adiabatic, adiabatic[-2::-1]]
+            self._taper_angle = numpy.r_[taper_angle, taper_angle[-2::-1]]
+        else:
+            self._distance = distance
+            self._radius = radius
+            self._itr_list = itr_list
+            self._adiabatic = adiabatic
+            self._taper_angle = taper_angle
+
+    @property
+    def distance(self) -> numpy.ndarray:
+        try:
+            return self._distance
+        except AttributeError:
+            raise AttributeError('Profile has not been initialized yet. The user need to run the initialize() method first. ')
+
+    @property
+    def radius(self) -> numpy.ndarray:
+        try:
+            return self._radius
+        except AttributeError:
+            raise AttributeError('Profile has not been initialized yet. The user need to run the initialize() method first. ')
+
+    @property
+    def itr_list(self) -> numpy.ndarray:
+        try:
+            return self._itr_list
+        except AttributeError:
+            raise AttributeError('Profile has not been initialized yet. The user need to run the initialize() method first. ')
+
+    @property
+    def adiabatic(self) -> numpy.ndarray:
+        try:
+            return self._adiabatic
+        except AttributeError:
+            raise AttributeError('Profile has not been initialized yet. The user need to run the initialize() method first. ')
+
+    @property
+    def taper_angle(self) -> numpy.ndarray:
+        try:
+            return self._taper_angle
+        except AttributeError:
+            raise AttributeError('Profile has not been initialized yet. The user need to run the initialize() method first. ')
 
     def compute_radius_from_segment_from_interpolation(self, z: numpy.ndarray) -> numpy.ndarray:
         """
-        Gets the radius of the component from all the interpolation segment.
+        Computes the radius at specified z-distances based on interpolation from existing taper sections, providing a continuous
+        profile of the radius along the taper.
 
-        :param      z:    The distance array to which evaluate the radius of the component
-        :type       z:    numpy.ndarray
+        Parameters:
+            z (numpy.ndarray): Array of z-distances at which to evaluate the radius.
 
-        :returns:   The evaluated radius of the component vs the distance
-        :rtype:     numpy.ndarray
+        Returns:
+            numpy.ndarray: Array of radius values interpolated along the given z-distances.
         """
         radius = numpy.zeros(z.size)
 
         for section in self.section_list:
             evaluation = section.interpolation(z)
             idx_non_null = evaluation != 0
             radius[idx_non_null] = evaluation[idx_non_null]
@@ -492,169 +548,176 @@
             self, *,
             alpha: float,
             initial_heating_length: float,
             stretching_length: float,
             initial_radius: float = None,
             n_point: int = 100) -> None:
         """
-        Add a tapered section following the previous one for a given alpha, initial_heating_length, stretching_length.
+        Adds a tapered section following the previously defined section, using provided taper parameters to define the new section's
+        geometry and behavior.
+
+        Parameters:
+            alpha (float): Rate at which the heating section's influence changes over time.
+            initial_heating_length (float): Initial length of the heating section.
+            stretching_length (float): Total length over which the segment is stretched.
+            initial_radius (float): Radius at the start of the segment, defaults to the last radius if not provided.
+            n_point (int): Number of points along the section for resolution, defaults to 100.
 
-        :param      alpha:                  Alpha parameter which represent how the heating section changes in time
-        :type       alpha:                  float
-        :param      initial_heating_length: Initial length of the heating section
-        :type       initial_heating_length: float
-        :param      stretching_length:      The total elongated lenght of the current segment to be added
-        :type       stretching_length:      float
-        :param      n_point:                The number of point where wo which evaluate that segment
-        :type       n_point:                int
+        Returns:
+            None
         """
         return self.add_taper_custom_segment(
             alpha=alpha,
             initial_heating_length=initial_heating_length,
             initial_radius=self.last_radius,
             stretching_length=stretching_length,
             start_z=self.last_z,
             n_point=n_point
         )
 
-    def get_itr_vs_distance_interpolation(self):
+    def get_itr_vs_distance_interpolation(self) -> Callable:
+        """
+        Generates an interpolation function for inverse taper ratio (ITR) as a function of distance.
+        This allows for quick lookups of ITR at arbitrary distances along the taper.
+
+        Returns:
+            Callable: A function that interpolates ITR based on given distances.
+        """
         return interp1d(
             x=self.distance,
             y=self.itr_list,
             bounds_error=False,
             fill_value=0
         )
 
-    def single_plot(function):
+    def single_plot(function) -> Callable:
+        """
+        Decorator to apply a standard plotting style to any plotting function within this class.
+        It automatically sets line styles, colors, and labels from the class attributes.
+
+        Parameters:
+            function (Callable): The plotting function to decorate.
+
+        Returns:
+            Callable: A wrapped plotting function that integrates additional styling and annotations.
+        """
+
         def wrapper(self, ax: Axis, line_color: str = None, line_style: str = None, **kwargs):
             line_style = self.line_style if line_style is None else line_style
             line_color = self.line_color if line_color is None else line_color
 
-            x, y = function(
-                self,
-                ax=ax,
-                line_color=line_color,
-                line_style=line_style,
-                **kwargs
-            )
-
-            ax.add_line(
-                x=x,
-                y=y,
-                label=self.label,
-                line_style=line_style,
-                color=line_color
-            )
+            x, y = function(self, ax=ax, line_color=line_color, line_style=line_style, **kwargs)
+
+            ax.add_line(x=x, y=y, label=self.label, line_style=line_style, color=line_color)
 
         return wrapper
 
     @single_plot
-    def render_itr_vs_z_on_ax(
-            self,
-            ax: Axis,
-            line_style: str = None,
-            line_color: str = None) -> None:
+    def render_itr_vs_z_on_ax(self, ax: Axis, **kwargs) -> tuple[numpy.ndarray, numpy.ndarray]:
         """
-        Add plot onto axis, the plots is ITR vs Z-distance
+        Renders a plot of inverse taper ratio (ITR) versus z-distance onto a given axis. This method is typically
+        used for visualizing how the ITR changes along the length of the taper.
 
-        :param      ax:   The axis on which to add the plot
-        :type       ax:   Axis
+        Parameters:
+            ax (Axis): The matplotlib axis on which to plot.
+            line_style (str, optional): Line style for the plot, defaults to class attribute.
+            line_color (str, optional): Line color for the plot, defaults to class attribute.
+
+        Returns:
+            tuple[numpy.ndarray, numpy.ndarray]
         """
         ax.set_style(
             show_legend=False,
             y_limits=[0, None],
             x_label='Z-propagation [mm]',
             y_label='Inverse taper ratio [ITR]',
             x_scale_factor=1e3,
             y_scale="linear",
             line_width=2
         )
 
         return self.distance, self.itr_list
 
     @single_plot
-    def render_taper_angle_vs_z_on_ax(
-            self,
-            ax: Axis,
-            line_style: str = None,
-            line_color: str = None) -> None:
+    def render_taper_angle_vs_z_on_ax(self, ax: Axis, **kwargs) -> tuple[numpy.ndarray, numpy.ndarray]:
         """
-        Add plot onto axis, the plots is ITR vs Z-distance
+        Plots the taper angle as a function of z-distance on a provided axis. Useful for understanding the geometric
+        changes in the taper profile over its length.
 
-        :param      ax:   The axis on which to add the plot
-        :type       ax:   Axis
+        Parameters:
+            ax (Axis): The matplotlib axis on which to plot.
+            line_style (str, optional): Specifies the style of the plot line, if different from the class default.
+            line_color (str, optional): Specifies the color of the plot line, if different from the class default.
+
+        Returns:
+            tuple[numpy.ndarray, numpy.ndarray]
         """
         ax.set_style(
             show_legend=False,
             y_limits=[0, None],
             y_label='Taper angle [rad]',
             x_label='Z-propagation [mm]',
             x_scale_factor=1e3,
             y_scale="linear",
             line_width=2
         )
 
         return self.distance, self.taper_angle
 
     @single_plot
-    def render_adiabatic_factor_vs_z_on_ax(
-            self,
-            ax: Axis,
-            line_style: str = None,
-            line_color: str = None) -> None:
+    def render_adiabatic_factor_vs_z_on_ax(self, ax: Axis, **kwargs) -> tuple[numpy.ndarray, numpy.ndarray]:
         """
-        Add plot onto axis, the plots is adiabatic criterion vs Z-distance
+        Plots the adiabatic criterion versus z-distance on the specified axis. This plot helps assess the
+        efficiency and effectiveness of the taper in maintaining adiabatic conditions throughout its course.
 
-        :param      ax:   The axis on which to add the plot
-        :type       ax:   Axis
+        Parameters:
+            ax (Axis): The matplotlib axis on which to plot.
+            line_style (str, optional): Line style for the plot, can override default.
+            line_color (str, optional): Line color for the plot, can override default.
+
+        Returns:
+            tuple[numpy.ndarray, numpy.ndarray]
         """
         ax.set_style(
             y_scale='log',
             y_label='Adiabatic criterion',
             x_label='z-distance'
         )
 
         return self.distance, self.adiabatic
 
     @single_plot
-    def render_adiabatic_factor_vs_itr_on_ax(
-            self,
-            ax: Axis,
-            line_style: str = None,
-            line_color: str = None) -> None:
+    def render_adiabatic_factor_vs_itr_on_ax(self, ax: Axis, **kwargs) -> tuple[numpy.ndarray, numpy.ndarray]:
         """
         Add adiabatic criterion vs ITR plot to axis
 
         :param      ax:   The axis on which to add the plot
         :type       ax:   Axis
         """
-        ax.set_style(**representation.adiabatic.ax_style)
+        ax.set_style(**representation.adiabatic.Adiabatic.plot_style)
 
         return self.itr_list, self.adiabatic
 
     def plot(
             self,
             show_radius: bool = True,
             show_adiabatic: bool = True,
             show_taper_angle: bool = True) -> SceneList:
         """
-        Generate two plots: ITR vs z distance and adiabatic criterion vs ITR
+        Generates plots based on the current state of the taper profile. This can include plots of radius vs. z-distance,
+        adiabatic factor vs. ITR, and taper angle vs. z-distance, based on the specified flags.
 
-        :param      show_radius:       If True, plot shows radius as function of ITR
-        :type       show_radius:       bool
-        :param      show_adiabatic:    If True, plot shows adiabatic criterion as function of ITR
-        :type       show_adiabatic:    bool
-        :param      show_taper_angle:  If True, plot shows taper angle as function of ITR
-        :type       show_taper_angle:  bool
+        Parameters:
+            show_radius (bool): If True, includes a plot of radius vs. z-distance.
+            show_adiabatic (bool): If True, includes a plot of adiabatic factor vs. ITR.
+            show_taper_angle (bool): If True, includes a plot of taper angle vs. z-distance.
 
-        :returns:   The scene list.
-        :rtype:     SceneList
+        Returns:
+            SceneList: A collection of matplotlib axes with the requested plots.
         """
-        self.initialize()
-
         figure = SceneList(
             title=f'Minimum ITR: {self.smallest_itr:.4f}',
             ax_orientation='vertical',
             unit_size=(8, 3)
         )
 
         if show_radius:
@@ -677,49 +740,37 @@
             self,
             output_directory: str = './new_gif.gif',
             dpi: int = 100,
             fps: int = 20,
             number_of_frames: int = 200,
             dark_background: bool = True) -> None:
         """
-        Genrates gif of the propagation of light into the taper structure
-
-        :param      output_directory:  The output directory
-        :type       output_directory:  str
-        :param      dpi:               The dpi
-        :type       dpi:               int
-        :param      fps:               The fps [frame per seconde]
-        :type       fps:               int
-        :param      number_of_frames:  The number of frame
-        :type       number_of_frames:  int
-        :param      dark_background:   If True the background is black
-        :type       dark_background:   bool
-
-        :returns:   No returns
-        :rtype:     None
-        """
-        self.initialize()
-
-        figure, ax = plt.subplots(1, 1, figsize=(12, 6))
+        Generates an animated GIF of light propagation in a taper structure.
 
-        ax.set_xlabel('Propagation axis [mm]', color='white')
+        Parameters:
+            output_directory (str): Path where the GIF will be saved.
+            dpi (int): Dots per inch for the output GIF.
+            fps (int): Frames per second for the animation.
+            number_of_frames (int): Total number of frames in the animation.
+            dark_background (bool): If True, use a dark background for the GIF.
+
+        Returns:
+            None
+        """
+        figure, ax = plt.subplots(figsize=(12, 6))
+        ax.set_xlabel('Propagation axis [mm]', color='white' if dark_background else 'black')
+        style_context = "dark_background" if dark_background else "default"
 
         sub_sampling_factor = int(self.distance.size / number_of_frames)
 
         sub_distance = self.distance[::sub_sampling_factor] * 1e3
         sub_radius = self.radius[::sub_sampling_factor]
         sub_itr_list = self.itr_list[::sub_sampling_factor]
 
-        if dark_background:
-            style = plt.style.context("dark_background")
-            ax.tick_params(colors='white', direction='out')
-        else:
-            style = plt.style.context('default')
-
-        with style:
+        with plt.style.context(style_context):
             def init_func() -> tuple:
                 line_0 = ax.plot(sub_distance, sub_radius, color='black')
                 line_1 = ax.plot(sub_distance, -sub_radius, color='black')
 
                 line_2 = ax.fill_between(
                     sub_distance,
                     +sub_radius,
@@ -736,32 +787,27 @@
                 title = f'[slice: {slice_number} - ITR: {itr:.3f}]'
 
                 if slice_number > 0:
                     ax.lines[-1].remove()
 
                 line_0 = ax.set_title(title, color='white')
 
-                line_1 = ax.axvline(
-                    position,
-                    linestyle='--',
-                    linewidth=2,
-                    color='red'
-                )
+                line_1 = ax.axvline(position, linestyle='--', linewidth=2, color='red')
 
                 return line_0, line_1
 
-            animation = FuncAnimation(
-                fig=figure,
-                func=animate,
-                init_func=init_func,
-                blit=True,
-                repeat=True,
-                frames=sub_itr_list.size
-            )
-
-            animation.save(
-                output_directory,
-                dpi=dpi,
-                writer=PillowWriter(fps=fps)
-            )
+        animation = FuncAnimation(
+            fig=figure,
+            func=animate,
+            init_func=init_func,
+            blit=True,
+            repeat=True,
+            frames=sub_itr_list.size
+        )
+
+        animation.save(
+            output_directory,
+            dpi=dpi,
+            writer=PillowWriter(fps=fps)
+        )
 
 # -
```

## SuPyMode/solver.py

```diff
@@ -2,93 +2,72 @@
 # -*- coding: utf-8 -*-
 
 # Third-party imports
 import numpy
 from dataclasses import dataclass, field
 from PyFinitDiff.finite_difference_2D import FiniteDifference
 from PyFinitDiff.finite_difference_2D import Boundaries
-from MPSTools.tools.mathematics import get_rho_gradient
 from FiberFusing.geometry import Geometry
 from FiberFusing.coordinate_system import CoordinateSystem
 
 # Local imports
 from SuPyMode.superset import SuperSet
 from SuPyMode.supermode import SuperMode
 from SuPyMode.binary.CppSolver import CppSolver
-from SuPyMode.binary.SuperMode import SuperMode as BindingSuperMode  # It has to be imported in order for pybind11 to know the type
-from SuPyMode.tools.mode_label import ModeLabel
+from SuPyMode.binary.ModelParameters import ModelParameters
+from SuPyMode.binary.SuperMode import SuperMode as BindingSuperMode  # noqa: F401 It has to be imported in order for pybind11 to know the type
+from SuPyMode.mode_label import ModeLabel
 
 
 @dataclass()
 class SuPySolver(object):
     """
-    This solver class directly links to a c++ Eigensolver.
-    It solves the eigenvalues problems for a given geometry and return a collection of SuperModes.
+    Solver class integrating a C++ eigensolver to compute eigenvalues for optical fiber geometries.
+    This class manages the eigenvalue problems and returns collections of computed SuperModes.
 
+    Attributes:
+        geometry (Geometry | np.ndarray): The refractive index geometry of the optical structure.
+        tolerance (float): Absolute tolerance for the propagation constant computation.
+        max_iter (int): Maximum iterations for the C++ eigensolver.
+        accuracy (int): Accuracy level of the finite difference method.
+        extrapolation_order (int): Order of Taylor series used to extrapolate eigenvalues.
+        debug_mode (int): Debug output level from the C++ binding (0, 1, 2).
+        coordinate_system (Optional[CoordinateSystem]): The coordinate system linked with the geometry.
     """
     geometry: Geometry | numpy.ndarray = field(repr=False)
-    """ Refractive index geometry of the optical structure """
     tolerance: float = 1e-8
-    """ Absolute tolerance on the propagation constant computation """
     max_iter: int = 10_000
-    """ Maximum iteration for the c++ Eigensolver """
     accuracy: int = 2
-    """ Accuracy of the finit difference methode """
     extrapolation_order: int = 2
-    """ Order of the taylor serie to extrapolate next eigenvalues . """
     debug_mode: int = 1
-    """ Level of debug outprint from the c++ binding [0, 1, 2] """
-    coordinate_system: CoordinateSystem = None
+    coordinate_system: CoordinateSystem | None = None
 
     def __post_init__(self):
         if isinstance(self.geometry, numpy.ndarray):
             assert self.coordinate_system is not None, "Geometry provided without its coordinate system"
             self.mesh = self.geometry
         else:
             self.geometry.generate_coordinate_system()
-            self.geometry.generate_mesh()
-            self.mesh = self.geometry.mesh
+            self.mesh = self.geometry.generate_mesh()
             self.coordinate_system = self.geometry.coordinate_system
 
         self.mode_number = 0
         self.solver_number = 0
 
-    def get_n2_rho_gradient(self) -> numpy.ndarray:
+    def initialize_binding(self, n_sorted_mode: int, boundaries: Boundaries, n_added_mode: int) -> CppSolver:
         """
-        Returns the n squared radial gradient.
+        Initializes and configures the C++ solver binding for eigenvalue computations.
 
-        :returns:   The n 2 rho gradient.
-        :rtype:     numpy.ndarray
-        """
-        gradient = get_rho_gradient(
-            mesh=self.mesh**2,
-            coordinate_system=self.coordinate_system
-        )
-
-        return gradient
+        Args:
+            n_sorted_mode (int): Number of modes to sort and retrieve from the solver.
+            boundaries (Boundaries): Boundary conditions for the finite difference system.
+            n_added_mode (int): Number of extra modes calculated for accuracy and reliability.
 
-    def initialize_binding(
-            self,
-            n_sorted_mode: int,
-            boundaries: Boundaries,
-            n_added_mode: int) -> CppSolver:
-        """
-        Initializes the c++ binding of the class.
-
-        :param      wavelength:       Wavelenght for the mode computation
-        :type       wavelength:       float
-        :param      n_sorted_mode:    Number of mode that are outputed by the c++ solver.
-        :type       n_sorted_mode:    int
-        :param      n_added_mode:     Number of additional modes that are computed for that will be sorted out, the higher the value the less likely mode mismatch will occur.
-        :type       n_added_mode:     int
-        :param      boundaries:       Symmetries of the finit-difference system.
-        :type       boundaries:       Boundaries
-
-        :returns:   The cpp solver.
-        :rtype:     CppSolver
+        Returns:
+            CppSolver: Configured C++ solver instance.
         """
         self.FD = FiniteDifference(
             n_x=self.coordinate_system.nx,
             n_y=self.coordinate_system.ny,
             dx=self.coordinate_system.dx,
             dy=self.coordinate_system.dy,
             derivative=2,
@@ -100,145 +79,122 @@
 
         new_array = numpy.c_[
             self.FD._triplet.array[:, 1],
             self.FD._triplet.array[:, 0],
             self.FD._triplet.array[:, 2]
         ]
 
-        mesh_gradient_term = self.get_n2_rho_gradient() * self.coordinate_system.rho_mesh
-
-        Solver = CppSolver(
-            mesh=self.mesh,
-            gradient=mesh_gradient_term,
+        self.model_parameters = ModelParameters(
+            dx=self.coordinate_system.dx,
+            dy=self.coordinate_system.dy,
+            wavelength=self.wavelength,
             itr_list=self.itr_list,
+            mesh=self.mesh,
+            x_vector=self.coordinate_system.x_vector,
+            y_vector=self.coordinate_system.y_vector,
+            left_boundary=boundaries.left,
+            right_boundary=boundaries.right,
+            top_boundary=boundaries.top,
+            bottom_boundary=boundaries.bottom,
+            debug_mode=self.debug_mode
+        )
+
+        solver = CppSolver(
+            model_parameters=self.model_parameters,
             finit_matrix=new_array.T,
             n_computed_mode=n_sorted_mode + n_added_mode,
             n_sorted_mode=n_sorted_mode,
             max_iter=self.max_iter,
-            tolerance=self.tolerance,
-            wavelength=self.wavelength,
-            debug_mode=self.debug_mode,
-            dx=self.coordinate_system.dx,
-            dy=self.coordinate_system.dy
+            tolerance=self.tolerance
         )
 
-        Solver.compute_laplacian()
+        solver.compute_laplacian()
 
-        return Solver
+        return solver
 
-    def init_superset(
-            self,
-            wavelength: float,
-            n_step: int = 300,
-            itr_initial: float = 1.0,
-            itr_final: float = 0.1) -> None:
-        """
-        Initialize superset instance which contains the computed superodes.
-
-        :param      wavelength:  Wavelenght for the mode computation
-        :type       wavelength:  float
-        :param      n_step:      Number of stop to iterate through the ITR (inverse taper ration) section.
-        :type       n_step:      int
-        :param      itr_initial: Initial value of ITR.
-        :type       itr_initial: float
-        :param      itr_final:   Final value of ITR.
-        :type       itr_final:   float
+    def init_superset(self, wavelength: float, n_step: int = 300, itr_initial: float = 1.0, itr_final: float = 0.1) -> None:
+        """
+        Initializes a SuperSet instance containing computed supermodes over a range of inverse taper ratios (ITR).
 
-        :returns:   No returns
-        :rtype:     None
+        Args:
+            wavelength (float): Wavelength for the mode computation.
+            n_step (int): Number of steps for the ITR interpolation.
+            itr_initial (float): Initial ITR value.
+            itr_final (float): Final ITR value.
         """
         self.wavelength = wavelength
         self.wavenumber = 2 * numpy.pi / wavelength
         self.itr_list = numpy.linspace(itr_initial, itr_final, n_step)
         self.superset = SuperSet(parent_solver=self, wavelength=wavelength)
 
     def index_to_eigen_value(self, index: float) -> float:
         """
-        Converts an effective index to the equivalent eigen value of the
-        linear system to be solved.
+        Converts a refractive index to the corresponding eigenvalue for the solver.
 
-        :param      eigen_value:  The eigen value
-        :type       eigen_value:  float
+        Args:
+            index (float): Refractive index to convert.
 
-        :returns:   The equivalent eigen value
-        :rtype:     float
+        Returns:
+            float: Calculated eigenvalue based on the given index and the wavenumber.
         """
         return -(index * self.wavenumber)**2
 
     def eigen_value_to_index(self, eigen_value: float) -> float:
         """
-        Converts an eigen value of the linear equation to solve to
-        its equivalent effective index.
+        Converts an eigenvalue from the solver to the corresponding refractive index.
 
-        :param      eigen_value:  The eigen value
-        :type       eigen_value:  float
+        Args:
+            eigen_value (float): Eigenvalue to convert.
 
-        :returns:   The equivalent eigen value
-        :rtype:     float
+        Returns:
+            float: Equivalent refractive index calculated from the eigenvalue and the wavenumber.
         """
         return numpy.sqrt(eigen_value) / self.wavenumber
 
     def get_supermode_labels(self, n_modes: int, boundaries: Boundaries, auto_label: bool) -> list:
         """
-        Generate and returns the supermode label depending if auto_label
-        is activated or not.
+        Generates labels for supermodes based on boundary conditions and whether auto-labeling is enabled.
 
-        :param      n_modes:     The n modes
-        :type       n_modes:     int
-        :param      boundaries:  The boundaries
-        :type       boundaries:  Boundaries
-        :param      auto_label:  The automatic label option
-        :type       auto_label:  bool
+        Args:
+            n_modes (int): Number of modes for which labels are needed.
+            boundaries (Boundaries): Boundary conditions that affect mode symmetries.
+            auto_label (bool): If True, automatically generates labels based on mode symmetries; otherwise, generates generic labels.
 
-        :returns:   The supermode labels.
-        :rtype:     list
+        Returns:
+            list: List of labels for the supermodes.
         """
         if auto_label:
-            mode_label = ModeLabel(boundaries=boundaries, n_mode=n_modes)
-            supermode_labels = mode_label.get_labels()
+            return [ModeLabel(boundaries=boundaries, mode_number=n).label for n in range(n_modes)]
         else:
-            supermode_labels = ["mode_" + "{" + str(n) + "}" for n in range(n_modes)]
+            return ["mode_" + "{" + str(n) + "}" for n in range(n_modes)]
 
-        return supermode_labels
+    def add_modes(self, n_sorted_mode: int, boundaries: Boundaries, n_added_mode: int = 4, index_guess: float = 0., auto_label: bool = True) -> None:
+        """
+        Computes and adds a specified number of supermodes to the solver's collection, using given boundary conditions and mode sorting criteria.
 
-    def add_modes(
-            self,
-            n_sorted_mode: int,
-            boundaries: Boundaries,
-            n_added_mode: int = 4,
-            index_guess: float = 0.,
-            auto_label: bool = True) -> None:
-        """
-        This methodes compute new set of n_added_mode modes for a given boundaries condition.
-        It appends those modes to the one already computed.
-        The auto_labeling options works only for almost cylindrical symmetric structure with low itr.
-        If wrong label is settle it can be modified with the label_supermode method. Index guess is the effective index
-        guess given to the inverse shift power method solver to retrieve the modes with close effective index.
-        Adds modes to the superset instance. SuperSet is accessible through .get_set().
-
-        :param      n_sorted_mode:    Number of mode that are outputed by the c++ solver.
-        :type       n_sorted_mode:    int
-        :param      boundaries:       Boundaries of the finit-difference system.
-        :type       boundaries:       Boundaries
-        :param      n_added_mode:     Number of additional modes that are computed for that will be sorted out, the higher the value the less likely mode mismatch will occur.
-        :type       n_added_mode:     int
-        :param      index_guess:      Initial effective index guess (if 0, auto evaluated).
-        :type       index_guess:      float
+        Args:
+            n_sorted_mode (int): Number of modes to output and sort from the solver.
+            boundaries (Boundaries): Boundary conditions for the finite difference calculations.
+            n_added_mode (int): Additional modes computed to ensure mode matching accuracy.
+            index_guess (float): Starting guess for the refractive index used in calculations (if 0, auto evaluated).
+            auto_label (bool): If True, enables automatic labeling of modes based on symmetry.
 
-        :returns:   No returns
-        :rtype:     None
+        Returns:
+            None: This method updates the solver's internal state but does not return any value.
         """
         alpha = self.index_to_eigen_value(index_guess)
 
         cpp_solver = self.initialize_binding(
             boundaries=boundaries,
             n_added_mode=n_added_mode,
             n_sorted_mode=n_sorted_mode
         )
 
+        self.superset.model_parameters = self.model_parameters
+
         cpp_solver.loop_over_itr(
             extrapolation_order=self.extrapolation_order,
             alpha=alpha
         )
 
         mode_labels = self.get_supermode_labels(
             n_modes=n_sorted_mode,
```

## SuPyMode/supermode.py

```diff
@@ -1,143 +1,189 @@
 # #!/usr/bin/env python
 # # -*- coding: utf-8 -*-
 
+from typing import Self
 # Built-in imports
 import numpy
-from dataclasses import dataclass
+from dataclasses import dataclass, field as field_arg
 from scipy.interpolate import RectBivariateSpline
 
 # Local imports
 from SuPyMode import representation
 from SuPyMode.binary.ModelParameters import ModelParameters
-from SuPyMode.tools.utils import interpret_slice_number_and_itr
+from SuPyMode.utils import interpret_slice_number_and_itr, get_symmetrized_vector
 
 
-class InheritFromSuperSet():
+@dataclass(kw_only=True)
+class SuperMode():
     """
-    Property class for inherited attribute from SuperSet.
-
+    Represents supermodes within fiber optic structures. This class serves as a Python
+    counterpart to a C++ SuperMode class, facilitating integration and computation via
+    the SuPySolver. Instances of this class belong to a SuperSet, and each supermode
+    is uniquely identified within its symmetry set by a mode number.
+
+    Attributes:
+        parent_set (None): The SuperSet instance associated with this supermode.
+        binded_supermode (None): The corresponding C++ bound supermode object.
+        solver_number (int): Identifier linking this supermode to a specific Python solver.
+        mode_number (int): Unique identifier for this mode within a symmetry set.
+        boundaries (dict): Specifications of the boundary conditions for the supermode.
+        label (str, optional): An arbitrary descriptive label for the supermode.
     """
-    @property
-    def geometry(self) -> object:
-        return self.parent_set.geometry
-
-    @property
-    def coordinate_system(self) -> object:
-        return self.parent_set.coordinate_system
-
-    @property
-    def itr_list(self) -> numpy.ndarray:
-        return self.binded_supermode.model_parameters.itr_list
-
-
-@dataclass
-class SuperMode(InheritFromSuperSet):
-    """
-    This class is a representation of the fiber optic structures SuperModes.
-    Those mode belongs to a SuperSet class and are constructed with the SuPySolver.
-    It links to c++ SuperMode class.
-    """
-    parent_set: None
-    """SuperSet to which is associated the computed this mode"""
-    binded_supermode: None
-    """C++ binded sueprmode"""
+    parent_set: object
+    binded_supermode: object
     solver_number: int
-    """Number which bind this mode to a specific python solver"""
     mode_number: int
-    """Unique number associated to this mode in a particular symmetry set"""
     boundaries: dict
-    """Boundary conditions"""
     label: str = None
-    """Arbitrary label given to the mode"""
+    ID: list = field_arg(init=False)
+    # Other representations
+    field: representation.Field = field_arg(init=False)
+    index: representation.Index = field_arg(init=False)
+    beta: representation.Beta = field_arg(init=False)
+    normalized_coupling: representation.NormalizedCoupling = field_arg(init=False)
+    adiabatic: representation.Adiabatic = field_arg(init=False)
+    eigen_value: representation.EigenValue = field_arg(init=False)
+    beating_length: representation.BeatingLength = field_arg(init=False)
 
     def __post_init__(self):
         self.ID = [self.solver_number, self.binding_number]
         self.field = representation.Field(parent_supermode=self)
         self.index = representation.Index(parent_supermode=self)
         self.beta = representation.Beta(parent_supermode=self)
         self.normalized_coupling = representation.NormalizedCoupling(parent_supermode=self)
         self.adiabatic = representation.Adiabatic(parent_supermode=self)
         self.eigen_value = representation.EigenValue(parent_supermode=self)
         self.beating_length = representation.BeatingLength(parent_supermode=self)
 
     def __hash__(self):
+        """
+        Returns a hash based on the binded supermode object, allowing this class
+        instance to be used in hash-based collections like sets and dictionaries.
+
+        Returns:
+            int: The hash value of the binded supermode object.
+        """
         return hash(self.binded_supermode)
 
     @property
     def binding_number(self) -> int:
-        """ Returns the mode number specific to one CppSolver """
+        """Retrieves the binding number specific to the linked C++ solver."""
         return self.binded_supermode.binding_number
 
     @property
+    def geometry(self) -> object:
+        """
+        Provides access to the geometric configuration associated with the supermode.
+
+        Returns:
+            object: The geometry of the parent SuperSet.
+        """
+        return self.parent_set.geometry
+
+    @property
+    def coordinate_system(self) -> object:
+        """
+        Accesses the coordinate system used by the supermode.
+
+        Returns:
+            object: The coordinate system of the parent SuperSet.
+        """
+        return self.parent_set.coordinate_system
+
+    @property
+    def itr_list(self) -> numpy.ndarray:
+        """Provides a list of iteration parameters from the model."""
+        return self.binded_supermode.model_parameters.itr_list
+
+    @property
     def model_parameters(self) -> ModelParameters:
+        """
+        Retrieves parameters defining the model's computational aspects.
+
+        Returns:
+            ModelParameters: Computational parameters from the binded supermode.
+        """
         return self.binded_supermode.model_parameters
 
     @property
     def mesh_gradient(self) -> numpy.ndarray:
+        """Accesses the gradient mesh associated with the supermode."""
         return self.binded_supermode.mesh_gradient
 
     @property
     def amplitudes(self) -> numpy.ndarray:
+        """
+        Computes the amplitude array for this supermode, setting its own mode number
+        to 1 and all others to 0.
+
+        Returns:
+            numpy.ndarray: Array of complex numbers representing amplitudes.
+        """
         n_mode = len(self.parent_set.supermodes)
         amplitudes = numpy.zeros(n_mode, dtype=complex)
         amplitudes[self.mode_number] = 1
         return amplitudes
 
     @property
     def stylized_label(self) -> str:
+        """
+        Provides a stylized label for the supermode. If no custom label is provided,
+        it defaults to a generic label with the mode ID.
+
+        Returns:
+            str: The stylized or default label.
+        """
         if self.label is None:
             return f"Mode: {self.ID}"
         else:
             return f"${self.label}$"
 
-    def is_computation_compatible(self, other: 'SuperMode') -> bool:
+    def is_computation_compatible(self, other: Self) -> bool:
         """
-        Determines whether the specified other supermode is compatible
-        for computation of the modal coupling and adiabatic criterion.
-        It, basically return False only if the mode is the same or if the
-        boundaries symmetries differ in some way.
+        Determines if another supermode is compatible for computation, based on unique
+        identifiers and boundary conditions.
 
-        :param      other:  The other SuperMode to compare with
-        :type       other:  SuperMode
+        Parameters:
+            other (SuperMode): The other supermode to compare.
 
-        :returns:   True if the specified other is computation compatible, False otherwise.
-        :rtype:     bool
+        Returns:
+            bool: True if the supermodes are compatible for computation, False otherwise.
         """
-        if self.ID != other.ID and self.is_symmetry_compatible(other):
-            return True
-        else:
-            return False
+        return self.binded_supermode.is_computation_compatible(other.binded_supermode)
 
-    def is_symmetry_compatible(self, other: 'SuperMode') -> bool:
+    def is_symmetry_compatible(self, other: Self) -> bool:
         """
         Determines whether the specified other supermode has same symmetry.
 
         :param      other:  The other supermode
         :type       other:  SuperMode
 
         :returns:   True if the specified other is symmetry compatible, False otherwise.
         :rtype:     bool
         """
         return self.boundaries == other.boundaries
 
     def get_field_interpolation(self, itr: float = None, slice_number: int = None) -> RectBivariateSpline:
         """
-        Gets the mode field interpolation at a certain itr or slice number value.
+        Computes the field interpolation for a given iteration or slice number. Requires
+        exactly one of the parameters to be specified.
 
-        :param      itr:           The itr
-        :type       itr:           float
-        :param      slice_number:  The slice number
-        :type       slice_number:  int
+        Parameters:
+            itr (float, optional): The iteration number for which to compute the interpolation.
+            slice_number (int, optional): The slice number for which to compute the interpolation.
 
-        :returns:   The mode field interpolation.
-        :rtype:     RectBivariateSpline
+        Returns:
+            RectBivariateSpline: Interpolated field values over a grid.
+
+        Raises:
+            ValueError: If neither or both parameters are specified.
         """
-        if not (itr is None) ^ (slice_number is None):
-            raise ValueError("Exactly one of the two keyword argument [itr, slice_number] has to be provided.")
+        if (itr is None) == (slice_number is None):
+            raise ValueError("Exactly one of itr or slice_number must be provided.")
 
         if slice_number is None:
             slice_number = self.parent_set.itr_to_slice(itr_list=itr)
 
         if itr is None:
             slice_number, itr = interpret_slice_number_and_itr(
                 itr_baseline=self.itr_list,
@@ -152,85 +198,77 @@
             x=x_axis * itr,
             y=y_axis * itr,
             z=field,
         )
 
         return field_interpolation
 
-    def _get_symmetrize_vector(self, vector: numpy.ndarray, symmetry_type: str = 'last') -> numpy.ndarray:
-        """
-        Take as input a vector and return a symmetric version of that vector.
-        The symmetry can be setted mirror the last or first element.
-
-        :param      vector:          The vector
-        :type       vector:          numpy.ndarray
-        :param      symmetry_type:   The symmetry type
-        :type       symmetry_type:   str
-
-        :returns:   The symmetrized vector
-        :rtype:     numpy.ndarray
-
-        :raises     AssertionError:  Verify that input vector is 1-dimensionnal.
-        """
-        assert vector.ndim == 1, f'Vector should be 1d, instead {vector.ndim} dimensional is provided.'
-
-        size = len(vector)
-        dx = abs(vector[0] - vector[1])
-
-        match symmetry_type.lower():
-            case 'last':
-                start_value = vector[0]
-                return numpy.arange(0, 2 * size - 1) * dx + start_value
-
-            case 'first':
-                start_value = vector[-1]
-                return numpy.arange(0, 2 * size - 1) * -dx + start_value
-
     def _get_axis_vector(self, add_symmetries: bool = True) -> tuple:
         full_x_axis = self.coordinate_system.x_vector
         full_y_axis = self.coordinate_system.y_vector
 
         if not add_symmetries:
             return full_x_axis, full_y_axis
 
         if self.boundaries.right in ['symmetric', 'anti-symmetric']:
-            full_x_axis = self._get_symmetrize_vector(full_x_axis, symmetry_type='last')
+            full_x_axis = get_symmetrized_vector(full_x_axis, symmetry_type='last')
             full_x_axis.sort()
 
         if self.boundaries.left in ['symmetric', 'anti-symmetric']:
-            full_x_axis = self._get_symmetrize_vector(full_x_axis, symmetry_type='first')
+            full_x_axis = get_symmetrized_vector(full_x_axis, symmetry_type='first')
             full_x_axis.sort()
 
         if self.boundaries.top in ['symmetric', 'anti-symmetric']:
-            full_y_axis = self._get_symmetrize_vector(full_y_axis, symmetry_type='last')
+            full_y_axis = get_symmetrized_vector(full_y_axis, symmetry_type='last')
             full_y_axis.sort()
 
         if self.boundaries.bottom in ['symmetric', 'anti-symmetric']:
-            full_y_axis = self._get_symmetrize_vector(full_y_axis, symmetry_type='first')
+            full_y_axis = get_symmetrized_vector(full_y_axis, symmetry_type='first')
             full_y_axis.sort()
 
         return full_x_axis, full_y_axis
 
     def get_axis(self, slice_number: int, add_symmetries: bool = True) -> tuple:
         itr = self.model_parameters.itr_list[slice_number]
 
         x_axis, y_axis = self._get_axis_vector(add_symmetries=add_symmetries)
 
         return (x_axis * itr, y_axis * itr)
 
     def __repr__(self) -> str:
         return self.label
 
-    def plot(self, plot_type: str, *args, **kwargs):
+    def plot(self, plot_type: str, **kwargs):
+        """
+        Plots various properties of the supermode based on specified type.
+
+        Parameters:
+            plot_type (str): The type of plot to generate (e.g., 'field', 'beta').
+            *args: Additional positional arguments for the plot function.
+            **kwargs: Additional keyword arguments for the plot function.
+
+        Returns:
+            The result of the plotting function, typically a plot object.
+
+        Raises:
+            ValueError: If an invalid plot type is specified.
+        """
         match plot_type.lower():
             case 'field':
-                return self.field.plot(*args, **kwargs)
+                return self.field.plot(**kwargs)
             case 'beta':
-                return self.beta.plot(*args, **kwargs)
+                return self.beta.plot(**kwargs)
             case 'index':
-                return self.beta.plot(*args, **kwargs)
+                return self.index.plot(**kwargs)
             case 'eigen-value':
-                return self.eigen_value.plot(*args, **kwargs)
+                return self.eigen_value.plot(**kwargs)
             case 'beating-length':
-                return self.beating_length.plot(*args, **kwargs)
+                return self.beating_length.plot(**kwargs)
+            case 'adiabatic':
+                return self.adiabatic.plot(**kwargs)
+            case 'normalized-coupling':
+                return self.normalized_coupling.plot(**kwargs)
+            case _:
+                raise ValueError(f'Invalid plot type: {plot_type}. Options are: index, beta, eigen-value, field, beating-length, adiabatic, normalized-coupling')
+
 
 # -
```

## SuPyMode/superset.py

```diff
@@ -5,37 +5,39 @@
 import pickle
 import numpy
 import logging
 from dataclasses import dataclass
 from pathlib import Path
 from itertools import combinations, product
 from pathvalidate import sanitize_filepath
+from typing import Optional, Tuple, List, Callable
 
 # Third-party imports
 from scipy.interpolate import interp1d
 from scipy.integrate import solve_ivp
 import pyvista
 
 # Local imports
 from SuPyMode.supermode import SuperMode
 from SuPyMode import representation
-from SuPyMode.tools.utils import test_valid_input, get_intersection, interpret_slice_number_and_itr, interpret_mode_of_interest
+from SuPyMode.utils import test_valid_input, get_intersection, interpret_slice_number_and_itr, interpret_mode_of_interest
 from SuPyMode.profiles import AlphaProfile
-from SuPyMode.tools import directories
+from SuPyMode import directories
 from MPSPlots.render2D import SceneMatrix, SceneList, Axis, Multipage
 
 
 @dataclass
 class SuperSet(object):
     """
-    Solver to which is associated the computed SuperSet Modes.
-    This class is a representation of the fiber optic structures set of supermodes, hence the name.
-    The items of this class are the supermodes generated from within the SuPySolver.
-    It doesn't link to any c++ binding, it is pure Python.
+    A class representing a set of supermodes calculated for a specific optical fiber configuration.
+    It facilitates operations on supermodes like sorting, plotting, and computations related to fiber optics simulations.
 
+    Attributes:
+        parent_solver (object): The solver instance that generated this SuperSet.
+        wavelength (float): The wavelength used in the solver, in meters.
     """
     parent_solver: object
     wavelength: float
 
     def __post_init__(self):
         self.wavenumber = 2 * numpy.pi / self.wavelength
         self._transmission_matrix = None
@@ -68,32 +70,34 @@
         Return axes object of the geometry
         """
         return self.parent_solver.geometry.coordinate_system
 
     @property
     def fundamental_supermodes(self) -> list[SuperMode]:
         """
-        Returns a list of the fundamental supermodes.
-        Those supermodes are defined as the highest beta-value supermodes associated
-        with a particular fiber
+        Identifies and returns fundamental supermodes based on the highest beta values and minimal spatial overlap.
 
-        :returns:   The fundamental supermodes
-        :rtype:     list[SuperMode]
+        Args:
+            tolerance (float): The spatial overlap tolerance for mode distinction.
+
+        Returns:
+            list[SuperMode]: A list of fundamental supermodes.
         """
         return self.get_fundamental_supermodes(tolerance=1e-2)
 
     @property
     def non_fundamental_supermodes(self) -> list[SuperMode]:
         """
-        Returns a list of the non-fundamental supermodes.
-        The fundamental supermodes are defined as the highest beta-value supermodes associated
-        with a particular fiber
+        Identifies and returns non-fundamental supermodes based on the specified spatial overlap tolerance.
 
-        :returns:   The non-fundamental supermodes
-        :rtype:     list[SuperMode]
+        Args:
+            tolerance (float): The spatial overlap tolerance for distinguishing between fundamental and other modes.
+
+        Returns:
+            list[SuperMode]: A list of non-fundamental supermodes.
         """
         return self.get_non_fundamental_supermodes(tolerance=1e-2)
 
     @property
     def transmission_matrix(self) -> numpy.ndarray:
         """
         Return supermode transfert matrix
@@ -122,34 +126,41 @@
         Returns list of modes that do not spatially overlap and that have the highest
         propagation constant values.
 
         :param      tolerance:  The tolerance to which consider the spatial overlap
         :type       tolerance:  float
 
         :returns:   List of the fundamental modes.
-        :rtype:     list
+        :rtype:     list[SuperMode]
         """
-        self.sorting_modes_beta()
+        self.sort_modes_by_beta()
 
         fundamental_supermodes = [self.supermodes[0]]
 
-        def coupling(mode_0: SuperMode, mode_1: SuperMode):
-            field_0 = numpy.abs(mode_0.field[0])
-            field_1 = numpy.abs(mode_1.field[0])
+        def absolute_overlap(mode_0: SuperMode, mode_1: SuperMode) -> float:
+            field_0 = numpy.abs(mode_0.field.data[0])
+            norm_0 = field_0.sum()
+            field_0 /= numpy.sqrt(norm_0)
+
+            field_1 = numpy.abs(mode_1.field.data[0])
+            norm_1 = field_1.sum()
+            field_1 /= numpy.sqrt(norm_1)
 
-            return numpy.sum(field_0 * field_1)
+            overlap = numpy.sum(field_0 * field_1)
+
+            return overlap
 
         for mode_0 in self.supermodes:
-            couplings = [
-                coupling(mode_0, mode_1) for mode_1 in fundamental_supermodes
+            abs_overlap = [
+                absolute_overlap(mode_0, mode_1) for mode_1 in fundamental_supermodes
             ]
 
-            couplings = numpy.asarray(couplings)
+            abs_overlaps = numpy.asarray(abs_overlap)
 
-            if numpy.any(couplings > tolerance):
+            if numpy.any(abs_overlaps > tolerance):
                 continue
 
             fundamental_supermodes.append(mode_0)
 
         return fundamental_supermodes
 
     def get_non_fundamental_supermodes(self, *, tolerance: float = 0.1) -> list[SuperMode]:
@@ -227,15 +238,15 @@
             len(self.supermodes),
             len(self.itr_list)
         ]
 
         self._transmission_matrix = numpy.zeros(shape)
 
         for mode in self.supermodes:
-            self._transmission_matrix[mode.mode_number, mode.mode_number, :] = mode.beta._data * 2.0 * numpy.pi
+            self._transmission_matrix[mode.mode_number, mode.mode_number, :] = mode.beta.data * 2.0 * numpy.pi
 
     def add_coupling_to_t_matrix(self, *, t_matrix: numpy.ndarray, adiabatic_factor: numpy.ndarray) -> numpy.ndarray:
         """
         Add the coupling coefficients to the transmission matrix.
 
         :param      t_matrix:          The t matrix to which add the coupling values
         :type       t_matrix:          numpy.ndarray
@@ -254,16 +265,18 @@
             coupling = mode_0.normalized_coupling.get_values(mode_1)[:size]
 
             coupling *= adiabatic_factor
 
             t_matrix[mode_0.mode_number, mode_1.mode_number, :] = - coupling
             t_matrix[mode_1.mode_number, mode_0.mode_number, :] = + coupling
 
-        if numpy.isnan(t_matrix).any() or numpy.isinf(t_matrix).any():
-            raise ValueError('Nan or inf values detected in transmission matrix')
+        if numpy.isnan(t_matrix).any():
+            raise ValueError('Nan values detected in transmission matrix.')
+        if numpy.isinf(t_matrix).any():
+            raise ValueError('Inf values detected in transmission matrix, verify that there is no hybrid mode in the computation.')
 
         return t_matrix
 
     def compute_coupling_factor(self, *, coupler_length: float) -> numpy.ndarray:
         r"""
         Compute the coupling factor defined as:
 
@@ -310,165 +323,156 @@
 
         return sub_distance, sub_itr_vector, sub_t_matrix
 
     def propagate(
             self, *,
             profile: AlphaProfile,
             initial_amplitude: list,
-            max_step: float = None,
-            n_step: int = None,
+            max_step: Optional[float] = None,
+            n_step: Optional[int] = None,
             add_coupling: bool = True,
             method: str = 'RK45',
-            **kwargs) -> numpy.ndarray:
+            **kwargs: dict) -> Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]:
         """
-        Returns the amplitudes value of the supermodes in the coupler.
+        Propagates the amplitudes of the supermodes in a coupler based on a given profile.
 
-        :param      initial_amplitude:  The initial amplitude
-        :type       initial_amplitude:  list
-        :param      profile:            The z-profile of the coupler
-        :type       profile:            object
-        :param      max_step:           The maximum stride to use in the solver
-        :type       max_step:           float
-        :param      add_coupling:       Add coupling to the transmission matrix
-        :type       add_coupling:       bool
-        :param      kwargs:             The keywords arguments to be passed to the solver
-        :type       kwargs:             dictionary
-
-        :returns:   The amplitudes as a function of the distance in the coupler
-        :rtype:     numpy.ndarray
+        Args:
+            profile (AlphaProfile): The z-profile of the coupler.
+            initial_amplitude (list): The initial amplitude as a list.
+            max_step (float, optional): The maximum step size used by the solver. Defaults to None.
+            n_step (int, optional): Number of steps used by the solver (not currently used in this method).
+            add_coupling (bool): Flag to add coupling to the transmission matrix. Defaults to True.
+            method (str): Integration method to be used by the solver. Defaults to 'RK45'.
+            **kwargs (Dict[str, Any]): Additional keyword arguments to be passed to the solver.
+
+        Returns:
+            Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]: A tuple containing the times of the solution,
+                                                       the solution array of amplitudes, and the interpolated
+                                                       index of refraction at those times.
         """
-        profile.initialize()
-
-        initial_amplitude = numpy.asarray(initial_amplitude).astype(complex)
+        initial_amplitude = numpy.asarray(initial_amplitude, dtype=complex)
 
         if max_step is None:
             max_step = self.parent_solver.wavelength / 200
 
         sub_distance, sub_itr_vector, sub_t_matrix = self.get_transmision_matrix_from_profile(
             profile=profile,
-            add_coupling=add_coupling,
-        )
-
-        z_to_itr = interp1d(
-            profile.distance,
-            profile.itr_list,
-            bounds_error=False,
-            fill_value='extrapolate',
-            axis=-1
+            add_coupling=add_coupling
         )
 
-        itr_to_t_matrix = interp1d(
-            sub_itr_vector,
-            sub_t_matrix,
-            bounds_error=False,
-            fill_value='extrapolate',
-            axis=-1
-        )
+        z_to_itr = interp1d(profile.distance, profile.itr_list, bounds_error=False, fill_value='extrapolate')
+        itr_to_t_matrix = interp1d(sub_itr_vector, sub_t_matrix, bounds_error=False, fill_value='extrapolate')
 
         def model(z, y):
             itr = z_to_itr(z)
-            return 1j * itr_to_t_matrix(itr).dot(y)
+            return 1j * itr_to_t_matrix(itr) @ y
 
         sol = solve_ivp(
-            model,
+            fun=model,
             y0=initial_amplitude,
             t_span=[0, profile.total_length],
+            method=method,
             vectorized=True,
             max_step=max_step,
-            method=method,
             **kwargs
         )
 
-        norm = (numpy.abs(sol.y)**2).sum(axis=0)
-
-        if not numpy.all(numpy.isclose(norm, 1.0, atol := 1e-1)):
-            logging.warning(f'Power conservation is not acheived [{atol = }]. You should consider reducing the max step size [{max_step = }]')
+        # Check power conservation across the propagation
+        norm = numpy.sum(numpy.abs(sol.y)**2, axis=0)
+        if not numpy.allclose(norm, 1.0, atol=1e-1):
+            logging.warning(f'Power conservation not achieved [{max_step = }, atol = 1e-1].')
 
         return sol.t, sol.y, z_to_itr(sol.t)
 
-    def interpret_initial_input(self, initial_amplitude: list) -> numpy.ndarray:
-        amplitude_size = len(initial_amplitude)
-        number_of_supermodes = len(self.supermodes)
-        assert len(initial_amplitude) == len(self.supermodes), f'Amplitudes size: {amplitude_size} do not match with the number of supermodes: {number_of_supermodes}'
+    def interpret_initial_input(self, initial_amplitude: list | SuperMode) -> numpy.ndarray:
+        """
+        Interprets the initial amplitude input, ensuring compatibility with the expected number of supermodes.
+
+        Args:
+            initial_amplitude (list | SuperMode): The initial amplitude as either a list of complex numbers or a SuperMode object.
 
+        Returns:
+            numpy.ndarray: The initial amplitudes as a NumPy array of complex numbers.
+
+        Raises:
+            ValueError: If the length of the initial amplitude list does not match the number of supermodes.
+        """
         if isinstance(initial_amplitude, SuperMode):
-            return initial_amplitude.amplitudes
+            amplitudes = initial_amplitude.amplitudes
         else:
-            return numpy.asarray(initial_amplitude).astype(complex)
+            amplitudes = initial_amplitude
+
+        amplitude_size = len(amplitudes)
+        number_of_supermodes = len(self.supermodes)
+
+        if amplitude_size != number_of_supermodes:
+            raise ValueError(f'Amplitudes size: {amplitude_size} does not match with the number of supermodes: {number_of_supermodes}')
+
+        return numpy.asarray(amplitudes, dtype=complex)
 
     def plot_propagation(
             self, *,
             profile: AlphaProfile,
             initial_amplitude,
-            max_step: float = None,
+            max_step: Optional[float] = None,
             add_coupling: bool = True,
             method: str = 'RK45',
             sub_sampling: int = 5,
             show_energy: bool = True,
             show_amplitudes: bool = True,
-            **kwargs) -> tuple:
+            **kwargs: dict) -> Tuple[SceneList, Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]]:
+        """
+        Plots the propagation of amplitudes over a given profile, showing energy and amplitude plots.
 
-        initial_amplitude = self.interpret_initial_input(
-            initial_amplitude=initial_amplitude
-        )
+        Args:
+            profile (AlphaProfile): The profile to propagate.
+            initial_amplitude: The initial amplitudes, either as a list or a SuperMode object.
+            max_step (Optional[float]): The maximum step size for the solver.
+            add_coupling (bool): Whether to add coupling in the transmission matrix.
+            method (str): Numerical method for solving the propagation.
+            sub_sampling (int): The factor for sub-sampling data for plotting.
+            show_energy (bool): Whether to plot the energy of the modes.
+            show_amplitudes (bool): Whether to plot the real part of the amplitudes.
+            **kwargs (Dict[str, Any]): Additional keyword arguments for solver.
+
+        Returns:
+            Tuple[SceneList, Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]]: A tuple containing the matplotlib figure object
+                                                                          and a tuple with propagation distances, amplitudes,
+                                                                          and inverse taper ratios.
+        """
+        initial_amplitude = self.interpret_initial_input(initial_amplitude)
 
         z, amplitudes, itr_list = self.propagate(
             initial_amplitude=initial_amplitude,
             profile=profile,
             add_coupling=add_coupling,
             max_step=max_step,
-            method=method
+            method=method,
+            **kwargs
         )
 
         figure = SceneList(unit_size=(12, 4))
-
-        ax = figure.append_ax(
-            line_width=2,
-            show_legend=True,
-            x_label='Propagation distance z',
-            y_label='Inverse taper ratio [ITR]'
-        )
+        ax = figure.append_ax(line_width=2, show_legend=True, x_label='Propagation distance z', y_label='Inverse taper ratio [ITR]')
 
         for idx, mode in enumerate(self.supermodes):
             color = f"C{idx}"
-            if show_energy:
-                ax.add_line(
-                    x=z[::sub_sampling],
-                    y=abs(amplitudes[idx, ::sub_sampling])**2,
-                    label=mode.stylized_label,
-                    line_width=2.0,
-                    line_style='-',
-                    color=color
-                )
+            x_values = z[::sub_sampling]
+            y_energy = numpy.abs(amplitudes[idx, ::sub_sampling])**2
+            y_amplitude = amplitudes[idx, ::sub_sampling].real
 
+            if show_energy:
+                ax.add_line(x=x_values, y=y_energy, label=mode.stylized_label, line_width=2.0, line_style='-', color=color)
             if show_amplitudes:
-                ax.add_line(
-                    x=z[::sub_sampling],
-                    y=amplitudes[idx, ::sub_sampling].real,
-                    label=mode.stylized_label,
-                    line_width=2.0,
-                    line_style='--',
-                    color=color
-                )
+                ax.add_line(x=x_values, y=y_amplitude, label=mode.stylized_label + ' Amplitude', line_width=2.0, line_style='--', color=color)
 
         if show_energy:
-            total_energy = abs(amplitudes)**2
-            total_energy = total_energy.sum(axis=0)
-            total_energy = numpy.sqrt(total_energy)
-
-            ax.add_line(
-                x=z[::sub_sampling],
-                y=total_energy[::sub_sampling],
-                label='Total energy',
-                line_width=3.0,
-                line_style='--',
-                color='black'
-            )
+            total_energy = numpy.sqrt(numpy.sum(numpy.abs(amplitudes)**2, axis=0))[::sub_sampling]
+            ax.add_line(x=x_values, y=total_energy, label='Total energy', line_width=3.0, line_style='--', color='black')
 
-        return figure, (z, amplitudes, itr_list)
+        return figure.fig, (z, amplitudes, itr_list)
 
     def generate_propagation_gif(
             self, *,
             profile: AlphaProfile,
             initial_amplitude,
             max_step: float = None,
             coupling: str = 'normalized',
@@ -584,69 +588,68 @@
             plotter.update_scalars(total_field.T.ravel(), render=False)
             plotter.add_title(f'ITR: {itr: .3f}\t  z: {z: .3e}', font='courier', color='w', font_size=20)
 
             plotter.write_frame()
 
         plotter.close()
 
-    def _sorting_modes_(self, *ordering_list) -> None:
+    def _sort_modes(self, *ordering_keys) -> List[SuperMode]:
         """
-        Generic mode sorting method
+        Sorts supermodes using specified keys provided as tuples in ordering_keys.
 
-        :param      ordering_parameters:  The ordering list to sort the supermodes
-        :type       ordering_parameters:  list
-        """
-        order = numpy.lexsort(ordering_list)
-
-        supermodes = [self.supermodes[idx] for idx in order]
-
-        for n, supermode in enumerate(supermodes):
-            supermode.mode_number = n
+        Args:
+            ordering_keys (tuple): Tuple containing keys to sort by.
 
-        return supermodes
+        Returns:
+            List[SuperMode]: Sorted list of supermodes.
+        """
+        order = numpy.lexsort(ordering_keys)
+        sorted_supermodes = [self.supermodes[idx] for idx in order]
+        for i, supermode in enumerate(sorted_supermodes):
+            supermode.mode_number = i
+        return sorted_supermodes
 
-    def sorting_modes_beta(self) -> None:
+    def sort_modes_by_beta(self) -> None:
         """
-        Re-order modes to sort them in descending value of propagation constant.
+        Sorts supermodes in descending order of their propagation constants (beta).
         """
-        return self._sorting_modes_([-mode.beta[-1] for mode in self.supermodes])
+        self.all_supermodes = self._sort_modes([-mode.beta.data[-1] for mode in self.supermodes])
 
-    def sorting_modes(self, *, sorting_method: str = "beta", keep_only: int = None) -> None:
-        """
-        Re-order modes according to a sorting method, either "beta" or "symmetry+beta".
-        The final mode selection will also be filter to keep only a certain number of modes
+    def sort_modes(self, sorting_method: str = "beta", keep_only: Optional[int] = None) -> None:
         """
-        assert sorting_method.lower() in ["beta", "symmetry+beta"], \
-            f"Unrecognized sortingmethod: {sorting_method}, accepted values are ['beta', 'symmetry+beta']"
+        Sorts supermodes according to the specified method, optionally limiting the number of modes retained.
 
-        match sorting_method.lower():
-            case "beta":
-                supermodes = self.sorting_modes_beta()
-            case "symmetry+beta":
-                supermodes = self.sorting_modes_solver_beta()
+        Args:
+            sorting_method (str): Sorting method to use, either "beta" or "symmetry+beta".
+            keep_only (int, optional): Number of supermodes to retain after sorting.
 
-        self.all_supermodes = supermodes
+        Raises:
+            ValueError: If an unrecognized sorting method is provided.
+        """
+        match sorting_method.lower():
+            case 'beta':
+                self.sort_modes_by_beta()
+            case 'symmetry+beta':
+                self.sort_modes_by_solver_and_beta()
+            case _:
+                raise ValueError(f"Unrecognized sorting method: {sorting_method}, accepted values are ['beta', 'symmetry+beta']")
 
-        self.supermodes = supermodes[:keep_only]
+        self.supermodes = self.all_supermodes[:keep_only] if keep_only is not None else self.all_supermodes
 
-    def sorting_modes_solver_beta(self) -> list[SuperMode]:
+    def sort_modes_by_solver_and_beta(self) -> None:
         """
-        Re-order modes to sort them in with two parameters:
-        ascending cpp_solver number and descending value of propagation constant.
-
-        :returns:   list of supermode in ordered beta
-        :rtype:     list[SuperMode]
+        Sorts supermodes primarily by solver number and secondarily by descending propagation constant (beta).
         """
-        return self._sorting_modes_(
-            [-mode.beta[-1] for mode in self.supermodes],
-            [mode.solver_number for mode in self.supermodes],
+        self.all_supermodes = self._sort_modes(
+            ([mode.solver_number for mode in self.supermodes],
+             [-mode.beta[-1] for mode in self.supermodes])
         )
 
     @staticmethod
-    def single_plot(plot_function):
+    def single_plot(plot_function) -> Callable:
         def wrapper(self, *args, mode_of_interest='all', **kwargs):
             mode_of_interest = interpret_mode_of_interest(
                 superset=self,
                 mode_of_interest=mode_of_interest
             )
 
             figure = SceneList(unit_size=(16, 6), ax_orientation='vertical')
@@ -656,15 +659,15 @@
             plot_function(self, ax=ax, *args, mode_of_interest=mode_of_interest, **kwargs)
 
             return figure
 
         return wrapper
 
     @staticmethod
-    def combination_plot(plot_function):
+    def combination_plot(plot_function) -> Callable:
         def wrapper(self, *args, mode_of_interest='all', mode_selection: str = 'pairs', **kwargs):
             mode_of_interest = interpret_mode_of_interest(
                 superset=self,
                 mode_of_interest=mode_of_interest
             )
 
             combination = self.interpret_mode_selection(
@@ -695,15 +698,15 @@
         :type       mode_of_interest:  str
         :param      artist_kwargs:     The keywords arguments
         :type       artist_kwargs:     dictionary
 
         :returns:   figure instance, to plot the show() method.
         :rtype:     SceneList
         """
-        ax.set_style(**representation.index.ax_style)
+        ax.set_style(**representation.index.Index.plot_style)
 
         for mode in mode_of_interest:
             mode.index.render_on_ax(ax=ax)
 
         if show_crossings:
             self.add_crossings_to_ax(ax=ax, mode_of_interest=mode_of_interest, data_type='index')
 
@@ -720,15 +723,15 @@
         :type       mode_of_interest:  str
         :param      artist_kwargs:     The keywords arguments
         :type       artist_kwargs:     dictionary
 
         :returns:   figure instance, to plot the show() method.
         :rtype:     SceneList
         """
-        ax.set_style(**representation.beta.ax_style)
+        ax.set_style(**representation.beta.Beta.plot_style)
 
         for mode in mode_of_interest:
             mode.beta.render_on_ax(ax=ax)
 
         if show_crossings:
             self.add_crossings_to_ax(ax=ax, mode_of_interest=mode_of_interest, data_type='beta')
 
@@ -745,15 +748,15 @@
         :type       mode_of_interest:  str
         :param      artist_kwargs:     The keywords arguments
         :type       artist_kwargs:     dictionary
 
         :returns:   figure instance, to plot the show() method.
         :rtype:     SceneList
         """
-        ax.set_style(**representation.eigen_value.ax_style)
+        ax.set_style(**representation.eigen_value.EigenValue.plot_style)
 
         for mode in mode_of_interest:
             mode.index.render_on_ax(ax=ax)
 
         if show_crossings:
             self.add_crossings_to_ax(ax=ax, mode_of_interest=mode_of_interest, data_type='eigen_value')
 
@@ -772,15 +775,15 @@
         :type       mode_selection:    str
         :param      artist_kwargs:     The keywords arguments
         :type       artist_kwargs:     dictionary
 
         :returns:   figure instance, to plot the show() method.
         :rtype:     SceneList
         """
-        ax.set_style(**representation.normalized_coupling.ax_style)
+        ax.set_style(**representation.normalized_coupling.NormalizedCoupling.plot_style)
 
         for mode_0, mode_1 in combination:
             mode_0.normalized_coupling.render_on_ax(ax=ax, other_supermode=mode_1)
 
     @combination_plot
     def plot_beating_length(
             self,
@@ -793,15 +796,15 @@
         :param      mode_of_interest:  List of the mode that are to be considered in the adiabatic criterion plotting.
         :type       mode_of_interest:  list
 
         :returns:   figure instance, to plot the show() method.
         :rtype:     SceneList
         """
         for mode_0, mode_1 in combination:
-            ax.set_style(**mode_0.beating_length.ax_style)
+            ax.set_style(**mode_0.beating_length.BeatingLength.plot_style)
             mode_0.beating_length.render_on_ax(ax=ax, other_supermode=mode_1)
 
     @combination_plot
     def plot_adiabatic(
             self,
             ax: Axis,
             mode_of_interest: list[SuperMode],
@@ -816,20 +819,20 @@
         :type       mode_selection:    str
         :param      artist_kwargs:     The keywords arguments
         :type       artist_kwargs:     dictionary
 
         :returns:   figure instance, to plot the show() method.
         :rtype:     SceneList
         """
-        ax.set_style(**representation.adiabatic.ax_style)
+        ax.set_style(**representation.adiabatic.Adiabatic.plot_style)
         for mode_0, mode_1 in combination:
             mode_0.adiabatic.render_on_ax(ax=ax, other_supermode=mode_1)
 
         for profile in numpy.atleast_1d(add_profile):
-            profile.render_adiabatic_factor_vs_itr_on_ax(ax=ax, line_style='--', line_color='black')
+            profile.render_adiabatic_factor_vs_itr_on_ax(ax=ax, line_style='--')
 
     def is_compute_compatible(self, pair_of_mode: tuple) -> bool:
         """
         Determines whether the specified pair of mode is compatible for computation.
 
         :param      pair_of_mode:  The pair of mode
         :type       pair_of_mode:  tuple
@@ -884,16 +887,16 @@
         mode_combinations = self.remove_duplicate_combination(mode_combinations)
 
         return set(mode_combinations)
 
     def plot_field(
             self,
             mode_of_interest: list = 'all',
-            itr_list: list[float] = [],
-            slice_list: list[int] = [0, -1],
+            itr_list: list[float] = None,
+            slice_list: list[int] = None,
             show_mode_label: bool = True,
             show_itr: bool = True,
             show_slice: bool = True) -> SceneList:
         """
         Plot each of the mode field for different itr value or slice number.
 
         :param      itr_list:    List of itr value to evaluate the mode field
@@ -915,44 +918,42 @@
         mode_of_interest = interpret_mode_of_interest(
             superset=self,
             mode_of_interest=mode_of_interest
         )
 
         for m, mode in enumerate(mode_of_interest):
             for n, slice_number in enumerate(slice_list):
-                ax = figure.append_ax(
-                    row=n,
-                    column=m,
-                )
+                ax = figure.append_ax(row=n, column=m)
 
-                ax.set_style(**representation.field.ax_style)
+                ax.set_style(**representation.field.Field.plot_style)
 
                 mode.field.render_on_ax(
                     ax=ax,
                     slice_number=slice_number,
                     show_mode_label=show_mode_label,
                     show_itr=show_itr,
                     show_slice=show_slice
                 )
 
         return figure
 
     def plot(self, plot_type: str, **kwargs) -> SceneList:
         """
-        Generic plot function.
+        General plotting function to handle different types of supermode plots.
 
         Args:
-            type: Plot type ['index', 'beta', 'adiabatic', 'normalized-adiabatic', 'coupling', 'field', 'beating-length']
-        """
-        test_valid_input(
-            variable_name='plot_type',
-            user_input=plot_type,
-            valid_inputs=['index', 'beta', 'eigen-value', 'adiabatic', 'normalized-adiabatic', 'normalized-coupling', 'field', 'beating-length']
-        )
+            plot_type (str): The type of plot to generate. Options include 'index', 'beta', 'eigen-value', etc.
+            **kwargs: Additional keyword arguments for specific plot configurations.
 
+        Returns:
+            SceneList: The generated plot as a SceneList object.
+
+        Raises:
+            ValueError: If an unrecognized plot type is specified.
+        """
         match plot_type.lower():
             case 'index':
                 return self.plot_index(**kwargs)
             case 'beta':
                 return self.plot_beta(**kwargs)
             case 'eigen-value':
                 return self.plot_eigen_value(**kwargs)
@@ -964,21 +965,23 @@
                 return self.plot_adiabatic(**kwargs)
             case 'field':
                 return self.plot_field(**kwargs)
             case 'beating-length':
                 return self.plot_beating_length(**kwargs)
             case 'normalized-adiabatic':
                 return self.plot_normalized_adiabatic(**kwargs)
+            case _:
+                raise ValueError(f'Invalid plot type: {plot_type}. Options are: index, beta, eigen-value, adiabatic, normalized-adiabatic, normalized-coupling, field, beating-length')
 
     def generate_pdf_report(
             self,
             filename: str = "report",
             directory: str = '.',
-            itr_list: list[float] = [],
-            slice_list: list[int] = [],
+            itr_list: list[float] | None = None,
+            slice_list: list[int] | None = None,
             dpi: int = 200,
             mode_of_interest: list = 'all',
             mode_selection: str = 'specific') -> None:
         """
         Generate a full report of the coupler properties as a .pdf file
 
         :param      filename:          Name of the Report file to be outputed.
@@ -1017,15 +1020,15 @@
         figure_list.append(self.plot_adiabatic(mode_of_interest=mode_of_interest, mode_selection=mode_selection)._render_())
 
         Multipage(filename, figs=figure_list, dpi=dpi)
 
         for figure in figure_list:
             figure.close()
 
-    def save_instance(self, filename: str, directory: str = '.') -> Path:
+    def save_instance(self, filename: str, directory: str = 'auto') -> Path:
         """
         Saves the superset instance as a serialized pickle file.
 
         :param      filename:  The directory where to save the file, 'auto' options means the superset_instance folder
         :type       filename:  str
         :param      filename:  The filename
         :type       filename:  str
@@ -1054,16 +1057,16 @@
             mode_of_interest=mode_of_interest,
             mode_selection='pairs'
         )
 
         for mode_0, mode_1 in combination:
             x, y = get_intersection(
                 x=self.itr_list,
-                y0=getattr(mode_0, data_type)._data,
-                y1=getattr(mode_1, data_type)._data,
+                y0=getattr(mode_0, data_type).data,
+                y1=getattr(mode_1, data_type).data,
                 average=True
             )
 
             if x is not None:
                 ax.add_scatter(
                     x=x,
                     y=y,
```

## SuPyMode/workflow.py

```diff
@@ -1,73 +1,72 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
 
+from typing import List, Union, Optional
 from dataclasses import dataclass
 from pathlib import Path
 
 from FiberFusing import Geometry, BackGround
 from SuPyMode.solver import SuPySolver
 from FiberFusing.fiber import catalogue as fiber_catalogue
-from SuPyMode.profiles import AlphaProfile
-from FiberFusing import configuration
+from SuPyMode.profiles import AlphaProfile  # noqa: F401
+from FiberFusing import configuration  # noqa: F401
 
 from PyFinitDiff.finite_difference_2D import Boundaries
 from pathvalidate import sanitize_filepath
 
 
 def prepare_simulation_geometry(
         wavelength: float,
         clad_structure: object,
-        fiber_list: list,
-        capillary_tube: object = None,
-        fusion_degree: float | str = 'auto',
-        fiber_radius: float = None,
-        x_bounds: str | list = '',
-        y_bounds: str | list = '',
-        clad_index: float | str = 'silica',
+        fiber_list: List[object],
+        capillary_tube: Optional[object] = None,
+        fusion_degree: Union[float, str] = 'auto',
+        fiber_radius: Optional[float] = None,
+        x_bounds: Union[str, List[float]] = '',
+        y_bounds: Union[str, List[float]] = '',
+        clad_index: Union[float, str] = 'silica',
         core_position_scrambling: float = 0,
         index_scrambling: float = 0,
         resolution: int = 150,
         rotation: float = 0,
         boundary_pad_factor: float = 1.2,
         gaussian_filter: float = 0,
         background_index: float = 1) -> Geometry:
     """
-    Prepare and returns the processed geometry for simulation using SuPyMode.
+    Prepares and returns the simulation geometry for optical fiber configurations,
+    incorporating fused structures, optional capillary tubes, and specific boundary conditions.
 
-    :param      wavelength:                Wavelength at which evaluate the computation
-    :type       wavelength:                float
-    :param      clad_structure:            Initial optical structure
-    :type       clad_structure:            object
-    :param      fiber_list:                The fiber list
-    :type       fiber_list:                list
-    :param      capillary_tube:            Additional optical structure such as clad to add
-    :type       capillary_tube:            object
-    :param      fusion_degree:             Fusion degree for the clad fused structure
-    :type       fusion_degree:             float
-    :param      fiber_radius:              The fiber radius for the fused clad structure, all radii are assumed the same here.
-    :type       fiber_radius:              float
-    :param      x_bounds:                  The x-axis boundaries.
-    :type       x_bounds:                  str
-    :param      y_bounds:                  The y-axis boundaries.
-    :type       y_bounds:                  str
-    :param      clad_index:                The fused clad refractive index.
-    :type       clad_index:                str
-    :param      core_position_scrambling:  The core position scrambling.
-    :type       core_position_scrambling:  float
-    :param      resolution:                The rasterisation resolution for the geometry.
-    :type       resolution:                int
-    :param      background_index:          The background refractive index.
-    :type       background_index:          float
+    Args:
+        wavelength (float): Wavelength for refractive index calculation.
+        clad_structure (object): Cladding or structural template for fibers.
+        fiber_list (List[object]): List of fibers to be included in the simulation.
+        capillary_tube (Optional[object]): Optional capillary structure to add.
+        fusion_degree (Union[float, str]): Degree of fusion, specifying overlap between fibers.
+        fiber_radius (Optional[float]): Uniform radius for all fibers, if specified.
+        x_bounds (Union[str, List[float]]): X-axis boundary conditions or limits.
+        y_bounds (Union[str, List[float]]): Y-axis boundary conditions or limits.
+        clad_index (Union[float, str]): Refractive index for the cladding material, can be a known string identifier.
+        core_position_scrambling (float): Random displacement added to fiber core positions to simulate imperfections.
+        index_scrambling (float): Noise level to simulate index inhomogeneity.
+        resolution (int): Resolution of the geometry mesh grid.
+        rotation (float): Rotation angle for the structure (degrees).
+        boundary_pad_factor (float): Padding factor for boundary adjustments.
+        gaussian_filter (float): Standard deviation for Gaussian blur to smooth sharp transitions.
+        background_index (float): Background refractive index for the simulation area.
 
-    :returns:   The simulation geometry
-    :rtype:     Geometry
+    Returns:
+        Geometry: Configured geometry object ready for simulation.
     """
-    if clad_index.lower() == 'silica':
+    if isinstance(clad_index, str) and clad_index.lower() == 'silica':
         index = fiber_catalogue.get_silica_index(wavelength=wavelength)
+    elif isinstance(clad_index, (float, int)):
+        index = clad_index
+    else:
+        raise ValueError("Invalid clad_index: must be either 'silica' or a numeric index value.")
 
     background = BackGround(index=background_index)
 
     clad_instance = prepare_fused_structure(
         clad_class=clad_structure,
         fiber_radius=fiber_radius,
         fusion_degree=fusion_degree,
@@ -141,93 +140,98 @@
         clad_instance.rotate(rotation)
 
     return clad_instance
 
 
 @dataclass
 class Workflow():
+    """
+    A class to configure and execute optical simulations using finite difference methods on specified fiber geometries.
+
+    Attributes:
+        wavelength (float): Wavelength at which the simulation is evaluated.
+        resolution (int): Resolution of the simulation mesh.
+        fiber_radius (float): Radius for the fused clad structure.
+        n_sorted_mode (int): Number of modes that are computed and sorted.
+        n_added_mode (int): Additional modes computed beyond the sorted modes for increased accuracy.
+        itr_final (float): Final Inverse Taper Ratio (ITR) for mode evaluation.
+        itr_initial (float): Initial ITR for mode evaluation.
+        n_step (int): Number of steps to iterate through the ITR section.
+        fusion_degree (Union[float, str]): Fusion degree for the clad fused structure; 'auto' for automatic calculation.
+        clad_rotation (float): Rotation of the clad structure in degrees.
+        accuracy (int): Accuracy level of the finite difference method.
+        debug_mode (int): Debug mode level for verbose output during computations.
+        auto_label (bool): If True, automatically labels supermodes.
+        generate_report (bool): If True, generates a PDF report of the simulation results.
+        save_superset (bool): If True, saves the computed superset instance for later use.
+        fiber_list (List[object]): List of fibers included in the optical structure.
+        boundaries (List[Boundaries]): Boundary conditions applied to the simulation.
+        capillary_tube (Optional[object]): Additional capillary structure to include in the simulation.
+        clad_structure (Optional[object]): Initial optical structure used for the simulation.
+        x_bounds (str): Boundary conditions along the x-axis.
+        y_bounds (str): Boundary conditions along the y-axis.
+        air_padding_factor (float): Factor for padding the structure with air to prevent boundary effects.
+        gaussian_filter_factor (Optional[float]): Gaussian blurring factor applied to the structure for smoothing.
+
+    Plotting Flags:
+        Various flags that determine which aspects of the simulation are plotted.
+
+    Methods:
+        __post_init__: Initializes the simulation geometry and solver upon object creation.
+        plot: Plots various simulation outputs based on the provided plot type.
+        save_superset_instance: Saves the computed superset to a file for later use.
+        generate_pdf_report: Generates a comprehensive PDF report of all relevant simulation data and results.
+        _get_auto_generated_filename: Generates a filename based on the simulation parameters.
+    """
+
     #  Geometry arguments --------------------------
     wavelength: float
-    """ Wavelenght at which evaluate the computation """
     clad_rotation: float = 0
-    """ Rotation of the clad structure [degree] """
     capillary_tube: object = None
-    """ Additional optical structure such as clad to add """
     resolution: int = 100
-    """ Discretization of the mesh [resolution x resolution] """
     clad_structure: object = None
-    """ Initial optical structure """
     fiber_list: list = tuple()
-    """ List of the fiber to add to the optical structure """
     fiber_radius: float = 62.5e-6
-    """ Fiber radius for the clad fused structure """
     fusion_degree: float = 'auto'
-    """ Fusion degree for the clad fused structure """
     x_bounds: str = ''
-    """ X-boundaries """
     y_bounds: str = ''
-    """ Y-boundaries """
     air_padding_factor: float = 1.2
-    """ Padding factor for air around the optica structure, preferable over 1.2 """
     gaussian_filter_factor: float = None
-    """ Gaussian blurring of the optical structure """
 
     #  Solver arguments --------------------------
     n_sorted_mode: int = 4
-    """ Number of mode that are computed """
     n_added_mode: int = 4
-    """ Number of mode that are computed additionally to the sorted modes """
     itr_final: float = 0.05
-    """ Final ITR at which evaluate the modes """
     itr_initial: float = 1.0
-    """ Start ITR at which evaluate the modes """
     n_step: int = 500
-    """ Discretization of the z-profile """
     extrapolation_order: int = 2
-    """ Eigen_value extrapolation for slice solving """
     core_position_scrambling: float = 0
-    """ Scrambling of the clad core position """
     index_scrambling: float = 0
-    """ Scrambling of the structure refractive index """
     boundaries: list = (Boundaries(),)
-    """ List of boundaries cndition to which evaluate to modes """
     accuracy: int = 2
-    """ Accuracy of the finit-difference set of value """
 
     #  Plot arguments --------------------------
     plot_geometry: bool = False
-    """ Plot the computed geometry mesh prior computation """
     plot_cladding: bool = False
-    """ Plot the cladding structure prior computation """
     plot_field: bool = False
-    """ Plot the mode field after computation """
     plot_adiabatic: bool = False
-    """ Plot the adiabatic criterion after computation """
     plot_coupling: bool = False
-    """ Plot the mode coupling after computation """
     plot_beating_length: bool = False
-    """ Plot the mode beating length after computation """
     plot_eigen_values: bool = False
-    """ Plot the computed eigen_values after computation """
     plot_index: bool = False
-    """ Plot the computed effective index after computation """
     plot_beta: bool = False
-    """ Plot the computed propagation constant after computation """
 
     #  Extra arguments --------------------------
     debug_mode: int = 1
-    """ Level of debug mode printing [0, 1, 2, 3]"""
     auto_label: bool = False
-    """ Enable auto labeling of the supermodes """
     generate_report: bool = False
-    """ Generate final pdf reports containing geometry, fields, coupling, adiabatic criterions """
     save_superset: bool = False
-    """ Save the created superset instance into a pickle file for further use """
 
     def __post_init__(self):
+        """Initializes the simulation geometry and solver, and optionally plots the initial setup if enabled."""
         self.geometry = prepare_simulation_geometry(
             wavelength=self.wavelength,
             clad_structure=self.clad_structure,
             fiber_list=self.fiber_list,
             capillary_tube=self.capillary_tube,
             fusion_degree=self.fusion_degree,
             fiber_radius=self.fiber_radius,
@@ -274,14 +278,16 @@
             self.save_superset_instance()
 
     @property
     def superset(self):
         return self.solver.superset
 
     def _initialize_solver_(self) -> None:
+        """Initializes the solver with the set geometry and starts the mode computation process."""
+
         self.solver = SuPySolver(
             geometry=self.geometry,
             tolerance=1e-20,
             max_iter=5000,
             accuracy=self.accuracy,
             debug_mode=self.debug_mode,
             extrapolation_order=self.extrapolation_order
@@ -298,15 +304,15 @@
             self.solver.add_modes(
                 n_added_mode=self.n_added_mode,
                 n_sorted_mode=self.n_sorted_mode,
                 boundaries=boundary,
                 auto_label=self.auto_label
             )
 
-        self.solver.superset.sorting_modes(sorting_method='beta')
+        self.solver.superset.sort_modes(sorting_method='beta')
 
     def get_superset(self):
         return self.solver.superset
 
     def _get_auto_generated_filename_(self) -> str:
         """
         Returns an auton-generated filename taking account for:
@@ -326,25 +332,15 @@
             f"resolution={self.resolution}_"
             f'wavelength={self.wavelength}'
         )
 
         return filename.replace('.', '_')
 
     def save_superset_instance(self, filename: str = 'auto', directory: str = 'auto') -> Path:
-        """
-        Saves a superset instance in the form of a serialized files using the picles library.
-
-        :param      filename:   The filename
-        :type       filename:   str
-        :param      directory:  The directory
-        :type       directory:  str
-
-        :returns:   The path directory of the saved instance
-        :rtype:     Path
-        """
+        """Saves the superset instance to a file, defaulting to an auto-generated filename if not specified."""
         if filename == 'auto':
             filename = self._get_auto_generated_filename_()
 
         filename = Path(filename + '.pdf')
 
         filename = sanitize_filepath(filename)
 
@@ -370,19 +366,18 @@
         if filename == 'auto':
             filename = self._get_auto_generated_filename_()
 
         filename = Path(filename).with_suffix('.pdf')
 
         filename = sanitize_filepath(filename)
 
-        self.solver.superset.generate_pdf_report(
-            filename=filename,
-            **kwargs
-        )
+        self.solver.superset.generate_pdf_report(filename=filename, **kwargs)
 
         return filename
 
     def plot(self, *args, **kwargs):
+        """Plots various types of data from the simulation based on the specified plot type."""
+
         return self.solver.superset.plot(*args, **kwargs)
 
 
 # -
```

## SuPyMode/representation/adiabatic.py

```diff
@@ -8,82 +8,100 @@
 
 import numpy
 
 from SuPyMode.representation.base import InheritFromSuperMode, BaseMultiModePlot
 from MPSPlots.render2D import SceneList, Axis
 
 
-ax_style = dict(
-    show_legend=True,
-    x_label='Inverse taper ratio',
-    y_label=r'Adiabatic criterion [$\mu$m$^{-1}$]',
-    y_scale='log',
-    y_scale_factor=1e-6,
-    y_limits=[1e-5, 1],
-    line_width=2
-)
+class Adiabatic(InheritFromSuperMode, BaseMultiModePlot):
+    """
+    Represents the adiabatic criterion between modes of different supermodes in optical fiber simulations.
 
+    This class extends from `InheritFromSuperMode` for accessing supermode-related data and `BaseMultiModePlot`
+    for plotting functionalities tailored to visualize adiabatic transition measurements.
 
-class Adiabatic(InheritFromSuperMode, BaseMultiModePlot):
-    def __init__(self, parent_supermode):
+    Class Attributes:
+        plot_style (dict): A dictionary defining the default style settings for plots generated by this class.
+    """
+
+    plot_style = dict(
+        show_legend=True,
+        x_label='Inverse taper ratio',
+        y_label=r'Adiabatic criterion [$\mu$m$^{-1}$]',
+        y_scale='log',
+        y_scale_factor=1e-6,
+        y_limits=[1e-5, 1],
+        line_width=2
+    )
+
+    def __init__(self, parent_supermode: SuperMode):
+        """
+        Initializes an Adiabatic object with a reference to a parent supermode.
+
+        Args:
+            parent_supermode (SuperMode): The parent supermode object that provides the base mode data.
+        """
         self.parent_supermode = parent_supermode
 
     def get_values(self, other_supermode: SuperMode) -> numpy.ndarray:
         """
-        Return the array of the modal coupling for the mode
+        Calculates the adiabatic transition measure between the parent supermode and another specified supermode.
 
-        :param      other_supermode:  The other supermode
-        :type       other_supermode:  SuperMode
+        Args:
+            other_supermode (SuperMode): The supermode with which to compare the parent supermode.
 
-        :returns:   The values
-        :rtype:     numpy.ndarray
+        Returns:
+            numpy.ndarray: An array of adiabatic transition measures calculated between the two supermodes,
+                           possibly adjusted by compatibility considerations.
         """
         output = self.parent_supermode.binded_supermode.get_adiabatic_with_mode(other_supermode.binded_supermode)
 
         if not self.parent_supermode.is_computation_compatible(other_supermode):
             output *= numpy.inf
 
         return output
 
     def render_on_ax(self, ax: Axis, other_supermode: SuperMode) -> None:
         """
-        Renders the normalized-coupling data with another modes on a given ax
+        Renders adiabatic transition data as a line plot on the provided Axis object, comparing the parent supermode
+        with another supermode.
 
-        :param      ax:               Axis to which add the plot
-        :type       ax:               Axis
-        :param      other_supermode:  The other supermode
-        :type       other_supermode:  SuperMode
+        Args:
+            ax (Axis): The Axis object on which to plot the adiabatic transitions.
+            other_supermode (SuperMode): The other supermode to compare against.
 
-        :returns:   No returns
-        :rtype:     None
+        Note:
+            This method is conditioned on computational compatibility between the supermodes.
         """
         if not self.parent_supermode.is_computation_compatible(other_supermode):
             return
 
         y = self.get_values(other_supermode=other_supermode)
 
         ax.add_line(
             x=self.itr_list,
             y=numpy.abs(y),
             label=f'{self.parent_supermode.stylized_label} - {other_supermode.stylized_label}'
         )
 
     def plot(self, other_supermode: SuperMode) -> SceneList:
         """
-        Plots the normalized coupling of this specific mode with the other one
-        given as input.
+        Generates a plot of adiabatic transitions between the parent supermode and another specified supermode using a SceneList.
+
+        This method creates a single-axis plot showing the comparative adiabatic transitions as a function of the inverse taper ratio,
+        formatted according to the predefined plot style.
 
-        :param      other_supermode:  The other supermode
-        :type       other_supermode:  SuperMode
+        Args:
+            other_supermode (SuperMode): The supermode to compare against.
 
-        :returns:   The scene list.
-        :rtype:     SceneList
+        Returns:
+            SceneList: A scene list containing the plot of adiabatic transitions.
         """
         figure = SceneList()
 
-        ax = figure.append_ax(**ax_style)
+        ax = figure.append_ax(**self.plot_style)
 
         self.render_on_ax(ax=ax, other_supermode=other_supermode)
 
         return figure
 
 # -
```

## SuPyMode/representation/beating_length.py

```diff
@@ -1,74 +1,94 @@
 # #!/usr/bin/env python
 # # -*- coding: utf-8 -*-
 
 from __future__ import annotations
+from typing import TYPE_CHECKING
+if TYPE_CHECKING:
+    from SuPyMode.supermode import SuperMode
+
 import numpy
 
 from SuPyMode.representation.base import InheritFromSuperMode, BaseMultiModePlot
 from MPSPlots.render2D import Axis, SceneList
 
-from typing import TYPE_CHECKING
 
-if TYPE_CHECKING:
-    from SuPyMode.supermode import SuperMode
+class BeatingLength(InheritFromSuperMode, BaseMultiModePlot):
+    """
+    Represents the beating lengths between modes of different supermodes in optical fiber simulations.
 
+    This class extends from `InheritFromSuperMode` to utilize supermode-related data and from `BaseMultiModePlot`
+    for advanced plotting functionalities tailored to visualize beating length comparisons.
 
-ax_style = dict(
-    show_legend=True,
-    x_label='Inverse taper ratio',
-    y_label='Beating length [m]',
-    y_scale="log",
-    line_width=2
-)
+    Class Attributes:
+        plot_style (dict): Default style settings for plots generated by this class.
+    """
+
+    plot_style = dict(
+        show_legend=True,
+        x_label='Inverse taper ratio',
+        y_label='Beating length [m]',
+        y_scale="log",
+        line_width=2
+    )
 
+    def __init__(self, parent_supermode: SuperMode):
+        """
+        Initializes a BeatingLength object with a reference to a parent supermode.
 
-class BeatingLength(InheritFromSuperMode, BaseMultiModePlot):
-    def __init__(self, parent_supermode):
+        Args:
+            parent_supermode (SuperMode): The parent supermode object that provides the base mode data.
+        """
         self.parent_supermode = parent_supermode
 
-    def get_values(self, other_supermode) -> numpy.ndarray:
+    def get_values(self, other_supermode: SuperMode) -> numpy.ndarray:
         """
-        Return the array of the modal coupling for the mode
+        Calculates the beating length between the parent supermode and another specified supermode.
+
+        Args:
+            other_supermode (SuperMode): The supermode with which to compare the parent supermode.
+
+        Returns:
+            numpy.ndarray: An array of beating lengths calculated between the two supermodes.
         """
         return self.parent_supermode.binded_supermode.get_beating_length_with_mode(other_supermode.binded_supermode)
 
     def render_on_ax(self, ax: Axis, other_supermode: SuperMode) -> None:
         """
-        Renders the normalized-coupling data with another modes on a given ax
+        Renders beating length data as a line plot on the provided Axis object, comparing the parent supermode
+        with another supermode.
 
-        :param      ax:               The axis to which add the plot
-        :type       ax:               Axis
-        :param      other_supermode:  The other supermode
-        :type       other_supermode:  SuperMode
+        Args:
+            ax (Axis): The Axis object on which to plot the beating lengths.
+            other_supermode (SuperMode): The other supermode to compare against.
 
-        :returns:   No returns
-        :rtype:     None
+        Note:
+            This method utilizes the `plot_style` class attribute to define the appearance of the plot.
         """
         y = self.get_values(other_supermode=other_supermode)
 
-        ax.add_line(
-            x=self.itr_list,
-            y=numpy.abs(y),
-            label=f'{self.parent_supermode.stylized_label} - {other_supermode.stylized_label}'
-        )
+        label = f'{self.parent_supermode.stylized_label} - {other_supermode.stylized_label}'
+
+        ax.add_line(x=self.itr_list, y=numpy.abs(y), label=label)
 
     def plot(self, other_supermode: SuperMode) -> SceneList:
         """
-        Plots the normalized coupling of this specific mode with the other one
-        given as input.
+        Generates a plot of beating lengths between the parent supermode and another specified supermode using a SceneList.
+
+        This method creates a single-axis plot showing the comparative beating lengths as a function of the inverse taper ratio,
+        formatted according to the predefined plot style.
 
-        :param      other_supermode:  The other supermode
-        :type       other_supermode:  SuperMode
+        Args:
+            other_supermode (SuperMode): The supermode to compare against.
 
-        :returns:   The scene list.
-        :rtype:     SceneList
+        Returns:
+            SceneList: A scene list containing the plot of beating lengths.
         """
         figure = SceneList()
 
-        ax = figure.append_ax(**ax_style)
+        ax = figure.append_ax(**self.plot_style)
 
         self.render_on_ax(ax=ax, other_supermode=other_supermode)
 
         return figure
 
 # -
```

## SuPyMode/representation/beta.py

```diff
@@ -1,60 +1,85 @@
 # #!/usr/bin/env python
 # # -*- coding: utf-8 -*-
 
-import numpy
+from __future__ import annotations
+from typing import TYPE_CHECKING
+if TYPE_CHECKING:
+    from SuPyMode.supermode import SuperMode
 
 from SuPyMode.representation.base import InheritFromSuperMode, BaseSingleModePlot
 from MPSPlots.render2D import SceneList, Axis
 
-ax_style = dict(
-    show_legend=True,
-    x_label='Inverse taper ratio',
-    y_label='Propagation constant [rad/M]',
-    y_scale="linear",
-    line_width=2
-)
-
 
 class Beta(InheritFromSuperMode, BaseSingleModePlot):
-    def __init__(self, parent_supermode):
+    """
+    Represents the propagation constants (beta values) of a mode derived from a supermode in optical simulations.
+
+    This class utilizes inheritance from `InheritFromSuperMode` for accessing supermode-related data and
+    `BaseSingleModePlot` for plotting functionalities tailored to propagation constant visualization.
+
+    Class Attributes:
+        plot_style (dict): A dictionary defining the default style settings for plots generated by this class.
+
+    Attributes:
+        parent_supermode (InheritFromSuperMode): A reference to the parent supermode object from which beta data is sourced.
+    """
+
+    plot_style = dict(
+        show_legend=True,
+        x_label='Inverse taper ratio',
+        y_label='Propagation constant [rad/M]',
+        y_scale="linear",
+        line_width=2
+    )
+
+    def __init__(self, parent_supermode: SuperMode):
+        """
+        Initializes a Beta object with a reference to a parent supermode.
+
+        Args:
+            parent_supermode (InheritFromSuperMode): The parent supermode object.
+        """
         self.parent_supermode = parent_supermode
-        self._data = self.parent_supermode.binded_supermode.get_betas()
 
-    def get_values(self) -> numpy.ndarray:
-        return self._data
+    @property
+    def data(self):
+        return self.parent_supermode.binded_supermode.get_betas()
 
     def render_on_ax(self, ax: Axis) -> None:
         """
-        Render the instance values to given ax.
+        Renders the propagation constants as a line plot on the provided Axis object.
 
-        :param      ax:   The axis to which add the values
-        :type       ax:   Axis
+        Args:
+            ax (Axis): The Axis object on which to plot the propagation constants.
 
-        :returns:   No returns
-        :rtype:     None
+        Note:
+            Utilizes the `plot_style` class attribute to define the appearance of the plot.
         """
         ax.add_line(
             x=self.itr_list,
-            y=self._data,
+            y=self.data,
             label=f'{self.stylized_label}'
         )
 
     def plot(self) -> SceneList:
         """
-        Plot the mode propagation constant.
+        Generates a plot of the propagation constants using a SceneList to manage multiple plots if necessary.
+
+        This method creates a single-axis plot showing the propagation constants as a function of the inverse taper ratio,
+        formatted according to the predefined plot style.
 
-        :returns:   The figure
-        :rtype:     SceneMatrix
+        Returns:
+            SceneList: A scene list containing the plot of propagation constants.
         """
         figure = SceneList()
 
         ax = figure.append_ax()
 
-        ax.set_style(**ax_style)
+        ax.set_style(**self.plot_style)
 
         self.render_on_ax(ax=ax)
 
         return figure
 
 
 # -
```

## SuPyMode/representation/eigen_value.py

```diff
@@ -1,61 +1,78 @@
 # #!/usr/bin/env python
 # # -*- coding: utf-8 -*-
 
-import numpy
+from __future__ import annotations
+from typing import TYPE_CHECKING
+if TYPE_CHECKING:
+    from SuPyMode.supermode import SuperMode
 
 from SuPyMode.representation.base import InheritFromSuperMode, BaseSingleModePlot
 from MPSPlots.render2D import SceneList, Axis
 
 
-ax_style = dict(
-    show_legend=True,
-    x_label='Inverse taper ratio',
-    y_label='Mode eigen values',
-    y_scale="linear",
-    line_width=2
-)
+class EigenValue(InheritFromSuperMode, BaseSingleModePlot):
+    """
+    Represents the eigenvalues of a mode derived from a supermode in a waveguide or optical fiber simulation.
 
+    This class extends from `InheritFromSuperMode` to access supermode-related data and from `BaseSingleModePlot`
+    to provide plotting capabilities tailored to eigenvalue visualization.
 
-class EigenValue(InheritFromSuperMode, BaseSingleModePlot):
-    def __init__(self, parent_supermode):
-        self.parent_supermode = parent_supermode
-        self._data = self.parent_supermode.binded_supermode.get_eigen_value()
+    Attributes:
+        parent_supermode (InheritFromSuperMode): The parent supermode object from which eigenvalue data is derived.
+    """
+
+    plot_style = dict(
+        show_legend=True,
+        x_label='Inverse taper ratio',
+        y_label='Mode eigen values',
+        y_scale="linear",
+        line_width=2
+    )
+
+    def __init__(self, parent_supermode: SuperMode):
+        """
+        Initializes an EigenValue object with a parent supermode reference.
 
-    def get_values(self) -> numpy.ndarray:
-        return self._data
+        Args:
+            parent_supermode (InheritFromSuperMode): A reference to the parent supermode object.
+        """
+        self.parent_supermode = parent_supermode
+        self.data = self.parent_supermode.binded_supermode.get_eigen_value()
 
     def render_on_ax(self, ax: Axis) -> None:
         """
-        Render the instance values to given ax.
+        Renders the eigenvalues as a line plot on the provided Axis object.
 
-        :param      ax:   The axis to which add the values
-        :type       ax:   Axis
+        Args:
+            ax (Axis): The Axis object on which the eigenvalues will be plotted.
 
-        :returns:   No returns
-        :rtype:     None
+        Note:
+            This method utilizes the plotting configuration set on the Axis to define the appearance of the plot.
         """
         ax.add_line(
             x=self.itr_list,
-            y=self._data,
+            y=self.data,
             label=f'{self.stylized_label}'
         )
 
     def plot(self) -> SceneList:
         """
-        Plot the mode eigen values.
+        Generates a plot of the eigenvalues using a SceneList to manage multiple plots if necessary.
+
+        This method creates a single-axis plot showing the mode eigenvalues as a function of the inverse taper ratio.
 
-        :returns:   The figure
-        :rtype:     SceneMatrix
+        Returns:
+            SceneList: A scene list containing the eigenvalue plot.
         """
         figure = SceneList()
 
         ax = figure.append_ax()
 
-        ax.set_style(**ax_style)
+        ax.set_style(**self.plot_style)
 
         self.render_on_ax(ax=ax)
 
         return figure
 
 
 # -
```

## SuPyMode/representation/field.py

```diff
@@ -1,97 +1,131 @@
 # #!/usr/bin/env python
 # # -*- coding: utf-8 -*-
 
+from __future__ import annotations
+from typing import TYPE_CHECKING
+if TYPE_CHECKING:
+    from SuPyMode.supermode import SuperMode
+
 import numpy
 from MPSPlots.render2D import Axis
 from MPSPlots import colormaps
 from MPSPlots.render2D import SceneMatrix
 
-from SuPyMode.tools.utils import interpret_slice_number_and_itr, slice_to_itr
+from SuPyMode.utils import interpret_slice_number_and_itr, slice_to_itr
 
 from SuPyMode.representation.base import InheritFromSuperMode
 
-ax_style = dict(
-    show_legend=False,
-    x_label=r'',
-    y_label=r'',
-    show_ticks=False,
-    x_scale_factor=1e6,
-    y_scale_factor=1e6,
-)
-
 
 class Field(InheritFromSuperMode):
-    def __init__(self, parent_supermode):
+    """
+    Represents a field derived from a supermode in a modal analysis framework.
+
+    This class extends functionality from a parent supermode class to manage field data operations,
+    including retrieving and processing field data for visualization and analysis.
+
+    Attributes:
+        parent_supermode (InheritFromSuperMode): Reference to the parent supermode object that provides source data.
+    """
+
+    plot_style = dict(
+        show_legend=False,
+        x_label=r'',
+        y_label=r'',
+        show_ticks=False,
+        x_scale_factor=1e6,
+        y_scale_factor=1e6
+    )
+
+    def __init__(self, parent_supermode: SuperMode):
+        """
+        Initialize the Field object with a reference to a parent supermode.
+
+        Args:
+            parent_supermode (InheritFromSuperMode): The parent supermode from which this field is derived.
+        """
         self.parent_supermode = parent_supermode
-        self._data = self.parent_supermode.binded_supermode.get_fields()
 
-    def get_values(self):
-        return self._data
+    @property
+    def data(self):
+        return self.parent_supermode.binded_supermode.get_fields()
 
     def get_norm(self, slice_number: int) -> float:
+        """
+        Calculate the norm of the field for a specific slice.
+
+        Args:
+            slice_number (int): The slice number for which to calculate the norm.
+
+        Returns:
+            float: The norm of the field.
+        """
         return self.parent_supermode.binded_supermode.get_norm(slice_number)
 
     @property
     def itr_list(self) -> numpy.ndarray:
+        """
+        Provides a list of iteration indices available for the fields.
+
+        Returns:
+            numpy.ndarray: An array of iteration indices.
+        """
         return self.parent_supermode.binded_supermode.model_parameters.itr_list
 
     @property
     def parent_superset(self) -> object:
-        return self.parent_supermode.parent_set
+        """
+        Access the parent set of the supermode.
 
-    def get_field(
-            self,
-            slice_number: int = [],
-            itr: float = [],
-            add_symmetries: bool = True) -> numpy.ndarray:
-        """
-        Returns the field with the predefined boundary conditions for a certain slice number.
-        The normalization type must either be square integration (L2), max value set to one (max), center value set to one (center)
-        or the normalization provided with coupled-mode theory (cmt).
-
-        :param      slice_number:    The slice number
-        :type       slice_number:    int
-        :param      add_symmetries:  Add or not the boundary symmetries
-        :type       add_symmetries:  bool
+        Returns:
+            object: The parent set object.
+        """
+        return self.parent_supermode.parent_set
 
-        :returns:   The field mesh.
-        :rtype:     numpy.ndarray
+    def get_field(self, slice_number: int = None, itr: float = None, add_symmetries: bool = True) -> numpy.ndarray:
         """
-        slice_number = numpy.array(slice_number)
-        itr = numpy.array(itr)
+        Retrieve a specific field adjusted for boundary conditions and optionally add symmetries.
+
+        Args:
+            slice_number (int): The slice number to retrieve.
+            itr (float): The iteration to use for retrieving the field.
+            add_symmetries (bool): Whether to add boundary symmetries to the field.
 
-        assert (slice_number.size == 0) ^ (itr.size == 0), 'Exactly one of the two values [slice_number, itr] has to be defined'
+        Returns:
+            numpy.ndarray: The requested field as a numpy array.
 
+        Raises:
+            AssertionError: If neither or both of slice_number and itr are defined.
+        """
         slice_list, itr_list = interpret_slice_number_and_itr(
             itr_baseline=self.itr_list,
             itr_list=itr,
             slice_list=slice_number
         )
 
-        field = numpy.take(self._data, slice_number, axis=0)
-
+        fields = self.parent_supermode.binded_supermode.get_fields()
+        fields = numpy.take(fields, slice_list, axis=0)
         if add_symmetries:
-            field = self._get_symmetrized_field(field=field)
+            fields = self._get_symmetrized_field(fields)
 
-        return field
+        return fields
 
     def normalize_field(self, field: numpy.ndarray, itr: float, norm_type: str = 'L2') -> numpy.ndarray:
         """
-        Deprecated at the moment.
+        Normalize a field array based on a specified normalization method.
+
+        Currently, this method is deprecated.
 
-        :param      field:      The field
-        :type       field:      { type_description }
-        :param      itr:        The itr
-        :type       itr:        float
-        :param      norm_type:  The normalize type
-        :type       norm_type:  str
+        Args:
+            field (numpy.ndarray): The field to normalize.
+            itr (float): The iteration value for normalization scaling.
+            norm_type (str): The type of normalization ('max', 'center', 'L2', 'cmt').
 
-        :returns:   { description_of_the_return_value }
-        :rtype:     { return_type_description }
+        Returns:
+            numpy.ndarray: The normalized field.
         """
         match norm_type.lower():
             case 'max':
                 norm = abs(field).max()
             case 'center':
                 idx_x_center = numpy.argmin(abs(self.parent_supermode.parent_set.coordinate_system.x_vector))
                 idx_y_center = numpy.argmin(abs(self.parent_supermode.parent_set.coordinate_system.y_vector))
@@ -105,34 +139,46 @@
                 dx_scaled = self.parent_supermode.parent_set.coordinate_system.dx * itr
                 dy_scaled = self.parent_supermode.parent_set.coordinate_system.dy * itr
                 norm = numpy.sqrt(numpy.trapz(numpy.trapz(numpy.square(field), dx=dx_scaled, axis=0), dx=dy_scaled, axis=0))
 
         return field / norm
 
     def _get_symmetrized_field_and_axis(self, field: numpy.ndarray) -> tuple:
+        """
+        Generate a symmetrical version of the input field mesh according to defined boundary conditions.
+
+        Args:
+            field (numpy.ndarray): The 2D field mesh to be symmetrized.
+
+        Returns:
+            numpy.ndarray: The symmetrized field mesh.
+
+        Raises:
+            AssertionError: If the input is not a 2D array.
+        """
         x_axis, y_axis = self._get_axis_vector(add_symmetries=True)
 
         field = self._get_symmetrized_field(field=field)
 
         return x_axis, y_axis, field
 
     def _get_symmetrized_field(self, field: numpy.ndarray) -> numpy.ndarray:
         """
-        Take as input a mesh and return a symmetric version of that mesh.
-        The symmetry can be setted mirror the top or bottom, left or right.
+        Retrieve the field and axis data adjusted for symmetry.
 
-        :param      vector:          The 2-d mesh
-        :type       vector:          numpy.ndarray
+        This method generates symmetrized versions of the field and its corresponding axis vectors.
 
-        :returns:   The symmetrized mesh
-        :rtype:     numpy.ndarray
+        Args:
+            field (numpy.ndarray): The field data array to be symmetrized.
 
-        :raises     AssertionError:  Verify that input vector is 2-dimensionnal.
+        Returns:
+            tuple: A tuple containing the x-axis, y-axis, and the symmetrized field data.
         """
-        assert field.ndim == 2, f'Mesh should be 2d, instead {field.ndim} dimensional is provided.'
+        field = field.squeeze()
+        assert field.ndim == 2, f"Expected a 2-dimensional array, but got {field.ndim}-dimensional."
 
         symmetric_field = field[:, -2::-1]
         match self.boundaries.left.lower():
             case 'symmetric':
                 field = numpy.c_[symmetric_field, field]
 
             case 'anti-symmetric':
@@ -159,15 +205,29 @@
 
             case 'anti-symmetric':
                 field = numpy.r_[-symmetric_field, field]
 
         return field
 
     def _render_on_ax_(self, ax: Axis, slice: int) -> None:
-        x, y, field = self._get_symmetrized_field_and_axis(field=self._data[slice])
+        """
+        Renders a specified slice of the field data on a provided Axis object.
+
+        This method is typically used to add a field mesh plot to a plotting axis as part of a larger figure or plot matrix.
+
+        Args:
+            ax (Axis): The plotting Axis object to render the field on.
+            slice (int): The slice index of the field data to render.
+
+        Note:
+            This method applies internal colormap settings and adjusts the axis based on the field data.
+        """
+        field = self.parent_supermode.binded_supermode.get_field[slice]
+
+        x, y, field = self._get_symmetrized_field_and_axis(field=field)
 
         artist = ax.add_mesh(
             x=x,
             y=y,
             scalar=field,
         )
 
@@ -183,36 +243,39 @@
             itr_list: list[float] = [],
             slice_list: list[int] = [0, -1],
             add_symmetries: bool = True,
             show_mode_label: bool = True,
             show_itr: bool = True,
             show_slice: bool = True) -> SceneMatrix:
         """
-        Plot each of the mode field for different itr value or slice number.
+        Plot the field for specified iterations or slice numbers.
 
-        :param      itr_list:    List of itr value to evaluate the mode field
-        :type       itr_list:    list
-        :param      slice_list:  List of integer reprenting the slice where the mode field is evaluated
-        :type       slice_list:  list
+        Args:
+            itr_list (list[float]): List of iterations to evaluate the field.
+            slice_list (list[int]): List of slices to evaluate the field.
+            add_symmetries (bool): Whether to include boundary symmetries in the plot.
+            show_mode_label (bool): Whether to show the mode label.
+            show_itr (bool): Whether to show the iteration value.
+            show_slice (bool): Whether to show the slice number.
 
-        :returns:   The figure
-        :rtype:     SceneMatrix
+        Returns:
+            SceneMatrix: A matrix scene containing the plots.
         """
         figure = SceneMatrix(unit_size=(3, 3))
 
         slice_list, itr_list = interpret_slice_number_and_itr(
             itr_baseline=self.itr_list,
             itr_list=itr_list,
             slice_list=slice_list
         )
 
         for n, (itr, slice_number) in enumerate(zip(itr_list, slice_list)):
             ax = figure.append_ax(row=n, column=0)
 
-            ax.set_style(**ax_style)
+            ax.set_style(**self.plot_style)
 
             self.render_on_ax(
                 ax=ax,
                 slice_number=slice_number,
                 add_symmetries=add_symmetries
             )
 
@@ -272,31 +335,24 @@
             artist=artist,
             colormap=colormaps.blue_black_red,
             symmetric=True
         )
 
     def get_plot_mode_field_title(self, slice_number: int, show_mode_label: bool, show_itr: bool, show_slice: bool) -> str:
         """
-        Gets the title for the plot_field outputed subplots.
+        Constructs a title for the field plot based on the mode, iteration, and slice number.
 
-        :param      supermode:         The supermode corresponding to the specific subplot.
-        :type       supermode:         SuperMode
-        :param      itr:               The itr value
-        :type       itr:               float
-        :param      slice_number:      The slice number
-        :type       slice_number:      int
-        :param      show_mode_label:   If True the mode label will be shown.
-        :type       show_mode_label:   bool
-        :param      show_itr:          If True the title contains the itr value.
-        :type       show_itr:          bool
-        :param      show_slice:        If True the title contains the slice number of the evaluated ITR
-        :type       show_slice:        bool
+        Args:
+            slice_number (int): The slice number for which the field is plotted.
+            show_mode_label (bool): Flag to include the mode label in the title.
+            show_itr (bool): Flag to include the iteration number in the title.
+            show_slice (bool): Flag to include the slice number in the title.
 
-        :returns:   The plot mode field title.
-        :rtype:     str
+        Returns:
+            str: The constructed title for the plot.
         """
         title = ''
 
         if show_mode_label:
             title += f'{self.stylized_label}'
 
         if show_itr or show_slice:
```

## SuPyMode/representation/index.py

```diff
@@ -1,62 +1,83 @@
 # #!/usr/bin/env python
 # # -*- coding: utf-8 -*-
 
-import numpy
+from __future__ import annotations
+from typing import TYPE_CHECKING
+if TYPE_CHECKING:
+    from SuPyMode.supermode import SuperMode
 
 from SuPyMode.representation.base import InheritFromSuperMode, BaseSingleModePlot
 from MPSPlots.render2D import SceneList, Axis
 
 
-ax_style = dict(
-    show_legend=True,
-    x_label='Inverse taper ratio',
-    y_label='Effective refraction index',
-    y_scale="linear",
-    y_limits=[1.44, 1.455],
-    line_width=2
-)
+class Index(InheritFromSuperMode, BaseSingleModePlot):
+    """
+    Represents the effective refractive index of a mode derived from a supermode in optical fiber simulations.
 
+    This class extends from `InheritFromSuperMode` for accessing supermode-related data and `BaseSingleModePlot`
+    for plotting functionalities tailored to visualize the effective refractive index.
 
-class Index(InheritFromSuperMode, BaseSingleModePlot):
-    def __init__(self, parent_supermode):
+    Class Attributes:
+        plot_style (dict): A dictionary defining the default style settings for plots generated by this class.
+    """
+
+    plot_style = dict(
+        show_legend=True,
+        x_label='Inverse taper ratio',
+        y_label='Effective refraction index',
+        y_scale="linear",
+        y_limits=[1.44, 1.455],
+        line_width=2
+    )
+
+    def __init__(self, parent_supermode: SuperMode):
+        """
+        Initializes an Index object with a reference to a parent supermode.
+
+        Args:
+            parent_supermode (SuperMode): The parent supermode object that provides the base mode data.
+        """
         self.parent_supermode = parent_supermode
-        self._data = self.parent_supermode.binded_supermode.get_index()
 
-    def get_values(self) -> numpy.ndarray:
-        return self._data
+    @property
+    def data(self):
+        return self.parent_supermode.binded_supermode.get_index()
 
     def render_on_ax(self, ax: Axis) -> None:
         """
-        Render the instance values to given ax.
+        Renders the effective refractive index data as a line plot on the provided Axis object.
 
-        :param      ax:   The axis to which add the values
-        :type       ax:   Axis
+        Args:
+            ax (Axis): The Axis object on which to plot the effective refractive index.
 
-        :returns:   No returns
-        :rtype:     None
+        Note:
+            This method utilizes the `plot_style` class attribute to define the appearance of the plot.
         """
         ax.add_line(
             x=self.itr_list,
-            y=self._data,
+            y=self.data,
             label=f'{self.stylized_label}'
         )
 
     def plot(self) -> SceneList:
         """
-        Plot the mode effective index.
+        Generates a plot of the effective refractive index using a SceneList.
+
+        This method creates a single-axis plot showing the effective refractive index as a function of the inverse taper ratio,
+        formatted according to the predefined plot style.
 
-        :returns:   The figure
-        :rtype:     SceneMatrix
+        Returns:
+            SceneList: A scene list containing the plot of effective refractive index.
         """
         figure = SceneList()
 
         ax = figure.append_ax()
 
-        ax.set_style(**ax_style)
+        ax.set_style(**self.plot_style)
 
         self.render_on_ax(ax=ax)
 
         return figure
 
 
 # -
```

## SuPyMode/representation/normalized_coupling.py

```diff
@@ -1,84 +1,104 @@
 # #!/usr/bin/env python
 # # -*- coding: utf-8 -*-
 
 from __future__ import annotations
+from typing import TYPE_CHECKING
+if TYPE_CHECKING:
+    from SuPyMode.supermode import SuperMode
 
 import numpy
 
 from SuPyMode.representation.base import InheritFromSuperMode, BaseMultiModePlot
 from MPSPlots.render2D import SceneList, Axis
 
-from typing import TYPE_CHECKING
 
+class NormalizedCoupling(InheritFromSuperMode, BaseMultiModePlot):
+    """
+    Represents the normalized mode coupling between modes of different supermodes in optical fiber simulations.
 
-if TYPE_CHECKING:
-    from SuPyMode.supermode import SuperMode
+    This class extends from `InheritFromSuperMode` for accessing supermode-related data and `BaseMultiModePlot`
+    for plotting functionalities tailored to visualize mode coupling comparisons.
 
-ax_style = dict(
-    show_legend=True,
-    x_label='Inverse taper ratio',
-    y_label='Mode coupling',
-    y_scale="linear",
-    line_width=2
-)
+    Class Attributes:
+        plot_style (dict): A dictionary defining the default style settings for plots generated by this class.
+    """
+
+    plot_style = dict(
+        show_legend=True,
+        x_label='Inverse taper ratio',
+        y_label='Mode coupling',
+        y_scale="linear",
+        line_width=2
+    )
 
+    def __init__(self, parent_supermode: SuperMode):
+        """
+        Initializes a NormalizedCoupling object with a reference to a parent supermode.
 
-class NormalizedCoupling(InheritFromSuperMode, BaseMultiModePlot):
-    def __init__(self, parent_supermode):
+        Args:
+            parent_supermode (SuperMode): The parent supermode object that provides the base mode data.
+        """
         self.parent_supermode = parent_supermode
 
     def get_values(self, other_supermode: SuperMode) -> numpy.ndarray:
         """
-        Return the array of the modal coupling for the mode
-        """
+        Calculates the normalized mode coupling between the parent supermode and another specified supermode.
 
+        Args:
+            other_supermode (SuperMode): The supermode with which to compare the parent supermode.
+
+        Returns:
+            numpy.ndarray: An array of normalized mode coupling values, adjusted for computational compatibility.
+        """
         output = self.parent_supermode.binded_supermode.get_normalized_coupling_with_mode(other_supermode.binded_supermode)
 
         if not self.parent_supermode.is_computation_compatible(other_supermode):
             output *= 0
 
         return output
 
     def render_on_ax(self, ax: Axis, other_supermode: SuperMode) -> None:
         """
-        Renders the normalized-coupling data with another modes on a given ax
+        Renders normalized mode coupling data as a line plot on the provided Axis object, comparing the parent supermode
+        with another supermode.
 
-        :param      ax:               Axis to which add the plot
-        :type       ax:               Axis
-        :param      other_supermode:  The other supermode
-        :type       other_supermode:  SuperMode
+        Args:
+            ax (Axis): The Axis object on which to plot the normalized mode coupling.
+            other_supermode (SuperMode): The other supermode to compare against.
 
-        :returns:   No returns
-        :rtype:     None
+        Note:
+            This method is conditioned on computational compatibility between the supermodes.
         """
         if not self.parent_supermode.is_computation_compatible(other_supermode):
             return
 
         y = self.get_values(other_supermode=other_supermode)
 
         ax.add_line(
             x=self.itr_list,
             y=numpy.abs(y),
             label=f'{self.parent_supermode.stylized_label} - {other_supermode.stylized_label}'
         )
 
     def plot(self, other_supermode: SuperMode) -> SceneList:
         """
-        Plots the normalized coupling of this specific mode with the other one
-        given as input.
+        Generates a plot of normalized mode coupling between the parent supermode and another specified supermode using a SceneList.
+
+        This method creates a single-axis plot showing the comparative mode couplings as a function of the inverse taper ratio,
+        formatted according to the predefined plot style.
 
-        :param      other_supermode:  The other supermode
-        :type       other_supermode:  SuperMode
+        Args:
+            other_supermode (SuperMode): The supermode to compare against.
 
-        :returns:   The scene list.
-        :rtype:     SceneList
+        Returns:
+            SceneList: A scene list containing the plot of normalized mode couplings.
         """
         figure = SceneList()
 
-        ax = figure.append_ax(**ax_style)
+        ax = figure.append_ax(**self.plot_style)
 
         self.render_on_ax(ax=ax, other_supermode=other_supermode)
 
         return figure
 
 # -
```

## SuPyMode/tools/utils.py

```diff
@@ -1,20 +1,21 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
 
 from __future__ import annotations
 from typing import TYPE_CHECKING
+from typing import Iterable
 if TYPE_CHECKING:
     from SuPyMode.superset import SuperSet
     from SuPyMode.supermode import SuperMode
 
 import numpy
 import pickle
 from pathlib import Path
-from SuPyMode.tools.directories import instance_directory
+from SuPyMode.directories import instance_directory
 
 
 def load_superset(filename: str, directory: str = '.'):
     """
     Saves the superset instance as a serialized pickle file.
 
     :param      filename:  The filename
@@ -36,23 +37,14 @@
 
     if x is not None:
         return x[idx], y0[idx]
 
     return y0[idx]
 
 
-def get_intersection_(y0: numpy.ndarray, y1: numpy.ndarray, x: numpy.ndarray = None):
-    idx = numpy.argwhere(numpy.diff(numpy.sign(y0 - y1))).flatten()
-
-    if x is not None:
-        return x[idx], y0[idx]
-
-    return y0[idx]
-
-
 def get_intersection(y0: numpy.ndarray, y1: numpy.ndarray, x: numpy.ndarray, average: bool = True):
 
     idx = numpy.argwhere(numpy.diff(numpy.sign(y0 - y1))).flatten()
 
     if len(idx) == 0:  # No intersection
         return None, None
 
@@ -125,28 +117,40 @@
     return itr
 
 
 def interpret_slice_number_and_itr(
         itr_baseline: numpy.ndarray,
         slice_list: int | list[int] = [],
         itr_list: float | list[float] = [],
-        sort_slice_number: bool = True) -> tuple:
+        sort_slice_number: bool = False) -> tuple:
     """
-    Interpret the itr and slice_list as input and return a tuple containing all the associated values
+    Interprets slice numbers and corresponding inverse taper ratios (ITRs), returning arrays of slice numbers
+    and their respective ITRs based on the provided lists of slices and ITRs.
+
+    Parameters:
+    - itr_baseline (numpy.ndarray): Array of baseline ITR values, typically equidistant, representing the full range.
+    - slice_list (Union[int, List[int]], optional): A single slice index or a list of slice indices. Default is an empty list.
+    - itr_list (Union[float, List[float]], optional): A single ITR value or a list of ITR values to be converted to slice indices. Default is an empty list.
+    - sort_slice_number (bool, optional): Whether to sort the resulting slice numbers and corresponding ITRs in descending order. Default is False.
 
-    :param      itr_baseline:      The itr list
-    :type       itr_baseline:      numpy.ndarray
-    :param      slice_number:  The slice number
-    :type       slice_number:  int | list[int]
-    :param      itr:           The itr
-    :type       itr:           float | list[float]
+    Returns:
+    - Tuple[numpy.ndarray, numpy.ndarray]: Two numpy arrays, the first containing slice indices and the second containing the corresponding ITR values.
 
-    :returns:   All the associated slice numbers and itr values
-    :rtype:     tuple
+    Raises:
+    - ValueError: If the provided ITRs or slice indices are outside the bounds of the baseline ITR array.
+
+    Note:
+    - This function assumes that the input ITRs and slice numbers are within the range covered by the `itr_baseline`.
+    - The function will also combine and sort the slice indices derived directly and those converted from the given ITRs if `sort_slice_number` is True.
     """
+    return_as_iterable = False
+
+    if isinstance(slice_list, Iterable) or isinstance(itr_list, Iterable):
+        return_as_iterable = True
+
     slice_list = numpy.atleast_1d(slice_list)
 
     slice_from_itr = itr_to_slice(itr_baseline, itr=itr_list)
 
     slice_from_itr = numpy.atleast_1d(slice_from_itr)
 
     total_slice_list = [*slice_list, *slice_from_itr]
@@ -158,43 +162,94 @@
     itr_list = numpy.asarray(total_itr_list)
 
     if sort_slice_number:
         slice_list = numpy.sort(slice_list)[::-1]
 
         itr_list = numpy.sort(itr_list)[::-1]
 
-    if len(itr_list) == 1:
+    if not return_as_iterable:
         return slice_list[0], itr_list[0]
 
     return slice_list, itr_list
 
 
 def interpret_mode_of_interest(superset: SuperSet, mode_of_interest: str | SuperMode | list[SuperMode]) -> list[SuperMode]:
     """
-    Interpret and returns the input for the mode_of_intereset argument.
-
-    :param      superset:          The superset
-    :type       superset:          SuperSet
-    :param      mode_of_interest:  The mode of interest
-    :type       mode_of_interest:  str | SuperMode | list[SuperMode]
+    Resolves the mode of interest from user input to the appropriate list of SuperMode instances
+    based on the specified criteria or direct references.
 
-    :returns:   A list of the mode of interest
-    :rtype:     list[SuperMode]
+    Parameters:
+        - superset (SuperSet): The superset containing all supermodes, including fundamental and non-fundamental modes.
+        - mode_of_interest (Union[str, SuperMode, List[SuperMode]]): This parameter can be a string specifying a category
+          of modes such as 'fundamental', 'non-fundamental', 'all', a single SuperMode instance, or a list of SuperMode instances.
+
+    Returns:
+        - List[SuperMode]: A list of SuperMode instances corresponding to the specified mode of interest.
+
+    Raises:
+        - ValueError: If the mode_of_interest is not one of the expected types or if the string input does not match
+        any known category.
     """
     if isinstance(mode_of_interest, str):
         match mode_of_interest:
             case 'fundamental':
                 return superset.fundamental_supermodes
             case 'non-fundamental':
                 return superset.non_fundamental_supermodes
             case 'all':
                 return superset.supermodes
+            case _:
+                raise ValueError(f"Unrecognized mode category '{mode_of_interest}'. Expected 'fundamental', 'non-fundamental', or 'all'.")
 
-    if not numpy.iterable(mode_of_interest):
+    if isinstance(mode_of_interest, SuperMode):
         return [mode_of_interest]
 
-    if isinstance(mode_of_interest, list):
+    if isinstance(mode_of_interest, list) and all(isinstance(item, SuperMode) for item in mode_of_interest):
         return mode_of_interest
 
-    raise ValueError(f"Invalid input for {mode_of_interest=}. Valid in put must be string ['fundamental', 'non-fundamental', 'all'] or a list or instance of SuperMode.")
+    raise ValueError("mode_of_interest must be either 'fundamental', 'non-fundamental', 'all', a SuperMode instance, or a list of SuperMode instances.")
+
+
+def get_symmetrized_vector(vector: numpy.ndarray, symmetry_type: str = 'last') -> numpy.ndarray:
+    """
+    Generate a symmetric version of the input vector based on the specified symmetry type.
+
+    Parameters:
+    -----------
+    vector : numpy.ndarray
+        A one-dimensional array for which the symmetric version is to be calculated.
+    symmetry_type : str, optional
+        Type of symmetry to apply. Supported types:
+        - 'last': Symmetrize using the last element as reference.
+        - 'first': Symmetrize using the first element as reference.
+        Default is 'last'.
+
+    Returns:
+    --------
+    numpy.ndarray
+        A new vector that is the symmetrized version of the input vector.
+
+    Raises:
+    -------
+    ValueError
+        If the input vector is not one-dimensional or the symmetry type is unsupported.
+    """
+
+    if vector.ndim != 1:
+        raise ValueError(f"Expected a 1-dimensional vector, but got a {vector.ndim}-dimensional vector instead.")
+
+    if symmetry_type.lower() not in ['last', 'first']:
+        raise ValueError("Symmetry type must be 'last' or 'first'.")
+
+    size = len(vector)
+    dx = numpy.diff(vector)[0]  # More robust than assuming vector[1] - vector[0]
+
+    if symmetry_type.lower() == 'last':
+        start_value = vector[-1]
+        expanded = numpy.arange(0, 2 * size - 1) * dx
+        return start_value - expanded[::-1] if dx > 0 else start_value + expanded[::-1]
+    else:  # 'first'
+        start_value = vector[0]
+        expanded = numpy.arange(0, 2 * size - 1) * dx
+        return start_value + expanded
 
 # -
```

## docs/examples/basic/plot_alpha_profile_0.py

```diff
@@ -22,10 +22,12 @@
 # Adding a first taper segment with small initial heating length (i.e. steep reduction)
 profile.add_taper_segment(
     alpha=0,
     initial_heating_length=2e-3,
     stretching_length=0.2e-3 * 20
 )
 
+profile.initialize()
+
 profile.plot().show()
 
 # -
```

## docs/examples/basic/plot_alpha_profile_1.py

```diff
@@ -22,10 +22,14 @@
 # Adding a first taper segment with small initial heating length (i.e. steep reduction)
 profile.add_taper_segment(
     alpha=0,
     initial_heating_length=2e-3,
     stretching_length=0.2e-3 * 20
 )
 
-profile.plot().show()
+profile.initialize()
+
+print(profile.adiabatic)
+
+profile.plot(show_adiabatic=False).show()
 
 # -
```

## docs/examples/basic/plot_workflow_02.py

```diff
@@ -33,15 +33,15 @@
 # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 # Workflow class to define all the computation parameters before initializing the solver
 workflow = Workflow(
     fiber_list=fiber_list,          # List of fiber to be added in the mesh, the order matters.
     clad_structure=clad_structure,  # Cladding structure, if None provided then no cladding is set.
     fusion_degree=0.9,              # Degree of fusion of the structure if applicable.
     wavelength=wavelength,          # Wavelength used for the mode computation.
-    resolution=60,                  # Number of point in the x and y axis [is divided by half if symmetric or anti-symmetric boundaries].
+    resolution=50,                  # Number of point in the x and y axis [is divided by half if symmetric or anti-symmetric boundaries].
     x_bounds="left",                # Mesh x-boundary structure.
     y_bounds="bottom",              # Mesh y-boundary structure.
     boundaries=boundaries,          # Set of symmetries to be evaluated, each symmetry add a round of simulation
     n_sorted_mode=4,                # Total computed and sorted mode.
     n_added_mode=2,                 # Additional computed mode that are not considered later except for field comparison [the higher the better but the slower].
     plot_geometry=True,             # Plot the geometry mesh before computation.
     debug_mode=0,                   # Print the iteration step for the solver plus some other important steps.
```

## docs/examples/basic/plot_workflow_03.py

```diff
@@ -15,55 +15,70 @@
 
 # %%
 # Generating the fiber structure
 # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 # Here we define the cladding and fiber structure to model the problem
 clad_structure = configuration.ring.FusedProfile_03x03
 
+custom_fiber = fiber_catalogue.CustomFiber(wavelength=1.55e-6)
+custom_fiber.add_silica_pure_cladding(radius=62.5e-6, name='outer-clad')
+
+custom_fiber.create_and_add_new_structure(
+    radius=40e-6 / 2,
+    NA=0.13,
+    name='inner-clad'
+)
+custom_fiber.create_and_add_new_structure(
+    radius=9.2e-6 / 2,
+    NA=0.13,
+    name='core'
+)
+
 fiber_list = [
+    fiber_catalogue.load_fiber('DCF1300S_42', wavelength=wavelength),
     fiber_catalogue.load_fiber('DCF1300S_33', wavelength=wavelength),
-    fiber_catalogue.load_fiber('DCF1300S_33', wavelength=wavelength),
-    fiber_catalogue.load_fiber('DCF1300S_33', wavelength=wavelength),
+    custom_fiber
 ]
 
+
 # %%
 # Defining the boundaries of the system
 boundaries = [
     Boundaries(),
 ]
 
 # %%
 # Generating the computing workflow
 # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 # Workflow class to define all the computation parameters before initializing the solver
 workflow = Workflow(
     fiber_list=fiber_list,          # List of fiber to be added in the mesh, the order matters.
     clad_structure=clad_structure,  # Cladding structure, if None provided then no cladding is set.
-    fusion_degree='auto',           # Degree of fusion of the structure if applicable.
+    fusion_degree=0.8,           # Degree of fusion of the structure if applicable.
     wavelength=wavelength,          # Wavelength used for the mode computation.
-    resolution=20,                  # Number of point in the x and y axis [is divided by half if symmetric or anti-symmetric boundaries].
+    resolution=40,                  # Number of point in the x and y axis [is divided by half if symmetric or anti-symmetric boundaries].
     x_bounds="centering",           # Mesh x-boundary structure.
     y_bounds="centering",           # Mesh y-boundary structure.
     boundaries=boundaries,          # Set of symmetries to be evaluated, each symmetry add a round of simulation
-    n_sorted_mode=6,                # Total computed and sorted mode.
-    n_added_mode=3,                 # Additional computed mode that are not considered later except for field comparison [the higher the better but the slower].
+    n_sorted_mode=2,                # Total computed and sorted mode.
+    n_added_mode=5,                 # Additional computed mode that are not considered later except for field comparison [the higher the better but the slower].
     plot_geometry=True,             # Plot the geometry mesh before computation.
-    debug_mode=0,                   # Print the iteration step for the solver plus some other important steps.
+    debug_mode=3,                   # Print the iteration step for the solver plus some other important steps.
     auto_label=True,                # Auto labeling the mode. Label are not always correct and should be verified afterwards.
-    itr_final=0.1,                  # Final value of inverse taper ratio to simulate
+    itr_final=0.05,                  # Final value of inverse taper ratio to simulate
     clad_rotation=0,                # Rotate the geoemtry in the given angle in degree
-    index_scrambling=1e-4           # Scrambling of refractive index value in order to lift mode degeneracy [useful for some analysis]
+    index_scrambling=1e-7           # Scrambling of refractive index value in order to lift mode degeneracy [useful for some analysis]
 )
 
 superset = workflow.get_superset()
 
 # %%
 # Field computation: :math:`E_{i,j}`
 # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-_ = superset.plot(plot_type='field', itr_list=[1.0, 0.1]).show()
+_ = superset.plot(plot_type='field', slice_list=[], itr_list=[1.0, 0.3, 0.1]).show()
 
 # %%
 # Effective index: :math:`n^{eff}_{i,j}`
 # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 _ = superset.plot(plot_type='index').show()
 
 # %%
```

## docs/examples/validation/plot_beta_DCF.py

```diff
@@ -93,15 +93,15 @@
     line_width=2,
     color='red',
     layer_position=1
 )
 
 ax.add_scatter(
     x=itr_list,
-    y=supymode_mode.index.get_values(),
+    y=supymode_mode.index.data,
     label=supymode_mode,
     color='black',
     line_width=2,
     edge_color='blue',
     marker_size=80,
     line_style='-',
     layer_position=2
```

## docs/examples/validation/plot_beta_SMF28.py

```diff
@@ -93,15 +93,15 @@
     line_width=2,
     color='red',
     layer_position=1
 )
 
 ax.add_scatter(
     x=itr_list,
-    y=supymode_mode.index.get_values(),
+    y=supymode_mode.index.data,
     label=supymode_mode,
     color='black',
     line_width=2,
     edge_color='blue',
     marker_size=80,
     line_style='-',
     layer_position=2
```

## docs/examples/validation/plot_normalized_coupling_DCF.py

```diff
@@ -1,84 +1,81 @@
 """
-Normalized coupling: SMF28
+Propagation constant: DCFC
 ==========================
 """
 
 # %%
 # Imports
 # ~~~~~~~
 import numpy
-from SuPyMode.workflow import Workflow, fiber_catalogue, Boundaries
+from SuPyMode.workflow import Workflow, fiber_catalogue, Boundaries, configuration
 from PyFiberModes.__future__ import get_normalized_LP_coupling
-from PyFiberModes import LP01, LP02
 from PyFiberModes.fiber import load_fiber
 from MPSPlots.render2D import SceneList
+import PyFiberModes
 
-wavelength = 1550e-9
-fiber_name = 'DCF1300S_33'
-
+wavelength = 780e-9
+fiber_name = 'SMF28'
 
 # %%
 # Generating the fiber structure
 # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 # Here we define the cladding and fiber structure to model the problem
-supymode_fiber = fiber_catalogue.load_fiber(fiber_name, wavelength=wavelength)
-supymode_fiber = supymode_fiber.scale(10)
+fiber_list = [
+    fiber_catalogue.load_fiber(fiber_name, wavelength=wavelength)
+]
 
 
 # %%
 # Defining the boundaries of the system
 boundaries = [
-    Boundaries(right='symmetric', top='symmetric'),
+    Boundaries(right='symmetric', bottom='symmetric'),
 ]
 
-
 # %%
 # Generating the computing workflow
 # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 # Workflow class to define all the computation parameters before initializing the solver
 workflow = Workflow(
-    fiber_list=[supymode_fiber],    # List of fiber to be added in the mesh, the order matters.
+    fiber_list=fiber_list,          # List of fiber to be added in the mesh, the order matters.
+    clad_structure=configuration.ring.FusedProfile_01x01,
+    fusion_degree='auto',           # Degree of fusion of the structure if applicable.
     wavelength=wavelength,          # Wavelength used for the mode computation.
-    resolution=50,                 # Number of point in the x and y axis [is divided by half if symmetric or anti-symmetric boundaries].
-    x_bounds=[-200e-6, 0],          # Mesh x-boundary structure.
-    y_bounds=[-200e-6, 0],          # Mesh y-boundary structure.
+    resolution=100,                 # Number of point in the x and y axis [is divided by half if symmetric or anti-symmetric boundaries].
+    x_bounds="left",                # Mesh x-boundary structure.
+    y_bounds="top",                 # Mesh y-boundary structure.
     boundaries=boundaries,          # Set of symmetries to be evaluated, each symmetry add a round of simulation
-    n_sorted_mode=5,                # Total computed and sorted mode.
+    n_sorted_mode=6,                # Total computed and sorted mode.
     n_added_mode=4,                 # Additional computed mode that are not considered later except for field comparison [the higher the better but the slower].
     plot_geometry=True,             # Plot the geometry mesh before computation.
     debug_mode=0,                   # Print the iteration step for the solver plus some other important steps.
     auto_label=True,                # Auto labeling the mode. Label are not always correct and should be verified afterwards.
-    itr_final=0.5,                  # Final value of inverse taper ratio to simulate
+    itr_final=0.2,                  # Final value of inverse taper ratio to simulate
     index_scrambling=0,             # Scrambling of refractive index value in order to lift mode degeneracy [useful for some analysis]
-    n_step=100,
-    plot_field=True
+    n_step=70
 )
 
 superset = workflow.get_superset()
-itr_list = superset.itr_list
-
+itr_list = superset.itr_list[::10]
 
 # %%
 # Computing the analytical values using FiberModes solver.
 pyfibermodes_fiber = load_fiber(
     fiber_name=fiber_name,
     wavelength=wavelength,
-    add_air_layer=False
+    add_air_layer=True
 )
 
-pyfibermodes_fiber = pyfibermodes_fiber.scale(10)
-
 analytical = numpy.empty(itr_list.shape)
 for idx, itr in enumerate(itr_list):
     _fiber = pyfibermodes_fiber.scale(factor=itr)
     analytical[idx] = get_normalized_LP_coupling(
         fiber=_fiber,
-        mode_0=LP01,
-        mode_1=LP02
+        mode_0=PyFiberModes.LP01,
+        mode_1=PyFiberModes.LP02
     )
 
 
 # %%
 # Preparing the figure
 figure = SceneList(unit_size=(12, 4))
 
@@ -89,25 +86,26 @@
     font_size=18,
     tick_size=15,
     legend_font_size=18
 )
 
 ax.add_line(
     x=itr_list,
-    y=abs(analytical),
+    y=analytical,
     label='Analytical',
     line_style='-',
     line_width=2,
     color='red',
     layer_position=1
 )
 
-simulation = -abs(superset.LP01.normalized_coupling.get_values(superset.LP02))
+simulation = superset.LP01.normalized_coupling.get_values(superset.LP02).imag
+
 ax.add_scatter(
-    x=itr_list,
+    x=superset.itr_list,
     y=simulation,
     label="SuPyMode",
     color='black',
     line_width=2,
     edge_color='blue',
     marker_size=80,
     line_style='-',
```

## docs/examples/validation/plot_normalized_coupling_SMF28.py

```diff
@@ -3,75 +3,83 @@
 ==========================
 """
 
 # %%
 # Imports
 # ~~~~~~~
 import numpy
-from SuPyMode.workflow import Workflow, fiber_catalogue, Boundaries
+from SuPyMode.workflow import Workflow, fiber_catalogue, Boundaries, configuration
 from PyFiberModes.__future__ import get_normalized_LP_coupling
 from PyFiberModes import LP01, LP02
 from PyFiberModes.fiber import load_fiber
 from MPSPlots.render2D import SceneList
 
-wavelength = 1550e-9
+wavelength = 350e-9
 fiber_name = 'SMF28'
 
 
 # %%
 # Generating the fiber structure
 # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 # Here we define the cladding and fiber structure to model the problem
 supymode_fiber = fiber_catalogue.load_fiber(fiber_name, wavelength=wavelength)
-supymode_fiber = supymode_fiber.scale(10)
 
 
 # %%
 # Defining the boundaries of the system
 boundaries = [
-    Boundaries(right='symmetric', top='symmetric'),
+    Boundaries(right='symmetric', bottom='symmetric'),
 ]
 
 
 # %%
 # Generating the computing workflow
 # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 # Workflow class to define all the computation parameters before initializing the solver
 workflow = Workflow(
     fiber_list=[supymode_fiber],    # List of fiber to be added in the mesh, the order matters.
     wavelength=wavelength,          # Wavelength used for the mode computation.
-    resolution=50,                 # Number of point in the x and y axis [is divided by half if symmetric or anti-symmetric boundaries].
-    x_bounds=[-200e-6, 0],          # Mesh x-boundary structure.
-    y_bounds=[-200e-6, 0],          # Mesh y-boundary structure.
+    clad_structure=configuration.ring.FusedProfile_01x01,
+    resolution=160,                 # Number of point in the x and y axis [is divided by half if symmetric or anti-symmetric boundaries].
+    x_bounds="left",                # Mesh x-boundary structure.
+    y_bounds="top",                 # Mesh y-boundary structure.
     boundaries=boundaries,          # Set of symmetries to be evaluated, each symmetry add a round of simulation
     n_sorted_mode=5,                # Total computed and sorted mode.
     n_added_mode=4,                 # Additional computed mode that are not considered later except for field comparison [the higher the better but the slower].
-    plot_geometry=True,             # Plot the geometry mesh before computation.
-    debug_mode=0,                   # Print the iteration step for the solver plus some other important steps.
+    # plot_geometry=True,             # Plot the geometry mesh before computation.
+    debug_mode=1,                   # Print the iteration step for the solver plus some other important steps.
     auto_label=True,                # Auto labeling the mode. Label are not always correct and should be verified afterwards.
-    itr_final=0.5,                  # Final value of inverse taper ratio to simulate
+    itr_final=0.9,                  # Final value of inverse taper ratio to simulate
     index_scrambling=0,             # Scrambling of refractive index value in order to lift mode degeneracy [useful for some analysis]
-    n_step=100,
-    plot_field=True
+    n_step=20,
+    # plot_field=True
 )
 
 superset = workflow.get_superset()
-itr_list = superset.itr_list
+itr_list = superset.itr_list[::5]
+
+import matplotlib.pyplot as plt
+
+figure, ax = plt.subplots(1, 2)
+print(superset.model_parameters.mesh_gradient)
+ax[0].pcolormesh(superset.model_parameters.mesh)
+ax[1].pcolormesh(superset.model_parameters.mesh_gradient)
+
+
+plt.show()
 
 
 # %%
 # Computing the analytical values using FiberModes solver.
 pyfibermodes_fiber = load_fiber(
     fiber_name=fiber_name,
     wavelength=wavelength,
     add_air_layer=False
 )
 
-pyfibermodes_fiber = pyfibermodes_fiber.scale(10)
-
 analytical = numpy.empty(itr_list.shape)
 for idx, itr in enumerate(itr_list):
     _fiber = pyfibermodes_fiber.scale(factor=itr)
     analytical[idx] = get_normalized_LP_coupling(
         fiber=_fiber,
         mode_0=LP01,
         mode_1=LP02
@@ -97,17 +105,17 @@
     label='Analytical',
     line_style='-',
     line_width=2,
     color='red',
     layer_position=1
 )
 
-simulation = -abs(superset.LP01.normalized_coupling.get_values(superset.LP02))
+simulation = superset.LP01.normalized_coupling.get_values(superset.LP02).imag
 ax.add_scatter(
-    x=itr_list,
+    x=superset.itr_list,
     y=simulation,
     label="SuPyMode",
     color='black',
     line_width=2,
     edge_color='blue',
     marker_size=80,
     line_style='-',
```

## docs/source/conf.py

```diff
@@ -4,15 +4,15 @@
 import sys
 from sphinx_gallery.sorting import FileNameSortKey
 from sphinx_gallery.sorting import ExplicitOrder
 from packaging.version import parse
 from MPSPlots.styles import use_mpsplots_style
 
 
-from SuPyMode.tools.directories import (
+from SuPyMode.directories import (
     project_path,
     doc_css_path,
     version_path,
 )
 
 
 sys.path.insert(0, project_path)
```

## Comparing `SuPyMode/__debug__.py` & `docs/legacy/__debug__.py`

 * *Files identical despite different names*

## Comparing `SuPyMode/python_debuging/eigen_solver.py` & `docs/legacy/python_debuging/eigen_solver.py`

 * *Files identical despite different names*

## Comparing `SuPyMode/python_debuging/mode_solver.py` & `docs/legacy/python_debuging/mode_solver.py`

 * *Files identical despite different names*

## Comparing `SuPyMode-1.1.6.dist-info/LICENSE` & `SuPyMode-1.2.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `SuPyMode-1.1.6.dist-info/METADATA` & `SuPyMode-1.2.0.dist-info/METADATA`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: SuPyMode
-Version: 1.1.6
+Version: 1.2.0
 Summary: A package for light propagation in fiber optics.
 Home-page: https://github.com/MartinPdeS/SuPyMode
 Author: Martin Poinsinet de Sivry
 Author-email: Martin.poinsinet.de.sivry@gmail.com
 License: MIT
 Platform: unix
 Platform: linux
@@ -18,17 +18,17 @@
 Classifier: Development Status :: 4 - Beta
 Classifier: Operating System :: OS Independent
 Classifier: Topic :: Scientific/Engineering :: Physics
 Classifier: Intended Audience :: Telecommunications Industry
 Classifier: Intended Audience :: Science/Research
 Description-Content-Type: text/x-rst
 License-File: LICENSE
-Requires-Dist: MPSPlots ==1.3.19
+Requires-Dist: MPSPlots ==1.4.0
 Requires-Dist: PyFinitDiff ==1.1.2
-Requires-Dist: FiberFusing ==1.0.16
+Requires-Dist: FiberFusing ==1.2.1
 Requires-Dist: scipy ==1.11.3
 Requires-Dist: matplotlib
 Requires-Dist: pathvalidate ==3.2.0
 Provides-Extra: documentation
 Requires-Dist: numpydoc ==1.6.0 ; extra == 'documentation'
 Requires-Dist: sphinx >=5.1.1 ; extra == 'documentation'
 Requires-Dist: sphinx-gallery ==0.15.0 ; extra == 'documentation'
@@ -103,43 +103,37 @@
 Manual installation
 *******************
 
 To install manually (os independent) you will need to install:
 
 1. cmake (3.16+)
 
-In order to use the SuPyMode Simulator Library, one must have installed the python dependencies:
-
-.. code-block:: python
-
-    >>> pip3 install -r requirements.txt
-
 Then, download and install the SuPyMode package:
 
 .. code-block:: python
 
-    >>> git clone https://github.com/MartinPdeS/SuPyMode.git
+    >>> git clone --recurse-submodules https://github.com/MartinPdeS/SuPyMode.git
     >>> cd SuPyMode && mkdir build && cd build
     >>> cmake ..
-    >>> make install (Linux, MacOs)
+    >>> cmake --build .
     >>> cd ..
     >>> pip3 install .
 
 ----
 
 Testing
 *******
 
-To test localy (with cloning the GitHub repository) you'll need to install the dependencies and run the coverage command as
+Make sure to install both coverage and pytest using ``pip3 install coverage pytest``. To test locally (with cloning the GitHub repository) you'll need to install the dependencies and run the coverage command as
 
 .. code:: python
 
-   >>> git clone https://github.com/MartinPdeS/SuPyMode.git
+   >>> git clone --recurse-submodules https://github.com/MartinPdeS/SuPyMode.git
    >>> cd SuPyMode
-   >>> pip install -r requirements/requirements.txt
+   >>> pip3 install PyFiberModes
    >>> coverage run --source=SuPyMode --module pytest --verbose tests
    >>> coverage report --show-missing
 
 ----
 
 Contact Information
 *******************
```

## Comparing `SuPyMode-1.1.6.dist-info/RECORD` & `SuPyMode-1.2.0.dist-info/RECORD`

 * *Files 27% similar despite different names*

```diff
@@ -1,86 +1,74 @@
-SuPyMode/VERSION,sha256=Jbfr4LwBRuHv_rymOjYAOLy0wRU4as3hjDLPEzPsImc,7
-SuPyMode/__debug__.py,sha256=lyiUh90a4Pi3j-OhYO9yp2teHML8IlJxZxpaQJ9w3Js,1726
-SuPyMode/__init__.py,sha256=zbdlyRc4eKmwq1i78ejdAYChRG3ltrnCseX-ikW8lK4,38
-SuPyMode/profiles.py,sha256=Oy4qDgkXVBhKgUyQTrK2uRrtTxyeemS6Vv0Ss5tVzWQ,25526
-SuPyMode/solver.py,sha256=Pu3AWlzZKy8E433u-nrqC19nCCzxwxxQGWH-DIlZ9eQ,10053
-SuPyMode/supermode.py,sha256=pviilBb600kYiqM_vIigr48coh5SkNvj-jRAfwrRAAU,8645
-SuPyMode/superset.py,sha256=T-mUV8kXuLc8nyeD6fw4pTn9A-kGdvBo5JHEpLgTS2g,39037
-SuPyMode/workflow.py,sha256=ai7ZLgB2am5pnmpYp3wkO_N5nqNNREKFnIaR38RsPY0,13700
-SuPyMode/__pycache__/__init__.cpython-311.pyc,sha256=cUxY4ke2frYKP83GDYCna8HFOUbcfCfeJXguQuMCk-E,215
-SuPyMode/__pycache__/profiles.cpython-311.pyc,sha256=K2jsxBf-IGeIntPovV-jZG2B0chOvXNLDNMlsYUPa8g,32063
-SuPyMode/__pycache__/solver.cpython-311.pyc,sha256=doUAGn3YXGvhL_ZEPExjpwiZcbIrGlKRNScvqalBz2c,11879
-SuPyMode/__pycache__/supermode.cpython-311.pyc,sha256=nW8RLgOzfyVJYx-f9kkUCDFIQbsW71yIiOrbCxi00ZI,11812
-SuPyMode/__pycache__/superset.cpython-311.pyc,sha256=J6u1M3zibdDOnyoDvvIgpEn4r8pOH2Rdtd0fwjHtQBA,48753
-SuPyMode/__pycache__/workflow.cpython-311.pyc,sha256=mSP7Vd3XOUHuVimVybak2qesVgZBzlSMCYKoFzdzjT8,14777
-SuPyMode/binary/CppSolver.cp311-win_amd64.pyd,sha256=lZm0N2Xg9NP8-xhnJB_meDBP7Vtp4o0HtIttOMA2xjw,1513984
-SuPyMode/binary/CppSolver.cp312-win_amd64.pyd,sha256=iUCQCYj6rJbjh-UooYbJ-gOaBV55uXiE-1qV6rGpneE,1515520
-SuPyMode/binary/ModelParameters.cp311-win_amd64.pyd,sha256=O5w7oQzATba8pr8jKDOciNfQtvk15_Rh5GX0FJesXJ4,1093632
-SuPyMode/binary/ModelParameters.cp312-win_amd64.pyd,sha256=VrTC3M_imlxQ0D24cpt3SijgWMIU7GsH84HDPs12-wM,1092096
-SuPyMode/binary/SuperMode.cp311-win_amd64.pyd,sha256=HLRky_j4pS8dt3BvcwqH7rV_LFxXpITm5DbQmqigqDk,1141248
-SuPyMode/binary/SuperMode.cp312-win_amd64.pyd,sha256=9VqSYcY6m0Za9I48EY4yMVfglogFUe9wtJPjCsWVBaw,1140736
+SuPyMode/VERSION,sha256=pkcIsBDivPYoFU3cIF7UloimNH75OmakJJJDD2PwIbE,7
+SuPyMode/__init__.py,sha256=Bpg3W59JPi806tYYi-UFH3IGlbeb-VzedVpo8WevbaI,52
+SuPyMode/directories.py,sha256=nWDOBTB-chyHBHUTOkOy-wJHylLX3yHlFmT4rzYCUVs,1165
+SuPyMode/mode_label.py,sha256=SczeSYwK1A2m7xxJ-KJPCEIaHtvPi35uvYLny06qzUs,5219
+SuPyMode/profiles.py,sha256=PjOTV7Kg1UxbGaBLwwQ4Fb7QYtrP3mAdHy9NQWjNgTQ,31102
+SuPyMode/solver.py,sha256=XNEnOGhIjONuhrv10ZNZcVJRe5uxubDSTVbgaBqL2PI,9049
+SuPyMode/special.py,sha256=cwuVcMrxtRbbM60gByR5bfEgsoJF1pTYwU9TNYvyr1M,4775
+SuPyMode/supermode.py,sha256=ZIE31qqm8M60Pn3xD7LO_xhi6m6flODh_wNzXEsLylw,10578
+SuPyMode/superset.py,sha256=tBS1AtAkvGi0nw-_0UtZfmJhJDKediKHTQWFAGA6aPE,41698
+SuPyMode/utils.py,sha256=Q5IWsy8q_l3PYv23HTsNpdrJ1mzbmCVmA66qglxzRIo,9808
+SuPyMode/workflow.py,sha256=iIuBOEXqx-SikJurTq4NHozqnGMNfSttFbXFXA8oESw,14653
+SuPyMode/binary/CppSolver.cp311-win_amd64.pyd,sha256=B6XJlp80opMoXllMOCbzZnoa2Uds-lbHi60WMi2XFoU,1485312
+SuPyMode/binary/CppSolver.cp312-win_amd64.pyd,sha256=shLsBUQPexYqrS8mnGWmPbM1FvKDVWDE5NbOLZitUB4,1483776
+SuPyMode/binary/Example.cp311-win_amd64.pyd,sha256=L7ysHfxVGIz_6gyRcL-IzOx-0_KsN5z3mGz2xQ42Qc8,1078272
+SuPyMode/binary/Example.cp312-win_amd64.pyd,sha256=SKLhVGSspPpI5yVDjpEaI0l7sUtZj0R-4t1mO4P7PlQ,1078272
+SuPyMode/binary/ModelParameters.cp311-win_amd64.pyd,sha256=xcMcWDw37tsa4PHFvs0QNwsgcm60q3tV1tqRf-XTRnY,1122816
+SuPyMode/binary/ModelParameters.cp312-win_amd64.pyd,sha256=qghPuN4lGa23DCOyQO8dc1Gs0CWLjeNObZvvqOGi7nY,1123328
+SuPyMode/binary/SuperMode.cp311-win_amd64.pyd,sha256=9E5Ez9NQicQcmk8X3RGXvz4zFnClJQEK0vjj7lCV1qA,1157120
+SuPyMode/binary/SuperMode.cp312-win_amd64.pyd,sha256=mU33CUUgtVrr6SQSQOepYP9_OSXU1QVqTW3tcDd3694,1156608
 SuPyMode/binary/__init__.py,sha256=frcCV1k9oG9oKj3dpUqdJg1PxRT2RSN_XKdLCPjaYaY,2
-SuPyMode/binary/__pycache__/__init__.cpython-311.pyc,sha256=k9maBf2oYSrbMfiFRjKbqNf_LoNFCex952AyHXSs8wI,159
-SuPyMode/python_debuging/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-SuPyMode/python_debuging/eigen_solver.py,sha256=jKWwtV6KS3pwRpy35n-aU5w_xajE9qs02wNUQpL0b8E,11485
-SuPyMode/python_debuging/mode_solver.py,sha256=z2sfLwh147ZjrQYGw9nmoJI5Im3VaL-2L5ibm-m3CO0,13021
 SuPyMode/representation/__init__.py,sha256=CIPkjhqrdVAaV92WfRaYrBAhmRREfQV-0FudypEKmNs,253
-SuPyMode/representation/adiabatic.py,sha256=uerCCmcx14D9CjP5R_NQtwD9EQVXltrYhofSDlcE2TY,2684
+SuPyMode/representation/adiabatic.py,sha256=lwmnWLkSCqSVuD1BR5WUWkHyBVnkcFG9BdWocbOR5_Y,3964
 SuPyMode/representation/base.py,sha256=2-eRL956PcsYuhWKCzza_CBG5xLfutHOd6EKJ3LC-58,4205
-SuPyMode/representation/beating_length.py,sha256=DUdPktoSifzEnIpkTM82oFIbvtVS3y_6YTIKl8hUWhA,2192
-SuPyMode/representation/beta.py,sha256=A34QTJGdML1LgHpz3b5c21eBIDaYzopYB7_lIZ97K8w,1423
-SuPyMode/representation/eigen_value.py,sha256=bmhvRxGKRK9oR2G2Ky_NOTNvV9So7EkT1CqoyWnLZnY,1418
-SuPyMode/representation/field.py,sha256=DaaORd5AKybgajCZl9WUsXMP4jYd3FeZ2oolf1hLNL4,11075
-SuPyMode/representation/index.py,sha256=hG4dZcLY_BxhsQHfQUaupTQBfvfJSmLoKZkAeFxRoYg,1448
-SuPyMode/representation/normalized_coupling.py,sha256=EPxbGtd7oXY1yhVZzXYNrZiFlhw7daw_PpUUC27UsOg,2451
-SuPyMode/representation/__pycache__/__init__.cpython-311.pyc,sha256=tuZeiC73D8Z1P60MYKpj6GraEGzhHL-1bpbiMoIwmq4,583
-SuPyMode/representation/__pycache__/adiabatic.cpython-311.pyc,sha256=fgvWMzqhDDvXmbwKNa0WEORhTfnYV3htsQFrqfx4Q-M,3783
-SuPyMode/representation/__pycache__/base.cpython-311.pyc,sha256=8pM0l1pZSjPkqoioLI93tKKD14L-48Bp4keLHNP2iYg,7632
-SuPyMode/representation/__pycache__/beating_length.cpython-311.pyc,sha256=_7YgbxidC7VgjSpWKOl7wsEw3EIoRn_e9Eu-lf5O2zI,3290
-SuPyMode/representation/__pycache__/beta.cpython-311.pyc,sha256=SI-XlxyYpOvbOROGvdID9V-MMWgaQ1R4-wIPJt4i6iQ,2471
-SuPyMode/representation/__pycache__/eigen_value.cpython-311.pyc,sha256=QH6qjz2s_FTGBLx7x4yzWtO6GpidmalRrzJf6I8AQbo,2497
-SuPyMode/representation/__pycache__/field.cpython-311.pyc,sha256=9-cK5BFFoibQ74vNy5TC1mtKo6oVPgR5ywxWlaqFYBA,13763
-SuPyMode/representation/__pycache__/index.cpython-311.pyc,sha256=pO10Pf4zBYoxnOSlnibcVh_YuGK_86r4BLBh00AjAKg,2513
-SuPyMode/representation/__pycache__/normalized_coupling.cpython-311.pyc,sha256=S61HKLFRqHz3z4iUSBMobJupVbgvQV_-Tm2G8Kt7lWA,3561
+SuPyMode/representation/beating_length.py,sha256=_XKlJeyJtthqfIMyRBxP8sEQaS30XU56THKMENnECbw,3473
+SuPyMode/representation/beta.py,sha256=8sX-4ok5_7QFGGY0M4-6BeYfGJxq6rytrfk3S0J__Sw,2762
+SuPyMode/representation/eigen_value.py,sha256=3Qy2JEv5QdwSR_jr1URxWJgF_62G4CBsQ2HLslKdZc8,2501
+SuPyMode/representation/field.py,sha256=3Ga0Xg2_ZJtLutT6yfESww7id9bHy8BenDVZE0Td7ww,12984
+SuPyMode/representation/index.py,sha256=GD0NBAoo3UROAxVbmle_6JKUAjXMY3btApgDiHCaxIw,2667
+SuPyMode/representation/normalized_coupling.py,sha256=zQUP3x8krrhv04WUQ2eXkYjWe7BLldMAt8wmVWUx8ew,3831
 SuPyMode/tools/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-SuPyMode/tools/directories.py,sha256=eJv-OcPkctK_04MEnry6ereIBC29_WBxOkl4pVJTd94,1315
-SuPyMode/tools/mode_label.py,sha256=C89_irHB9aDU0huEs-HwIdbExyh0gbJk2glEDMOjs9I,1780
 SuPyMode/tools/special.py,sha256=cwuVcMrxtRbbM60gByR5bfEgsoJF1pTYwU9TNYvyr1M,4775
-SuPyMode/tools/utils.py,sha256=2yi8oBaEuEhizZ4H8_hL6ty8WcSmWx1wBmxaCaVQs0g,5858
-SuPyMode/tools/__pycache__/__init__.cpython-311.pyc,sha256=aVOLBm_sVKZ2eFKgVRYNEwJXgv0XBVzSh1OEc1uBLSE,158
-SuPyMode/tools/__pycache__/directories.cpython-311.pyc,sha256=YkVNgD5sEgCWvqTzKqk-853DrnI84VFX8xl11MQR9Ds,1903
-SuPyMode/tools/__pycache__/mode_label.cpython-311.pyc,sha256=w5ThUQwTFoce8jqZP9toAZO8-3aQGzt_v4-zF_qvkKY,3274
-SuPyMode/tools/__pycache__/utils.cpython-311.pyc,sha256=ka9wVB5tXN5YCcNhI_UwwAhZx5OhBcqfkqZLmkuuHiQ,8282
+SuPyMode/tools/utils.py,sha256=pcd_Sqab0IeB0KjiewwAp1QBEueF0m-zRkZQrIe3fH8,8943
 SuPyMode/validation_data/SBB_figure_4_16_a/LP01-LP02.csv,sha256=j0ybGVc3SmFcwrsK8MGyW1TY0QHRuXaNoiSNEQUbmYY,4073
 SuPyMode/validation_data/SBB_figure_4_16_a/LP01-LP21.csv,sha256=E6AshwC1Fu87mg2e9TkLC4-HZUmWSqha7Ext-TiVh7s,3640
 SuPyMode/validation_data/SBB_figure_4_16_a/LP01-LP41.csv,sha256=E9DXjgBQTUKnOP_DbUq2iwZy_lzD6MamUQR5MLWkYD8,3552
 SuPyMode/validation_data/SBB_figure_4_16_a/LP11-LP12.csv,sha256=ra1S20zmBTXZ8HU0SqRR_Ms_5fhPNCppTRA2mEz-vXo,3435
 SuPyMode/validation_data/SBB_figure_4_16_a/LP11-LP31.csv,sha256=KlOx0xrVh02eklLTjxSvJe6NBv4Qjopm85J9GSJTVDk,3871
 SuPyMode/validation_data/SBB_figure_4_16_a/LP11-LP51.csv,sha256=EZ1sv0B5--UCImPpknu669oyKtPNLUJTuNfG_h7KpIc,3351
 SuPyMode/validation_data/SBB_figure_4_16_b/LP01-LP02.csv,sha256=dVTY2BJANQL8IOV_VHOclnDoSQpCJTJklBfh8SQS1s8,11801
 SuPyMode/validation_data/SBB_figure_4_16_b/LP01-LP21.csv,sha256=oOWGCwlufEzh2CsJz4z2HIhP8O2IX7L04LkHXXlWDig,3180
 SuPyMode/validation_data/SBB_figure_4_16_b/LP01-LP41.csv,sha256=YiLbzJqQ-kwEQc2Xq_XMqdYpXyV6AREh4tKFM4KNFKQ,9766
 SuPyMode/validation_data/SBB_figure_4_16_b/LP11-LP12.csv,sha256=f1EgCIevVz9dggpXWIZBVj15KiGdeVnbGXAGjUQi8ts,5278
 SuPyMode/validation_data/SBB_figure_4_16_b/LP11-LP31.csv,sha256=VvIhe6OE5OfHbTuc30yUPoyzWB7B5hRk1IgnwAfTgkc,6584
 SuPyMode/validation_data/SBB_figure_4_16_b/LP11-LP51.csv,sha256=eRUF3mav8mN9wmV-sSLC6yh-jK4eSVhW39-hvd1cPig,9280
-docs/examples/basic/plot_alpha_profile_0.py,sha256=Q2ivUTXsqP_BWzf50IHPQxibSaCDwl0wVwUzAxGvm38,694
-docs/examples/basic/plot_alpha_profile_1.py,sha256=hxPD5DEUN6jbRby087Zapa22Cc5aCQ5pj6zPBg4a47Y,685
+developments/gradient_tests_2.py,sha256=eM3DbTFmRUByCeon3FYTrSiyrrRjErW7bIF_avAcJnA,1129
+developments/validation.py,sha256=9ocXrQ-0ljVVqo_OiE37rkkpZ33icUZcFL1vpdLp64I,4038
+developments/validation_2.py,sha256=ErN6LjFoNzQ4K5hOX9pIPAKGarxJGNlqldGuGBk-ibg,4045
+docs/examples/basic/plot_alpha_profile_0.py,sha256=V12fCuK-DeZiPFw3-hE2YvdF0z9VKWQJk3fgbq1pSc8,718
+docs/examples/basic/plot_alpha_profile_1.py,sha256=rABdmTUGeTrkSB7rX8XFkI-JPo1uwzRko-bGPC4spao,757
 docs/examples/basic/plot_workflow_01.py,sha256=ZdAMr3N3mOUOdl_NxoQ_q07tkoPixwr7PGv90A07EVg,3117
-docs/examples/basic/plot_workflow_02.py,sha256=ttDD2FnmNrF3ZZOs0vtzih9uWswpTggDq1xxSUzKPqU,3195
-docs/examples/basic/plot_workflow_03.py,sha256=QzKR2VmwrzWBoNJor52DVbTXoLz0JZf2MQMfAgYXJrw,3326
+docs/examples/basic/plot_workflow_02.py,sha256=3iUYM2sqEUI8hHw7b_EDcx8MeA_JUE2Qg2uLpMrsO0Q,3195
+docs/examples/basic/plot_workflow_03.py,sha256=gdCPpuaENvSA_DMfEAC402qbL0LNh1N-geTbHsOSc80,3644
 docs/examples/basic/plot_workflow_04.py,sha256=RjVxgEyfYjFsqaCIAtj_oUueQ23djGjHa0-tqie3vWk,3244
 docs/examples/basic/plot_workflow_05.py,sha256=onH24k4cRXYbBi25FqAS84EP7f4o_yvQsKtICbreAOQ,3615
 docs/examples/basic/plot_workflow_06.py,sha256=5-gQWZHIApZjDVWwH2ZE8cWQKV3dLM6vv4U1JtAl0EM,3699
 docs/examples/basic/plot_workflow_07.py,sha256=cB_mZefe0MMcAYDIN90rha8KF4fiu7GCj6n0bBsw0YY,3321
 docs/examples/basic/plot_workflow_08.py,sha256=jOA_07ED7ACweQpLTLddsYsi6fhoh4_n9gCerYsvTco,3300
-docs/examples/validation/plot_beta_DCF.py,sha256=JA1NHTBOStqJ1SXI0aYUbQQCr_02a-0GQmVHdCQpbtE,3588
-docs/examples/validation/plot_beta_SMF28.py,sha256=G20F5YgKn1OYr9sX4MWFQLVRjPVKwBIKNv5vvVxu9Hs,3581
-docs/examples/validation/plot_normalized_coupling_DCF.py,sha256=Q2nUPaPs7NB2NnmIadkitIsGwBPifkjfzbKxd_S9twM,3683
-docs/examples/validation/plot_normalized_coupling_SMF28.py,sha256=7Sr953igu2w6VZLfz-XC_DzUEZtszlsflAHhvuy5x7Y,3672
-docs/source/conf.py,sha256=v9HyZlI5EGukJfmrIDVHxZDvyQ48tfy_O8-b2den9DU,4485
+docs/examples/validation/plot_beta_DCF.py,sha256=Y_TEg_57HxRfyO5Yvbu6hpqRZ_RNQyU7Fgk4ST5ps4w,3580
+docs/examples/validation/plot_beta_SMF28.py,sha256=l5wtRnI_5uf3oWTpzd5pXEMQjkbZQfykvkbvYtiRZPQ,3573
+docs/examples/validation/plot_normalized_coupling_DCF.py,sha256=UDDhaRpzlwSA2r8aRgsy1j1U3oFLXZc0o6vAO3fm5eo,3743
+docs/examples/validation/plot_normalized_coupling_SMF28.py,sha256=J1bm-AfTgmXcFE3iws-_4vi0PnFZoZu5vtZOax8Dpwo,3912
+docs/examples/validation/plot_validation.py,sha256=Y52CW_WLfYX6k5l06lR9ezHn8XuQpUCgABxgvreJ51c,5878
+docs/legacy/__debug__.py,sha256=lyiUh90a4Pi3j-OhYO9yp2teHML8IlJxZxpaQJ9w3Js,1726
+docs/legacy/python_debuging/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+docs/legacy/python_debuging/eigen_solver.py,sha256=jKWwtV6KS3pwRpy35n-aU5w_xajE9qs02wNUQpL0b8E,11485
+docs/legacy/python_debuging/mode_solver.py,sha256=z2sfLwh147ZjrQYGw9nmoJI5Im3VaL-2L5ibm-m3CO0,13021
+docs/source/conf.py,sha256=NA0sdw-U6RnmowK_94ncHRDRpAJu9C7yZBFJ3B2Mfig,4479
 extern/eigen/debug/gdb/__init__.py,sha256=Zm25_g-Pu7xBYyUqKD4MgNKVDKx1dkzPUr99Wh4ptAg,23
 extern/eigen/debug/gdb/printers.py,sha256=Z6BPQsF75qJmbJ2Xl-UBUiO6rloj1Qop00t5Q2Ch3GA,9931
 extern/eigen/scripts/relicense.py,sha256=9bC_4t-_u2cyzKL3-iKk7bDNUNYnXO0EvQUcASfpCUM,2437
 extern/pybind11/noxfile.py,sha256=PdQfwsFP_cW_Oe0V0hyamFVvPOFSTxJPkKB8-IniyAQ,2853
 extern/pybind11/setup.py,sha256=6y7BV5FX9E3xt0JHbLOFo65lp9xMEuKw8GDaPCDKFck,5005
 extern/pybind11/docs/benchmark.py,sha256=xGe51SxzhQEqBC4uVlj9U4uqXtkTPW4geLfrlu2-2dA,2940
 extern/pybind11/docs/conf.py,sha256=0QNgwuj4TUvnRT8cVh-prR0QFsZWVdYYGI1xEhjME5k,11942
@@ -143,12 +131,12 @@
 extern/pybind11/tests/extra_setuptools/test_setuphelper.py,sha256=wkDPeVFCh0UYxKQqr5g4917_15SzbFvmgDMbX0fN_3A,4304
 extern/pybind11/tests/test_cmake_build/test.py,sha256=FIAyjOQkxy8mScsPccANS8lIkxEHMXucr2D0IzjxY2Q,206
 extern/pybind11/tests/test_embed/test_interpreter.py,sha256=unuIU5dE-Ie8L2l6UkUuFfE2s_dTyboWkITp2TrjzuA,251
 extern/pybind11/tests/test_embed/test_trampoline.py,sha256=fa6Pm_kP3TZFriK4zGkJT98JF6GDWFoFGZ5fUAoP9zw,291
 extern/pybind11/tools/codespell_ignore_lines_from_errors.py,sha256=-uOBDpMzC32MQ-TtfYpWtBjb-9PzXcFNOIqCHuLcqgM,1156
 extern/pybind11/tools/libsize.py,sha256=xp1nJIl4vHGMbSpYOydVV9kzcraSNRXNS52eImM7a94,1067
 extern/pybind11/tools/make_changelog.py,sha256=gFxp0WanqGCaF2KVvkjPehnqBlNxfcWihlTgBmdBJWE,2135
-SuPyMode-1.1.6.dist-info/LICENSE,sha256=_Xcqg6btgIHBE66SoLrThK_k6I8az305mCNRWdWThVE,1093
-SuPyMode-1.1.6.dist-info/METADATA,sha256=Pqo9o0CDFWFhLL1QLNMlZVo8I2d2kixRcuGaf0EvlTM,5698
-SuPyMode-1.1.6.dist-info/WHEEL,sha256=j9Aissza3750LQHFAQyYerNjmkEON1-8w_RaZNFtKSs,102
-SuPyMode-1.1.6.dist-info/top_level.txt,sha256=fbS2kDl3Q39JcVJfgeFdZuRsyuUdjlDG4vzbvgRVwUk,60
-SuPyMode-1.1.6.dist-info/RECORD,,
+SuPyMode-1.2.0.dist-info/LICENSE,sha256=_Xcqg6btgIHBE66SoLrThK_k6I8az305mCNRWdWThVE,1093
+SuPyMode-1.2.0.dist-info/METADATA,sha256=9c6Uz50EF5OLde_IQYzrBZmVcWkelKAT_sTk_NUlwMQ,5624
+SuPyMode-1.2.0.dist-info/WHEEL,sha256=fZWyj_84lK0cA-ZNCsdwhbJl0OTrpWkxInEn424qrSs,102
+SuPyMode-1.2.0.dist-info/top_level.txt,sha256=4wDFcf5kyQU2nrrrdYayxkcXY96Uwq9KEL1aJ6R7jns,73
+SuPyMode-1.2.0.dist-info/RECORD,,
```

